#ifndef __BDK_CSRS_CGX_H__
#define __BDK_CSRS_CGX_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX CGX.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration cgx_bar_e
 *
 * CGX Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define BDK_CGX_BAR_E_CGXX_PF_BAR0(a) (0x87e0e0000000ll + 0x1000000ll * (a))
#define BDK_CGX_BAR_E_CGXX_PF_BAR0_SIZE 0x100000ull
#define BDK_CGX_BAR_E_CGXX_PF_BAR4(a) (0x87e0e0400000ll + 0x1000000ll * (a))
#define BDK_CGX_BAR_E_CGXX_PF_BAR4_SIZE 0x100000ull

/**
 * Enumeration cgx_int_vec_e
 *
 * CGX MSI-X Vector Enumeration
 * Enumeration the MSI-X interrupt vectors.
 */
#define BDK_CGX_INT_VEC_E_CMRX_INT(a) (0 + 9 * (a))
#define BDK_CGX_INT_VEC_E_CMRX_SW(a) (0x26 + (a))
#define BDK_CGX_INT_VEC_E_CMR_MEM_INT (0x24)
#define BDK_CGX_INT_VEC_E_GMPX_GMI_RX_INT(a) (5 + 9 * (a))
#define BDK_CGX_INT_VEC_E_GMPX_GMI_TX_INT(a) (6 + 9 * (a))
#define BDK_CGX_INT_VEC_E_GMPX_GMI_WOL_INT(a) (7 + 9 * (a))
#define BDK_CGX_INT_VEC_E_GMPX_PCS_INT(a) (4 + 9 * (a))
#define BDK_CGX_INT_VEC_E_SMUX_RX_INT(a) (2 + 9 * (a))
#define BDK_CGX_INT_VEC_E_SMUX_RX_WOL_INT(a) (8 + 9 * (a))
#define BDK_CGX_INT_VEC_E_SMUX_TX_INT(a) (3 + 9 * (a))
#define BDK_CGX_INT_VEC_E_SPUX_INT(a) (1 + 9 * (a))
#define BDK_CGX_INT_VEC_E_SW (0x25)

/**
 * Enumeration cgx_lmac_types_e
 *
 * CGX LMAC Type Enumeration
 * Enumerates the LMAC Types that CGX supports.
 */
#define BDK_CGX_LMAC_TYPES_E_FIFTYG_R (8)
#define BDK_CGX_LMAC_TYPES_E_FORTYG_R (4)
#define BDK_CGX_LMAC_TYPES_E_HUNDREDG_R (9)
#define BDK_CGX_LMAC_TYPES_E_QSGMII (6)
#define BDK_CGX_LMAC_TYPES_E_RGMII (5)
#define BDK_CGX_LMAC_TYPES_E_RXAUI (2)
#define BDK_CGX_LMAC_TYPES_E_SGMII (0)
#define BDK_CGX_LMAC_TYPES_E_TENG_R (3)
#define BDK_CGX_LMAC_TYPES_E_TWENTYFIVEG_R (7)
#define BDK_CGX_LMAC_TYPES_E_USXGMII (0xa)
#define BDK_CGX_LMAC_TYPES_E_XAUI (1)

/**
 * Enumeration cgx_opcode_e
 *
 * INTERNAL: CGX Error Opcode Enumeration
 *
 * Enumerates the error opcodes created by CGX and presented to NCSI/NIX.
 */
#define BDK_CGX_OPCODE_E_RE_FCS (7)
#define BDK_CGX_OPCODE_E_RE_FCS_RCV (8)
#define BDK_CGX_OPCODE_E_RE_JABBER (2)
#define BDK_CGX_OPCODE_E_RE_NONE (0)
#define BDK_CGX_OPCODE_E_RE_PARTIAL (1)
#define BDK_CGX_OPCODE_E_RE_RX_CTL (0xb)
#define BDK_CGX_OPCODE_E_RE_SKIP (0xc)
#define BDK_CGX_OPCODE_E_RE_TERMINATE (9)

/**
 * Enumeration cgx_spu_br_train_cst_e
 *
 * CGX Training Coefficient Status Enumeration
 * 2-bit status for each coefficient as defined in IEEE 802.3, Table 72-5.
 */
#define BDK_CGX_SPU_BR_TRAIN_CST_E_MAXIMUM (3)
#define BDK_CGX_SPU_BR_TRAIN_CST_E_MINIMUM (2)
#define BDK_CGX_SPU_BR_TRAIN_CST_E_NOT_UPDATED (0)
#define BDK_CGX_SPU_BR_TRAIN_CST_E_UPDATED (1)

/**
 * Enumeration cgx_spu_br_train_cup_e
 *
 * CGX Training Coefficient Enumeration
 * 2-bit command for each coefficient as defined in IEEE 802.3, Table 72-4.
 */
#define BDK_CGX_SPU_BR_TRAIN_CUP_E_DECREMENT (1)
#define BDK_CGX_SPU_BR_TRAIN_CUP_E_HOLD (0)
#define BDK_CGX_SPU_BR_TRAIN_CUP_E_INCREMENT (2)
#define BDK_CGX_SPU_BR_TRAIN_CUP_E_RSV_CMD (3)

/**
 * Enumeration cgx_usxgmii_rate_e
 *
 * CGX USXGMII Rate Enumeration
 * Enumerates the USXGMII sub-port type rate, CGX()_SPU()_CONTROL1[USXGMII_RATE].
 *
 * Selecting a rate higher than the maximum allowed for a given port sub-type
 * (specified by CGX()_SPU()_CONTROL1[USXGMII_TYPE]), e.g., selecting ::RATE_2HG (2.5
 * Gbps) for CGX_USXGMII_TYPE_E::SXGMII_2G, will cause unpredictable behavior. USXGMII
 * hardware-based autonegotiation may change this setting.
 */
#define BDK_CGX_USXGMII_RATE_E_RATE_100M (1)
#define BDK_CGX_USXGMII_RATE_E_RATE_10G (5)
#define BDK_CGX_USXGMII_RATE_E_RATE_10M (0)
#define BDK_CGX_USXGMII_RATE_E_RATE_1G (2)
#define BDK_CGX_USXGMII_RATE_E_RATE_20G (6)
#define BDK_CGX_USXGMII_RATE_E_RATE_2HG (3)
#define BDK_CGX_USXGMII_RATE_E_RATE_5G (4)
#define BDK_CGX_USXGMII_RATE_E_RSV_RATE (7)

/**
 * Enumeration cgx_usxgmii_type_e
 *
 * CGX USXGMII Port Sub-Type Enumeration
 * Enumerates the USXGMII sub-port type, CGX()_SPU()_CONTROL1[USXGMII_TYPE].
 *
 * The description indicates the maximum rate and the maximum number of ports (LMACs)
 * for each sub-type. The minimum rate for any port is 10M.
 * The rate selection for each LMAC is made using CGX()_SPU()_CONTROL1[USXGMII_RATE]
 * and the number of active ports/LMACs is implicitly determined by the value given to
 * CGX()_CMR()_CONFIG[ENABLE] for each LMAC.
 *
 * Selecting a rate higher than the maximum allowed for a given port sub-type or
 * enabling more LMACs than the maximum allowed for a given port sub-type will cause
 * unpredictable behavior.
 */
#define BDK_CGX_USXGMII_TYPE_E_DXGMII_10G (3)
#define BDK_CGX_USXGMII_TYPE_E_DXGMII_20G (5)
#define BDK_CGX_USXGMII_TYPE_E_DXGMII_5G (4)
#define BDK_CGX_USXGMII_TYPE_E_QXGMII_10G (7)
#define BDK_CGX_USXGMII_TYPE_E_QXGMII_20G (6)
#define BDK_CGX_USXGMII_TYPE_E_SXGMII_10G (0)
#define BDK_CGX_USXGMII_TYPE_E_SXGMII_2G (2)
#define BDK_CGX_USXGMII_TYPE_E_SXGMII_5G (1)

/**
 * Structure cgx_spu_br_lane_train_status_s
 *
 * CGX Lane Training Status Structure
 * This is the group of lane status bits for a single lane in the BASE-R PMD status register
 * (MDIO address 1.151) as defined in IEEE 802.3ba-2010, Table 45-55.
 */
union bdk_cgx_spu_br_lane_train_status_s
{
    uint32_t u;
    struct bdk_cgx_spu_br_lane_train_status_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t training_failure      : 1;  /**< [  3:  3] Link training failure. */
        uint32_t training              : 1;  /**< [  2:  2] Link training state.
                                                                 0 = Training in progress.
                                                                 1 = Training has completed. */
        uint32_t frame_lock            : 1;  /**< [  1:  1] Frame lock status. Set when training frame delineation has been detected. */
        uint32_t rx_trained            : 1;  /**< [  0:  0] Receiver trained status.
                                                                 0 = Receiver training.
                                                                 1 = Receiver trained and ready to receive data for the lane. */
#else /* Word 0 - Little Endian */
        uint32_t rx_trained            : 1;  /**< [  0:  0] Receiver trained status.
                                                                 0 = Receiver training.
                                                                 1 = Receiver trained and ready to receive data for the lane. */
        uint32_t frame_lock            : 1;  /**< [  1:  1] Frame lock status. Set when training frame delineation has been detected. */
        uint32_t training              : 1;  /**< [  2:  2] Link training state.
                                                                 0 = Training in progress.
                                                                 1 = Training has completed. */
        uint32_t training_failure      : 1;  /**< [  3:  3] Link training failure. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgx_spu_br_lane_train_status_s_s cn; */
};

/**
 * Structure cgx_spu_br_train_cup_s
 *
 * CGX Lane Training Coefficient Structure
 * This is the coefficient update field of the BASE-R link training packet as defined in
 * IEEE 802.3, Table 72-4.
 */
union bdk_cgx_spu_br_train_cup_s
{
    uint32_t u;
    struct bdk_cgx_spu_br_train_cup_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t preset                : 1;  /**< [ 13: 13] Preset. Set to indicate that all TX coefficients be set to a state where equalization is
                                                                 turned off, i.e. the precursor (k = -1) and postcursor (k = +1) coefficients should be set
                                                                 to 0 and the main
                                                                 (k = 0) coefficient should be set to its maximum value. */
        uint32_t init                  : 1;  /**< [ 12: 12] Initialize. Set to indicate that the TX coefficients should be set to meet the conditions
                                                                 defined in IEEE 802.3 sub-clause 72.6.10.4.2. */
        uint32_t reserved_6_11         : 6;
        uint32_t post_cup              : 2;  /**< [  5:  4] Post-cursor (k = +1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t main_cup              : 2;  /**< [  3:  2] Main (k = 0) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t pre_cup               : 2;  /**< [  1:  0] Pre-cursor (k = -1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
#else /* Word 0 - Little Endian */
        uint32_t pre_cup               : 2;  /**< [  1:  0] Pre-cursor (k = -1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t main_cup              : 2;  /**< [  3:  2] Main (k = 0) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t post_cup              : 2;  /**< [  5:  4] Post-cursor (k = +1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t reserved_6_11         : 6;
        uint32_t init                  : 1;  /**< [ 12: 12] Initialize. Set to indicate that the TX coefficients should be set to meet the conditions
                                                                 defined in IEEE 802.3 sub-clause 72.6.10.4.2. */
        uint32_t preset                : 1;  /**< [ 13: 13] Preset. Set to indicate that all TX coefficients be set to a state where equalization is
                                                                 turned off, i.e. the precursor (k = -1) and postcursor (k = +1) coefficients should be set
                                                                 to 0 and the main
                                                                 (k = 0) coefficient should be set to its maximum value. */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    struct bdk_cgx_spu_br_train_cup_s_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t reserved_14_15        : 2;
        uint32_t preset                : 1;  /**< [ 13: 13] Preset. Set to indicate that all TX coefficients be set to a state where equalization is
                                                                 turned off, i.e. the precursor (k = -1) and postcursor (k = +1) coefficients should be set
                                                                 to 0 and the main
                                                                 (k = 0) coefficient should be set to its maximum value. */
        uint32_t init                  : 1;  /**< [ 12: 12] Initialize. Set to indicate that the TX coefficients should be set to meet the conditions
                                                                 defined in IEEE 802.3 sub-clause 72.6.10.4.2. */
        uint32_t reserved_6_11         : 6;
        uint32_t post_cup              : 2;  /**< [  5:  4] Post-cursor (k = +1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t main_cup              : 2;  /**< [  3:  2] Main (k = 0) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t pre_cup               : 2;  /**< [  1:  0] Pre-cursor (k = -1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
#else /* Word 0 - Little Endian */
        uint32_t pre_cup               : 2;  /**< [  1:  0] Pre-cursor (k = -1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t main_cup              : 2;  /**< [  3:  2] Main (k = 0) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t post_cup              : 2;  /**< [  5:  4] Post-cursor (k = +1) coefficient update. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CUP_E. */
        uint32_t reserved_6_11         : 6;
        uint32_t init                  : 1;  /**< [ 12: 12] Initialize. Set to indicate that the TX coefficients should be set to meet the conditions
                                                                 defined in IEEE 802.3 sub-clause 72.6.10.4.2. */
        uint32_t preset                : 1;  /**< [ 13: 13] Preset. Set to indicate that all TX coefficients be set to a state where equalization is
                                                                 turned off, i.e. the precursor (k = -1) and postcursor (k = +1) coefficients should be set
                                                                 to 0 and the main
                                                                 (k = 0) coefficient should be set to its maximum value. */
        uint32_t reserved_14_15        : 2;
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn;
};

/**
 * Structure cgx_spu_br_train_rep_s
 *
 * CGX Training Report Structure
 * This is the status report field of the BASE-R link training packet as defined in IEEE 802.3,
 * Table 72-5.
 */
union bdk_cgx_spu_br_train_rep_s
{
    uint32_t u;
    struct bdk_cgx_spu_br_train_rep_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rx_ready              : 1;  /**< [ 15: 15] Receiver ready. Set to indicate that the local receiver has determined that training is
                                                                 complete and is prepared to receive data. */
        uint32_t reserved_6_14         : 9;
        uint32_t post_cst              : 2;  /**< [  5:  4] Post-cursor (k = +1) coefficient status. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CST_E. */
        uint32_t main_cst              : 2;  /**< [  3:  2] Main (k = 0) coefficient status. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CST_E. */
        uint32_t pre_cst               : 2;  /**< [  1:  0] Pre-cursor (k = -1) coefficient status. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CST_E. */
#else /* Word 0 - Little Endian */
        uint32_t pre_cst               : 2;  /**< [  1:  0] Pre-cursor (k = -1) coefficient status. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CST_E. */
        uint32_t main_cst              : 2;  /**< [  3:  2] Main (k = 0) coefficient status. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CST_E. */
        uint32_t post_cst              : 2;  /**< [  5:  4] Post-cursor (k = +1) coefficient status. Valid when PRESET = INIT = 0. Enumerated by
                                                                 CGX_SPU_BR_TRAIN_CST_E. */
        uint32_t reserved_6_14         : 9;
        uint32_t rx_ready              : 1;  /**< [ 15: 15] Receiver ready. Set to indicate that the local receiver has determined that training is
                                                                 complete and is prepared to receive data. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgx_spu_br_train_rep_s_s cn; */
};

/**
 * Structure cgx_spu_sds_cu_s
 *
 * INTERNAL: CGX Training Coeffiecient Structure
 *
 * This structure is similar to CGX_SPU_BR_TRAIN_CUP_S format, but with reserved fields removed
 * and [RCVR_READY] field added.
 */
union bdk_cgx_spu_sds_cu_s
{
    uint32_t u;
    struct bdk_cgx_spu_sds_cu_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t rcvr_ready            : 1;  /**< [  8:  8] See CGX_SPU_BR_TRAIN_REP_S[RX_READY]. */
        uint32_t preset                : 1;  /**< [  7:  7] See CGX_SPU_BR_TRAIN_CUP_S[PRESET]. */
        uint32_t initialize            : 1;  /**< [  6:  6] See CGX_SPU_BR_TRAIN_CUP_S[INIT]. */
        uint32_t post_cu               : 2;  /**< [  5:  4] See CGX_SPU_BR_TRAIN_CUP_S[POST_CUP]. */
        uint32_t main_cu               : 2;  /**< [  3:  2] See CGX_SPU_BR_TRAIN_CUP_S[MAIN_CUP]. */
        uint32_t pre_cu                : 2;  /**< [  1:  0] See CGX_SPU_BR_TRAIN_CUP_S[PRE_CUP]. */
#else /* Word 0 - Little Endian */
        uint32_t pre_cu                : 2;  /**< [  1:  0] See CGX_SPU_BR_TRAIN_CUP_S[PRE_CUP]. */
        uint32_t main_cu               : 2;  /**< [  3:  2] See CGX_SPU_BR_TRAIN_CUP_S[MAIN_CUP]. */
        uint32_t post_cu               : 2;  /**< [  5:  4] See CGX_SPU_BR_TRAIN_CUP_S[POST_CUP]. */
        uint32_t initialize            : 1;  /**< [  6:  6] See CGX_SPU_BR_TRAIN_CUP_S[INIT]. */
        uint32_t preset                : 1;  /**< [  7:  7] See CGX_SPU_BR_TRAIN_CUP_S[PRESET]. */
        uint32_t rcvr_ready            : 1;  /**< [  8:  8] See CGX_SPU_BR_TRAIN_REP_S[RX_READY]. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgx_spu_sds_cu_s_s cn; */
};

/**
 * Structure cgx_spu_sds_skew_status_s
 *
 * CGX Skew Status Structure
 * Provides receive skew information detected for a physical SerDes lane when it is assigned to a
 * multilane LMAC/LPCS. Contents are valid when RX deskew is done for the associated LMAC/LPCS.
 */
union bdk_cgx_spu_sds_skew_status_s
{
    uint32_t u;
    struct bdk_cgx_spu_sds_skew_status_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t lane_skew             : 7;  /**< [ 29: 23] Lane skew. The SerDes lane's receive skew/delay in number of code-groups (BASE-X) or
                                                                 blocks (40G/50G/100GBASE-R) relative to the earliest (least delayed) lane of the LMAC/LPCS. */
        uint32_t reserved_21_22        : 2;
        uint32_t am_lane_id            : 5;  /**< [ 20: 16] Alignment marker ID. Valid for 40G/50G/100GBASE-R only. This is the PCS lane
                                                                 number of the alignment marker received on the SerDes lane. */
        uint32_t reserved_12_15        : 4;
        uint32_t am_timestamp          : 12; /**< [ 11:  0] Alignment marker PTP timestamp. Valid for 40G/50G/100GBASE-R only. Contains the
                                                                 lower 12 bits of the PTP timestamp of the alignment marker received on the
                                                                 SerDes lane during align/skew detection. */
#else /* Word 0 - Little Endian */
        uint32_t am_timestamp          : 12; /**< [ 11:  0] Alignment marker PTP timestamp. Valid for 40G/50G/100GBASE-R only. Contains the
                                                                 lower 12 bits of the PTP timestamp of the alignment marker received on the
                                                                 SerDes lane during align/skew detection. */
        uint32_t reserved_12_15        : 4;
        uint32_t am_lane_id            : 5;  /**< [ 20: 16] Alignment marker ID. Valid for 40G/50G/100GBASE-R only. This is the PCS lane
                                                                 number of the alignment marker received on the SerDes lane. */
        uint32_t reserved_21_22        : 2;
        uint32_t lane_skew             : 7;  /**< [ 29: 23] Lane skew. The SerDes lane's receive skew/delay in number of code-groups (BASE-X) or
                                                                 blocks (40G/50G/100GBASE-R) relative to the earliest (least delayed) lane of the LMAC/LPCS. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgx_spu_sds_skew_status_s_s cn; */
};

/**
 * Structure cgx_spu_sds_sr_s
 *
 * INTERNAL: CGX Lane Training Coefficient Structure
 *
 * Similar to CGX_SPU_BR_TRAIN_REP_S format, but with reserved and RX ready fields removed.
 */
union bdk_cgx_spu_sds_sr_s
{
    uint32_t u;
    struct bdk_cgx_spu_sds_sr_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t post_status           : 2;  /**< [  5:  4] See CGX_SPU_BR_TRAIN_REP_S[POST_CST]. */
        uint32_t main_status           : 2;  /**< [  3:  2] See CGX_SPU_BR_TRAIN_REP_S[MAIN_CST]. */
        uint32_t pre_status            : 2;  /**< [  1:  0] See CGX_SPU_BR_TRAIN_REP_S[PRE_CST]. */
#else /* Word 0 - Little Endian */
        uint32_t pre_status            : 2;  /**< [  1:  0] See CGX_SPU_BR_TRAIN_REP_S[PRE_CST]. */
        uint32_t main_status           : 2;  /**< [  3:  2] See CGX_SPU_BR_TRAIN_REP_S[MAIN_CST]. */
        uint32_t post_status           : 2;  /**< [  5:  4] See CGX_SPU_BR_TRAIN_REP_S[POST_CST]. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgx_spu_sds_sr_s_s cn; */
};

/**
 * Register (RSL) cgx#_active_pc
 *
 * CGX ACTIVE PC Register
 * This register counts the conditional clocks for power management.
 */
union bdk_cgxx_active_pc
{
    uint64_t u;
    struct bdk_cgxx_active_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count of conditional clock cycles since reset. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count of conditional clock cycles since reset. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_active_pc_s cn; */
};
typedef union bdk_cgxx_active_pc bdk_cgxx_active_pc_t;

static inline uint64_t BDK_CGXX_ACTIVE_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_ACTIVE_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_ACTIVE_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_ACTIVE_PC(a) bdk_cgxx_active_pc_t
#define bustype_BDK_CGXX_ACTIVE_PC(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_ACTIVE_PC(a) "CGXX_ACTIVE_PC"
#define device_bar_BDK_CGXX_ACTIVE_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_ACTIVE_PC(a) (a)
#define arguments_BDK_CGXX_ACTIVE_PC(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr#_activity
 *
 * CGX CMR Activity Registers
 */
union bdk_cgxx_cmrx_activity
{
    uint64_t u;
    struct bdk_cgxx_cmrx_activity_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t pause_rx              : 1;  /**< [  5:  5](R/W1C/H) Set whenever MAC receives PAUSE or PFC packets. */
        uint64_t act_rx_hi             : 1;  /**< [  4:  4](R/W1C/H) Set whenever MAC receive activity signal is high. */
        uint64_t act_rx_lo             : 1;  /**< [  3:  3](R/W1C/H) Set whenever MAC receive side activity signal is low. */
        uint64_t pause_tx              : 1;  /**< [  2:  2](R/W1C/H) Set whenever MAC transmits PAUSE or PFC packets. */
        uint64_t act_tx_hi             : 1;  /**< [  1:  1](R/W1C/H) Set whenever MAC transmit activity signal is high. */
        uint64_t act_tx_lo             : 1;  /**< [  0:  0](R/W1C/H) Set whenever MAC transmit side activity signal is low. */
#else /* Word 0 - Little Endian */
        uint64_t act_tx_lo             : 1;  /**< [  0:  0](R/W1C/H) Set whenever MAC transmit side activity signal is low. */
        uint64_t act_tx_hi             : 1;  /**< [  1:  1](R/W1C/H) Set whenever MAC transmit activity signal is high. */
        uint64_t pause_tx              : 1;  /**< [  2:  2](R/W1C/H) Set whenever MAC transmits PAUSE or PFC packets. */
        uint64_t act_rx_lo             : 1;  /**< [  3:  3](R/W1C/H) Set whenever MAC receive side activity signal is low. */
        uint64_t act_rx_hi             : 1;  /**< [  4:  4](R/W1C/H) Set whenever MAC receive activity signal is high. */
        uint64_t pause_rx              : 1;  /**< [  5:  5](R/W1C/H) Set whenever MAC receives PAUSE or PFC packets. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_activity_s cn; */
};
typedef union bdk_cgxx_cmrx_activity bdk_cgxx_cmrx_activity_t;

static inline uint64_t BDK_CGXX_CMRX_ACTIVITY(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_ACTIVITY(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00005f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00005f8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00005f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00005f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_ACTIVITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_ACTIVITY(a,b) bdk_cgxx_cmrx_activity_t
#define bustype_BDK_CGXX_CMRX_ACTIVITY(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_ACTIVITY(a,b) "CGXX_CMRX_ACTIVITY"
#define device_bar_BDK_CGXX_CMRX_ACTIVITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_ACTIVITY(a,b) (a)
#define arguments_BDK_CGXX_CMRX_ACTIVITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_config
 *
 * CGX CMR Configuration Registers
 * Logical MAC/PCS configuration registers; one per LMAC. The maximum number of LMACs (and
 * maximum LMAC ID) that can be enabled by these registers is limited by
 * CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS].
 *
 * Internal:
 * \<pre\>
 * Example configurations:
 *   ---------------------------------------------------------------------------
 *   Configuration           LMACS  Register             [ENABLE]    [LMAC_TYPE]
 *   ---------------------------------------------------------------------------
 *   1x50G+1x25G+1xSGMII     4      CGXn_CMR0_CONFIG     1           8
 *                                  CGXn_CMR1_CONFIG     0           --
 *                                  CGXn_CMR2_CONFIG     1           7
 *                                  CGXn_CMR3_CONFIG     1           0
 *   ---------------------------------------------------------------------------
 *   USXGMII                 1-4    CGXn_CMR0_CONFIG     1           a
 *                                  CGXn_CMR1_CONFIG     1           a
 *                                  CGXn_CMR2_CONFIG     1           a
 *                                  CGXn_CMR3_CONFIG     1           a
 *   ---------------------------------------------------------------------------
 *   1x100GBASE-R4           1      CGXn_CMR0_CONFIG     1           9
 *                                  CGXn_CMR1_CONFIG     0           --
 *                                  CGXn_CMR2_CONFIG     0           --
 *                                  CGXn_CMR3_CONFIG     0           --
 *   ---------------------------------------------------------------------------
 *   2x50GBASE-R2            2      CGXn_CMR0_CONFIG     1           8
 *                                  CGXn_CMR1_CONFIG     1           8
 *                                  CGXn_CMR2_CONFIG     0           --
 *                                  CGXn_CMR3_CONFIG     0           --
 *   ---------------------------------------------------------------------------
 *   4x25GBASE-R             4      CGXn_CMR0_CONFIG     1           7
 *                                  CGXn_CMR1_CONFIG     1           7
 *                                  CGXn_CMR2_CONFIG     1           7
 *                                  CGXn_CMR3_CONFIG     1           7
 *   ---------------------------------------------------------------------------
 *   QSGMII                  4      CGXn_CMR0_CONFIG     1           6
 *                                  CGXn_CMR1_CONFIG     1           6
 *                                  CGXn_CMR2_CONFIG     1           6
 *                                  CGXn_CMR3_CONFIG     1           6
 *   ---------------------------------------------------------------------------
 *   1x40GBASE-R4            1      CGXn_CMR0_CONFIG     1           4
 *                                  CGXn_CMR1_CONFIG     0           --
 *                                  CGXn_CMR2_CONFIG     0           --
 *                                  CGXn_CMR3_CONFIG     0           --
 *   ---------------------------------------------------------------------------
 *   4x10GBASE-R             4      CGXn_CMR0_CONFIG     1           3
 *                                  CGXn_CMR1_CONFIG     1           3
 *                                  CGXn_CMR2_CONFIG     1           3
 *                                  CGXn_CMR3_CONFIG     1           3
 *   ---------------------------------------------------------------------------
 *   2xRXAUI                 2      CGXn_CMR0_CONFIG     1           2
 *                                  CGXn_CMR1_CONFIG     1           2
 *                                  CGXn_CMR2_CONFIG     0           --
 *                                  CGXn_CMR3_CONFIG     0           --
 *   ---------------------------------------------------------------------------
 *   1x10GBASE-X/XAUI/DXAUI  1      CGXn_CMR0_CONFIG     1           1
 *                                  CGXn_CMR1_CONFIG     0           --
 *                                  CGXn_CMR2_CONFIG     0           --
 *                                  CGXn_CMR3_CONFIG     0           --
 *   ---------------------------------------------------------------------------
 *   4xSGMII/1000BASE-X      4      CGXn_CMR0_CONFIG     1           0
 *                                  CGXn_CMR1_CONFIG     1           0
 *                                  CGXn_CMR2_CONFIG     1           0
 *                                  CGXn_CMR3_CONFIG     1           0
 *   ---------------------------------------------------------------------------
 * \</pre\>
 */
union bdk_cgxx_cmrx_config
{
    uint64_t u;
    struct bdk_cgxx_cmrx_config_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects interior side P2X interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects interior side X2P interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated CGX context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared CGX resources (data path, SerDes lanes) is disabled.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. This bit together with [LMAC_TYPE] is also used to
                                                                 enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                                 is enabled when any of the paths are enabled. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Data packet receive enable. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 1, the reception of
                                                                 data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 0, the
                                                                 MAC layer drops received data and flow-control packets. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Data packet transmit enable. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 1, the transmission
                                                                 of data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 0,
                                                                 the MAC layer suppresses the transmission of new data and packets for the LMAC. */
        uint64_t int_beat_gen          : 1;  /**< [ 52: 52](R/W) Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                                 during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
                                                                 TXREADY/TXCREDIT from the associated SerDes lanes, internally generates fake (idle)
                                                                 RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
        uint64_t unused                : 8;  /**< [ 51: 44](RAZ) Reserved. */
        uint64_t lmac_type             : 4;  /**< [ 43: 40](R/W) Logical MAC/PCS/port type:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Name     Description          NUM_LOG_LANES
                                                                   ---------  -------  -------------------  -------------
                                                                   0x0        SGMII    SGMII/1000BASE-X             1
                                                                   0x1        XAUI     10GBASE-X/XAUI or DXAUI      4
                                                                   0x2        RXAUI    Reduced XAUI                 2
                                                                   0x3        10G_R    10GBASE-R                    1
                                                                   0x4        40G_R    40GBASE-R                    4
                                                                   0x5        --       Reserved                     -
                                                                   0x6        QSGMII   QSGMII                       1
                                                                   0x7        25G_R    25GBASE-R                    1
                                                                   0x8        50G_R    50GBASE-R                    2
                                                                   0x9        100G_R   100GBASE-R                   4
                                                                   0xa        USXGMII  USXGMII                      1
                                                                   Other      --       Reserved                     -
                                                                 \</pre\>

                                                                 NUM_LOG_LANES specifies the number of logical lanes that are valid for
                                                                 each type. Each valid logical lane is mapped to a physical SerDes lane
                                                                 based on the programming of [LANE_TO_SDS], except in USXGMII mode.

                                                                 This field must be programmed to its final value before [ENABLE] is set, and must not
                                                                 be changed when [ENABLE] = 1.

                                                                 When LMAC_TYPE = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK]  = 0.
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_STRP] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN]      = 8.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL]   = 1. */
        uint64_t reserved_8_39         : 32;
        uint64_t lane_to_sds           : 8;  /**< [  7:  0](R/W) Logical lane-to-SerDes lane mapping.
                                                                 This is an array of 2-bit values that map each logical PCS lane in the LMAC to a
                                                                 physical SerDes lane, as follows:

                                                                 \<pre\>
                                                                   Bits     Description                Reset value
                                                                   -------  -------------------------  -----------
                                                                   \<07:06\>  Logical lane 03 SerDes ID       0x3
                                                                   \<05:04\>  Logical lane 02 SerDes ID       0x2
                                                                   \<03:02\>  Logical lane 01 SerDes ID       0x1
                                                                   \<01:00\>  Logical lane 00 SerDes ID       0x0
                                                                 \</pre\>
                                                                 \<page\>

                                                                 Logical PCS lanes 0 through NUM_LOG_LANES-1 are valid, where NUM_LOG_LANES is a
                                                                 function of the logical MAC/PCS type (see [LMAC_TYPE]). For example, when
                                                                 [LMAC_TYPE] = SGMII, then there is only one PCS lane per LMAC (NUM_LOG_LANES =
                                                                 1), and it will be logical PCS lane 0, and the associated physical SerDes lanes
                                                                 are selected by bits \<1:0\>.

                                                                 For 40GBASE-R ([LMAC_TYPE] = 40G_R), all four logical lanes are valid, and the PCS lane
                                                                 IDs determine the block distribution order and associated alignment markers on the
                                                                 transmit side. This is not necessarily the order in which logical lanes receive data
                                                                 because 802.3 allows multilane BASE-R receive lanes to be reordered. When a lane
                                                                 (called service interface (or lane) in 802.3) has achieved alignment marker lock on the
                                                                 receive side (i.e. the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), then
                                                                 the actual detected RX PCS lane number is recorded in the corresponding
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies to 100GBASE-R ([LMAC_TYPE] = 100G_R) which also uses all four logical
                                                                 lanes which fan into 20 service lanes. The 20 service lanes map to 20 PCS lanes via
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies individually for each of up to two 50GBASE-R LMACs ([LMAC_TYPE] =
                                                                 50G_R) each of which uses 2 logical lanes and 2 SerDes.

                                                                 For QSGMII, [LANE_TO_SDS]\<1:0\> for LMAC 0 selects the physical SerDes lane shared by four
                                                                 LMACs, and [LANE_TO_SDS]\<1:0\> must be unique for each of the four LMACs.

                                                                 For USXGMII, [LANE_TO_SDS] is ignored.  For SerDes mapping in USXGMII mode, see
                                                                 CGX()_SPU_USXGMII_CONTROL[SDS_ID].

                                                                 This field must be programmed to its final value before [ENABLE] is set, and
                                                                 must not be changed when [ENABLE] = 1. */
#else /* Word 0 - Little Endian */
        uint64_t lane_to_sds           : 8;  /**< [  7:  0](R/W) Logical lane-to-SerDes lane mapping.
                                                                 This is an array of 2-bit values that map each logical PCS lane in the LMAC to a
                                                                 physical SerDes lane, as follows:

                                                                 \<pre\>
                                                                   Bits     Description                Reset value
                                                                   -------  -------------------------  -----------
                                                                   \<07:06\>  Logical lane 03 SerDes ID       0x3
                                                                   \<05:04\>  Logical lane 02 SerDes ID       0x2
                                                                   \<03:02\>  Logical lane 01 SerDes ID       0x1
                                                                   \<01:00\>  Logical lane 00 SerDes ID       0x0
                                                                 \</pre\>
                                                                 \<page\>

                                                                 Logical PCS lanes 0 through NUM_LOG_LANES-1 are valid, where NUM_LOG_LANES is a
                                                                 function of the logical MAC/PCS type (see [LMAC_TYPE]). For example, when
                                                                 [LMAC_TYPE] = SGMII, then there is only one PCS lane per LMAC (NUM_LOG_LANES =
                                                                 1), and it will be logical PCS lane 0, and the associated physical SerDes lanes
                                                                 are selected by bits \<1:0\>.

                                                                 For 40GBASE-R ([LMAC_TYPE] = 40G_R), all four logical lanes are valid, and the PCS lane
                                                                 IDs determine the block distribution order and associated alignment markers on the
                                                                 transmit side. This is not necessarily the order in which logical lanes receive data
                                                                 because 802.3 allows multilane BASE-R receive lanes to be reordered. When a lane
                                                                 (called service interface (or lane) in 802.3) has achieved alignment marker lock on the
                                                                 receive side (i.e. the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), then
                                                                 the actual detected RX PCS lane number is recorded in the corresponding
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies to 100GBASE-R ([LMAC_TYPE] = 100G_R) which also uses all four logical
                                                                 lanes which fan into 20 service lanes. The 20 service lanes map to 20 PCS lanes via
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies individually for each of up to two 50GBASE-R LMACs ([LMAC_TYPE] =
                                                                 50G_R) each of which uses 2 logical lanes and 2 SerDes.

                                                                 For QSGMII, [LANE_TO_SDS]\<1:0\> for LMAC 0 selects the physical SerDes lane shared by four
                                                                 LMACs, and [LANE_TO_SDS]\<1:0\> must be unique for each of the four LMACs.

                                                                 For USXGMII, [LANE_TO_SDS] is ignored.  For SerDes mapping in USXGMII mode, see
                                                                 CGX()_SPU_USXGMII_CONTROL[SDS_ID].

                                                                 This field must be programmed to its final value before [ENABLE] is set, and
                                                                 must not be changed when [ENABLE] = 1. */
        uint64_t reserved_8_39         : 32;
        uint64_t lmac_type             : 4;  /**< [ 43: 40](R/W) Logical MAC/PCS/port type:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Name     Description          NUM_LOG_LANES
                                                                   ---------  -------  -------------------  -------------
                                                                   0x0        SGMII    SGMII/1000BASE-X             1
                                                                   0x1        XAUI     10GBASE-X/XAUI or DXAUI      4
                                                                   0x2        RXAUI    Reduced XAUI                 2
                                                                   0x3        10G_R    10GBASE-R                    1
                                                                   0x4        40G_R    40GBASE-R                    4
                                                                   0x5        --       Reserved                     -
                                                                   0x6        QSGMII   QSGMII                       1
                                                                   0x7        25G_R    25GBASE-R                    1
                                                                   0x8        50G_R    50GBASE-R                    2
                                                                   0x9        100G_R   100GBASE-R                   4
                                                                   0xa        USXGMII  USXGMII                      1
                                                                   Other      --       Reserved                     -
                                                                 \</pre\>

                                                                 NUM_LOG_LANES specifies the number of logical lanes that are valid for
                                                                 each type. Each valid logical lane is mapped to a physical SerDes lane
                                                                 based on the programming of [LANE_TO_SDS], except in USXGMII mode.

                                                                 This field must be programmed to its final value before [ENABLE] is set, and must not
                                                                 be changed when [ENABLE] = 1.

                                                                 When LMAC_TYPE = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK]  = 0.
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_STRP] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN]      = 8.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL]   = 1. */
        uint64_t unused                : 8;  /**< [ 51: 44](RAZ) Reserved. */
        uint64_t int_beat_gen          : 1;  /**< [ 52: 52](R/W) Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                                 during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
                                                                 TXREADY/TXCREDIT from the associated SerDes lanes, internally generates fake (idle)
                                                                 RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Data packet transmit enable. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 1, the transmission
                                                                 of data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 0,
                                                                 the MAC layer suppresses the transmission of new data and packets for the LMAC. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Data packet receive enable. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 1, the reception of
                                                                 data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 0, the
                                                                 MAC layer drops received data and flow-control packets. */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated CGX context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared CGX resources (data path, SerDes lanes) is disabled.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. This bit together with [LMAC_TYPE] is also used to
                                                                 enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                                 is enabled when any of the paths are enabled. */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects interior side X2P interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects interior side P2X interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_config_s cn9; */
    /* struct bdk_cgxx_cmrx_config_s cn96xx; */
    struct bdk_cgxx_cmrx_config_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects interior side P2X interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2                 P2X2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects interior side X2P interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2                 X2P2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated CGX context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared CGX resources (data path, SerDes lanes) is disabled.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. This bit together with [LMAC_TYPE] is also used to
                                                                 enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                                 is enabled when any of the paths are enabled. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Data packet receive enable. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 1, the reception of
                                                                 data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 0, the
                                                                 MAC layer drops received data and flow-control packets. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Data packet transmit enable. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 1, the transmission
                                                                 of data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 0,
                                                                 the MAC layer suppresses the transmission of new data and packets for the LMAC. */
        uint64_t int_beat_gen          : 1;  /**< [ 52: 52](R/W) Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                                 during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
                                                                 TXREADY/TXCREDIT from the associated SerDes lanes, internally generates fake (idle)
                                                                 RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
        uint64_t unused                : 8;  /**< [ 51: 44](RAZ) Reserved. */
        uint64_t lmac_type             : 4;  /**< [ 43: 40](R/W) Logical MAC/PCS/port type:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Name     Description          NUM_LOG_LANES
                                                                   ---------  -------  -------------------  -------------
                                                                   0x0        SGMII    SGMII/1000BASE-X             1
                                                                   0x1        XAUI     10GBASE-X/XAUI or DXAUI      4
                                                                   0x2        RXAUI    Reduced XAUI                 2
                                                                   0x3        10G_R    10GBASE-R                    1
                                                                   0x4        40G_R    40GBASE-R                    4
                                                                   0x5        --       Reserved                     -
                                                                   0x6        QSGMII   QSGMII                       1
                                                                   0x7        25G_R    25GBASE-R                    1
                                                                   0x8        50G_R    50GBASE-R                    2
                                                                   0x9        100G_R   100GBASE-R                   4
                                                                   0xa        USXGMII  USXGMII                      1
                                                                   Other      --       Reserved                     -
                                                                 \</pre\>

                                                                 NUM_LOG_LANES specifies the number of logical lanes that are valid for
                                                                 each type. Each valid logical lane is mapped to a physical SerDes lane
                                                                 based on the programming of [LANE_TO_SDS], except in USXGMII mode.

                                                                 This field must be programmed to its final value before [ENABLE] is set, and must not
                                                                 be changed when [ENABLE] = 1.

                                                                 When LMAC_TYPE = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK]  = 0.
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_STRP] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN]      = 8.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL]   = 1. */
        uint64_t reserved_8_39         : 32;
        uint64_t lane_to_sds           : 8;  /**< [  7:  0](R/W) Logical lane-to-SerDes lane mapping.
                                                                 This is an array of 2-bit values that map each logical PCS lane in the LMAC to a
                                                                 physical SerDes lane, as follows:

                                                                 \<pre\>
                                                                   Bits     Description                Reset value
                                                                   -------  -------------------------  -----------
                                                                   \<07:06\>  Logical lane 03 SerDes ID       0x3
                                                                   \<05:04\>  Logical lane 02 SerDes ID       0x2
                                                                   \<03:02\>  Logical lane 01 SerDes ID       0x1
                                                                   \<01:00\>  Logical lane 00 SerDes ID       0x0
                                                                 \</pre\>
                                                                 \<page\>

                                                                 Logical PCS lanes 0 through NUM_LOG_LANES-1 are valid, where NUM_LOG_LANES is a
                                                                 function of the logical MAC/PCS type (see [LMAC_TYPE]). For example, when
                                                                 [LMAC_TYPE] = SGMII, then there is only one PCS lane per LMAC (NUM_LOG_LANES =
                                                                 1), and it will be logical PCS lane 0, and the associated physical SerDes lanes
                                                                 are selected by bits \<1:0\>.

                                                                 For 40GBASE-R ([LMAC_TYPE] = 40G_R), all four logical lanes are valid, and the PCS lane
                                                                 IDs determine the block distribution order and associated alignment markers on the
                                                                 transmit side. This is not necessarily the order in which logical lanes receive data
                                                                 because 802.3 allows multilane BASE-R receive lanes to be reordered. When a lane
                                                                 (called service interface (or lane) in 802.3) has achieved alignment marker lock on the
                                                                 receive side (i.e. the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), then
                                                                 the actual detected RX PCS lane number is recorded in the corresponding
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies to 100GBASE-R ([LMAC_TYPE] = 100G_R) which also uses all four logical
                                                                 lanes which fan into 20 service lanes. The 20 service lanes map to 20 PCS lanes via
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies individually for each of up to two 50GBASE-R LMACs ([LMAC_TYPE] =
                                                                 50G_R) each of which uses 2 logical lanes and 2 SerDes.

                                                                 For QSGMII, [LANE_TO_SDS]\<1:0\> for LMAC 0 selects the physical SerDes lane shared by four
                                                                 LMACs, and [LANE_TO_SDS]\<1:0\> must be unique for each of the four LMACs.

                                                                 For USXGMII, [LANE_TO_SDS] is ignored.  For SerDes mapping in USXGMII mode, see
                                                                 CGX()_SPU_USXGMII_CONTROL[SDS_ID].

                                                                 This field must be programmed to its final value before [ENABLE] is set, and
                                                                 must not be changed when [ENABLE] = 1. */
#else /* Word 0 - Little Endian */
        uint64_t lane_to_sds           : 8;  /**< [  7:  0](R/W) Logical lane-to-SerDes lane mapping.
                                                                 This is an array of 2-bit values that map each logical PCS lane in the LMAC to a
                                                                 physical SerDes lane, as follows:

                                                                 \<pre\>
                                                                   Bits     Description                Reset value
                                                                   -------  -------------------------  -----------
                                                                   \<07:06\>  Logical lane 03 SerDes ID       0x3
                                                                   \<05:04\>  Logical lane 02 SerDes ID       0x2
                                                                   \<03:02\>  Logical lane 01 SerDes ID       0x1
                                                                   \<01:00\>  Logical lane 00 SerDes ID       0x0
                                                                 \</pre\>
                                                                 \<page\>

                                                                 Logical PCS lanes 0 through NUM_LOG_LANES-1 are valid, where NUM_LOG_LANES is a
                                                                 function of the logical MAC/PCS type (see [LMAC_TYPE]). For example, when
                                                                 [LMAC_TYPE] = SGMII, then there is only one PCS lane per LMAC (NUM_LOG_LANES =
                                                                 1), and it will be logical PCS lane 0, and the associated physical SerDes lanes
                                                                 are selected by bits \<1:0\>.

                                                                 For 40GBASE-R ([LMAC_TYPE] = 40G_R), all four logical lanes are valid, and the PCS lane
                                                                 IDs determine the block distribution order and associated alignment markers on the
                                                                 transmit side. This is not necessarily the order in which logical lanes receive data
                                                                 because 802.3 allows multilane BASE-R receive lanes to be reordered. When a lane
                                                                 (called service interface (or lane) in 802.3) has achieved alignment marker lock on the
                                                                 receive side (i.e. the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), then
                                                                 the actual detected RX PCS lane number is recorded in the corresponding
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies to 100GBASE-R ([LMAC_TYPE] = 100G_R) which also uses all four logical
                                                                 lanes which fan into 20 service lanes. The 20 service lanes map to 20 PCS lanes via
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies individually for each of up to two 50GBASE-R LMACs ([LMAC_TYPE] =
                                                                 50G_R) each of which uses 2 logical lanes and 2 SerDes.

                                                                 For QSGMII, [LANE_TO_SDS]\<1:0\> for LMAC 0 selects the physical SerDes lane shared by four
                                                                 LMACs, and [LANE_TO_SDS]\<1:0\> must be unique for each of the four LMACs.

                                                                 For USXGMII, [LANE_TO_SDS] is ignored.  For SerDes mapping in USXGMII mode, see
                                                                 CGX()_SPU_USXGMII_CONTROL[SDS_ID].

                                                                 This field must be programmed to its final value before [ENABLE] is set, and
                                                                 must not be changed when [ENABLE] = 1. */
        uint64_t reserved_8_39         : 32;
        uint64_t lmac_type             : 4;  /**< [ 43: 40](R/W) Logical MAC/PCS/port type:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Name     Description          NUM_LOG_LANES
                                                                   ---------  -------  -------------------  -------------
                                                                   0x0        SGMII    SGMII/1000BASE-X             1
                                                                   0x1        XAUI     10GBASE-X/XAUI or DXAUI      4
                                                                   0x2        RXAUI    Reduced XAUI                 2
                                                                   0x3        10G_R    10GBASE-R                    1
                                                                   0x4        40G_R    40GBASE-R                    4
                                                                   0x5        --       Reserved                     -
                                                                   0x6        QSGMII   QSGMII                       1
                                                                   0x7        25G_R    25GBASE-R                    1
                                                                   0x8        50G_R    50GBASE-R                    2
                                                                   0x9        100G_R   100GBASE-R                   4
                                                                   0xa        USXGMII  USXGMII                      1
                                                                   Other      --       Reserved                     -
                                                                 \</pre\>

                                                                 NUM_LOG_LANES specifies the number of logical lanes that are valid for
                                                                 each type. Each valid logical lane is mapped to a physical SerDes lane
                                                                 based on the programming of [LANE_TO_SDS], except in USXGMII mode.

                                                                 This field must be programmed to its final value before [ENABLE] is set, and must not
                                                                 be changed when [ENABLE] = 1.

                                                                 When LMAC_TYPE = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK]  = 0.
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_STRP] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN]      = 8.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL]   = 1. */
        uint64_t unused                : 8;  /**< [ 51: 44](RAZ) Reserved. */
        uint64_t int_beat_gen          : 1;  /**< [ 52: 52](R/W) Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                                 during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
                                                                 TXREADY/TXCREDIT from the associated SerDes lanes, internally generates fake (idle)
                                                                 RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Data packet transmit enable. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 1, the transmission
                                                                 of data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 0,
                                                                 the MAC layer suppresses the transmission of new data and packets for the LMAC. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Data packet receive enable. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 1, the reception of
                                                                 data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 0, the
                                                                 MAC layer drops received data and flow-control packets. */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated CGX context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared CGX resources (data path, SerDes lanes) is disabled.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. This bit together with [LMAC_TYPE] is also used to
                                                                 enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                                 is enabled when any of the paths are enabled. */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects interior side X2P interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2                 X2P2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects interior side P2X interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2                 P2X2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_cmrx_config_s cnf95xxp1; */
    struct bdk_cgxx_cmrx_config_cnf95xxp2
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects interior side P2X interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0 (for CGX0), RFOE0 (for CGX1), RFOE1 (for CGX2)
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects interior side X2P interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0 (for CGX0), RFOE0 (for CGX1), RFOE1 (for CGX2)
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated CGX context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared CGX resources (data path, SerDes lanes) is disabled.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. This bit together with [LMAC_TYPE] is also used to
                                                                 enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                                 is enabled when any of the paths are enabled. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Data packet receive enable. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 1, the reception of
                                                                 data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 0, the
                                                                 MAC layer drops received data and flow-control packets. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Data packet transmit enable. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 1, the transmission
                                                                 of data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 0,
                                                                 the MAC layer suppresses the transmission of new data and packets for the LMAC. */
        uint64_t int_beat_gen          : 1;  /**< [ 52: 52](R/W) Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                                 during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
                                                                 TXREADY/TXCREDIT from the associated SerDes lanes, internally generates fake (idle)
                                                                 RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
        uint64_t unused                : 8;  /**< [ 51: 44](RAZ) Reserved. */
        uint64_t lmac_type             : 4;  /**< [ 43: 40](R/W) Logical MAC/PCS/port type:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Name     Description          NUM_LOG_LANES
                                                                   ---------  -------  -------------------  -------------
                                                                   0x0        SGMII    SGMII/1000BASE-X             1
                                                                   0x1        XAUI     10GBASE-X/XAUI or DXAUI      4
                                                                   0x2        RXAUI    Reduced XAUI                 2
                                                                   0x3        10G_R    10GBASE-R                    1
                                                                   0x4        40G_R    40GBASE-R                    4
                                                                   0x5        --       Reserved                     -
                                                                   0x6        QSGMII   QSGMII                       1
                                                                   0x7        25G_R    25GBASE-R                    1
                                                                   0x8        50G_R    50GBASE-R                    2
                                                                   0x9        100G_R   100GBASE-R                   4
                                                                   0xa        USXGMII  USXGMII                      1
                                                                   Other      --       Reserved                     -
                                                                 \</pre\>

                                                                 NUM_LOG_LANES specifies the number of logical lanes that are valid for
                                                                 each type. Each valid logical lane is mapped to a physical SerDes lane
                                                                 based on the programming of [LANE_TO_SDS], except in USXGMII mode.

                                                                 This field must be programmed to its final value before [ENABLE] is set, and must not
                                                                 be changed when [ENABLE] = 1.

                                                                 When LMAC_TYPE = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK]  = 0.
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_STRP] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN]      = 8.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL]   = 1. */
        uint64_t reserved_8_39         : 32;
        uint64_t lane_to_sds           : 8;  /**< [  7:  0](R/W) Logical lane-to-SerDes lane mapping.
                                                                 This is an array of 2-bit values that map each logical PCS lane in the LMAC to a
                                                                 physical SerDes lane, as follows:

                                                                 \<pre\>
                                                                   Bits     Description                Reset value
                                                                   -------  -------------------------  -----------
                                                                   \<07:06\>  Logical lane 03 SerDes ID       0x3
                                                                   \<05:04\>  Logical lane 02 SerDes ID       0x2
                                                                   \<03:02\>  Logical lane 01 SerDes ID       0x1
                                                                   \<01:00\>  Logical lane 00 SerDes ID       0x0
                                                                 \</pre\>
                                                                 \<page\>

                                                                 Logical PCS lanes 0 through NUM_LOG_LANES-1 are valid, where NUM_LOG_LANES is a
                                                                 function of the logical MAC/PCS type (see [LMAC_TYPE]). For example, when
                                                                 [LMAC_TYPE] = SGMII, then there is only one PCS lane per LMAC (NUM_LOG_LANES =
                                                                 1), and it will be logical PCS lane 0, and the associated physical SerDes lanes
                                                                 are selected by bits \<1:0\>.

                                                                 For 40GBASE-R ([LMAC_TYPE] = 40G_R), all four logical lanes are valid, and the PCS lane
                                                                 IDs determine the block distribution order and associated alignment markers on the
                                                                 transmit side. This is not necessarily the order in which logical lanes receive data
                                                                 because 802.3 allows multilane BASE-R receive lanes to be reordered. When a lane
                                                                 (called service interface (or lane) in 802.3) has achieved alignment marker lock on the
                                                                 receive side (i.e. the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), then
                                                                 the actual detected RX PCS lane number is recorded in the corresponding
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies to 100GBASE-R ([LMAC_TYPE] = 100G_R) which also uses all four logical
                                                                 lanes which fan into 20 service lanes. The 20 service lanes map to 20 PCS lanes via
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies individually for each of up to two 50GBASE-R LMACs ([LMAC_TYPE] =
                                                                 50G_R) each of which uses 2 logical lanes and 2 SerDes.

                                                                 For QSGMII, [LANE_TO_SDS]\<1:0\> for LMAC 0 selects the physical SerDes lane shared by four
                                                                 LMACs, and [LANE_TO_SDS]\<1:0\> must be unique for each of the four LMACs.

                                                                 For USXGMII, [LANE_TO_SDS] is ignored.  For SerDes mapping in USXGMII mode, see
                                                                 CGX()_SPU_USXGMII_CONTROL[SDS_ID].

                                                                 This field must be programmed to its final value before [ENABLE] is set, and
                                                                 must not be changed when [ENABLE] = 1. */
#else /* Word 0 - Little Endian */
        uint64_t lane_to_sds           : 8;  /**< [  7:  0](R/W) Logical lane-to-SerDes lane mapping.
                                                                 This is an array of 2-bit values that map each logical PCS lane in the LMAC to a
                                                                 physical SerDes lane, as follows:

                                                                 \<pre\>
                                                                   Bits     Description                Reset value
                                                                   -------  -------------------------  -----------
                                                                   \<07:06\>  Logical lane 03 SerDes ID       0x3
                                                                   \<05:04\>  Logical lane 02 SerDes ID       0x2
                                                                   \<03:02\>  Logical lane 01 SerDes ID       0x1
                                                                   \<01:00\>  Logical lane 00 SerDes ID       0x0
                                                                 \</pre\>
                                                                 \<page\>

                                                                 Logical PCS lanes 0 through NUM_LOG_LANES-1 are valid, where NUM_LOG_LANES is a
                                                                 function of the logical MAC/PCS type (see [LMAC_TYPE]). For example, when
                                                                 [LMAC_TYPE] = SGMII, then there is only one PCS lane per LMAC (NUM_LOG_LANES =
                                                                 1), and it will be logical PCS lane 0, and the associated physical SerDes lanes
                                                                 are selected by bits \<1:0\>.

                                                                 For 40GBASE-R ([LMAC_TYPE] = 40G_R), all four logical lanes are valid, and the PCS lane
                                                                 IDs determine the block distribution order and associated alignment markers on the
                                                                 transmit side. This is not necessarily the order in which logical lanes receive data
                                                                 because 802.3 allows multilane BASE-R receive lanes to be reordered. When a lane
                                                                 (called service interface (or lane) in 802.3) has achieved alignment marker lock on the
                                                                 receive side (i.e. the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), then
                                                                 the actual detected RX PCS lane number is recorded in the corresponding
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies to 100GBASE-R ([LMAC_TYPE] = 100G_R) which also uses all four logical
                                                                 lanes which fan into 20 service lanes. The 20 service lanes map to 20 PCS lanes via
                                                                 CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING].

                                                                 Above also applies individually for each of up to two 50GBASE-R LMACs ([LMAC_TYPE] =
                                                                 50G_R) each of which uses 2 logical lanes and 2 SerDes.

                                                                 For QSGMII, [LANE_TO_SDS]\<1:0\> for LMAC 0 selects the physical SerDes lane shared by four
                                                                 LMACs, and [LANE_TO_SDS]\<1:0\> must be unique for each of the four LMACs.

                                                                 For USXGMII, [LANE_TO_SDS] is ignored.  For SerDes mapping in USXGMII mode, see
                                                                 CGX()_SPU_USXGMII_CONTROL[SDS_ID].

                                                                 This field must be programmed to its final value before [ENABLE] is set, and
                                                                 must not be changed when [ENABLE] = 1. */
        uint64_t reserved_8_39         : 32;
        uint64_t lmac_type             : 4;  /**< [ 43: 40](R/W) Logical MAC/PCS/port type:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Name     Description          NUM_LOG_LANES
                                                                   ---------  -------  -------------------  -------------
                                                                   0x0        SGMII    SGMII/1000BASE-X             1
                                                                   0x1        XAUI     10GBASE-X/XAUI or DXAUI      4
                                                                   0x2        RXAUI    Reduced XAUI                 2
                                                                   0x3        10G_R    10GBASE-R                    1
                                                                   0x4        40G_R    40GBASE-R                    4
                                                                   0x5        --       Reserved                     -
                                                                   0x6        QSGMII   QSGMII                       1
                                                                   0x7        25G_R    25GBASE-R                    1
                                                                   0x8        50G_R    50GBASE-R                    2
                                                                   0x9        100G_R   100GBASE-R                   4
                                                                   0xa        USXGMII  USXGMII                      1
                                                                   Other      --       Reserved                     -
                                                                 \</pre\>

                                                                 NUM_LOG_LANES specifies the number of logical lanes that are valid for
                                                                 each type. Each valid logical lane is mapped to a physical SerDes lane
                                                                 based on the programming of [LANE_TO_SDS], except in USXGMII mode.

                                                                 This field must be programmed to its final value before [ENABLE] is set, and must not
                                                                 be changed when [ENABLE] = 1.

                                                                 When LMAC_TYPE = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK]  = 0.
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_STRP] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN]      = 8.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL]   = 1. */
        uint64_t unused                : 8;  /**< [ 51: 44](RAZ) Reserved. */
        uint64_t int_beat_gen          : 1;  /**< [ 52: 52](R/W) Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                                 during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
                                                                 TXREADY/TXCREDIT from the associated SerDes lanes, internally generates fake (idle)
                                                                 RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Data packet transmit enable. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 1, the transmission
                                                                 of data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_TX_EN] = 0,
                                                                 the MAC layer suppresses the transmission of new data and packets for the LMAC. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Data packet receive enable. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 1, the reception of
                                                                 data packets is enabled in the MAC layer. When [ENABLE] = 1 and [DATA_PKT_RX_EN] = 0, the
                                                                 MAC layer drops received data and flow-control packets. */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated CGX context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared CGX resources (data path, SerDes lanes) is disabled.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. This bit together with [LMAC_TYPE] is also used to
                                                                 enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                                 is enabled when any of the paths are enabled. */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects interior side X2P interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0 (for CGX0), RFOE0 (for CGX1), RFOE1 (for CGX2)
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects interior side P2X interface over which the LMAC will communicate:
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0 (for CGX0), RFOE0 (for CGX1), RFOE1 (for CGX2)
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } cnf95xxp2;
    /* struct bdk_cgxx_cmrx_config_cnf95xxp2 loki; */
};
typedef union bdk_cgxx_cmrx_config bdk_cgxx_cmrx_config_t;

static inline uint64_t BDK_CGXX_CMRX_CONFIG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_CONFIG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_CONFIG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_CONFIG(a,b) bdk_cgxx_cmrx_config_t
#define bustype_BDK_CGXX_CMRX_CONFIG(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_CONFIG(a,b) "CGXX_CMRX_CONFIG"
#define device_bar_BDK_CGXX_CMRX_CONFIG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_CONFIG(a,b) (a)
#define arguments_BDK_CGXX_CMRX_CONFIG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_int
 *
 * CGX CMR Interrupt Register
 */
union bdk_cgxx_cmrx_int
{
    uint64_t u;
    struct bdk_cgxx_cmrx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) TX channel out-of-range from NIX1 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) TX channel out-of-range from NIX0 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) TX channel out-of-range from NIX1 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) TX channel out-of-range from NIX0 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) RX overflow. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) RX PAUSE packet was dropped due to full RXB FIFO or during partner reset. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) RX PAUSE packet was dropped due to full RXB FIFO or during partner reset. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) RX overflow. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) TX channel out-of-range from NIX0 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) TX channel out-of-range from NIX1 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) TX channel out-of-range from NIX0 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) TX channel out-of-range from NIX1 interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_int_s cn; */
};
typedef union bdk_cgxx_cmrx_int bdk_cgxx_cmrx_int_t;

static inline uint64_t BDK_CGXX_CMRX_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_INT(a,b) bdk_cgxx_cmrx_int_t
#define bustype_BDK_CGXX_CMRX_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_INT(a,b) "CGXX_CMRX_INT"
#define device_bar_BDK_CGXX_CMRX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_INT(a,b) (a)
#define arguments_BDK_CGXX_CMRX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_int_ena_w1c
 *
 * CGX CMR Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_cmrx_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_cmrx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_cmrx_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_cmrx_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_cmrx_int_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_cmrx_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_cmrx_int_ena_w1c bdk_cgxx_cmrx_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_CMRX_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_INT_ENA_W1C(a,b) bdk_cgxx_cmrx_int_ena_w1c_t
#define bustype_BDK_CGXX_CMRX_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_INT_ENA_W1C(a,b) "CGXX_CMRX_INT_ENA_W1C"
#define device_bar_BDK_CGXX_CMRX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_CMRX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_int_ena_w1s
 *
 * CGX CMR Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_cmrx_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_cmrx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_cmrx_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_cmrx_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_cmrx_int_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_cmrx_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_cmrx_int_ena_w1s bdk_cgxx_cmrx_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_CMRX_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_INT_ENA_W1S(a,b) bdk_cgxx_cmrx_int_ena_w1s_t
#define bustype_BDK_CGXX_CMRX_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_INT_ENA_W1S(a,b) "CGXX_CMRX_INT_ENA_W1S"
#define device_bar_BDK_CGXX_CMRX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_CMRX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_int_w1s
 *
 * CGX CMR Interrupt Set Register
 * This register sets interrupt bits.
 */
union bdk_cgxx_cmrx_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_cmrx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_int_w1s_s cn9; */
    /* struct bdk_cgxx_cmrx_int_w1s_s cn96xx; */
    struct bdk_cgxx_cmrx_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_cmrx_int_w1s_s cnf95xx; */
    struct bdk_cgxx_cmrx_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[PAUSE_DRP]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_drp             : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[PAUSE_DRP]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t nic_nxc               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIC_NXC].
                                                                 Internal:
                                                                 TX channel out-of-range from NIC interface.
                                                                 Reported on this LMAC for ids in the range of lmac_id+4, lmac_id+8 and lmac_id+12.
                                                                 Reported regardless of LMAC enable or CGX()_CMR()_CONFIG[P2X_SELECT] association for this LMAC. */
        uint64_t nix0_nxc              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX0_NXC]. */
        uint64_t nix1_nxc              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX1_NXC]. */
        uint64_t nix0_e_nxc            : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX0_E_NXC]. */
        uint64_t nix1_e_nxc            : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_CMR(0..3)_INT[NIX1_E_NXC]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_cmrx_int_w1s bdk_cgxx_cmrx_int_w1s_t;

static inline uint64_t BDK_CGXX_CMRX_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_INT_W1S(a,b) bdk_cgxx_cmrx_int_w1s_t
#define bustype_BDK_CGXX_CMRX_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_INT_W1S(a,b) "CGXX_CMRX_INT_W1S"
#define device_bar_BDK_CGXX_CMRX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_CMRX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_led_timing
 *
 * CGX MAC LED Activity Timing Registers
 */
union bdk_cgxx_cmrx_led_timing
{
    uint64_t u;
    struct bdk_cgxx_cmrx_led_timing_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t extension             : 8;  /**< [  7:  0](R/W) Extension number of cycles for activity LED illumination. The same register is
                                                                 used for both MAC RX and TX.
                                                                 * For RX, LED is on for the data transfer length through minimum IFG +
                                                                 [EXTENSION] number of coprocessor-clock cycles.
                                                                 * For TX, LED on for data transfers through transition to IDLE + [EXTENSION]
                                                                 number of coprocessor-clock cycles.

                                                                 Internal:
                                                                 Per LMAC, SMU TX treats any 128-bus cycle that carries packet data and/or IFG as BUSY
                                                                 (called activity high cycle); any 128-bus carries all IDLE, or LPI, or FAULT sequence as
                                                                 IDLE (called activity low cycle). The extension counter starts when a high to low
                                                                 transition detected on the first low cycles. The counter continues counting on sclk until
                                                                 it reaches [EXTENSION]. If any BUSY cycle occurs during the counting procedure, the
                                                                 counter resets to 0. After the counter reaches [EXTENSION], once a low cycle occurs, the
                                                                 activity indication line switches to 0. A HIGH cycle will always switch the activity
                                                                 indication line to 1. */
#else /* Word 0 - Little Endian */
        uint64_t extension             : 8;  /**< [  7:  0](R/W) Extension number of cycles for activity LED illumination. The same register is
                                                                 used for both MAC RX and TX.
                                                                 * For RX, LED is on for the data transfer length through minimum IFG +
                                                                 [EXTENSION] number of coprocessor-clock cycles.
                                                                 * For TX, LED on for data transfers through transition to IDLE + [EXTENSION]
                                                                 number of coprocessor-clock cycles.

                                                                 Internal:
                                                                 Per LMAC, SMU TX treats any 128-bus cycle that carries packet data and/or IFG as BUSY
                                                                 (called activity high cycle); any 128-bus carries all IDLE, or LPI, or FAULT sequence as
                                                                 IDLE (called activity low cycle). The extension counter starts when a high to low
                                                                 transition detected on the first low cycles. The counter continues counting on sclk until
                                                                 it reaches [EXTENSION]. If any BUSY cycle occurs during the counting procedure, the
                                                                 counter resets to 0. After the counter reaches [EXTENSION], once a low cycle occurs, the
                                                                 activity indication line switches to 0. A HIGH cycle will always switch the activity
                                                                 indication line to 1. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_led_timing_s cn; */
};
typedef union bdk_cgxx_cmrx_led_timing bdk_cgxx_cmrx_led_timing_t;

static inline uint64_t BDK_CGXX_CMRX_LED_TIMING(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_LED_TIMING(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00005f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00005f0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00005f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00005f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_LED_TIMING", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_LED_TIMING(a,b) bdk_cgxx_cmrx_led_timing_t
#define bustype_BDK_CGXX_CMRX_LED_TIMING(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_LED_TIMING(a,b) "CGXX_CMRX_LED_TIMING"
#define device_bar_BDK_CGXX_CMRX_LED_TIMING(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_LED_TIMING(a,b) (a)
#define arguments_BDK_CGXX_CMRX_LED_TIMING(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_prt_cbfc_ctl
 *
 * CGX CMR LMAC PFC Control Registers
 * See CGX()_CMR()_RX_LOGL_XOFF[XOFF].
 */
union bdk_cgxx_cmrx_prt_cbfc_ctl
{
    uint64_t u;
    struct bdk_cgxx_cmrx_prt_cbfc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t phys_bp               : 16; /**< [ 31: 16](R/W) When the hardware is backpressuring any LMACs (from either DFC or PFC packets or
                                                                 CGX()_CMR()_TX_OVR_BP[TX_CHAN_BP]) and all channels indicated by [PHYS_BP] are
                                                                 backpressured, simulate physical backpressure by deferring all packets on the
                                                                 transmitter (i.e. signal to the MAC an assertion of physical backpressure).
                                                                 If LMAC_TYPE != SGMII/QSGMII, CGX()_SMU()_CBFC_CTL[RX_EN] or
                                                                 CGX()_SMU()_HG2_CONTROL[HG2RX_EN] also need to be set. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t phys_bp               : 16; /**< [ 31: 16](R/W) When the hardware is backpressuring any LMACs (from either DFC or PFC packets or
                                                                 CGX()_CMR()_TX_OVR_BP[TX_CHAN_BP]) and all channels indicated by [PHYS_BP] are
                                                                 backpressured, simulate physical backpressure by deferring all packets on the
                                                                 transmitter (i.e. signal to the MAC an assertion of physical backpressure).
                                                                 If LMAC_TYPE != SGMII/QSGMII, CGX()_SMU()_CBFC_CTL[RX_EN] or
                                                                 CGX()_SMU()_HG2_CONTROL[HG2RX_EN] also need to be set. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_prt_cbfc_ctl_s cn; */
};
typedef union bdk_cgxx_cmrx_prt_cbfc_ctl bdk_cgxx_cmrx_prt_cbfc_ctl_t;

static inline uint64_t BDK_CGXX_CMRX_PRT_CBFC_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_PRT_CBFC_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000608ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000608ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000608ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000608ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_PRT_CBFC_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_PRT_CBFC_CTL(a,b) bdk_cgxx_cmrx_prt_cbfc_ctl_t
#define bustype_BDK_CGXX_CMRX_PRT_CBFC_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_PRT_CBFC_CTL(a,b) "CGXX_CMRX_PRT_CBFC_CTL"
#define device_bar_BDK_CGXX_CMRX_PRT_CBFC_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_PRT_CBFC_CTL(a,b) (a)
#define arguments_BDK_CGXX_CMRX_PRT_CBFC_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_bp_drop
 *
 * CGX Receive Backpressure Drop Register
 */
union bdk_cgxx_cmrx_rx_bp_drop
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_bp_drop_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. [MARK] should typically be programmed to its reset
                                                                 value; failure to program correctly can lead to system instability. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. [MARK] should typically be programmed to its reset
                                                                 value; failure to program correctly can lead to system instability. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_bp_drop_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_bp_drop bdk_cgxx_cmrx_rx_bp_drop_t;

static inline uint64_t BDK_CGXX_CMRX_RX_BP_DROP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_BP_DROP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000d8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_BP_DROP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_BP_DROP(a,b) bdk_cgxx_cmrx_rx_bp_drop_t
#define bustype_BDK_CGXX_CMRX_RX_BP_DROP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_BP_DROP(a,b) "CGXX_CMRX_RX_BP_DROP"
#define device_bar_BDK_CGXX_CMRX_RX_BP_DROP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_BP_DROP(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_BP_DROP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_bp_off
 *
 * CGX Receive Backpressure Off Register
 */
union bdk_cgxx_cmrx_rx_bp_off
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_bp_off_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Low watermark (number of sixteen byte cycles to deassert backpressure). Level is also used
                                                                 to exit the overflow dropping state. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Low watermark (number of sixteen byte cycles to deassert backpressure). Level is also used
                                                                 to exit the overflow dropping state. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_bp_off_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_bp_off bdk_cgxx_cmrx_rx_bp_off_t;

static inline uint64_t BDK_CGXX_CMRX_RX_BP_OFF(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_BP_OFF(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000e8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000e8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000e8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000e8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_BP_OFF", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_BP_OFF(a,b) bdk_cgxx_cmrx_rx_bp_off_t
#define bustype_BDK_CGXX_CMRX_RX_BP_OFF(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_BP_OFF(a,b) "CGXX_CMRX_RX_BP_OFF"
#define device_bar_BDK_CGXX_CMRX_RX_BP_OFF(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_BP_OFF(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_BP_OFF(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_bp_on
 *
 * CGX Receive Backpressure On Register
 */
union bdk_cgxx_cmrx_rx_bp_on
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_bp_on_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t mark                  : 13; /**< [ 12:  0](R/W) High watermark. Buffer depth in multiple of 16-bytes, at which CGX will
                                                                 assert backpressure for each individual LMAC. Must satisfy:

                                                                   CGX()_CMR()_RX_BP_OFF[MARK] \<= CGX()_CMR()_RX_BP_ON[MARK] \<
                                                                   (fifo_size - CGX()_CMR()_RX_BP_DROP[MARK]).

                                                                 A value of 0x0 immediately asserts backpressure.

                                                                 The recommended value is 1/4th the size of the per-LMAC RX FIFO size as
                                                                 determined by CGX()_CMR_RX_LMACS[LMACS]. For example in SGMII mode with
                                                                 four LMACs of type SGMII, where CGX()_CMR_RX_LMACS[LMACS]=0x4, there is
                                                                 (CGX()_CONST[RX_FIFOSZ]/4) KB of buffering. The recommended 1/4th size
                                                                 of that buffering is (CGX()_CONST[RX_FIFOSZ]/4)/4. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 13; /**< [ 12:  0](R/W) High watermark. Buffer depth in multiple of 16-bytes, at which CGX will
                                                                 assert backpressure for each individual LMAC. Must satisfy:

                                                                   CGX()_CMR()_RX_BP_OFF[MARK] \<= CGX()_CMR()_RX_BP_ON[MARK] \<
                                                                   (fifo_size - CGX()_CMR()_RX_BP_DROP[MARK]).

                                                                 A value of 0x0 immediately asserts backpressure.

                                                                 The recommended value is 1/4th the size of the per-LMAC RX FIFO size as
                                                                 determined by CGX()_CMR_RX_LMACS[LMACS]. For example in SGMII mode with
                                                                 four LMACs of type SGMII, where CGX()_CMR_RX_LMACS[LMACS]=0x4, there is
                                                                 (CGX()_CONST[RX_FIFOSZ]/4) KB of buffering. The recommended 1/4th size
                                                                 of that buffering is (CGX()_CONST[RX_FIFOSZ]/4)/4. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_bp_on_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_bp_on bdk_cgxx_cmrx_rx_bp_on_t;

static inline uint64_t BDK_CGXX_CMRX_RX_BP_ON(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_BP_ON(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000e0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_BP_ON", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_BP_ON(a,b) bdk_cgxx_cmrx_rx_bp_on_t
#define bustype_BDK_CGXX_CMRX_RX_BP_ON(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_BP_ON(a,b) "CGXX_CMRX_RX_BP_ON"
#define device_bar_BDK_CGXX_CMRX_RX_BP_ON(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_BP_ON(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_BP_ON(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_bp_status
 *
 * CGX CMR Receive Backpressure Status Registers
 */
union bdk_cgxx_cmrx_rx_bp_status
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_bp_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t bp                    : 1;  /**< [  0:  0](RO/H) Per-LMAC backpressure status.
                                                                 0 = LMAC is not backpressured.
                                                                 1 = LMAC is backpressured. */
#else /* Word 0 - Little Endian */
        uint64_t bp                    : 1;  /**< [  0:  0](RO/H) Per-LMAC backpressure status.
                                                                 0 = LMAC is not backpressured.
                                                                 1 = LMAC is backpressured. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_bp_status_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_bp_status bdk_cgxx_cmrx_rx_bp_status_t;

static inline uint64_t BDK_CGXX_CMRX_RX_BP_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_BP_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000f0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_BP_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_BP_STATUS(a,b) bdk_cgxx_cmrx_rx_bp_status_t
#define bustype_BDK_CGXX_CMRX_RX_BP_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_BP_STATUS(a,b) "CGXX_CMRX_RX_BP_STATUS"
#define device_bar_BDK_CGXX_CMRX_RX_BP_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_BP_STATUS(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_BP_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_dmac_ctl0
 *
 * CGX CMR Receive DMAC Address-Control0 Register
 * DMAC CAM control register for use by X2P/NIX bound traffic.
 * Received packets are only passed to X2P/NIX when the DMAC0 filter result is
 * ACCEPT and STEERING0 filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM0
 * and CGX()_CMR_RX_STEERING0().
 *
 * Internal:
 * "* ALGORITHM
 * Here is some pseudo code that represents the address filter behavior.
 * \<pre\>
 * dmac_addr_filter(uint8 prt, uint48 dmac) {
 * for (lmac=0, lmac\<4, lmac++) {
 *   if (is_bcst(dmac))                               // broadcast accept
 *     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[BCST_ACCEPT] ? ACCEPT : REJECT);
 *   if (is_mcst(dmac) && CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 0)   // multicast reject
 *     return REJECT;
 *   if (is_mcst(dmac) && CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 1)   // multicast accept
 *     return ACCEPT;
 *   else        // DMAC CAM filter
 *     cam_hit = 0;
 *   for (i=0; i\<32; i++) {
 *     cam = CGX()_CMR_RX_DMAC(i)_CAM0;
 *     if (cam[EN] && cam[ID] == lmac && cam[ADR] == dmac) {
 *       cam_hit = 1;
 *       break;
 *     }
 *   }
 *   if (cam_hit) {
 *     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? ACCEPT : REJECT);
 *   else
 *     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? REJECT : ACCEPT);
 *   }
 * }
 * \</pre\>"
 */
union bdk_cgxx_cmrx_rx_dmac_ctl0
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_dmac_ctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t cam_accept            : 1;  /**< [  3:  3](R/W) Allow or deny DMAC address filter.
                                                                 0 = Reject the packet on DMAC CAM address match.
                                                                 1 = Accept the packet on DMAC CAM address match. */
        uint64_t mcst_mode             : 2;  /**< [  2:  1](R/W) Multicast mode.
                                                                 0x0 = Force reject all multicast packets.
                                                                 0x1 = Force accept all multicast packets.
                                                                 0x2 = Use the address filter CAM.
                                                                 0x3 = Reserved. */
        uint64_t bcst_accept           : 1;  /**< [  0:  0](R/W) Allow or deny broadcast packets.
                                                                 0 = Reject all broadcast packets.
                                                                 1 = Accept all broadcast packets. */
#else /* Word 0 - Little Endian */
        uint64_t bcst_accept           : 1;  /**< [  0:  0](R/W) Allow or deny broadcast packets.
                                                                 0 = Reject all broadcast packets.
                                                                 1 = Accept all broadcast packets. */
        uint64_t mcst_mode             : 2;  /**< [  2:  1](R/W) Multicast mode.
                                                                 0x0 = Force reject all multicast packets.
                                                                 0x1 = Force accept all multicast packets.
                                                                 0x2 = Use the address filter CAM.
                                                                 0x3 = Reserved. */
        uint64_t cam_accept            : 1;  /**< [  3:  3](R/W) Allow or deny DMAC address filter.
                                                                 0 = Reject the packet on DMAC CAM address match.
                                                                 1 = Accept the packet on DMAC CAM address match. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_dmac_ctl0_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_dmac_ctl0 bdk_cgxx_cmrx_rx_dmac_ctl0_t;

static inline uint64_t BDK_CGXX_CMRX_RX_DMAC_CTL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_DMAC_CTL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00001f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00001f8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00001f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00001f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_DMAC_CTL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_DMAC_CTL0(a,b) bdk_cgxx_cmrx_rx_dmac_ctl0_t
#define bustype_BDK_CGXX_CMRX_RX_DMAC_CTL0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_DMAC_CTL0(a,b) "CGXX_CMRX_RX_DMAC_CTL0"
#define device_bar_BDK_CGXX_CMRX_RX_DMAC_CTL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_DMAC_CTL0(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_DMAC_CTL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_dmac_ctl1
 *
 * CGX CMR Receive DMAC Address-Control1 Register
 * DMAC CAM control register for use by NCSI bound traffic.
 * Received packets are only passed to NCSI when the DMAC1 filter result is ACCEPT and
 * STEERING1 filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
 * CGX()_CMR_RX_STEERING1().
 * For use with the LMAC associated with NCSI; see CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
 *
 * Internal:
 * ALGORITHM: See CGX()_CMR()_RX_DMAC_CTL0.
 */
union bdk_cgxx_cmrx_rx_dmac_ctl1
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_dmac_ctl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t cam_accept            : 1;  /**< [  3:  3](R/W) Allow or deny DMAC address filter.
                                                                 0 = Reject the packet on DMAC CAM address match.
                                                                 1 = Accept the packet on DMAC CAM address match. */
        uint64_t mcst_mode             : 2;  /**< [  2:  1](R/W) Multicast mode.
                                                                 0x0 = Force reject all multicast packets.
                                                                 0x1 = Force accept all multicast packets.
                                                                 0x2 = Use the address filter CAM.
                                                                 0x3 = Reserved. */
        uint64_t bcst_accept           : 1;  /**< [  0:  0](R/W) Allow or deny broadcast packets.
                                                                 0 = Reject all broadcast packets.
                                                                 1 = Accept all broadcast packets. */
#else /* Word 0 - Little Endian */
        uint64_t bcst_accept           : 1;  /**< [  0:  0](R/W) Allow or deny broadcast packets.
                                                                 0 = Reject all broadcast packets.
                                                                 1 = Accept all broadcast packets. */
        uint64_t mcst_mode             : 2;  /**< [  2:  1](R/W) Multicast mode.
                                                                 0x0 = Force reject all multicast packets.
                                                                 0x1 = Force accept all multicast packets.
                                                                 0x2 = Use the address filter CAM.
                                                                 0x3 = Reserved. */
        uint64_t cam_accept            : 1;  /**< [  3:  3](R/W) Allow or deny DMAC address filter.
                                                                 0 = Reject the packet on DMAC CAM address match.
                                                                 1 = Accept the packet on DMAC CAM address match. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_dmac_ctl1_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_dmac_ctl1 bdk_cgxx_cmrx_rx_dmac_ctl1_t;

static inline uint64_t BDK_CGXX_CMRX_RX_DMAC_CTL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_DMAC_CTL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00003f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00003f8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00003f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00003f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_DMAC_CTL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_DMAC_CTL1(a,b) bdk_cgxx_cmrx_rx_dmac_ctl1_t
#define bustype_BDK_CGXX_CMRX_RX_DMAC_CTL1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_DMAC_CTL1(a,b) "CGXX_CMRX_RX_DMAC_CTL1"
#define device_bar_BDK_CGXX_CMRX_RX_DMAC_CTL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_DMAC_CTL1(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_DMAC_CTL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_fifo_len
 *
 * CGX CMR Receive Fifo Length Registers
 */
union bdk_cgxx_cmrx_rx_fifo_len
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_fifo_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t busy_e                : 1;  /**< [ 29: 29](RO/H) Indicates if MAC and CMR are busy processing a packet. Used when bringing an LMAC
                                                                 down since in low bandwidth cases, as the EXPRESS FIFO length may often appear to be 0x0. */
        uint64_t fifo_len_e            : 14; /**< [ 28: 15](RO/H) Per-LMAC FIFO length. Useful for determining if EXPRESS FIFO is empty when bringing an LMAC down. */
        uint64_t busy                  : 1;  /**< [ 14: 14](RO/H) Indicates if MAC and CMR are busy processing a packet. Used when bringing an LMAC
                                                                 down since in low bandwidth cases, as the FIFO length may often appear to be 0x0. */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC FIFO length. Useful for determining if FIFO is empty when bringing an LMAC down. */
#else /* Word 0 - Little Endian */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC FIFO length. Useful for determining if FIFO is empty when bringing an LMAC down. */
        uint64_t busy                  : 1;  /**< [ 14: 14](RO/H) Indicates if MAC and CMR are busy processing a packet. Used when bringing an LMAC
                                                                 down since in low bandwidth cases, as the FIFO length may often appear to be 0x0. */
        uint64_t fifo_len_e            : 14; /**< [ 28: 15](RO/H) Per-LMAC FIFO length. Useful for determining if EXPRESS FIFO is empty when bringing an LMAC down. */
        uint64_t busy_e                : 1;  /**< [ 29: 29](RO/H) Indicates if MAC and CMR are busy processing a packet. Used when bringing an LMAC
                                                                 down since in low bandwidth cases, as the EXPRESS FIFO length may often appear to be 0x0. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_fifo_len_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_fifo_len bdk_cgxx_cmrx_rx_fifo_len_t;

static inline uint64_t BDK_CGXX_CMRX_RX_FIFO_LEN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_FIFO_LEN(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000108ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000108ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000108ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000108ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_FIFO_LEN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_FIFO_LEN(a,b) bdk_cgxx_cmrx_rx_fifo_len_t
#define bustype_BDK_CGXX_CMRX_RX_FIFO_LEN(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_FIFO_LEN(a,b) "CGXX_CMRX_RX_FIFO_LEN"
#define device_bar_BDK_CGXX_CMRX_RX_FIFO_LEN(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_FIFO_LEN(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_FIFO_LEN(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_id_map
 *
 * CGX CMR Receive ID Map Register
 * These registers set the RX LMAC ID mapping for X2P/NIX.
 */
union bdk_cgxx_cmrx_rx_id_map
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_id_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t rid                   : 7;  /**< [ 14:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. Reassembly ID for Octeon PKI; not used in CN9XXX.
                                                                 Reassembly ID map for this LMAC. A shared pool of 96 reassembly IDs (RIDs) exists for all
                                                                 MACs.

                                                                 The RID for this LMAC must be constrained such that it does not overlap with any other MAC
                                                                 in the system. Its reset value has been chosen such that this condition is satisfied:

                                                                 _ RID reset value = 4*(cgx_id + 1) + lmac_id

                                                                 Changes to RID must only occur when the LMAC is quiescent (i.e. the LMAC receive interface
                                                                 is down and the RX FIFO is empty). */
        uint64_t unused                : 2;  /**< [  7:  6](RAZ) Reserved. */
        uint64_t pknd                  : 6;  /**< [  5:  0](R/W) Port kind for this LMAC. */
#else /* Word 0 - Little Endian */
        uint64_t pknd                  : 6;  /**< [  5:  0](R/W) Port kind for this LMAC. */
        uint64_t unused                : 2;  /**< [  7:  6](RAZ) Reserved. */
        uint64_t rid                   : 7;  /**< [ 14:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. Reassembly ID for Octeon PKI; not used in CN9XXX.
                                                                 Reassembly ID map for this LMAC. A shared pool of 96 reassembly IDs (RIDs) exists for all
                                                                 MACs.

                                                                 The RID for this LMAC must be constrained such that it does not overlap with any other MAC
                                                                 in the system. Its reset value has been chosen such that this condition is satisfied:

                                                                 _ RID reset value = 4*(cgx_id + 1) + lmac_id

                                                                 Changes to RID must only occur when the LMAC is quiescent (i.e. the LMAC receive interface
                                                                 is down and the RX FIFO is empty). */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_id_map_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_id_map bdk_cgxx_cmrx_rx_id_map_t;

static inline uint64_t BDK_CGXX_CMRX_RX_ID_MAP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_ID_MAP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000060ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_ID_MAP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_ID_MAP(a,b) bdk_cgxx_cmrx_rx_id_map_t
#define bustype_BDK_CGXX_CMRX_RX_ID_MAP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_ID_MAP(a,b) "CGXX_CMRX_RX_ID_MAP"
#define device_bar_BDK_CGXX_CMRX_RX_ID_MAP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_ID_MAP(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_ID_MAP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_logl_xoff
 *
 * CGX CMR Receive Logical XOFF Registers
 */
union bdk_cgxx_cmrx_rx_logl_xoff
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_logl_xoff_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t xoff                  : 16; /**< [ 15:  0](R/W1S/H) Together with CGX()_CMR()_RX_LOGL_XON, defines type of channel backpressure to
                                                                 apply to the MAC. In the case of SMU, Do not write when HiGig2 is
                                                                 enabled. Writing 1 sets the same physical register as that which is cleared by
                                                                 CGX()_CMR()_RX_LOGL_XON[XON]. An XOFF value of 1 will cause a backpressure on
                                                                 the MAC. */
#else /* Word 0 - Little Endian */
        uint64_t xoff                  : 16; /**< [ 15:  0](R/W1S/H) Together with CGX()_CMR()_RX_LOGL_XON, defines type of channel backpressure to
                                                                 apply to the MAC. In the case of SMU, Do not write when HiGig2 is
                                                                 enabled. Writing 1 sets the same physical register as that which is cleared by
                                                                 CGX()_CMR()_RX_LOGL_XON[XON]. An XOFF value of 1 will cause a backpressure on
                                                                 the MAC. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_logl_xoff_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_logl_xoff bdk_cgxx_cmrx_rx_logl_xoff_t;

static inline uint64_t BDK_CGXX_CMRX_RX_LOGL_XOFF(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_LOGL_XOFF(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000f8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000f8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_LOGL_XOFF", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_LOGL_XOFF(a,b) bdk_cgxx_cmrx_rx_logl_xoff_t
#define bustype_BDK_CGXX_CMRX_RX_LOGL_XOFF(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_LOGL_XOFF(a,b) "CGXX_CMRX_RX_LOGL_XOFF"
#define device_bar_BDK_CGXX_CMRX_RX_LOGL_XOFF(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_LOGL_XOFF(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_LOGL_XOFF(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_logl_xon
 *
 * CGX CMR Receive Logical XON Registers
 */
union bdk_cgxx_cmrx_rx_logl_xon
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_logl_xon_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t xon                   : 16; /**< [ 15:  0](R/W1C/H) Together with CGX()_CMR()_RX_LOGL_XOFF, defines type of channel backpressure to
                                                                 apply. Do not write when HiGig2 is enabled. Writing 1 clears the same physical register as
                                                                 that which is set by XOFF. An XON value of 1 means only NIX channel BP can cause a
                                                                 backpressure on the MAC. */
#else /* Word 0 - Little Endian */
        uint64_t xon                   : 16; /**< [ 15:  0](R/W1C/H) Together with CGX()_CMR()_RX_LOGL_XOFF, defines type of channel backpressure to
                                                                 apply. Do not write when HiGig2 is enabled. Writing 1 clears the same physical register as
                                                                 that which is set by XOFF. An XON value of 1 means only NIX channel BP can cause a
                                                                 backpressure on the MAC. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_logl_xon_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_logl_xon bdk_cgxx_cmrx_rx_logl_xon_t;

static inline uint64_t BDK_CGXX_CMRX_RX_LOGL_XON(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_LOGL_XON(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000100ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000100ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000100ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000100ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_LOGL_XON", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_LOGL_XON(a,b) bdk_cgxx_cmrx_rx_logl_xon_t
#define bustype_BDK_CGXX_CMRX_RX_LOGL_XON(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_LOGL_XON(a,b) "CGXX_CMRX_RX_LOGL_XON"
#define device_bar_BDK_CGXX_CMRX_RX_LOGL_XON(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_LOGL_XON(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_LOGL_XON(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_merge_stat0
 *
 * CGX RX Preemption Status Register 0
 */
union bdk_cgxx_cmrx_rx_merge_stat0
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_merge_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t fa_err_cnt            : 48; /**< [ 47:  0](R/W/H) Reassembly error count. Increments on frag count or frame count mismatch on
                                                                 SMD-C. Refer to section 30.14 in 802.3br specification
                                                                 (MACMergeFrameAssErrorCount). */
#else /* Word 0 - Little Endian */
        uint64_t fa_err_cnt            : 48; /**< [ 47:  0](R/W/H) Reassembly error count. Increments on frag count or frame count mismatch on
                                                                 SMD-C. Refer to section 30.14 in 802.3br specification
                                                                 (MACMergeFrameAssErrorCount). */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_merge_stat0_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_merge_stat0 bdk_cgxx_cmrx_rx_merge_stat0_t;

static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000138ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000138ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000138ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000138ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_MERGE_STAT0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_MERGE_STAT0(a,b) bdk_cgxx_cmrx_rx_merge_stat0_t
#define bustype_BDK_CGXX_CMRX_RX_MERGE_STAT0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_MERGE_STAT0(a,b) "CGXX_CMRX_RX_MERGE_STAT0"
#define device_bar_BDK_CGXX_CMRX_RX_MERGE_STAT0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_MERGE_STAT0(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_MERGE_STAT0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_merge_stat1
 *
 * CGX RX Preemption Status Register 1
 */
union bdk_cgxx_cmrx_rx_merge_stat1
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_merge_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t fs_err_cnt            : 48; /**< [ 47:  0](R/W/H) Unknown SMD-C fragment count. A count of received frames/fragments with unknown
                                                                 or unexpected SMD-C. Increments on fragments dropped. Refer to section 30.14 in
                                                                 802.3br specification (MACMergeFrameSmdErrorCount). */
#else /* Word 0 - Little Endian */
        uint64_t fs_err_cnt            : 48; /**< [ 47:  0](R/W/H) Unknown SMD-C fragment count. A count of received frames/fragments with unknown
                                                                 or unexpected SMD-C. Increments on fragments dropped. Refer to section 30.14 in
                                                                 802.3br specification (MACMergeFrameSmdErrorCount). */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_merge_stat1_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_merge_stat1 bdk_cgxx_cmrx_rx_merge_stat1_t;

static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_MERGE_STAT1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_MERGE_STAT1(a,b) bdk_cgxx_cmrx_rx_merge_stat1_t
#define bustype_BDK_CGXX_CMRX_RX_MERGE_STAT1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_MERGE_STAT1(a,b) "CGXX_CMRX_RX_MERGE_STAT1"
#define device_bar_BDK_CGXX_CMRX_RX_MERGE_STAT1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_MERGE_STAT1(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_MERGE_STAT1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_merge_stat2
 *
 * CGX RX Preemption Status Register 2
 */
union bdk_cgxx_cmrx_rx_merge_stat2
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_merge_stat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t fa_ok_cnt             : 48; /**< [ 47:  0](R/W/H) Successfully reassembled frames count. Increments in a good SMD-S and at least
                                                                 one good SMD-C received. Refer to section 30.14 in 802.3br specification
                                                                 (MACMergeFrameAssOkCount). */
#else /* Word 0 - Little Endian */
        uint64_t fa_ok_cnt             : 48; /**< [ 47:  0](R/W/H) Successfully reassembled frames count. Increments in a good SMD-S and at least
                                                                 one good SMD-C received. Refer to section 30.14 in 802.3br specification
                                                                 (MACMergeFrameAssOkCount). */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_merge_stat2_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_merge_stat2 bdk_cgxx_cmrx_rx_merge_stat2_t;

static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000148ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000148ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000148ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000148ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_MERGE_STAT2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_MERGE_STAT2(a,b) bdk_cgxx_cmrx_rx_merge_stat2_t
#define bustype_BDK_CGXX_CMRX_RX_MERGE_STAT2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_MERGE_STAT2(a,b) "CGXX_CMRX_RX_MERGE_STAT2"
#define device_bar_BDK_CGXX_CMRX_RX_MERGE_STAT2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_MERGE_STAT2(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_MERGE_STAT2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_merge_stat3
 *
 * CGX RX Preemption Status Register 3
 */
union bdk_cgxx_cmrx_rx_merge_stat3
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_merge_stat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t ff_cnt                : 48; /**< [ 47:  0](R/W/H) Good non-initial fragments received count (SMD-C). Refer to section 30.14 in
                                                                 802.3br specification (MACMergeFrameFragCountRx). */
#else /* Word 0 - Little Endian */
        uint64_t ff_cnt                : 48; /**< [ 47:  0](R/W/H) Good non-initial fragments received count (SMD-C). Refer to section 30.14 in
                                                                 802.3br specification (MACMergeFrameFragCountRx). */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_merge_stat3_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_merge_stat3 bdk_cgxx_cmrx_rx_merge_stat3_t;

static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000150ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000150ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000150ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000150ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_MERGE_STAT3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_MERGE_STAT3(a,b) bdk_cgxx_cmrx_rx_merge_stat3_t
#define bustype_BDK_CGXX_CMRX_RX_MERGE_STAT3(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_MERGE_STAT3(a,b) "CGXX_CMRX_RX_MERGE_STAT3"
#define device_bar_BDK_CGXX_CMRX_RX_MERGE_STAT3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_MERGE_STAT3(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_MERGE_STAT3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_merge_stat4
 *
 * CGX RX Preemption Status Register 4
 */
union bdk_cgxx_cmrx_rx_merge_stat4
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_merge_stat4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of packets dropped in SMU Rx. Packets may be dropped if the clock
                                                                 frequency is programmed too low or if the frequency of near-minimum IFG
                                                                 is too high. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of packets dropped in SMU Rx. Packets may be dropped if the clock
                                                                 frequency is programmed too low or if the frequency of near-minimum IFG
                                                                 is too high. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_merge_stat4_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_merge_stat4 bdk_cgxx_cmrx_rx_merge_stat4_t;

static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_MERGE_STAT4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000158ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000158ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000158ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000158ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_MERGE_STAT4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_MERGE_STAT4(a,b) bdk_cgxx_cmrx_rx_merge_stat4_t
#define bustype_BDK_CGXX_CMRX_RX_MERGE_STAT4(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_MERGE_STAT4(a,b) "CGXX_CMRX_RX_MERGE_STAT4"
#define device_bar_BDK_CGXX_CMRX_RX_MERGE_STAT4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_MERGE_STAT4(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_MERGE_STAT4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_pause_drop_time
 *
 * CGX CMR Receive Pause Drop-Time Register
 */
union bdk_cgxx_cmrx_rx_pause_drop_time
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_pause_drop_time_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pause_time_e          : 16; /**< [ 31: 16](R/W1C/H) Time extracted from the dropped PAUSE packet dropped due to RXB FIFO full or during partner reset. */
        uint64_t pause_time            : 16; /**< [ 15:  0](R/W1C/H) Time extracted from the dropped PAUSE packet dropped due to RXB FIFO full or during partner reset. */
#else /* Word 0 - Little Endian */
        uint64_t pause_time            : 16; /**< [ 15:  0](R/W1C/H) Time extracted from the dropped PAUSE packet dropped due to RXB FIFO full or during partner reset. */
        uint64_t pause_time_e          : 16; /**< [ 31: 16](R/W1C/H) Time extracted from the dropped PAUSE packet dropped due to RXB FIFO full or during partner reset. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_pause_drop_time_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_pause_drop_time bdk_cgxx_cmrx_rx_pause_drop_time_t;

static inline uint64_t BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000068ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_PAUSE_DROP_TIME", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(a,b) bdk_cgxx_cmrx_rx_pause_drop_time_t
#define bustype_BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(a,b) "CGXX_CMRX_RX_PAUSE_DROP_TIME"
#define device_bar_BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_PAUSE_DROP_TIME(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat0
 *
 * CGX Receive Status Register 0
 * These registers provide a count of received packets that meet the following conditions:
 * * are not recognized as ERROR packets(any OPCODE).
 * * are not recognized as PAUSE packets.
 * * are not dropped due FIFO full status.
 * * are not dropped due DMAC0 or STEERING0 filtering.
 *
 * Internal:
 * "This pseudo code represents the RX STAT0 through STAT8 accounting:
 * \<pre\>
 * If (errored)
 *   incr RX_STAT8
 * else if (ctrl packet, i.e. Pause/PFC)
 *   incr RX_STAT2,3
 * else if (fifo full drop)
 *   incr RX_STAT6,7
 * else if (DMAC0/VLAN0 filter drop)
 *   incr RX_STAT4,5 if not a filter+decision
 * else
 *   incr RX_STAT0,1
 * end
 * \</pre\>"
 */
union bdk_cgxx_cmrx_rx_stat0
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat0_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat0 bdk_cgxx_cmrx_rx_stat0_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000070ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT0(a,b) bdk_cgxx_cmrx_rx_stat0_t
#define bustype_BDK_CGXX_CMRX_RX_STAT0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT0(a,b) "CGXX_CMRX_RX_STAT0"
#define device_bar_BDK_CGXX_CMRX_RX_STAT0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT0(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat1
 *
 * CGX Receive Status Register 1
 * These registers provide a count of octets of received packets.
 */
union bdk_cgxx_cmrx_rx_stat1
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat1_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat1 bdk_cgxx_cmrx_rx_stat1_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000078ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT1(a,b) bdk_cgxx_cmrx_rx_stat1_t
#define bustype_BDK_CGXX_CMRX_RX_STAT1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT1(a,b) "CGXX_CMRX_RX_STAT1"
#define device_bar_BDK_CGXX_CMRX_RX_STAT1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT1(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat2
 *
 * CGX Receive Status Register 2
 * These registers provide a count of received packets that meet the following conditions:
 * * are not recognized as ERROR packets(any OPCODE).
 * * are recognized as PAUSE packets.
 *
 * Pause packets can be optionally dropped or forwarded based on
 * CGX()_SMU()_RX_FRM_CTL[CTL_DRP]/CGX()_GMP_GMI_RX()_FRM_CTL[CTL_DRP].
 * This count increments regardless of whether the packet is dropped.
 */
union bdk_cgxx_cmrx_rx_stat2
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of received PAUSE packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of received PAUSE packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat2_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat2 bdk_cgxx_cmrx_rx_stat2_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000080ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT2(a,b) bdk_cgxx_cmrx_rx_stat2_t
#define bustype_BDK_CGXX_CMRX_RX_STAT2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT2(a,b) "CGXX_CMRX_RX_STAT2"
#define device_bar_BDK_CGXX_CMRX_RX_STAT2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT2(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat3
 *
 * CGX Receive Status Register 3
 * These registers provide a count of octets of received PAUSE and control packets.
 */
union bdk_cgxx_cmrx_rx_stat3
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of received PAUSE packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of received PAUSE packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat3_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat3 bdk_cgxx_cmrx_rx_stat3_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000088ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT3(a,b) bdk_cgxx_cmrx_rx_stat3_t
#define bustype_BDK_CGXX_CMRX_RX_STAT3(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT3(a,b) "CGXX_CMRX_RX_STAT3"
#define device_bar_BDK_CGXX_CMRX_RX_STAT3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT3(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat4
 *
 * CGX Receive Status Register 4
 * These registers provide a count of received packets that meet the following conditions:
 * * are not recognized as ERROR packets(any OPCODE).
 * * are not recognized as PAUSE packets.
 * * are not dropped due FIFO full status.
 * * are dropped due DMAC0 or STEERING0 filtering.
 *
 * 16B packets or smaller (20B in case of FCS strip) as the result of truncation
 * or other means are not dropped by CGX (unless filter and decision is also
 * asserted) and will never appear in this count.
 * Should the MAC signal to the CMR that the packet be filtered upon decision before the end of
 * packet, then STAT4 and STAT5 will not be updated.
 */
union bdk_cgxx_cmrx_rx_stat4
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat4_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat4 bdk_cgxx_cmrx_rx_stat4_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000090ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT4(a,b) bdk_cgxx_cmrx_rx_stat4_t
#define bustype_BDK_CGXX_CMRX_RX_STAT4(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT4(a,b) "CGXX_CMRX_RX_STAT4"
#define device_bar_BDK_CGXX_CMRX_RX_STAT4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT4(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat5
 *
 * CGX Receive Status Register 5
 * These registers provide a count of octets of filtered DMAC0 or VLAN STEERING0 packets.
 */
union bdk_cgxx_cmrx_rx_stat5
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if
                                                                 LMAC is disabled
                                                                 with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if
                                                                 LMAC is disabled
                                                                 with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat5_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat5 bdk_cgxx_cmrx_rx_stat5_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000098ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000098ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000098ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000098ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT5(a,b) bdk_cgxx_cmrx_rx_stat5_t
#define bustype_BDK_CGXX_CMRX_RX_STAT5(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT5(a,b) "CGXX_CMRX_RX_STAT5"
#define device_bar_BDK_CGXX_CMRX_RX_STAT5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT5(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT5(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat6
 *
 * CGX Receive Status Register 6
 * These registers provide a count of received packets that meet the following conditions:
 * * are not recognized as ERROR packets(any OPCODE).
 * * are not recognized as PAUSE packets.
 * * are dropped due FIFO full status.
 *
 * They do not count any packet that is truncated at the point of overflow and sent
 * on to the NIX. The truncated packet will be marked with error and increment STAT8.
 * These registers count all entire packets dropped by the FIFO for a given LMAC.
 */
union bdk_cgxx_cmrx_rx_stat6
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat6_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat6 bdk_cgxx_cmrx_rx_stat6_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000a0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT6(a,b) bdk_cgxx_cmrx_rx_stat6_t
#define bustype_BDK_CGXX_CMRX_RX_STAT6(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT6(a,b) "CGXX_CMRX_RX_STAT6"
#define device_bar_BDK_CGXX_CMRX_RX_STAT6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT6(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT6(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat7
 *
 * CGX Receive Status Register 7
 * These registers provide a count of octets of received packets that were dropped due to a full
 * receive FIFO.
 */
union bdk_cgxx_cmrx_rx_stat7
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat7_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat7 bdk_cgxx_cmrx_rx_stat7_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT7(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT7(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000a8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT7(a,b) bdk_cgxx_cmrx_rx_stat7_t
#define bustype_BDK_CGXX_CMRX_RX_STAT7(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT7(a,b) "CGXX_CMRX_RX_STAT7"
#define device_bar_BDK_CGXX_CMRX_RX_STAT7(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT7(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT7(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat8
 *
 * CGX Receive Status Register 8
 * These registers provide a count of received packets that meet the following conditions:
 *  * are recognized as ERROR packets(any OPCODE).
 */
union bdk_cgxx_cmrx_rx_stat8
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of error packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of error packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat8_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat8 bdk_cgxx_cmrx_rx_stat8_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT8(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00000b0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00000b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00000b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT8(a,b) bdk_cgxx_cmrx_rx_stat8_t
#define bustype_BDK_CGXX_CMRX_RX_STAT8(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT8(a,b) "CGXX_CMRX_RX_STAT8"
#define device_bar_BDK_CGXX_CMRX_RX_STAT8(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT8(a,b) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT8(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_rx_stat_pri#_xoff
 *
 * CGX CMR RX XON to XOFF transition Registers
 */
union bdk_cgxx_cmrx_rx_stat_prix_xoff
{
    uint64_t u;
    struct bdk_cgxx_cmrx_rx_stat_prix_xoff_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions due to received PFC or pause packets
                                                                 for channels 0-7 on each LMAC. When LMAC is configured to use PAUSE (physical
                                                                 backpressure) instead of PFC, see name: CGX()_SMU()_CBFC_CTL[PHYS_EN], only
                                                                 priority(channel) 0's counters will count physical XON-\>XOFF transitions on the link. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions due to received PFC or pause packets
                                                                 for channels 0-7 on each LMAC. When LMAC is configured to use PAUSE (physical
                                                                 backpressure) instead of PFC, see name: CGX()_SMU()_CBFC_CTL[PHYS_EN], only
                                                                 priority(channel) 0's counters will count physical XON-\>XOFF transitions on the link. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_rx_stat_prix_xoff_s cn; */
};
typedef union bdk_cgxx_cmrx_rx_stat_prix_xoff bdk_cgxx_cmrx_rx_stat_prix_xoff_t;

static inline uint64_t BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=7)))
        return 0x87e0e00007c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=7)))
        return 0x87e0e00007c0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=7)))
        return 0x87e0e00007c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=7)))
        return 0x87e0e00007c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    __bdk_csr_fatal("CGXX_CMRX_RX_STAT_PRIX_XOFF", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) bdk_cgxx_cmrx_rx_stat_prix_xoff_t
#define bustype_BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) "CGXX_CMRX_RX_STAT_PRIX_XOFF"
#define device_bar_BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) (a)
#define arguments_BDK_CGXX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_cmr#_scratch#
 *
 * CGX CMR Scratch Registers
 */
union bdk_cgxx_cmrx_scratchx
{
    uint64_t u;
    struct bdk_cgxx_cmrx_scratchx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Hardware-opaque scratch register for software driver use. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Hardware-opaque scratch register for software driver use. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_scratchx_s cn; */
};
typedef union bdk_cgxx_cmrx_scratchx bdk_cgxx_cmrx_scratchx_t;

static inline uint64_t BDK_CGXX_CMRX_SCRATCHX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_SCRATCHX(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1);
    __bdk_csr_fatal("CGXX_CMRX_SCRATCHX", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_SCRATCHX(a,b,c) bdk_cgxx_cmrx_scratchx_t
#define bustype_BDK_CGXX_CMRX_SCRATCHX(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_SCRATCHX(a,b,c) "CGXX_CMRX_SCRATCHX"
#define device_bar_BDK_CGXX_CMRX_SCRATCHX(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_SCRATCHX(a,b,c) (a)
#define arguments_BDK_CGXX_CMRX_SCRATCHX(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_cmr#_sw_int
 *
 * CGX CMR Interrupt Register
 */
union bdk_cgxx_cmrx_sw_int
{
    uint64_t u;
    struct bdk_cgxx_cmrx_sw_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Software sets this bit to trigger an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Software sets this bit to trigger an interrupt */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_sw_int_s cn; */
};
typedef union bdk_cgxx_cmrx_sw_int bdk_cgxx_cmrx_sw_int_t;

static inline uint64_t BDK_CGXX_CMRX_SW_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_SW_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=2) && (b<=3)))
        return 0x87e0e0000180ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000180ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_SW_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_SW_INT(a,b) bdk_cgxx_cmrx_sw_int_t
#define bustype_BDK_CGXX_CMRX_SW_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_SW_INT(a,b) "CGXX_CMRX_SW_INT"
#define device_bar_BDK_CGXX_CMRX_SW_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_SW_INT(a,b) (a)
#define arguments_BDK_CGXX_CMRX_SW_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_sw_int_ena_w1c
 *
 * CGX CMR Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_cmrx_sw_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_cmrx_sw_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_sw_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_cmrx_sw_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_cmrx_sw_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
};
typedef union bdk_cgxx_cmrx_sw_int_ena_w1c bdk_cgxx_cmrx_sw_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_CMRX_SW_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_SW_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=2) && (b<=3)))
        return 0x87e0e0000190ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000190ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_SW_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_SW_INT_ENA_W1C(a,b) bdk_cgxx_cmrx_sw_int_ena_w1c_t
#define bustype_BDK_CGXX_CMRX_SW_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_SW_INT_ENA_W1C(a,b) "CGXX_CMRX_SW_INT_ENA_W1C"
#define device_bar_BDK_CGXX_CMRX_SW_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_SW_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_CMRX_SW_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_sw_int_ena_w1s
 *
 * CGX CMR Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_cmrx_sw_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_cmrx_sw_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_sw_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_cmrx_sw_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_cmrx_sw_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
};
typedef union bdk_cgxx_cmrx_sw_int_ena_w1s bdk_cgxx_cmrx_sw_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_CMRX_SW_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_SW_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=2) && (b<=3)))
        return 0x87e0e0000198ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000198ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_SW_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_SW_INT_ENA_W1S(a,b) bdk_cgxx_cmrx_sw_int_ena_w1s_t
#define bustype_BDK_CGXX_CMRX_SW_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_SW_INT_ENA_W1S(a,b) "CGXX_CMRX_SW_INT_ENA_W1S"
#define device_bar_BDK_CGXX_CMRX_SW_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_SW_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_CMRX_SW_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_sw_int_w1s
 *
 * CGX CMR Interrupt Set Register
 * This register sets interrupt bits.
 */
union bdk_cgxx_cmrx_sw_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_cmrx_sw_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_sw_int_w1s_s cn9; */
    /* struct bdk_cgxx_cmrx_sw_int_w1s_s cn96xx; */
    struct bdk_cgxx_cmrx_sw_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
};
typedef union bdk_cgxx_cmrx_sw_int_w1s bdk_cgxx_cmrx_sw_int_w1s_t;

static inline uint64_t BDK_CGXX_CMRX_SW_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_SW_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=2) && (b<=3)))
        return 0x87e0e0000188ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000188ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_SW_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_SW_INT_W1S(a,b) bdk_cgxx_cmrx_sw_int_w1s_t
#define bustype_BDK_CGXX_CMRX_SW_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_SW_INT_W1S(a,b) "CGXX_CMRX_SW_INT_W1S"
#define device_bar_BDK_CGXX_CMRX_SW_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_SW_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_CMRX_SW_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_channel
 *
 * CGX CMR Transmit-Channels Registers
 */
union bdk_cgxx_cmrx_tx_channel
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_channel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t msk                   : 16; /**< [ 15:  0](R/W) Backpressure channel mask. CGX can completely ignore the channel backpressure for channel
                                                                 specified by this field. Any channel in which MSK\<n\> is set never sends backpressure
                                                                 information to NIX. */
#else /* Word 0 - Little Endian */
        uint64_t msk                   : 16; /**< [ 15:  0](R/W) Backpressure channel mask. CGX can completely ignore the channel backpressure for channel
                                                                 specified by this field. Any channel in which MSK\<n\> is set never sends backpressure
                                                                 information to NIX. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_channel_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_channel bdk_cgxx_cmrx_tx_channel_t;

static inline uint64_t BDK_CGXX_CMRX_TX_CHANNEL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_CHANNEL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000600ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000600ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000600ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000600ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_CHANNEL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_CHANNEL(a,b) bdk_cgxx_cmrx_tx_channel_t
#define bustype_BDK_CGXX_CMRX_TX_CHANNEL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_CHANNEL(a,b) "CGXX_CMRX_TX_CHANNEL"
#define device_bar_BDK_CGXX_CMRX_TX_CHANNEL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_CHANNEL(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_CHANNEL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_fifo_len
 *
 * CGX CMR Transmit Fifo Length Registers
 */
union bdk_cgxx_cmrx_tx_fifo_len
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_fifo_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t lmac_e_idle           : 1;  /**< [ 29: 29](RO/H) Idle signal to identify when all credits and pipeline buffers are cleared out
                                                                 and LMAC can be considered IDLE in the CGX CMR TX Express path. */
        uint64_t fifo_e_len            : 14; /**< [ 28: 15](RO/H) Per-LMAC TXB main Express FIFO length. Useful for determining if main Express FIFO
                                                                 is empty when bringing an LMAC down. */
        uint64_t lmac_idle             : 1;  /**< [ 14: 14](RO/H) Idle signal to identify when all credits and pipeline buffers are cleared out
                                                                 and LMAC can be considered IDLE in the CGX CMR TX path. */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC TXB main FIFO length. Useful for determining if main FIFO is empty when bringing
                                                                 an LMAC down. */
#else /* Word 0 - Little Endian */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC TXB main FIFO length. Useful for determining if main FIFO is empty when bringing
                                                                 an LMAC down. */
        uint64_t lmac_idle             : 1;  /**< [ 14: 14](RO/H) Idle signal to identify when all credits and pipeline buffers are cleared out
                                                                 and LMAC can be considered IDLE in the CGX CMR TX path. */
        uint64_t fifo_e_len            : 14; /**< [ 28: 15](RO/H) Per-LMAC TXB main Express FIFO length. Useful for determining if main Express FIFO
                                                                 is empty when bringing an LMAC down. */
        uint64_t lmac_e_idle           : 1;  /**< [ 29: 29](RO/H) Idle signal to identify when all credits and pipeline buffers are cleared out
                                                                 and LMAC can be considered IDLE in the CGX CMR TX Express path. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_fifo_len_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_fifo_len bdk_cgxx_cmrx_tx_fifo_len_t;

static inline uint64_t BDK_CGXX_CMRX_TX_FIFO_LEN(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_FIFO_LEN(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000618ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000618ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000618ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000618ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_FIFO_LEN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_FIFO_LEN(a,b) bdk_cgxx_cmrx_tx_fifo_len_t
#define bustype_BDK_CGXX_CMRX_TX_FIFO_LEN(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_FIFO_LEN(a,b) "CGXX_CMRX_TX_FIFO_LEN"
#define device_bar_BDK_CGXX_CMRX_TX_FIFO_LEN(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_FIFO_LEN(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_FIFO_LEN(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_hg2_status
 *
 * CGX CMR Transmit HiGig2 Status Registers
 */
union bdk_cgxx_cmrx_tx_hg2_status
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_hg2_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t xof                   : 16; /**< [ 31: 16](RO/H) 16-bit XOF back pressure vector from HiGig2 message packet or from PFC packets. Non-
                                                                 zero only when logical back pressure is active. All bits are 0 when [LGTIM2GO] = 0x0. */
        uint64_t lgtim2go              : 16; /**< [ 15:  0](RO/H) Logical packet flow back pressure time remaining. Initial value set from XOF time field of
                                                                 HiGig2 message packet received or a function of the enabled and current timers for
                                                                 PFC packets. Nonzero only when logical back pressure is active. */
#else /* Word 0 - Little Endian */
        uint64_t lgtim2go              : 16; /**< [ 15:  0](RO/H) Logical packet flow back pressure time remaining. Initial value set from XOF time field of
                                                                 HiGig2 message packet received or a function of the enabled and current timers for
                                                                 PFC packets. Nonzero only when logical back pressure is active. */
        uint64_t xof                   : 16; /**< [ 31: 16](RO/H) 16-bit XOF back pressure vector from HiGig2 message packet or from PFC packets. Non-
                                                                 zero only when logical back pressure is active. All bits are 0 when [LGTIM2GO] = 0x0. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_hg2_status_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_hg2_status bdk_cgxx_cmrx_tx_hg2_status_t;

static inline uint64_t BDK_CGXX_CMRX_TX_HG2_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_HG2_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000610ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000610ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000610ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000610ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_HG2_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_HG2_STATUS(a,b) bdk_cgxx_cmrx_tx_hg2_status_t
#define bustype_BDK_CGXX_CMRX_TX_HG2_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_HG2_STATUS(a,b) "CGXX_CMRX_TX_HG2_STATUS"
#define device_bar_BDK_CGXX_CMRX_TX_HG2_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_HG2_STATUS(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_HG2_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_merge_stat0
 *
 * CGX TX Preemption Status Register 0
 */
union bdk_cgxx_cmrx_tx_merge_stat0
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_merge_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t ff_cnt                : 48; /**< [ 47:  0](R/W/H) Good non-initial fragments transmitted count (SMD-C). Refer to section 30.14 in
                                                                 802.3br specification (MACMergeFrameFragCountTx). */
#else /* Word 0 - Little Endian */
        uint64_t ff_cnt                : 48; /**< [ 47:  0](R/W/H) Good non-initial fragments transmitted count (SMD-C). Refer to section 30.14 in
                                                                 802.3br specification (MACMergeFrameFragCountTx). */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_merge_stat0_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_merge_stat0 bdk_cgxx_cmrx_tx_merge_stat0_t;

static inline uint64_t BDK_CGXX_CMRX_TX_MERGE_STAT0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_MERGE_STAT0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000160ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000160ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000160ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000160ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_MERGE_STAT0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_MERGE_STAT0(a,b) bdk_cgxx_cmrx_tx_merge_stat0_t
#define bustype_BDK_CGXX_CMRX_TX_MERGE_STAT0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_MERGE_STAT0(a,b) "CGXX_CMRX_TX_MERGE_STAT0"
#define device_bar_BDK_CGXX_CMRX_TX_MERGE_STAT0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_MERGE_STAT0(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_MERGE_STAT0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_ovr_bp
 *
 * CGX CMR Transmit-Channels Backpressure Override Registers
 */
union bdk_cgxx_cmrx_tx_ovr_bp
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_ovr_bp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t tx_chan_bp            : 16; /**< [ 15:  0](R/W) Per-channel backpressure status sent to NIX. Also see CGX()_CMR()_PRT_CBFC_CTL for
                                                                 details on impact to physical backpressure.
                                                                 0 = Channel is available.
                                                                 1 = Channel is backpressured. */
#else /* Word 0 - Little Endian */
        uint64_t tx_chan_bp            : 16; /**< [ 15:  0](R/W) Per-channel backpressure status sent to NIX. Also see CGX()_CMR()_PRT_CBFC_CTL for
                                                                 details on impact to physical backpressure.
                                                                 0 = Channel is available.
                                                                 1 = Channel is backpressured. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_ovr_bp_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_ovr_bp bdk_cgxx_cmrx_tx_ovr_bp_t;

static inline uint64_t BDK_CGXX_CMRX_TX_OVR_BP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_OVR_BP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000620ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000620ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000620ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000620ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_OVR_BP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_OVR_BP(a,b) bdk_cgxx_cmrx_tx_ovr_bp_t
#define bustype_BDK_CGXX_CMRX_TX_OVR_BP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_OVR_BP(a,b) "CGXX_CMRX_TX_OVR_BP"
#define device_bar_BDK_CGXX_CMRX_TX_OVR_BP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_OVR_BP(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_OVR_BP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat0
 *
 * CGX CMR Transmit Statistics Registers 0
 */
union bdk_cgxx_cmrx_tx_stat0
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t xscol                 : 48; /**< [ 47:  0](R/W/H) Number of packets dropped (never successfully sent) due to excessive collision. Defined by
                                                                 CGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. Half-duplex mode only and does not account for late
                                                                 collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t xscol                 : 48; /**< [ 47:  0](R/W/H) Number of packets dropped (never successfully sent) due to excessive collision. Defined by
                                                                 CGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. Half-duplex mode only and does not account for late
                                                                 collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat0_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat0 bdk_cgxx_cmrx_tx_stat0_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000700ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000700ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000700ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000700ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT0(a,b) bdk_cgxx_cmrx_tx_stat0_t
#define bustype_BDK_CGXX_CMRX_TX_STAT0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT0(a,b) "CGXX_CMRX_TX_STAT0"
#define device_bar_BDK_CGXX_CMRX_TX_STAT0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT0(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat1
 *
 * CGX CMR Transmit Statistics Registers 1
 */
union bdk_cgxx_cmrx_tx_stat1
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t xsdef                 : 48; /**< [ 47:  0](R/W/H) A count of the number of times any frame was deferred for an excessive period of time.
                                                                 See maxDeferTime in the IEEE 802.3 specification. Half-duplex mode only and not updated
                                                                 for late collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t xsdef                 : 48; /**< [ 47:  0](R/W/H) A count of the number of times any frame was deferred for an excessive period of time.
                                                                 See maxDeferTime in the IEEE 802.3 specification. Half-duplex mode only and not updated
                                                                 for late collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat1_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat1 bdk_cgxx_cmrx_tx_stat1_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000708ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000708ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000708ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000708ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT1(a,b) bdk_cgxx_cmrx_tx_stat1_t
#define bustype_BDK_CGXX_CMRX_TX_STAT1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT1(a,b) "CGXX_CMRX_TX_STAT1"
#define device_bar_BDK_CGXX_CMRX_TX_STAT1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT1(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat10
 *
 * CGX CMR Transmit Statistics Registers 10
 */
union bdk_cgxx_cmrx_tx_stat10
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist4                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 256-511. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist4                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 256-511. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat10_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat10 bdk_cgxx_cmrx_tx_stat10_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT10(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT10(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000750ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000750ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000750ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000750ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT10", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT10(a,b) bdk_cgxx_cmrx_tx_stat10_t
#define bustype_BDK_CGXX_CMRX_TX_STAT10(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT10(a,b) "CGXX_CMRX_TX_STAT10"
#define device_bar_BDK_CGXX_CMRX_TX_STAT10(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT10(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT10(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat11
 *
 * CGX CMR Transmit Statistics Registers 11
 */
union bdk_cgxx_cmrx_tx_stat11
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist5                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 512-1023. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist5                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 512-1023. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat11_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat11 bdk_cgxx_cmrx_tx_stat11_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT11(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT11(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000758ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000758ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000758ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000758ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT11", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT11(a,b) bdk_cgxx_cmrx_tx_stat11_t
#define bustype_BDK_CGXX_CMRX_TX_STAT11(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT11(a,b) "CGXX_CMRX_TX_STAT11"
#define device_bar_BDK_CGXX_CMRX_TX_STAT11(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT11(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT11(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat12
 *
 * CGX CMR Transmit Statistics Registers 12
 */
union bdk_cgxx_cmrx_tx_stat12
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist6                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 1024-1518. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist6                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 1024-1518. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat12_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat12 bdk_cgxx_cmrx_tx_stat12_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT12(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT12(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000760ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000760ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000760ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000760ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT12", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT12(a,b) bdk_cgxx_cmrx_tx_stat12_t
#define bustype_BDK_CGXX_CMRX_TX_STAT12(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT12(a,b) "CGXX_CMRX_TX_STAT12"
#define device_bar_BDK_CGXX_CMRX_TX_STAT12(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT12(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT12(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat13
 *
 * CGX CMR Transmit Statistics Registers 13
 */
union bdk_cgxx_cmrx_tx_stat13
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist7                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count \> 1518. Packet length is the sum of all data
                                                                 transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
                                                                 and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist7                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count \> 1518. Packet length is the sum of all data
                                                                 transmitted on the wire for the given packet including packet data, pad bytes, FCS bytes,
                                                                 and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat13_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat13 bdk_cgxx_cmrx_tx_stat13_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT13(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT13(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000768ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000768ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000768ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000768ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT13", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT13(a,b) bdk_cgxx_cmrx_tx_stat13_t
#define bustype_BDK_CGXX_CMRX_TX_STAT13(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT13(a,b) "CGXX_CMRX_TX_STAT13"
#define device_bar_BDK_CGXX_CMRX_TX_STAT13(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT13(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT13(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat14
 *
 * CGX CMR Transmit Statistics Registers 14
 */
union bdk_cgxx_cmrx_tx_stat14
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t bcst                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent to broadcast DMAC, excluding PAUSE or PFC control packets generated
                                                                 by CGX. Does not include MCST packets.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap.

                                                                 Note that CGX determines if the packet is MCST or BCST from the DMAC of the packet. CGX
                                                                 assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
                                                                 definition. If the system requires additional data before the L2 header, the MCST and BCST
                                                                 counters may not reflect reality and should be ignored by software. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t bcst                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent to broadcast DMAC, excluding PAUSE or PFC control packets generated
                                                                 by CGX. Does not include MCST packets.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap.

                                                                 Note that CGX determines if the packet is MCST or BCST from the DMAC of the packet. CGX
                                                                 assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
                                                                 definition. If the system requires additional data before the L2 header, the MCST and BCST
                                                                 counters may not reflect reality and should be ignored by software. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat14_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat14 bdk_cgxx_cmrx_tx_stat14_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT14(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT14(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000770ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000770ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000770ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000770ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT14", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT14(a,b) bdk_cgxx_cmrx_tx_stat14_t
#define bustype_BDK_CGXX_CMRX_TX_STAT14(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT14(a,b) "CGXX_CMRX_TX_STAT14"
#define device_bar_BDK_CGXX_CMRX_TX_STAT14(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT14(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT14(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat15
 *
 * CGX CMR Transmit Statistics Registers 15
 */
union bdk_cgxx_cmrx_tx_stat15
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t mcst                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent to multicast DMAC, excluding PAUSE or PFC control packets generated
                                                                 by CGX. Does not include BCST packets.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap.

                                                                 Note that CGX determines if the packet is MCST or BCST from the DMAC of the packet. CGX
                                                                 assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
                                                                 definition. If the system requires additional data before the L2 header, then the MCST and
                                                                 BCST counters may not reflect reality and should be ignored by software. Cleared if LMAC
                                                                 is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t mcst                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent to multicast DMAC, excluding PAUSE or PFC control packets generated
                                                                 by CGX. Does not include BCST packets.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap.

                                                                 Note that CGX determines if the packet is MCST or BCST from the DMAC of the packet. CGX
                                                                 assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
                                                                 definition. If the system requires additional data before the L2 header, then the MCST and
                                                                 BCST counters may not reflect reality and should be ignored by software. Cleared if LMAC
                                                                 is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat15_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat15 bdk_cgxx_cmrx_tx_stat15_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT15(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT15(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000778ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000778ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000778ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000778ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT15", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT15(a,b) bdk_cgxx_cmrx_tx_stat15_t
#define bustype_BDK_CGXX_CMRX_TX_STAT15(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT15(a,b) "CGXX_CMRX_TX_STAT15"
#define device_bar_BDK_CGXX_CMRX_TX_STAT15(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT15(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT15(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat16
 *
 * CGX CMR Transmit Statistics Registers 16
 */
union bdk_cgxx_cmrx_tx_stat16
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t undflw                : 48; /**< [ 47:  0](R/W/H) Number of underflow packets.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 48; /**< [ 47:  0](R/W/H) Number of underflow packets.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat16_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat16 bdk_cgxx_cmrx_tx_stat16_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT16(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT16(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000780ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000780ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000780ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000780ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT16", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT16(a,b) bdk_cgxx_cmrx_tx_stat16_t
#define bustype_BDK_CGXX_CMRX_TX_STAT16(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT16(a,b) "CGXX_CMRX_TX_STAT16"
#define device_bar_BDK_CGXX_CMRX_TX_STAT16(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT16(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT16(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat17
 *
 * CGX CMR Transmit Statistics Registers 17
 */
union bdk_cgxx_cmrx_tx_stat17
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat17_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t ctl                   : 48; /**< [ 47:  0](R/W/H) Number of PAUSE or PFC control packets generated by CGX. It does not include control
                                                                 packets forwarded or generated by the cores. Does not track the number of generated HG2
                                                                 messages.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t ctl                   : 48; /**< [ 47:  0](R/W/H) Number of PAUSE or PFC control packets generated by CGX. It does not include control
                                                                 packets forwarded or generated by the cores. Does not track the number of generated HG2
                                                                 messages.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat17_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat17 bdk_cgxx_cmrx_tx_stat17_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT17(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT17(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000788ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000788ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000788ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000788ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT17", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT17(a,b) bdk_cgxx_cmrx_tx_stat17_t
#define bustype_BDK_CGXX_CMRX_TX_STAT17(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT17(a,b) "CGXX_CMRX_TX_STAT17"
#define device_bar_BDK_CGXX_CMRX_TX_STAT17(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT17(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT17(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat2
 *
 * CGX CMR Transmit Statistics Registers 2
 */
union bdk_cgxx_cmrx_tx_stat2
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t mcol                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent with multiple collisions. Must be less than
                                                                 CGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. Half-duplex mode only and not updated
                                                                 for late collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t mcol                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent with multiple collisions. Must be less than
                                                                 CGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. Half-duplex mode only and not updated
                                                                 for late collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat2_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat2 bdk_cgxx_cmrx_tx_stat2_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000710ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000710ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000710ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000710ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT2(a,b) bdk_cgxx_cmrx_tx_stat2_t
#define bustype_BDK_CGXX_CMRX_TX_STAT2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT2(a,b) "CGXX_CMRX_TX_STAT2"
#define device_bar_BDK_CGXX_CMRX_TX_STAT2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT2(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat3
 *
 * CGX CMR Transmit Statistics Registers 3
 */
union bdk_cgxx_cmrx_tx_stat3
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t scol                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent with a single collision. Half-duplex mode only and not updated
                                                                 for late collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t scol                  : 48; /**< [ 47:  0](R/W/H) Number of packets sent with a single collision. Half-duplex mode only and not updated
                                                                 for late collisions.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat3_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat3 bdk_cgxx_cmrx_tx_stat3_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000718ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000718ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000718ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000718ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT3(a,b) bdk_cgxx_cmrx_tx_stat3_t
#define bustype_BDK_CGXX_CMRX_TX_STAT3(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT3(a,b) "CGXX_CMRX_TX_STAT3"
#define device_bar_BDK_CGXX_CMRX_TX_STAT3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT3(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat4
 *
 * CGX CMR Transmit Statistics Registers 4
 */
union bdk_cgxx_cmrx_tx_stat4
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t octs                  : 48; /**< [ 47:  0](R/W/H) Number of total octets sent on the interface, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Does not count octets from frames that were truncated due to collisions
                                                                 in half-duplex mode.
                                                                 Octet counts are the sum of all data transmitted on the wire including packet data, pad
                                                                 bytes, FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
                                                                 cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t octs                  : 48; /**< [ 47:  0](R/W/H) Number of total octets sent on the interface, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Does not count octets from frames that were truncated due to collisions
                                                                 in half-duplex mode.
                                                                 Octet counts are the sum of all data transmitted on the wire including packet data, pad
                                                                 bytes, FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
                                                                 cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat4_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat4 bdk_cgxx_cmrx_tx_stat4_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000720ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000720ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000720ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000720ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT4(a,b) bdk_cgxx_cmrx_tx_stat4_t
#define bustype_BDK_CGXX_CMRX_TX_STAT4(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT4(a,b) "CGXX_CMRX_TX_STAT4"
#define device_bar_BDK_CGXX_CMRX_TX_STAT4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT4(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat5
 *
 * CGX CMR Transmit Statistics Registers 5
 */
union bdk_cgxx_cmrx_tx_stat5
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t pkts                  : 48; /**< [ 47:  0](R/W/H) Number of total frames sent on the interface, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Does not count octets from frames that were truncated due to collisions
                                                                 in half-duplex mode.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t pkts                  : 48; /**< [ 47:  0](R/W/H) Number of total frames sent on the interface, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Does not count octets from frames that were truncated due to collisions
                                                                 in half-duplex mode.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat5_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat5 bdk_cgxx_cmrx_tx_stat5_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000728ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000728ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000728ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000728ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT5(a,b) bdk_cgxx_cmrx_tx_stat5_t
#define bustype_BDK_CGXX_CMRX_TX_STAT5(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT5(a,b) "CGXX_CMRX_TX_STAT5"
#define device_bar_BDK_CGXX_CMRX_TX_STAT5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT5(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT5(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat6
 *
 * CGX CMR Transmit Statistics Registers 6
 */
union bdk_cgxx_cmrx_tx_stat6
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist0                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count \< 64, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Packet length is the sum of all data transmitted on the wire for the
                                                                 given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
                                                                 do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist0                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count \< 64, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Packet length is the sum of all data transmitted on the wire for the
                                                                 given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
                                                                 do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat6_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat6 bdk_cgxx_cmrx_tx_stat6_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000730ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000730ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000730ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000730ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT6(a,b) bdk_cgxx_cmrx_tx_stat6_t
#define bustype_BDK_CGXX_CMRX_TX_STAT6(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT6(a,b) "CGXX_CMRX_TX_STAT6"
#define device_bar_BDK_CGXX_CMRX_TX_STAT6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT6(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT6(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat7
 *
 * CGX CMR Transmit Statistics Registers 7
 */
union bdk_cgxx_cmrx_tx_stat7
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist1                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count of 64, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Packet length is the sum of all data transmitted on the wire for the
                                                                 given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
                                                                 do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist1                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count of 64, excluding PAUSE or PFC control packets
                                                                 generated by CGX. Packet length is the sum of all data transmitted on the wire for the
                                                                 given packet including packet data, pad bytes, FCS bytes, and JAM bytes. The octet counts
                                                                 do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat7_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat7 bdk_cgxx_cmrx_tx_stat7_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT7(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT7(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000738ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000738ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000738ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000738ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT7(a,b) bdk_cgxx_cmrx_tx_stat7_t
#define bustype_BDK_CGXX_CMRX_TX_STAT7(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT7(a,b) "CGXX_CMRX_TX_STAT7"
#define device_bar_BDK_CGXX_CMRX_TX_STAT7(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT7(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT7(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat8
 *
 * CGX CMR Transmit Statistics Registers 8
 */
union bdk_cgxx_cmrx_tx_stat8
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist2                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 65-127. Packet length is the sum of all
                                                                 data transmitted on the wire for the given packet including packet data, pad bytes, FCS
                                                                 bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist2                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 65-127. Packet length is the sum of all
                                                                 data transmitted on the wire for the given packet including packet data, pad bytes, FCS
                                                                 bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat8_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat8 bdk_cgxx_cmrx_tx_stat8_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT8(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000740ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000740ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000740ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000740ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT8(a,b) bdk_cgxx_cmrx_tx_stat8_t
#define bustype_BDK_CGXX_CMRX_TX_STAT8(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT8(a,b) "CGXX_CMRX_TX_STAT8"
#define device_bar_BDK_CGXX_CMRX_TX_STAT8(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT8(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT8(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat9
 *
 * CGX CMR Transmit Statistics Registers 9
 */
union bdk_cgxx_cmrx_tx_stat9
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t hist3                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 128-255. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t hist3                 : 48; /**< [ 47:  0](R/W/H) Number of packets sent with an octet count between 128-255. Packet length is the sum of
                                                                 all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                                 FCS bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND cycles.

                                                                 Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
                                                                 disabled with CGX()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat9_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat9 bdk_cgxx_cmrx_tx_stat9_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT9(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT9(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000748ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0000748ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0000748ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0000748ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT9", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT9(a,b) bdk_cgxx_cmrx_tx_stat9_t
#define bustype_BDK_CGXX_CMRX_TX_STAT9(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT9(a,b) "CGXX_CMRX_TX_STAT9"
#define device_bar_BDK_CGXX_CMRX_TX_STAT9(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT9(a,b) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT9(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr#_tx_stat_pri#_xoff
 *
 * CGX CMR TX XON to XOFF transition Registers
 */
union bdk_cgxx_cmrx_tx_stat_prix_xoff
{
    uint64_t u;
    struct bdk_cgxx_cmrx_tx_stat_prix_xoff_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions signaled by transmitted PFC or pause packets
                                                                 for channels 0-7 on each LMAC. When LMAC is configured to use PAUSE (physical
                                                                 backpressure) instead of PFC, see name: CGX()_SMU()_CBFC_CTL[PHYS_EN], only
                                                                 priority(channel) 0's counters will count physical XON-\>XOFF transitions on the link. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions signaled by transmitted PFC or pause packets
                                                                 for channels 0-7 on each LMAC. When LMAC is configured to use PAUSE (physical
                                                                 backpressure) instead of PFC, see name: CGX()_SMU()_CBFC_CTL[PHYS_EN], only
                                                                 priority(channel) 0's counters will count physical XON-\>XOFF transitions on the link. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmrx_tx_stat_prix_xoff_s cn; */
};
typedef union bdk_cgxx_cmrx_tx_stat_prix_xoff bdk_cgxx_cmrx_tx_stat_prix_xoff_t;

static inline uint64_t BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=7)))
        return 0x87e0e0000800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=7)))
        return 0x87e0e0000800ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=7)))
        return 0x87e0e0000800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=7)))
        return 0x87e0e0000800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    __bdk_csr_fatal("CGXX_CMRX_TX_STAT_PRIX_XOFF", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) bdk_cgxx_cmrx_tx_stat_prix_xoff_t
#define bustype_BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) "CGXX_CMRX_TX_STAT_PRIX_XOFF"
#define device_bar_BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) (a)
#define arguments_BDK_CGXX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_cmr_bad
 *
 * CGX CMR Bad Registers
 */
union bdk_cgxx_cmr_bad
{
    uint64_t u;
    struct bdk_cgxx_cmr_bad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t rxb_nxl               : 1;  /**< [  0:  0](R/W1C/H) Receive side LMAC ID \> CGX()_CMR_RX_LMACS. */
#else /* Word 0 - Little Endian */
        uint64_t rxb_nxl               : 1;  /**< [  0:  0](R/W1C/H) Receive side LMAC ID \> CGX()_CMR_RX_LMACS. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_bad_s cn; */
};
typedef union bdk_cgxx_cmr_bad bdk_cgxx_cmr_bad_t;

static inline uint64_t BDK_CGXX_CMR_BAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_BAD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0001020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0001020ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0001020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0001020ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_BAD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_BAD(a) bdk_cgxx_cmr_bad_t
#define bustype_BDK_CGXX_CMR_BAD(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_BAD(a) "CGXX_CMR_BAD"
#define device_bar_BDK_CGXX_CMR_BAD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_BAD(a) (a)
#define arguments_BDK_CGXX_CMR_BAD(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_chan_msk_and
 *
 * CGX CMR Backpressure Channel Mask AND Registers
 */
union bdk_cgxx_cmr_chan_msk_and
{
    uint64_t u;
    struct bdk_cgxx_cmr_chan_msk_and_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t msk_and               : 64; /**< [ 63:  0](R/W) Assert physical backpressure when the backpressure channel vector combined with [MSK_AND]
                                                                 indicates backpressure as follows:
                                                                 _ phys_bp_msk_and = [MSK_AND]\<x:y\> != 0 && (chan_vector\<x:y\> & [MSK_AND]\<x:y\>) ==
                                                                 [MSK_AND]\<x:y\>
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#else /* Word 0 - Little Endian */
        uint64_t msk_and               : 64; /**< [ 63:  0](R/W) Assert physical backpressure when the backpressure channel vector combined with [MSK_AND]
                                                                 indicates backpressure as follows:
                                                                 _ phys_bp_msk_and = [MSK_AND]\<x:y\> != 0 && (chan_vector\<x:y\> & [MSK_AND]\<x:y\>) ==
                                                                 [MSK_AND]\<x:y\>
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_chan_msk_and_s cn; */
};
typedef union bdk_cgxx_cmr_chan_msk_and bdk_cgxx_cmr_chan_msk_and_t;

static inline uint64_t BDK_CGXX_CMR_CHAN_MSK_AND(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_CHAN_MSK_AND(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000110ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000110ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000110ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000110ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_CHAN_MSK_AND", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_CHAN_MSK_AND(a) bdk_cgxx_cmr_chan_msk_and_t
#define bustype_BDK_CGXX_CMR_CHAN_MSK_AND(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_CHAN_MSK_AND(a) "CGXX_CMR_CHAN_MSK_AND"
#define device_bar_BDK_CGXX_CMR_CHAN_MSK_AND(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_CHAN_MSK_AND(a) (a)
#define arguments_BDK_CGXX_CMR_CHAN_MSK_AND(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_chan_msk_or
 *
 * CGX Backpressure Channel Mask OR Registers
 */
union bdk_cgxx_cmr_chan_msk_or
{
    uint64_t u;
    struct bdk_cgxx_cmr_chan_msk_or_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t msk_or                : 64; /**< [ 63:  0](R/W) Assert physical backpressure when the backpressure channel vector combined with [MSK_OR]
                                                                 indicates backpressure as follows:

                                                                 _ phys_bp_msk_or = (chan_vector\<x:y\> & [MSK_OR]\<x:y\>) != 0
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#else /* Word 0 - Little Endian */
        uint64_t msk_or                : 64; /**< [ 63:  0](R/W) Assert physical backpressure when the backpressure channel vector combined with [MSK_OR]
                                                                 indicates backpressure as follows:

                                                                 _ phys_bp_msk_or = (chan_vector\<x:y\> & [MSK_OR]\<x:y\>) != 0
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_chan_msk_or_s cn; */
};
typedef union bdk_cgxx_cmr_chan_msk_or bdk_cgxx_cmr_chan_msk_or_t;

static inline uint64_t BDK_CGXX_CMR_CHAN_MSK_OR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_CHAN_MSK_OR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000118ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000118ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000118ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000118ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_CHAN_MSK_OR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_CHAN_MSK_OR(a) bdk_cgxx_cmr_chan_msk_or_t
#define bustype_BDK_CGXX_CMR_CHAN_MSK_OR(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_CHAN_MSK_OR(a) "CGXX_CMR_CHAN_MSK_OR"
#define device_bar_BDK_CGXX_CMR_CHAN_MSK_OR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_CHAN_MSK_OR(a) (a)
#define arguments_BDK_CGXX_CMR_CHAN_MSK_OR(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_eco
 *
 * INTERNAL: CGX ECO Registers
 */
union bdk_cgxx_cmr_eco
{
    uint64_t u;
    struct bdk_cgxx_cmr_eco_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t eco_ro                : 32; /**< [ 63: 32](RO) Reserved for ECO usage. */
        uint64_t eco_rw                : 32; /**< [ 31:  0](R/W) Reserved for ECO usage. */
#else /* Word 0 - Little Endian */
        uint64_t eco_rw                : 32; /**< [ 31:  0](R/W) Reserved for ECO usage. */
        uint64_t eco_ro                : 32; /**< [ 63: 32](RO) Reserved for ECO usage. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_eco_s cn; */
};
typedef union bdk_cgxx_cmr_eco bdk_cgxx_cmr_eco_t;

static inline uint64_t BDK_CGXX_CMR_ECO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_ECO(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0001028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0001028ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0001028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0001028ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_ECO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_ECO(a) bdk_cgxx_cmr_eco_t
#define bustype_BDK_CGXX_CMR_ECO(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_ECO(a) "CGXX_CMR_ECO"
#define device_bar_BDK_CGXX_CMR_ECO(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_ECO(a) (a)
#define arguments_BDK_CGXX_CMR_ECO(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_global_config
 *
 * CGX CMR Global Configuration Register
 * These registers configure the global CMR, PCS, and MAC.
 */
union bdk_cgxx_cmr_global_config
{
    uint64_t u;
    struct bdk_cgxx_cmr_global_config_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t cmr_clken_ovrd        : 1;  /**< [ 24: 24](R/W) Override X2P clocks to always be on. For diagnostic use only. */
        uint64_t cmr_ncsi_tag_cnt      : 13; /**< [ 23: 11](R/W) Number of outstanding NCSI tags that can be placed into CMR main FIFO. */
        uint64_t cmr_ncsi_reset        : 1;  /**< [ 10: 10](R/W) Interface reset for the CMR NCSI block.
                                                                 Upon power up the CMR NCSI logic is in reset and the NCSI block will be commanded
                                                                 by the external BMC to enable one of the CGX NCSI interfaces for passing network traffic.
                                                                 The BMC/NCSI will then proceed to configure the rest of the CGX CSRs for pass through
                                                                 traffic.

                                                                 When set, the CMR NCSI interface logic is effectively disabled.
                                                                 This bit will not reset the main RXB FIFOs. */
        uint64_t cmr_ncsi_drop         : 1;  /**< [  9:  9](R/W) NCSI drop.
                                                                 0 = Allow traffic to flow to the NCSI block.
                                                                 1 = Cleanly drop traffic going to the NCSI block.  Must set asserted
                                                                 with [CMR_X2P_RESET]=1 (in the same write operation) to avoid partial packets
                                                                 to the NCSI interface while performing an X2P partner reset. */
        uint64_t ncsi_lmac_id          : 2;  /**< [  8:  7](R/W) Logical MAC ID that carries NCSI traffic for both RX and TX side of CMR. */
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) A setting of 1 means the CGX strips the four FCS bytes of every packet.  For packets less
                                                                 than four
                                                                 bytes, the packet will be removed.
                                                                 A setting of 0 means the CGX will not modify or remove the FCS bytes. */
        uint64_t interleave_mode       : 1;  /**< [  5:  5](RAZ) Reserved. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface. see CGX()_CMR()_CONFIG[X2P_SELECT]

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Interface  Connected block in reset
                                                                 ---------------  ---------  ------------------------
                                                                   0..1           --         Reserved
                                                                   2              X2P1       NIX0
                                                                   3..7           --         Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the CGX by setting this bit. It resets the X2P
                                                                 interface state in the CGX (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the
                                                                 interface. Because the X2P and NCSI interfaces share the main RXB FIFOs it will
                                                                 also impact the NCSI interface therefore it is required to set [CMR_NCSI_DROP]
                                                                 bit first before setting this bit.

                                                                 Clearing this bit does not reset the X2P interface nor NCSI interface.  After the
                                                                 master block comes out of reset, software should clear this bit. */
        uint64_t cgx_clk_enable        : 1;  /**< [  1:  1](R/W) The global clock enable for CGX. Setting this bit overrides clock enables set by
                                                                 CGX()_CMR()_CONFIG[ENABLE] and CGX()_CMR()_CONFIG[LMAC_TYPE], essentially
                                                                 turning on clocks for the entire CGX. Setting this bit to 0 results in not overriding
                                                                 clock enables set by CGX()_CMR()_CONFIG[ENABLE] and
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. */
        uint64_t pmux_sds_sel          : 1;  /**< [  0:  0](R/W) SerDes/GSER output select. Must be 0 for CGX1 and CGX2. */
#else /* Word 0 - Little Endian */
        uint64_t pmux_sds_sel          : 1;  /**< [  0:  0](R/W) SerDes/GSER output select. Must be 0 for CGX1 and CGX2. */
        uint64_t cgx_clk_enable        : 1;  /**< [  1:  1](R/W) The global clock enable for CGX. Setting this bit overrides clock enables set by
                                                                 CGX()_CMR()_CONFIG[ENABLE] and CGX()_CMR()_CONFIG[LMAC_TYPE], essentially
                                                                 turning on clocks for the entire CGX. Setting this bit to 0 results in not overriding
                                                                 clock enables set by CGX()_CMR()_CONFIG[ENABLE] and
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface. see CGX()_CMR()_CONFIG[X2P_SELECT]

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Interface  Connected block in reset
                                                                 ---------------  ---------  ------------------------
                                                                   0..1           --         Reserved
                                                                   2              X2P1       NIX0
                                                                   3..7           --         Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the CGX by setting this bit. It resets the X2P
                                                                 interface state in the CGX (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the
                                                                 interface. Because the X2P and NCSI interfaces share the main RXB FIFOs it will
                                                                 also impact the NCSI interface therefore it is required to set [CMR_NCSI_DROP]
                                                                 bit first before setting this bit.

                                                                 Clearing this bit does not reset the X2P interface nor NCSI interface.  After the
                                                                 master block comes out of reset, software should clear this bit. */
        uint64_t interleave_mode       : 1;  /**< [  5:  5](RAZ) Reserved. */
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) A setting of 1 means the CGX strips the four FCS bytes of every packet.  For packets less
                                                                 than four
                                                                 bytes, the packet will be removed.
                                                                 A setting of 0 means the CGX will not modify or remove the FCS bytes. */
        uint64_t ncsi_lmac_id          : 2;  /**< [  8:  7](R/W) Logical MAC ID that carries NCSI traffic for both RX and TX side of CMR. */
        uint64_t cmr_ncsi_drop         : 1;  /**< [  9:  9](R/W) NCSI drop.
                                                                 0 = Allow traffic to flow to the NCSI block.
                                                                 1 = Cleanly drop traffic going to the NCSI block.  Must set asserted
                                                                 with [CMR_X2P_RESET]=1 (in the same write operation) to avoid partial packets
                                                                 to the NCSI interface while performing an X2P partner reset. */
        uint64_t cmr_ncsi_reset        : 1;  /**< [ 10: 10](R/W) Interface reset for the CMR NCSI block.
                                                                 Upon power up the CMR NCSI logic is in reset and the NCSI block will be commanded
                                                                 by the external BMC to enable one of the CGX NCSI interfaces for passing network traffic.
                                                                 The BMC/NCSI will then proceed to configure the rest of the CGX CSRs for pass through
                                                                 traffic.

                                                                 When set, the CMR NCSI interface logic is effectively disabled.
                                                                 This bit will not reset the main RXB FIFOs. */
        uint64_t cmr_ncsi_tag_cnt      : 13; /**< [ 23: 11](R/W) Number of outstanding NCSI tags that can be placed into CMR main FIFO. */
        uint64_t cmr_clken_ovrd        : 1;  /**< [ 24: 24](R/W) Override X2P clocks to always be on. For diagnostic use only. */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_global_config_s cn; */
};
typedef union bdk_cgxx_cmr_global_config bdk_cgxx_cmr_global_config_t;

static inline uint64_t BDK_CGXX_CMR_GLOBAL_CONFIG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_GLOBAL_CONFIG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_GLOBAL_CONFIG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_GLOBAL_CONFIG(a) bdk_cgxx_cmr_global_config_t
#define bustype_BDK_CGXX_CMR_GLOBAL_CONFIG(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_GLOBAL_CONFIG(a) "CGXX_CMR_GLOBAL_CONFIG"
#define device_bar_BDK_CGXX_CMR_GLOBAL_CONFIG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_GLOBAL_CONFIG(a) (a)
#define arguments_BDK_CGXX_CMR_GLOBAL_CONFIG(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_mem_int
 *
 * CGX CMR Memory Interrupt Register
 */
union bdk_cgxx_cmr_mem_int
{
    uint64_t u;
    struct bdk_cgxx_cmr_mem_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) RX SMU INFIFO overflow. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) RX GMP INFIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) RX GMP INFIFO overflow. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) RX SMU INFIFO overflow. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_mem_int_s cn; */
};
typedef union bdk_cgxx_cmr_mem_int bdk_cgxx_cmr_mem_int_t;

static inline uint64_t BDK_CGXX_CMR_MEM_INT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_MEM_INT(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_MEM_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_MEM_INT(a) bdk_cgxx_cmr_mem_int_t
#define bustype_BDK_CGXX_CMR_MEM_INT(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_MEM_INT(a) "CGXX_CMR_MEM_INT"
#define device_bar_BDK_CGXX_CMR_MEM_INT(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_MEM_INT(a) (a)
#define arguments_BDK_CGXX_CMR_MEM_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_mem_int_ena_w1c
 *
 * CGX CMR Memory Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_cmr_mem_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_cmr_mem_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_mem_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_cmr_mem_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_cmr_mem_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_cmr_mem_int_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_cmr_mem_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_cmr_mem_int_ena_w1c bdk_cgxx_cmr_mem_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_CMR_MEM_INT_ENA_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_MEM_INT_ENA_W1C(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_MEM_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_MEM_INT_ENA_W1C(a) bdk_cgxx_cmr_mem_int_ena_w1c_t
#define bustype_BDK_CGXX_CMR_MEM_INT_ENA_W1C(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_MEM_INT_ENA_W1C(a) "CGXX_CMR_MEM_INT_ENA_W1C"
#define device_bar_BDK_CGXX_CMR_MEM_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_MEM_INT_ENA_W1C(a) (a)
#define arguments_BDK_CGXX_CMR_MEM_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_mem_int_ena_w1s
 *
 * CGX CMR Memory Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_cmr_mem_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_cmr_mem_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_mem_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_cmr_mem_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_cmr_mem_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_cmr_mem_int_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_cmr_mem_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_cmr_mem_int_ena_w1s bdk_cgxx_cmr_mem_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_CMR_MEM_INT_ENA_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_MEM_INT_ENA_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_MEM_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_MEM_INT_ENA_W1S(a) bdk_cgxx_cmr_mem_int_ena_w1s_t
#define bustype_BDK_CGXX_CMR_MEM_INT_ENA_W1S(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_MEM_INT_ENA_W1S(a) "CGXX_CMR_MEM_INT_ENA_W1S"
#define device_bar_BDK_CGXX_CMR_MEM_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_MEM_INT_ENA_W1S(a) (a)
#define arguments_BDK_CGXX_CMR_MEM_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_mem_int_w1s
 *
 * CGX CMR Memory Interrupt Set Register
 * This register sets interrupt bits.
 */
union bdk_cgxx_cmr_mem_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_cmr_mem_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_mem_int_w1s_s cn9; */
    /* struct bdk_cgxx_cmr_mem_int_w1s_s cn96xx; */
    struct bdk_cgxx_cmr_mem_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_cmr_mem_int_w1s_s cnf95xx; */
    struct bdk_cgxx_cmr_mem_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_CMR_MEM_INT[GMP_IN_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t gmp_in_overfl         : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_CMR_MEM_INT[GMP_IN_OVERFL]. */
        uint64_t smu_in_overfl         : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_CMR_MEM_INT[SMU_IN_OVERFL]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_cmr_mem_int_w1s bdk_cgxx_cmr_mem_int_w1s_t;

static inline uint64_t BDK_CGXX_CMR_MEM_INT_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_MEM_INT_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_MEM_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_MEM_INT_W1S(a) bdk_cgxx_cmr_mem_int_w1s_t
#define bustype_BDK_CGXX_CMR_MEM_INT_W1S(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_MEM_INT_W1S(a) "CGXX_CMR_MEM_INT_W1S"
#define device_bar_BDK_CGXX_CMR_MEM_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_MEM_INT_W1S(a) (a)
#define arguments_BDK_CGXX_CMR_MEM_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_nic_nxc_adr
 *
 * CGX CMR NIC NXC Exception Registers
 */
union bdk_cgxx_cmr_nic_nxc_adr
{
    uint64_t u;
    struct bdk_cgxx_cmr_nic_nxc_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID associated with NXC exceptions associated with NIC. */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIC. */
#else /* Word 0 - Little Endian */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIC. */
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID associated with NXC exceptions associated with NIC. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_nic_nxc_adr_s cn; */
};
typedef union bdk_cgxx_cmr_nic_nxc_adr bdk_cgxx_cmr_nic_nxc_adr_t;

static inline uint64_t BDK_CGXX_CMR_NIC_NXC_ADR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_NIC_NXC_ADR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0001030ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0001030ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0001030ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0001030ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_NIC_NXC_ADR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_NIC_NXC_ADR(a) bdk_cgxx_cmr_nic_nxc_adr_t
#define bustype_BDK_CGXX_CMR_NIC_NXC_ADR(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_NIC_NXC_ADR(a) "CGXX_CMR_NIC_NXC_ADR"
#define device_bar_BDK_CGXX_CMR_NIC_NXC_ADR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_NIC_NXC_ADR(a) (a)
#define arguments_BDK_CGXX_CMR_NIC_NXC_ADR(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_nix0_nxc_adr
 *
 * CGX CMR NIX0 NXC Exception Registers
 */
union bdk_cgxx_cmr_nix0_nxc_adr
{
    uint64_t u;
    struct bdk_cgxx_cmr_nix0_nxc_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t lmac_e_id             : 4;  /**< [ 31: 28](RO/H) Logged Express LMAC ID associated with NXC exceptions associated with NIX0. */
        uint64_t channel_e             : 12; /**< [ 27: 16](RO/H) Logged Express channel for NXC exceptions associated with NIX0. */
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID associated with NXC exceptions associated with NIX0. */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX0. */
#else /* Word 0 - Little Endian */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX0. */
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID associated with NXC exceptions associated with NIX0. */
        uint64_t channel_e             : 12; /**< [ 27: 16](RO/H) Logged Express channel for NXC exceptions associated with NIX0. */
        uint64_t lmac_e_id             : 4;  /**< [ 31: 28](RO/H) Logged Express LMAC ID associated with NXC exceptions associated with NIX0. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_nix0_nxc_adr_s cn; */
};
typedef union bdk_cgxx_cmr_nix0_nxc_adr bdk_cgxx_cmr_nix0_nxc_adr_t;

static inline uint64_t BDK_CGXX_CMR_NIX0_NXC_ADR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_NIX0_NXC_ADR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0001038ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0001038ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0001038ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0001038ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_NIX0_NXC_ADR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_NIX0_NXC_ADR(a) bdk_cgxx_cmr_nix0_nxc_adr_t
#define bustype_BDK_CGXX_CMR_NIX0_NXC_ADR(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_NIX0_NXC_ADR(a) "CGXX_CMR_NIX0_NXC_ADR"
#define device_bar_BDK_CGXX_CMR_NIX0_NXC_ADR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_NIX0_NXC_ADR(a) (a)
#define arguments_BDK_CGXX_CMR_NIX0_NXC_ADR(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_nix1_nxc_adr
 *
 * CGX CMR NIX1 NXC Exception Registers
 */
union bdk_cgxx_cmr_nix1_nxc_adr
{
    uint64_t u;
    struct bdk_cgxx_cmr_nix1_nxc_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t lmac_e_id             : 4;  /**< [ 31: 28](RO/H) Logged Express LMAC ID associated with NXC exceptions associated with NIX1. */
        uint64_t channel_e             : 12; /**< [ 27: 16](RO/H) Logged Express channel for NXC exceptions associated with NIX1. */
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID associated with NXC exceptions associated with NIX1. */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX1. */
#else /* Word 0 - Little Endian */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX1. */
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID associated with NXC exceptions associated with NIX1. */
        uint64_t channel_e             : 12; /**< [ 27: 16](RO/H) Logged Express channel for NXC exceptions associated with NIX1. */
        uint64_t lmac_e_id             : 4;  /**< [ 31: 28](RO/H) Logged Express LMAC ID associated with NXC exceptions associated with NIX1. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_nix1_nxc_adr_s cn; */
};
typedef union bdk_cgxx_cmr_nix1_nxc_adr bdk_cgxx_cmr_nix1_nxc_adr_t;

static inline uint64_t BDK_CGXX_CMR_NIX1_NXC_ADR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_NIX1_NXC_ADR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0001040ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0001040ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0001040ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0001040ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_NIX1_NXC_ADR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_NIX1_NXC_ADR(a) bdk_cgxx_cmr_nix1_nxc_adr_t
#define bustype_BDK_CGXX_CMR_NIX1_NXC_ADR(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_NIX1_NXC_ADR(a) "CGXX_CMR_NIX1_NXC_ADR"
#define device_bar_BDK_CGXX_CMR_NIX1_NXC_ADR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_NIX1_NXC_ADR(a) (a)
#define arguments_BDK_CGXX_CMR_NIX1_NXC_ADR(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_p2x#_count
 *
 * CGX P2X Activity Register
 */
union bdk_cgxx_cmr_p2xx_count
{
    uint64_t u;
    struct bdk_cgxx_cmr_p2xx_count_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t p2x_cnt               : 64; /**< [ 63:  0](R/W/H) Incremented on every clock cycle that CGX receives data on the P2X. */
#else /* Word 0 - Little Endian */
        uint64_t p2x_cnt               : 64; /**< [ 63:  0](R/W/H) Incremented on every clock cycle that CGX receives data on the P2X. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_p2xx_count_s cn; */
};
typedef union bdk_cgxx_cmr_p2xx_count bdk_cgxx_cmr_p2xx_count_t;

static inline uint64_t BDK_CGXX_CMR_P2XX_COUNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_P2XX_COUNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=2)))
        return 0x87e0e0000168ll + 0x1000000ll * ((a) & 0x3) + 0x1000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=2)))
        return 0x87e0e0000168ll + 0x1000000ll * ((a) & 0x7) + 0x1000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=2)))
        return 0x87e0e0000168ll + 0x1000000ll * ((a) & 0x3) + 0x1000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=2)))
        return 0x87e0e0000168ll + 0x1000000ll * ((a) & 0x3) + 0x1000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_P2XX_COUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_P2XX_COUNT(a,b) bdk_cgxx_cmr_p2xx_count_t
#define bustype_BDK_CGXX_CMR_P2XX_COUNT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_P2XX_COUNT(a,b) "CGXX_CMR_P2XX_COUNT"
#define device_bar_BDK_CGXX_CMR_P2XX_COUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_P2XX_COUNT(a,b) (a)
#define arguments_BDK_CGXX_CMR_P2XX_COUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_dmac#_cam0
 *
 * CGX CMR Receive CAM Registers
 * These registers provide access to the 32 DMAC CAM0 entries in CGX,
 * for use by X2P/NIX bound traffic.
 */
union bdk_cgxx_cmr_rx_dmacx_cam0
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_dmacx_cam0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_51_63        : 13;
        uint64_t id                    : 2;  /**< [ 50: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. CGX has 32 DMAC CAM0 entries that
                                                                 can be accessed with the CGX()_CMR_RX_DMAC()_CAM0 CSRs. These 32 DMAC entries can be used
                                                                 by
                                                                 any of the four SGMII MACs or the 10G/40G MACs using these register bits.
                                                                 However, If any LMAC is configured for NCSI traffic
                                                                 (CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]),
                                                                 also see CGX()_CMR_RX_DMAC()_CAM1 and CGX()_CMR_RX_STEERING1() registers.

                                                                 A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                                 using the following settings:
                                                                 * LMAC interface 0: CGX()_CMR_RX_DMAC(0..7)_CAM0[ID] = 0x0.
                                                                 * LMAC interface 1: CGX()_CMR_RX_DMAC(8..15)_CAM0[ID] = 0x1.
                                                                 * LMAC interface 2: CGX()_CMR_RX_DMAC(16..23)_CAM0[ID] = 0x2.
                                                                 * LMAC interface 3: CGX()_CMR_RX_DMAC(24..31)_CAM0[ID] = 0x3. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All CGX()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any non-NCSI CGX MAC can use any of the 32 common DMAC0 entries. */
#else /* Word 0 - Little Endian */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All CGX()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any non-NCSI CGX MAC can use any of the 32 common DMAC0 entries. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t id                    : 2;  /**< [ 50: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. CGX has 32 DMAC CAM0 entries that
                                                                 can be accessed with the CGX()_CMR_RX_DMAC()_CAM0 CSRs. These 32 DMAC entries can be used
                                                                 by
                                                                 any of the four SGMII MACs or the 10G/40G MACs using these register bits.
                                                                 However, If any LMAC is configured for NCSI traffic
                                                                 (CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]),
                                                                 also see CGX()_CMR_RX_DMAC()_CAM1 and CGX()_CMR_RX_STEERING1() registers.

                                                                 A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                                 using the following settings:
                                                                 * LMAC interface 0: CGX()_CMR_RX_DMAC(0..7)_CAM0[ID] = 0x0.
                                                                 * LMAC interface 1: CGX()_CMR_RX_DMAC(8..15)_CAM0[ID] = 0x1.
                                                                 * LMAC interface 2: CGX()_CMR_RX_DMAC(16..23)_CAM0[ID] = 0x2.
                                                                 * LMAC interface 3: CGX()_CMR_RX_DMAC(24..31)_CAM0[ID] = 0x3. */
        uint64_t reserved_51_63        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_dmacx_cam0_s cn; */
};
typedef union bdk_cgxx_cmr_rx_dmacx_cam0 bdk_cgxx_cmr_rx_dmacx_cam0_t;

static inline uint64_t BDK_CGXX_CMR_RX_DMACX_CAM0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_DMACX_CAM0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=31)))
        return 0x87e0e0000200ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=31)))
        return 0x87e0e0000200ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=31)))
        return 0x87e0e0000200ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=31)))
        return 0x87e0e0000200ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    __bdk_csr_fatal("CGXX_CMR_RX_DMACX_CAM0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_DMACX_CAM0(a,b) bdk_cgxx_cmr_rx_dmacx_cam0_t
#define bustype_BDK_CGXX_CMR_RX_DMACX_CAM0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_DMACX_CAM0(a,b) "CGXX_CMR_RX_DMACX_CAM0"
#define device_bar_BDK_CGXX_CMR_RX_DMACX_CAM0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_DMACX_CAM0(a,b) (a)
#define arguments_BDK_CGXX_CMR_RX_DMACX_CAM0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_dmac#_cam1
 *
 * CGX CMR Receive CAM Registers
 * These registers provide access to the 32 DMAC CAM entries in CGX for use by NCSI bound
 * traffic. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID] and
 * CGX()_CMR_RX_STEERING1() registers.
 */
union bdk_cgxx_cmr_rx_dmacx_cam1
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_dmacx_cam1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_51_63        : 13;
        uint64_t id                    : 2;  /**< [ 50: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. Program to value of
                                                                 CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses */
#else /* Word 0 - Little Endian */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t id                    : 2;  /**< [ 50: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. Program to value of
                                                                 CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. */
        uint64_t reserved_51_63        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_dmacx_cam1_s cn; */
};
typedef union bdk_cgxx_cmr_rx_dmacx_cam1 bdk_cgxx_cmr_rx_dmacx_cam1_t;

static inline uint64_t BDK_CGXX_CMR_RX_DMACX_CAM1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_DMACX_CAM1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=31)))
        return 0x87e0e0000400ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=31)))
        return 0x87e0e0000400ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=31)))
        return 0x87e0e0000400ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=31)))
        return 0x87e0e0000400ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    __bdk_csr_fatal("CGXX_CMR_RX_DMACX_CAM1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_DMACX_CAM1(a,b) bdk_cgxx_cmr_rx_dmacx_cam1_t
#define bustype_BDK_CGXX_CMR_RX_DMACX_CAM1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_DMACX_CAM1(a,b) "CGXX_CMR_RX_DMACX_CAM1"
#define device_bar_BDK_CGXX_CMR_RX_DMACX_CAM1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_DMACX_CAM1(a,b) (a)
#define arguments_BDK_CGXX_CMR_RX_DMACX_CAM1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_lmacs
 *
 * CGX CMR Receive Logical MACs Registers
 */
union bdk_cgxx_cmr_rx_lmacs
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_lmacs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t lmacs                 : 3;  /**< [  2:  0](R/W) Number of LMACS. Specifies the number of LMACs that can be enabled.
                                                                 This determines the logical RX buffer size per LMAC and the maximum
                                                                 LMAC ID that can be used:

                                                                 0x0 = Reserved.
                                                                 0x1 = CGX()_CONST[RX_FIFOSZ] bytes per LMAC, maximum LMAC ID is 0.
                                                                 0x2 = CGX()_CONST[RX_FIFOSZ]/2 bytes per LMAC, maximum LMAC ID is 1.
                                                                 0x3 = CGX()_CONST[RX_FIFOSZ]/2 bytes for LMAC 0,
                                                                       CGX()_CONST[RX_FIFOSZ]/4 bytes for LMAC 1, 2. maximum LMAC ID is 2.
                                                                 0x4 = CGX()_CONST[RX_FIFOSZ]/4 bytes per LMAC, maximum LMAC ID is 3.
                                                                 0x5-0x7 = Reserved.

                                                                 Note the maximum LMAC ID is determined by the smaller of
                                                                 CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS]. The two fields
                                                                 should be set to the same value for normal operation.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
#else /* Word 0 - Little Endian */
        uint64_t lmacs                 : 3;  /**< [  2:  0](R/W) Number of LMACS. Specifies the number of LMACs that can be enabled.
                                                                 This determines the logical RX buffer size per LMAC and the maximum
                                                                 LMAC ID that can be used:

                                                                 0x0 = Reserved.
                                                                 0x1 = CGX()_CONST[RX_FIFOSZ] bytes per LMAC, maximum LMAC ID is 0.
                                                                 0x2 = CGX()_CONST[RX_FIFOSZ]/2 bytes per LMAC, maximum LMAC ID is 1.
                                                                 0x3 = CGX()_CONST[RX_FIFOSZ]/2 bytes for LMAC 0,
                                                                       CGX()_CONST[RX_FIFOSZ]/4 bytes for LMAC 1, 2. maximum LMAC ID is 2.
                                                                 0x4 = CGX()_CONST[RX_FIFOSZ]/4 bytes per LMAC, maximum LMAC ID is 3.
                                                                 0x5-0x7 = Reserved.

                                                                 Note the maximum LMAC ID is determined by the smaller of
                                                                 CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS]. The two fields
                                                                 should be set to the same value for normal operation.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_lmacs_s cn; */
};
typedef union bdk_cgxx_cmr_rx_lmacs bdk_cgxx_cmr_rx_lmacs_t;

static inline uint64_t BDK_CGXX_CMR_RX_LMACS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_LMACS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000128ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000128ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000128ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000128ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_LMACS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_LMACS(a) bdk_cgxx_cmr_rx_lmacs_t
#define bustype_BDK_CGXX_CMR_RX_LMACS(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_LMACS(a) "CGXX_CMR_RX_LMACS"
#define device_bar_BDK_CGXX_CMR_RX_LMACS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_LMACS(a) (a)
#define arguments_BDK_CGXX_CMR_RX_LMACS(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_ovr_bp
 *
 * CGX CMR Receive-Ports Backpressure Override Registers
 * Per-LMAC backpressure override register.
 * For SMU, CGX()_CMR_RX_OVR_BP[EN]\<0\> must be set to one and CGX()_CMR_RX_OVR_BP[BP]\<0\> must be
 * cleared to zero (to forcibly disable hardware-automatic 802.3 PAUSE packet generation) with
 * the HiGig2 Protocol when CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is
 * indicated by CGX()_SMU()_TX_CTL[HG_EN]=1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16).
 * Hardware can only auto-generate backpressure through HiGig2 messages (optionally, when
 * CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2 protocol.
 */
union bdk_cgxx_cmr_rx_ovr_bp
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_ovr_bp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t en                    : 4;  /**< [ 11:  8](R/W) Per-LMAC enable backpressure override.
                                                                 0 = Don't enable.
                                                                 1 = Enable override.

                                                                 Bit\<8\> represents LMAC 0, ..., bit\<11\> represents LMAC 3. */
        uint64_t bp                    : 4;  /**< [  7:  4](R/W) Per-LMAC backpressure status to use:
                                                                 0 = LMAC is available.
                                                                 1 = LMAC should be backpressured.

                                                                 Bit\<4\> represents LMAC 0, ..., bit\<7\> represents LMAC 3. */
        uint64_t ign_fifo_bp           : 4;  /**< [  3:  0](R/W) Ignore CGX()_CMR()_RX_BP_ON[MARK] when computing backpressure. CMR does not
                                                                 backpressure the MAC due to the FIFO length passing CGX()_CMR()_RX_BP_ON[MARK]. */
#else /* Word 0 - Little Endian */
        uint64_t ign_fifo_bp           : 4;  /**< [  3:  0](R/W) Ignore CGX()_CMR()_RX_BP_ON[MARK] when computing backpressure. CMR does not
                                                                 backpressure the MAC due to the FIFO length passing CGX()_CMR()_RX_BP_ON[MARK]. */
        uint64_t bp                    : 4;  /**< [  7:  4](R/W) Per-LMAC backpressure status to use:
                                                                 0 = LMAC is available.
                                                                 1 = LMAC should be backpressured.

                                                                 Bit\<4\> represents LMAC 0, ..., bit\<7\> represents LMAC 3. */
        uint64_t en                    : 4;  /**< [ 11:  8](R/W) Per-LMAC enable backpressure override.
                                                                 0 = Don't enable.
                                                                 1 = Enable override.

                                                                 Bit\<8\> represents LMAC 0, ..., bit\<11\> represents LMAC 3. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_ovr_bp_s cn; */
};
typedef union bdk_cgxx_cmr_rx_ovr_bp bdk_cgxx_cmr_rx_ovr_bp_t;

static inline uint64_t BDK_CGXX_CMR_RX_OVR_BP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_OVR_BP(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0000130ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0000130ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0000130ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0000130ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_OVR_BP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_OVR_BP(a) bdk_cgxx_cmr_rx_ovr_bp_t
#define bustype_BDK_CGXX_CMR_RX_OVR_BP(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_OVR_BP(a) "CGXX_CMR_RX_OVR_BP"
#define device_bar_BDK_CGXX_CMR_RX_OVR_BP(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_OVR_BP(a) (a)
#define arguments_BDK_CGXX_CMR_RX_OVR_BP(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_stat10
 *
 * CGX Receive Status Register 10
 * These registers provide a count of octets of filtered DMAC1 or VLAN STEERING1 packets.
 */
union bdk_cgxx_cmr_rx_stat10
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_stat10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of filtered DMAC1 or VLAN STEERING1 packets. [CNT] will wrap and is cleared if
                                                                 NCSI LMAC is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. It is also cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of filtered DMAC1 or VLAN STEERING1 packets. [CNT] will wrap and is cleared if
                                                                 NCSI LMAC is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. It is also cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_stat10_s cn; */
};
typedef union bdk_cgxx_cmr_rx_stat10 bdk_cgxx_cmr_rx_stat10_t;

static inline uint64_t BDK_CGXX_CMR_RX_STAT10(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STAT10(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e00000c0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e00000c0ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e00000c0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e00000c0ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_STAT10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STAT10(a) bdk_cgxx_cmr_rx_stat10_t
#define bustype_BDK_CGXX_CMR_RX_STAT10(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STAT10(a) "CGXX_CMR_RX_STAT10"
#define device_bar_BDK_CGXX_CMR_RX_STAT10(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STAT10(a) (a)
#define arguments_BDK_CGXX_CMR_RX_STAT10(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_stat11
 *
 * CGX Receive Status Register 11
 * This registers provides a count of packets dropped at the NCSI interface. This
 * includes drops due to CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_DROP] or NCSI FIFO full.
 * The count of dropped NCSI packets is not accounted for in any other stats
 * registers.
 */
union bdk_cgxx_cmr_rx_stat11
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_stat11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of dropped packets. [CNT] will wrap and is cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of dropped packets. [CNT] will wrap and is cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_stat11_s cn; */
};
typedef union bdk_cgxx_cmr_rx_stat11 bdk_cgxx_cmr_rx_stat11_t;

static inline uint64_t BDK_CGXX_CMR_RX_STAT11(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STAT11(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e00000c8ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e00000c8ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e00000c8ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e00000c8ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_STAT11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STAT11(a) bdk_cgxx_cmr_rx_stat11_t
#define bustype_BDK_CGXX_CMR_RX_STAT11(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STAT11(a) "CGXX_CMR_RX_STAT11"
#define device_bar_BDK_CGXX_CMR_RX_STAT11(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STAT11(a) (a)
#define arguments_BDK_CGXX_CMR_RX_STAT11(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_stat12
 *
 * CGX Receive Status Register 12
 * This register provide a count of octets of dropped at the NCSI interface.
 */
union bdk_cgxx_cmr_rx_stat12
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_stat12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of dropped NCSI packets. [CNT] will wrap and is cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of dropped NCSI packets. [CNT] will wrap and is cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_stat12_s cn; */
};
typedef union bdk_cgxx_cmr_rx_stat12 bdk_cgxx_cmr_rx_stat12_t;

static inline uint64_t BDK_CGXX_CMR_RX_STAT12(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STAT12(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e00000d0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e00000d0ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e00000d0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e00000d0ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_STAT12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STAT12(a) bdk_cgxx_cmr_rx_stat12_t
#define bustype_BDK_CGXX_CMR_RX_STAT12(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STAT12(a) "CGXX_CMR_RX_STAT12"
#define device_bar_BDK_CGXX_CMR_RX_STAT12(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STAT12(a) (a)
#define arguments_BDK_CGXX_CMR_RX_STAT12(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_stat9
 *
 * CGX Receive Status Register 9
 * These registers provide a count of all received packets that were dropped by the DMAC1 or VLAN
 * STEERING1 filter.
 * Packets that are dropped by the DMAC1 or VLAN STEERING1 filters are counted here
 * regardless of whether they were ERR packets, but does not include those reported in
 * CGX()_CMR()_RX_STAT6.
 * 16B packets or smaller (20B in case of FCS strip) as the result of truncation
 * or other means are not dropped by CGX (unless filter and decision is also
 * asserted) and will never appear in this count.
 * Should the MAC signal to the CMR that the packet be filtered upon decision before the end of
 * packet, then STAT9 and STAT10 will not be updated.
 */
union bdk_cgxx_cmr_rx_stat9
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_stat9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of filtered DMAC1 or VLAN STEERING1 packets. [CNT] will wrap and is cleared if NCSI
                                                                 LMAC is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. It is also cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of filtered DMAC1 or VLAN STEERING1 packets. [CNT] will wrap and is cleared if NCSI
                                                                 LMAC is disabled with CGX()_CMR()_CONFIG[ENABLE]=0. It is also cleared if NCSI is reset with
                                                                 CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_RESET]. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_stat9_s cn; */
};
typedef union bdk_cgxx_cmr_rx_stat9 bdk_cgxx_cmr_rx_stat9_t;

static inline uint64_t BDK_CGXX_CMR_RX_STAT9(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STAT9(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e00000b8ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e00000b8ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e00000b8ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e00000b8ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_STAT9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STAT9(a) bdk_cgxx_cmr_rx_stat9_t
#define bustype_BDK_CGXX_CMR_RX_STAT9(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STAT9(a) "CGXX_CMR_RX_STAT9"
#define device_bar_BDK_CGXX_CMR_RX_STAT9(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STAT9(a) (a)
#define arguments_BDK_CGXX_CMR_RX_STAT9(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_steering0#
 *
 * CGX CMR Receive Steering0 Registers
 * These registers, along with CGX()_CMR_RX_STEERING_VETYPE0(), provide eight filters for
 * identifying and steering receive traffic to X2P/NIX.
 * Received packets are only passed to X2P/NIX when the DMAC0 filter result is
 * ACCEPT and STEERING0 filter result is PASS. See also
 * CGX()_CMR()_RX_DMAC_CTL0.
 *
 * Internal:
 * "* ALGORITHM
 * \<pre\>
 * rx_steering(uint48 pkt_dmac, uint16 pkt_etype, uint16 pkt_vlan_id) {
 *    for (int i = 0; i \< 8; i++) {
 *       steer = CGX()_CMR_RX_STEERING0(i);
 *       vetype = CGX()_CMR_RX_STEERING_VETYPE0(i);
 *       if (steer[MCST_EN] || steer[DMAC_EN] || vetype[VLAN_EN] || vetype[VLAN_TAG_EN]) {
 *          // Filter is enabled.
 *          if (   (!steer[MCST_EN] || is_mcst(pkt_dmac))
 *              && (!steer[DMAC_EN] || pkt_dmac == steer[DMAC])
 *              && (!vetype[VLAN_EN] || pkt_vlan_id == vetype[VLAN_ID])
 *              && (!vetype[VLAN_TAG_EN] || pkt_etype == vetype[VLAN_ETYPE]) )
 *          {
 *             // Filter match (all enabled matching criteria are met).
 *             return steer[PASS];
 *          }
 *       }
 *    }
 *    return CGX()_CMR_RX_STEERING_DEFAULT0[PASS]; // No match
 * }
 * \</pre\>"
 */
union bdk_cgxx_cmr_rx_steering0x
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_steering0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_51_63        : 13;
        uint64_t pass                  : 1;  /**< [ 50: 50](R/W) 0 = Do not pass to the X2P on algorithm match.
                                                                 1 = Pass traffic to the X2P on algorithm match. */
        uint64_t mcst_en               : 1;  /**< [ 49: 49](R/W) Enable for identifying multicast packets:
                                                                 0 = Do not include multicast packets in the matching algorithm.
                                                                 1 = Include multicast packets in the matching algorithm. */
        uint64_t dmac_en               : 1;  /**< [ 48: 48](R/W) Enable DMAC address check:
                                                                 0 = Do not include DMAC address checking in the matching algorithm.
                                                                 1 = Include DMAC address checking in the matching algorithm. */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) DMAC address used for the matching algorithm when [DMAC_EN] is set. Broadcast can be
                                                                 specified with value 0xFFFF_FFFFFFFF. */
#else /* Word 0 - Little Endian */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) DMAC address used for the matching algorithm when [DMAC_EN] is set. Broadcast can be
                                                                 specified with value 0xFFFF_FFFFFFFF. */
        uint64_t dmac_en               : 1;  /**< [ 48: 48](R/W) Enable DMAC address check:
                                                                 0 = Do not include DMAC address checking in the matching algorithm.
                                                                 1 = Include DMAC address checking in the matching algorithm. */
        uint64_t mcst_en               : 1;  /**< [ 49: 49](R/W) Enable for identifying multicast packets:
                                                                 0 = Do not include multicast packets in the matching algorithm.
                                                                 1 = Include multicast packets in the matching algorithm. */
        uint64_t pass                  : 1;  /**< [ 50: 50](R/W) 0 = Do not pass to the X2P on algorithm match.
                                                                 1 = Pass traffic to the X2P on algorithm match. */
        uint64_t reserved_51_63        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_steering0x_s cn; */
};
typedef union bdk_cgxx_cmr_rx_steering0x bdk_cgxx_cmr_rx_steering0x_t;

static inline uint64_t BDK_CGXX_CMR_RX_STEERING0X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STEERING0X(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000300ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=7)))
        return 0x87e0e0000300ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000300ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=7)))
        return 0x87e0e0000300ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("CGXX_CMR_RX_STEERING0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STEERING0X(a,b) bdk_cgxx_cmr_rx_steering0x_t
#define bustype_BDK_CGXX_CMR_RX_STEERING0X(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STEERING0X(a,b) "CGXX_CMR_RX_STEERING0X"
#define device_bar_BDK_CGXX_CMR_RX_STEERING0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STEERING0X(a,b) (a)
#define arguments_BDK_CGXX_CMR_RX_STEERING0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_steering1#
 *
 * CGX CMR Receive Steering1 Registers
 * These registers, along with CGX()_CMR_RX_STEERING_VETYPE1(), provide eight filters for
 * identifying and steering NCSI receive traffic.
 * Received packets are only passed to NCSI when the DMAC1 filter result is ACCEPT and
 * STEERING1 filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
 * CGX()_CMR_RX_STEERING1().
 * For use with the LMAC associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
 *
 * Internal:
 * ALGORITHM: See CGX()_CMR_RX_STEERING0().
 */
union bdk_cgxx_cmr_rx_steering1x
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_steering1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_51_63        : 13;
        uint64_t pass                  : 1;  /**< [ 50: 50](R/W) 0 = Do not pass to the X2P on algorithm match.
                                                                 1 = Pass traffic to the X2P on algorithm match. */
        uint64_t mcst_en               : 1;  /**< [ 49: 49](R/W) Enable for identifying multicast packets:
                                                                 0 = Do not include multicast packets in the matching algorithm.
                                                                 1 = Include multicast packets in the matching algorithm. */
        uint64_t dmac_en               : 1;  /**< [ 48: 48](R/W) Enable DMAC address check:
                                                                 0 = Do not include DMAC address checking in the matching algorithm.
                                                                 1 = Include DMAC address checking in the matching algorithm. */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) DMAC address used for the matching algorithm when [DMAC_EN] is set. Broadcast can be
                                                                 specified with value 0xFFFF_FFFFFFFF. */
#else /* Word 0 - Little Endian */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) DMAC address used for the matching algorithm when [DMAC_EN] is set. Broadcast can be
                                                                 specified with value 0xFFFF_FFFFFFFF. */
        uint64_t dmac_en               : 1;  /**< [ 48: 48](R/W) Enable DMAC address check:
                                                                 0 = Do not include DMAC address checking in the matching algorithm.
                                                                 1 = Include DMAC address checking in the matching algorithm. */
        uint64_t mcst_en               : 1;  /**< [ 49: 49](R/W) Enable for identifying multicast packets:
                                                                 0 = Do not include multicast packets in the matching algorithm.
                                                                 1 = Include multicast packets in the matching algorithm. */
        uint64_t pass                  : 1;  /**< [ 50: 50](R/W) 0 = Do not pass to the X2P on algorithm match.
                                                                 1 = Pass traffic to the X2P on algorithm match. */
        uint64_t reserved_51_63        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_steering1x_s cn; */
};
typedef union bdk_cgxx_cmr_rx_steering1x bdk_cgxx_cmr_rx_steering1x_t;

static inline uint64_t BDK_CGXX_CMR_RX_STEERING1X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STEERING1X(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000500ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=7)))
        return 0x87e0e0000500ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000500ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=7)))
        return 0x87e0e0000500ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("CGXX_CMR_RX_STEERING1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STEERING1X(a,b) bdk_cgxx_cmr_rx_steering1x_t
#define bustype_BDK_CGXX_CMR_RX_STEERING1X(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STEERING1X(a,b) "CGXX_CMR_RX_STEERING1X"
#define device_bar_BDK_CGXX_CMR_RX_STEERING1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STEERING1X(a,b) (a)
#define arguments_BDK_CGXX_CMR_RX_STEERING1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_steering_default0
 *
 * CGX CMR Receive Steering Default0 Destination Register
 * For determining destination of traffic that does not meet matching algorithm
 * described in registers CGX()_CMR_RX_STEERING0() and CGX()_CMR_RX_STEERING_VETYPE0().
 * All 16B packets or smaller (20B in case of FCS strip) as the result of truncation will steer
 * to default destination
 */
union bdk_cgxx_cmr_rx_steering_default0
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_steering_default0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pass                  : 1;  /**< [  0:  0](R/W) 0 = Do not pass to the X2P/NIX.
                                                                 1 = Pass traffic to the X2P/NIX. */
#else /* Word 0 - Little Endian */
        uint64_t pass                  : 1;  /**< [  0:  0](R/W) 0 = Do not pass to the X2P/NIX.
                                                                 1 = Pass traffic to the X2P/NIX. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_steering_default0_s cn; */
};
typedef union bdk_cgxx_cmr_rx_steering_default0 bdk_cgxx_cmr_rx_steering_default0_t;

static inline uint64_t BDK_CGXX_CMR_RX_STEERING_DEFAULT0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STEERING_DEFAULT0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e00003f0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e00003f0ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e00003f0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e00003f0ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_STEERING_DEFAULT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STEERING_DEFAULT0(a) bdk_cgxx_cmr_rx_steering_default0_t
#define bustype_BDK_CGXX_CMR_RX_STEERING_DEFAULT0(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STEERING_DEFAULT0(a) "CGXX_CMR_RX_STEERING_DEFAULT0"
#define device_bar_BDK_CGXX_CMR_RX_STEERING_DEFAULT0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STEERING_DEFAULT0(a) (a)
#define arguments_BDK_CGXX_CMR_RX_STEERING_DEFAULT0(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_steering_default1
 *
 * CGX CMR Receive Steering Default1 Destination Register
 * For use with the lmac_id associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
 * For determining destination of traffic that does not meet matching algorithm
 * described in registers CGX()_CMR_RX_STEERING1() and CGX()_CMR_RX_STEERING_VETYPE1().
 * All 16B packets or smaller (20B in case of FCS strip) as the result of truncation will steer
 * to default destination
 */
union bdk_cgxx_cmr_rx_steering_default1
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_steering_default1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pass                  : 1;  /**< [  0:  0](R/W) 0 = Do not pass to NCSI.
                                                                 1 = Pass traffic to NCSI. */
#else /* Word 0 - Little Endian */
        uint64_t pass                  : 1;  /**< [  0:  0](R/W) 0 = Do not pass to NCSI.
                                                                 1 = Pass traffic to NCSI. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_steering_default1_s cn; */
};
typedef union bdk_cgxx_cmr_rx_steering_default1 bdk_cgxx_cmr_rx_steering_default1_t;

static inline uint64_t BDK_CGXX_CMR_RX_STEERING_DEFAULT1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STEERING_DEFAULT1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e00005e0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e00005e0ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e00005e0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e00005e0ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_RX_STEERING_DEFAULT1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STEERING_DEFAULT1(a) bdk_cgxx_cmr_rx_steering_default1_t
#define bustype_BDK_CGXX_CMR_RX_STEERING_DEFAULT1(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STEERING_DEFAULT1(a) "CGXX_CMR_RX_STEERING_DEFAULT1"
#define device_bar_BDK_CGXX_CMR_RX_STEERING_DEFAULT1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STEERING_DEFAULT1(a) (a)
#define arguments_BDK_CGXX_CMR_RX_STEERING_DEFAULT1(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_steering_vetype0#
 *
 * CGX CMR Receive VLAN Ethertype1 Register
 * These registers, along with CGX()_CMR_RX_STEERING0(), provide eight filters for identifying
 * and steering X2P/NIX receive traffic.
 */
union bdk_cgxx_cmr_rx_steering_vetype0x
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_steering_vetype0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t vlan_en               : 1;  /**< [ 29: 29](R/W) Enable VLAN ID check:
                                                                 0 = Do not include VLAN ID checking in the matching algorithm.
                                                                 1 = Include VLAN ID checking in the matching algorithm. */
        uint64_t vlan_id               : 12; /**< [ 28: 17](R/W) VLAN ID used for the matching algorithm when [VLAN_EN] is set. */
        uint64_t vlan_tag_en           : 1;  /**< [ 16: 16](R/W) Enable VLAN tag Ethertype check:
                                                                 0 = Do not include VLAN tag Ethertype checking in the matching algorithm.
                                                                 1 = Include VLAN tag Ethertype checking in the matching algorithm. */
        uint64_t vlan_etype            : 16; /**< [ 15:  0](R/W) VLAN Ethertype for the matching algorithm when [VLAN_TAG_EN] is set.
                                                                 802.1Q and 802.1ad specify several Ethertypes used to identify VLAN tagged and VLAN double
                                                                 tagged packets. CGX will always match against the tag immediately following the SMAC
                                                                 address of the L2 header. */
#else /* Word 0 - Little Endian */
        uint64_t vlan_etype            : 16; /**< [ 15:  0](R/W) VLAN Ethertype for the matching algorithm when [VLAN_TAG_EN] is set.
                                                                 802.1Q and 802.1ad specify several Ethertypes used to identify VLAN tagged and VLAN double
                                                                 tagged packets. CGX will always match against the tag immediately following the SMAC
                                                                 address of the L2 header. */
        uint64_t vlan_tag_en           : 1;  /**< [ 16: 16](R/W) Enable VLAN tag Ethertype check:
                                                                 0 = Do not include VLAN tag Ethertype checking in the matching algorithm.
                                                                 1 = Include VLAN tag Ethertype checking in the matching algorithm. */
        uint64_t vlan_id               : 12; /**< [ 28: 17](R/W) VLAN ID used for the matching algorithm when [VLAN_EN] is set. */
        uint64_t vlan_en               : 1;  /**< [ 29: 29](R/W) Enable VLAN ID check:
                                                                 0 = Do not include VLAN ID checking in the matching algorithm.
                                                                 1 = Include VLAN ID checking in the matching algorithm. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_steering_vetype0x_s cn; */
};
typedef union bdk_cgxx_cmr_rx_steering_vetype0x bdk_cgxx_cmr_rx_steering_vetype0x_t;

static inline uint64_t BDK_CGXX_CMR_RX_STEERING_VETYPE0X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STEERING_VETYPE0X(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000380ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=7)))
        return 0x87e0e0000380ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000380ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=7)))
        return 0x87e0e0000380ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("CGXX_CMR_RX_STEERING_VETYPE0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STEERING_VETYPE0X(a,b) bdk_cgxx_cmr_rx_steering_vetype0x_t
#define bustype_BDK_CGXX_CMR_RX_STEERING_VETYPE0X(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STEERING_VETYPE0X(a,b) "CGXX_CMR_RX_STEERING_VETYPE0X"
#define device_bar_BDK_CGXX_CMR_RX_STEERING_VETYPE0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STEERING_VETYPE0X(a,b) (a)
#define arguments_BDK_CGXX_CMR_RX_STEERING_VETYPE0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr_rx_steering_vetype1#
 *
 * CGX CMR Receive VLAN Ethertype1 Register
 * For use with the lmac_id associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
 * These registers, along with CGX()_CMR_RX_STEERING1(), provide eight filters for identifying
 * and steering NCSI receive traffic.
 */
union bdk_cgxx_cmr_rx_steering_vetype1x
{
    uint64_t u;
    struct bdk_cgxx_cmr_rx_steering_vetype1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t vlan_en               : 1;  /**< [ 29: 29](R/W) Enable VLAN ID check:
                                                                 0 = Do not include VLAN ID checking in the matching algorithm.
                                                                 1 = Include VLAN ID checking in the matching algorithm. */
        uint64_t vlan_id               : 12; /**< [ 28: 17](R/W) VLAN ID used for the matching algorithm when [VLAN_EN] is set. */
        uint64_t vlan_tag_en           : 1;  /**< [ 16: 16](R/W) Enable VLAN tag Ethertype check:
                                                                 0 = Do not include VLAN tag Ethertype checking in the matching algorithm.
                                                                 1 = Include VLAN tag Ethertype checking in the matching algorithm. */
        uint64_t vlan_etype            : 16; /**< [ 15:  0](R/W) VLAN Ethertype for the matching algorithm when [VLAN_TAG_EN] is set.
                                                                 802.1Q and 802.1ad specify several Ethertypes used to identify VLAN tagged and VLAN double
                                                                 tagged packets. CGX will always match against the tag immediately following the SMAC
                                                                 address of the L2 header. */
#else /* Word 0 - Little Endian */
        uint64_t vlan_etype            : 16; /**< [ 15:  0](R/W) VLAN Ethertype for the matching algorithm when [VLAN_TAG_EN] is set.
                                                                 802.1Q and 802.1ad specify several Ethertypes used to identify VLAN tagged and VLAN double
                                                                 tagged packets. CGX will always match against the tag immediately following the SMAC
                                                                 address of the L2 header. */
        uint64_t vlan_tag_en           : 1;  /**< [ 16: 16](R/W) Enable VLAN tag Ethertype check:
                                                                 0 = Do not include VLAN tag Ethertype checking in the matching algorithm.
                                                                 1 = Include VLAN tag Ethertype checking in the matching algorithm. */
        uint64_t vlan_id               : 12; /**< [ 28: 17](R/W) VLAN ID used for the matching algorithm when [VLAN_EN] is set. */
        uint64_t vlan_en               : 1;  /**< [ 29: 29](R/W) Enable VLAN ID check:
                                                                 0 = Do not include VLAN ID checking in the matching algorithm.
                                                                 1 = Include VLAN ID checking in the matching algorithm. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_rx_steering_vetype1x_s cn; */
};
typedef union bdk_cgxx_cmr_rx_steering_vetype1x bdk_cgxx_cmr_rx_steering_vetype1x_t;

static inline uint64_t BDK_CGXX_CMR_RX_STEERING_VETYPE1X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_RX_STEERING_VETYPE1X(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000580ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=7)))
        return 0x87e0e0000580ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=7)))
        return 0x87e0e0000580ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=7)))
        return 0x87e0e0000580ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("CGXX_CMR_RX_STEERING_VETYPE1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_RX_STEERING_VETYPE1X(a,b) bdk_cgxx_cmr_rx_steering_vetype1x_t
#define bustype_BDK_CGXX_CMR_RX_STEERING_VETYPE1X(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_RX_STEERING_VETYPE1X(a,b) "CGXX_CMR_RX_STEERING_VETYPE1X"
#define device_bar_BDK_CGXX_CMR_RX_STEERING_VETYPE1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_RX_STEERING_VETYPE1X(a,b) (a)
#define arguments_BDK_CGXX_CMR_RX_STEERING_VETYPE1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_cmr_tx_lmacs
 *
 * CGX CMR Transmit Logical MACs Registers
 * This register sets the number of LMACs allowed on the TX interface. The value is important for
 * defining the partitioning of the transmit FIFO.
 */
union bdk_cgxx_cmr_tx_lmacs
{
    uint64_t u;
    struct bdk_cgxx_cmr_tx_lmacs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t lmacs                 : 3;  /**< [  2:  0](R/W) Number of LMACS: Specifies the number of LMACs that can be enabled.
                                                                 This determines the logical TX buffer size per LMAC and the maximum
                                                                 LMAC ID that can be used:

                                                                 0x0 = Reserved.
                                                                 0x1 = CGX()_CONST[TX_FIFOSZ] bytes per LMAC, maximum LMAC ID is 0.
                                                                 0x2 = CGX()_CONST[TX_FIFOSZ]/2 bytes per LMAC, maximum LMAC ID is 1.
                                                                 0x3 = CGX()_CONST[TX_FIFOSZ]/2 bytes for LMAC 0,
                                                                       CGX()_CONST[TX_FIFOSZ]/4 bytes for LMAC 1, 2. maximum LMAC ID is 2.
                                                                 0x4 = CGX()_CONST[TX_FIFOSZ]/4 bytes per LMAC, maximum LMAC ID is 3.
                                                                 0x5-0x7 = Reserved.

                                                                 Note the maximum LMAC ID is determined by the smaller of
                                                                 CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS]. The two fields
                                                                 should be set to the same value for normal operation.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
#else /* Word 0 - Little Endian */
        uint64_t lmacs                 : 3;  /**< [  2:  0](R/W) Number of LMACS: Specifies the number of LMACs that can be enabled.
                                                                 This determines the logical TX buffer size per LMAC and the maximum
                                                                 LMAC ID that can be used:

                                                                 0x0 = Reserved.
                                                                 0x1 = CGX()_CONST[TX_FIFOSZ] bytes per LMAC, maximum LMAC ID is 0.
                                                                 0x2 = CGX()_CONST[TX_FIFOSZ]/2 bytes per LMAC, maximum LMAC ID is 1.
                                                                 0x3 = CGX()_CONST[TX_FIFOSZ]/2 bytes for LMAC 0,
                                                                       CGX()_CONST[TX_FIFOSZ]/4 bytes for LMAC 1, 2. maximum LMAC ID is 2.
                                                                 0x4 = CGX()_CONST[TX_FIFOSZ]/4 bytes per LMAC, maximum LMAC ID is 3.
                                                                 0x5-0x7 = Reserved.

                                                                 Note the maximum LMAC ID is determined by the smaller of
                                                                 CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS]. The two fields
                                                                 should be set to the same value for normal operation.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_tx_lmacs_s cn; */
};
typedef union bdk_cgxx_cmr_tx_lmacs bdk_cgxx_cmr_tx_lmacs_t;

static inline uint64_t BDK_CGXX_CMR_TX_LMACS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_TX_LMACS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_TX_LMACS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_TX_LMACS(a) bdk_cgxx_cmr_tx_lmacs_t
#define bustype_BDK_CGXX_CMR_TX_LMACS(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_TX_LMACS(a) "CGXX_CMR_TX_LMACS"
#define device_bar_BDK_CGXX_CMR_TX_LMACS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_TX_LMACS(a) (a)
#define arguments_BDK_CGXX_CMR_TX_LMACS(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_cmr_x2p#_count
 *
 * CGX X2P Activity Register
 */
union bdk_cgxx_cmr_x2px_count
{
    uint64_t u;
    struct bdk_cgxx_cmr_x2px_count_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t x2p_cnt               : 64; /**< [ 63:  0](R/W/H) Incremented on every clock cycle that CGX transmits data on the X2P. */
#else /* Word 0 - Little Endian */
        uint64_t x2p_cnt               : 64; /**< [ 63:  0](R/W/H) Incremented on every clock cycle that CGX transmits data on the X2P. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_cmr_x2px_count_s cn; */
};
typedef union bdk_cgxx_cmr_x2px_count bdk_cgxx_cmr_x2px_count_t;

static inline uint64_t BDK_CGXX_CMR_X2PX_COUNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CMR_X2PX_COUNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=2)))
        return 0x87e0e0000170ll + 0x1000000ll * ((a) & 0x3) + 0x1000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=2)))
        return 0x87e0e0000170ll + 0x1000000ll * ((a) & 0x7) + 0x1000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=2)))
        return 0x87e0e0000170ll + 0x1000000ll * ((a) & 0x3) + 0x1000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=2)))
        return 0x87e0e0000170ll + 0x1000000ll * ((a) & 0x3) + 0x1000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_CMR_X2PX_COUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CMR_X2PX_COUNT(a,b) bdk_cgxx_cmr_x2px_count_t
#define bustype_BDK_CGXX_CMR_X2PX_COUNT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CMR_X2PX_COUNT(a,b) "CGXX_CMR_X2PX_COUNT"
#define device_bar_BDK_CGXX_CMR_X2PX_COUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CMR_X2PX_COUNT(a,b) (a)
#define arguments_BDK_CGXX_CMR_X2PX_COUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_const
 *
 * CGX CONST Registers
 * This register contains constants for software discovery.
 */
union bdk_cgxx_const
{
    uint64_t u;
    struct bdk_cgxx_const_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t rx_fifosz             : 24; /**< [ 55: 32](RO) Number of bytes of receive buffering in entire CGX. This buffering may be split
                                                                 between LMACs; see CGX()_CMR_RX_LMACS[LMACS]. */
        uint64_t lmacs                 : 8;  /**< [ 31: 24](RO) Number of LMACs. */
        uint64_t tx_fifosz             : 24; /**< [ 23:  0](RO) Number of bytes of transmit buffering in entire CGX. This buffering may be split
                                                                 between LMACs; see CGX()_CMR_TX_LMACS[LMACS]. */
#else /* Word 0 - Little Endian */
        uint64_t tx_fifosz             : 24; /**< [ 23:  0](RO) Number of bytes of transmit buffering in entire CGX. This buffering may be split
                                                                 between LMACs; see CGX()_CMR_TX_LMACS[LMACS]. */
        uint64_t lmacs                 : 8;  /**< [ 31: 24](RO) Number of LMACs. */
        uint64_t rx_fifosz             : 24; /**< [ 55: 32](RO) Number of bytes of receive buffering in entire CGX. This buffering may be split
                                                                 between LMACs; see CGX()_CMR_RX_LMACS[LMACS]. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_const_s cn; */
};
typedef union bdk_cgxx_const bdk_cgxx_const_t;

static inline uint64_t BDK_CGXX_CONST(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CONST(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CONST", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CONST(a) bdk_cgxx_const_t
#define bustype_BDK_CGXX_CONST(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CONST(a) "CGXX_CONST"
#define device_bar_BDK_CGXX_CONST(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CONST(a) (a)
#define arguments_BDK_CGXX_CONST(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_const1
 *
 * CGX CONST1 Registers
 * This register contains constants for software discovery.
 */
union bdk_cgxx_const1
{
    uint64_t u;
    struct bdk_cgxx_const1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t res_types             : 21; /**< [ 31: 11](RO) Reserved for more LMAC TYPES. */
        uint64_t types                 : 11; /**< [ 10:  0](RO/H) LMAC types supported. Each bit if set corresponds to that value of CGX_LMAC_TYPES_E being
                                                                 supported.
                                                                 E.g. TYPES\<0\> if set indicates CGX_LMAC_TYPES_E::SGMII is supported. */
#else /* Word 0 - Little Endian */
        uint64_t types                 : 11; /**< [ 10:  0](RO/H) LMAC types supported. Each bit if set corresponds to that value of CGX_LMAC_TYPES_E being
                                                                 supported.
                                                                 E.g. TYPES\<0\> if set indicates CGX_LMAC_TYPES_E::SGMII is supported. */
        uint64_t res_types             : 21; /**< [ 31: 11](RO) Reserved for more LMAC TYPES. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_const1_s cn; */
};
typedef union bdk_cgxx_const1 bdk_cgxx_const1_t;

static inline uint64_t BDK_CGXX_CONST1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_CONST1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_CONST1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_CONST1(a) bdk_cgxx_const1_t
#define bustype_BDK_CGXX_CONST1(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_CONST1(a) "CGXX_CONST1"
#define device_bar_BDK_CGXX_CONST1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_CONST1(a) (a)
#define arguments_BDK_CGXX_CONST1(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_rx_wol_ctrl0
 *
 * CGX GMP GMI RX Wake-on-LAN Control 0 Registers
 */
union bdk_cgxx_gmp_gmix_rx_wol_ctrl0
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_rx_wol_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t pswd_len              : 4;  /**< [ 51: 48](R/W) The byte length of the optional Wake-on-LAN password. A value of 0 indicates a password
                                                                 is not supported. When non-zero, the least significant bytes of
                                                                 CGX()_GMP_GMI()_RX_WOL_CTRL1
                                                                 are used for the password match. Values 0x9 to 0xF are reserved. */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The MAC address to compare against received Wake-on-LAN packets. */
#else /* Word 0 - Little Endian */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The MAC address to compare against received Wake-on-LAN packets. */
        uint64_t pswd_len              : 4;  /**< [ 51: 48](R/W) The byte length of the optional Wake-on-LAN password. A value of 0 indicates a password
                                                                 is not supported. When non-zero, the least significant bytes of
                                                                 CGX()_GMP_GMI()_RX_WOL_CTRL1
                                                                 are used for the password match. Values 0x9 to 0xF are reserved. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmix_rx_wol_ctrl0_s cn; */
};
typedef union bdk_cgxx_gmp_gmix_rx_wol_ctrl0 bdk_cgxx_gmp_gmix_rx_wol_ctrl0_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a00ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038a00ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a00ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038a00ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_RX_WOL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(a,b) bdk_cgxx_gmp_gmix_rx_wol_ctrl0_t
#define bustype_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(a,b) "CGXX_GMP_GMIX_RX_WOL_CTRL0"
#define device_bar_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_rx_wol_ctrl1
 *
 * CGX GMP GMI RX Wake-on-LAN Control 1 Registers
 */
union bdk_cgxx_gmp_gmix_rx_wol_ctrl1
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_rx_wol_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pswd                  : 64; /**< [ 63:  0](R/W) The optional password to compare against received Wake-on-LAN packets. The length of the
                                                                 valid password is indicated by CGX()_GMP_GMI()_RX_WOL_CTRL0[PSWD_LEN]. */
#else /* Word 0 - Little Endian */
        uint64_t pswd                  : 64; /**< [ 63:  0](R/W) The optional password to compare against received Wake-on-LAN packets. The length of the
                                                                 valid password is indicated by CGX()_GMP_GMI()_RX_WOL_CTRL0[PSWD_LEN]. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmix_rx_wol_ctrl1_s cn; */
};
typedef union bdk_cgxx_gmp_gmix_rx_wol_ctrl1 bdk_cgxx_gmp_gmix_rx_wol_ctrl1_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a08ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038a08ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a08ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038a08ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_RX_WOL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(a,b) bdk_cgxx_gmp_gmix_rx_wol_ctrl1_t
#define bustype_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(a,b) "CGXX_GMP_GMIX_RX_WOL_CTRL1"
#define device_bar_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_RX_WOL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_tx_eee
 *
 * INTERNAL: CGX GMP GMI TX EEE Configure Registers
 *
 * Reserved.
 * Internal:
 * These registers control when GMP GMI TX requests to enter or exist LPI. Those
 * registers take effect only when EEE is supported and enabled for a given LMAC.
 */
union bdk_cgxx_gmp_gmix_tx_eee
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_tx_eee_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t sync_status_lpi_enable : 1; /**< [ 62: 62](RO/H) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX sync_status enables EEE LPI requests.  No LPI requests are allowed when
                                                                 sync_status = FAIL or within CGX()_GMP_GMI()_TX_EEE_CFG1[SYNC2LPI_TIME]
                                                                 microseconds (normally one second). */
        uint64_t tx_lpi_wait           : 1;  /**< [ 61: 61](RO/H) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX is in LPI state LPI_WAIT. GMI has stopped sending LPI_REQUEST, and is sending
                                                                 IDLE requests instead. TX traffic is still deferred until the Tw_sys_tx counter has
                                                                 expired.
                                                                 Both pause and CMR source packets are still deferred until [TX_LPI_WAIT]=0 and [TX_LPI]=0.

                                                                 [FORCE_LPI] is ignored in TX_LPI_WAIT state.  If [FORCE_LPI] is ignored when
                                                                 [TX_LPI_WAIT]=1, and if still set when TX_LPI_WAIT transitions 0, will then
                                                                 cause transition back to TX_LPI. */
        uint64_t tx_lpi                : 1;  /**< [ 60: 60](RO/H) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX is in LPI state LPI_ASSERTED. GMI is sending LPI_REQUEST to PCS.
                                                                 TX traffic is deferred. Both pause and CMR sourced packets are being deferred until
                                                                 [TX_LPI_WAIT]=0 and [TX_LPI]=0. */
        uint64_t idle_cnt              : 28; /**< [ 59: 32](RO/H) Reserved.
                                                                 Internal:
                                                                 The number of 128bit times that the LMAC has been idle. When [AUTO_LPI]=1 &&
                                                                 [IDLE_CNT] \>= [IDLE_THRESH] && CGX()_GMP_GMI()_TX_EEE_CFG1[TX_EEE_ENABLE]=1, EEE
                                                                 LPI will be asserted.

                                                                 The current IDLE counter value is only valid when [AUTO_LPI] is set. The counter will be
                                                                 incremented every 128bits of idle sent from the GMI to the PCS.  Time=128bits *
                                                                 bit_time/bit = 128 bit times.
                                                                 128 ns for 1000BASE-X.
                                                                   * Counter saturates to [IDLE_THRESH].
                                                                   * Counter is reset by srst_n.
                                                                   * Counter is reset when this LMAC has any bytes indicated by CMR heartbeats.  Does not
                                                                 require any threshold to be met.
                                                                   * Counter is reset when TX side needs to send a Pause packet.
                                                                   * Counter is reset when LMAC transitions from !enabled to enabled. */
        uint64_t auto_lpi              : 1;  /**< [ 31: 31](R/W) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX will send LPI requests to PCS when the bit is set and IDLE counter reaches
                                                                 [IDLE_THRESH].
                                                                 While in LPI state, GMP GMI TX will switch to send IDLE once TX has packets (including
                                                                 flow control
                                                                 packets) to send or [WAKEUP] is set by software. Packet transmission starts approx.
                                                                 CGX()_GMP_GMI()_TX_EEE_CFG1[WAKE2DATA_TIME]
                                                                 after the wakeup decision.
                                                                 [AUTO_LPI] is ignored if CGX()_GMP_GMI()_TX_EEE_CFG1[TX_EEE_ENABLE] = 0. */
        uint64_t wakeup                : 1;  /**< [ 30: 30](R/W/H) Reserved.
                                                                 Internal:
                                                                 [WAKEUP] is valid only when [AUTO_LPI] is set.  [WAKEUP] is ignored by hardware if the TX
                                                                 is not
                                                                 in LPI state indicated by [TX_LPI]=1.
                                                                 Setting [WAKEUP] to 1 causes hardware to exit [TX_LPI] = 1 state. Hardware clears [WAKEUP]
                                                                 when
                                                                 802.3-2012 tx lpi state == LPI_DEASSERTED. At this point hardware is ready to start
                                                                 sending packets.
                                                                 Setting [WAKEUP]=1 in TX_LPI_WAIT state does nothing, but the [WAKEUP] will remain set
                                                                 until hardware
                                                                 exits TX_LPI_WAIT.
                                                                 Software clearing of [WAKEUP] after setting [WAKEUP] is not recommended.
                                                                 Hardware can actually start sending packets IFG1+IFG2 time after [WAKEUP] clears. */
        uint64_t force_lpi             : 1;  /**< [ 29: 29](R/W) Reserved.
                                                                 Internal:
                                                                 [FORCE_LPI] is only valid when [AUTO_LPI] is cleared. GMP GMI TX will send LPI requests to
                                                                 PCS immediately after the current packet is transmitted when the bit is set.
                                                                 On [FORCE_LPI] deassertion, the TX will switch to send IDLE. Assuming there are packets to
                                                                 send, the
                                                                 GMI will start sending packet data after
                                                                 CGX()_GMP_GMI()_TX_EEE_CFG1[WAKE2DATA_TIME].

                                                                 All TX traffic is differed in [FORCE_LPI]=1 mode.  There will be no pause flow
                                                                 control transmitted.
                                                                 Current packet being sent includes IFG & IFG2. */
        uint64_t reserved_28           : 1;
        uint64_t idle_thresh           : 28; /**< [ 27:  0](R/W) Reserved.
                                                                 Internal:
                                                                 IDLE threshold. [IDLE_THRESH] is only used when [AUTO_LPI] is set. GMP GMI TX
                                                                 will send LPI requests to PCS when the idle counter reaches this threshold. The
                                                                 unit of value is a 16 codegroups (same as SMU) at the GMI TX state machine. Note that
                                                                 active flow
                                                                 control of an enabled LMAC will keep the corresponding LMAC NOT idle. */
#else /* Word 0 - Little Endian */
        uint64_t idle_thresh           : 28; /**< [ 27:  0](R/W) Reserved.
                                                                 Internal:
                                                                 IDLE threshold. [IDLE_THRESH] is only used when [AUTO_LPI] is set. GMP GMI TX
                                                                 will send LPI requests to PCS when the idle counter reaches this threshold. The
                                                                 unit of value is a 16 codegroups (same as SMU) at the GMI TX state machine. Note that
                                                                 active flow
                                                                 control of an enabled LMAC will keep the corresponding LMAC NOT idle. */
        uint64_t reserved_28           : 1;
        uint64_t force_lpi             : 1;  /**< [ 29: 29](R/W) Reserved.
                                                                 Internal:
                                                                 [FORCE_LPI] is only valid when [AUTO_LPI] is cleared. GMP GMI TX will send LPI requests to
                                                                 PCS immediately after the current packet is transmitted when the bit is set.
                                                                 On [FORCE_LPI] deassertion, the TX will switch to send IDLE. Assuming there are packets to
                                                                 send, the
                                                                 GMI will start sending packet data after
                                                                 CGX()_GMP_GMI()_TX_EEE_CFG1[WAKE2DATA_TIME].

                                                                 All TX traffic is differed in [FORCE_LPI]=1 mode.  There will be no pause flow
                                                                 control transmitted.
                                                                 Current packet being sent includes IFG & IFG2. */
        uint64_t wakeup                : 1;  /**< [ 30: 30](R/W/H) Reserved.
                                                                 Internal:
                                                                 [WAKEUP] is valid only when [AUTO_LPI] is set.  [WAKEUP] is ignored by hardware if the TX
                                                                 is not
                                                                 in LPI state indicated by [TX_LPI]=1.
                                                                 Setting [WAKEUP] to 1 causes hardware to exit [TX_LPI] = 1 state. Hardware clears [WAKEUP]
                                                                 when
                                                                 802.3-2012 tx lpi state == LPI_DEASSERTED. At this point hardware is ready to start
                                                                 sending packets.
                                                                 Setting [WAKEUP]=1 in TX_LPI_WAIT state does nothing, but the [WAKEUP] will remain set
                                                                 until hardware
                                                                 exits TX_LPI_WAIT.
                                                                 Software clearing of [WAKEUP] after setting [WAKEUP] is not recommended.
                                                                 Hardware can actually start sending packets IFG1+IFG2 time after [WAKEUP] clears. */
        uint64_t auto_lpi              : 1;  /**< [ 31: 31](R/W) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX will send LPI requests to PCS when the bit is set and IDLE counter reaches
                                                                 [IDLE_THRESH].
                                                                 While in LPI state, GMP GMI TX will switch to send IDLE once TX has packets (including
                                                                 flow control
                                                                 packets) to send or [WAKEUP] is set by software. Packet transmission starts approx.
                                                                 CGX()_GMP_GMI()_TX_EEE_CFG1[WAKE2DATA_TIME]
                                                                 after the wakeup decision.
                                                                 [AUTO_LPI] is ignored if CGX()_GMP_GMI()_TX_EEE_CFG1[TX_EEE_ENABLE] = 0. */
        uint64_t idle_cnt              : 28; /**< [ 59: 32](RO/H) Reserved.
                                                                 Internal:
                                                                 The number of 128bit times that the LMAC has been idle. When [AUTO_LPI]=1 &&
                                                                 [IDLE_CNT] \>= [IDLE_THRESH] && CGX()_GMP_GMI()_TX_EEE_CFG1[TX_EEE_ENABLE]=1, EEE
                                                                 LPI will be asserted.

                                                                 The current IDLE counter value is only valid when [AUTO_LPI] is set. The counter will be
                                                                 incremented every 128bits of idle sent from the GMI to the PCS.  Time=128bits *
                                                                 bit_time/bit = 128 bit times.
                                                                 128 ns for 1000BASE-X.
                                                                   * Counter saturates to [IDLE_THRESH].
                                                                   * Counter is reset by srst_n.
                                                                   * Counter is reset when this LMAC has any bytes indicated by CMR heartbeats.  Does not
                                                                 require any threshold to be met.
                                                                   * Counter is reset when TX side needs to send a Pause packet.
                                                                   * Counter is reset when LMAC transitions from !enabled to enabled. */
        uint64_t tx_lpi                : 1;  /**< [ 60: 60](RO/H) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX is in LPI state LPI_ASSERTED. GMI is sending LPI_REQUEST to PCS.
                                                                 TX traffic is deferred. Both pause and CMR sourced packets are being deferred until
                                                                 [TX_LPI_WAIT]=0 and [TX_LPI]=0. */
        uint64_t tx_lpi_wait           : 1;  /**< [ 61: 61](RO/H) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX is in LPI state LPI_WAIT. GMI has stopped sending LPI_REQUEST, and is sending
                                                                 IDLE requests instead. TX traffic is still deferred until the Tw_sys_tx counter has
                                                                 expired.
                                                                 Both pause and CMR source packets are still deferred until [TX_LPI_WAIT]=0 and [TX_LPI]=0.

                                                                 [FORCE_LPI] is ignored in TX_LPI_WAIT state.  If [FORCE_LPI] is ignored when
                                                                 [TX_LPI_WAIT]=1, and if still set when TX_LPI_WAIT transitions 0, will then
                                                                 cause transition back to TX_LPI. */
        uint64_t sync_status_lpi_enable : 1; /**< [ 62: 62](RO/H) Reserved.
                                                                 Internal:
                                                                 GMP GMI TX sync_status enables EEE LPI requests.  No LPI requests are allowed when
                                                                 sync_status = FAIL or within CGX()_GMP_GMI()_TX_EEE_CFG1[SYNC2LPI_TIME]
                                                                 microseconds (normally one second). */
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmix_tx_eee_s cn; */
};
typedef union bdk_cgxx_gmp_gmix_tx_eee bdk_cgxx_gmp_gmix_tx_eee_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_TX_EEE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_TX_EEE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038800ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_TX_EEE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_TX_EEE(a,b) bdk_cgxx_gmp_gmix_tx_eee_t
#define bustype_BDK_CGXX_GMP_GMIX_TX_EEE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_TX_EEE(a,b) "CGXX_GMP_GMIX_TX_EEE"
#define device_bar_BDK_CGXX_GMP_GMIX_TX_EEE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_TX_EEE(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_TX_EEE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_tx_eee_cfg1
 *
 * INTERNAL: CGX GMP GMI TX EEE Configure More Configuration Registers
 *
 * Reserved.
 * Internal:
 * Controls the GMP exiting of LPI and starting to send data.
 */
union bdk_cgxx_gmp_gmix_tx_eee_cfg1
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_tx_eee_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_61_63        : 3;
        uint64_t sync2lpi_time         : 21; /**< [ 60: 40](R/W) Reserved.
                                                                 Internal:
                                                                 Time from sync_status FAIL to OK to when TX can assert LPI. 802.3-2012 35.2.1 specifies no
                                                                 LPI when link_status=FAIL and for one second after status transitions to OK.
                                                                 Time units are microseconds based on 100Mhz reference clock and
                                                                 CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD].
                                                                 (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] == 99 default results in 1 us time unit)

                                                                 sync_status is observable in CGX()_GMP_PCS()_STATUS1[RECEIVE_LINK_STATUS] and
                                                                 CGX()_GMP_PCS_RX()_SYNC[SYNC].
                                                                 Microsecond unit is determined by divider on the 100mhz reference clock.
                                                                 1 us = 100 MHz reference period * (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] + 1)
                                                                 Simulation and PSV can change value to improve simulation efficiency and debug. */
        uint64_t reserved_37_39        : 3;
        uint64_t tx_eee_enable         : 1;  /**< [ 36: 36](R/W) Reserved.
                                                                 Internal:
                                                                 Enable bit for TX LPI. If clear, disables EEE, disables [FORCE_LPI], [AUTO_LPI]
                                                                 CGX()_GMP_GMI()_TX_EEE[WAKEUP]. Setting [TX_EEE_ENABLE] is illegal in
                                                                 half-duplex mode, and software must make sure it is cleared. */
        uint64_t reserved_24_35        : 12;
        uint64_t wake2data_time        : 24; /**< [ 23:  0](R/W) Reserved.
                                                                 Internal:
                                                                 The amount of time GMP must send /I/ (idle) after /LI/ before it starts sending data.
                                                                 Units are 10 ns (100 MHz reference clock ticks).  Allows maximum of 167 ms.
                                                                 Reset value gives 13.26 us. */
#else /* Word 0 - Little Endian */
        uint64_t wake2data_time        : 24; /**< [ 23:  0](R/W) Reserved.
                                                                 Internal:
                                                                 The amount of time GMP must send /I/ (idle) after /LI/ before it starts sending data.
                                                                 Units are 10 ns (100 MHz reference clock ticks).  Allows maximum of 167 ms.
                                                                 Reset value gives 13.26 us. */
        uint64_t reserved_24_35        : 12;
        uint64_t tx_eee_enable         : 1;  /**< [ 36: 36](R/W) Reserved.
                                                                 Internal:
                                                                 Enable bit for TX LPI. If clear, disables EEE, disables [FORCE_LPI], [AUTO_LPI]
                                                                 CGX()_GMP_GMI()_TX_EEE[WAKEUP]. Setting [TX_EEE_ENABLE] is illegal in
                                                                 half-duplex mode, and software must make sure it is cleared. */
        uint64_t reserved_37_39        : 3;
        uint64_t sync2lpi_time         : 21; /**< [ 60: 40](R/W) Reserved.
                                                                 Internal:
                                                                 Time from sync_status FAIL to OK to when TX can assert LPI. 802.3-2012 35.2.1 specifies no
                                                                 LPI when link_status=FAIL and for one second after status transitions to OK.
                                                                 Time units are microseconds based on 100Mhz reference clock and
                                                                 CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD].
                                                                 (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] == 99 default results in 1 us time unit)

                                                                 sync_status is observable in CGX()_GMP_PCS()_STATUS1[RECEIVE_LINK_STATUS] and
                                                                 CGX()_GMP_PCS_RX()_SYNC[SYNC].
                                                                 Microsecond unit is determined by divider on the 100mhz reference clock.
                                                                 1 us = 100 MHz reference period * (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] + 1)
                                                                 Simulation and PSV can change value to improve simulation efficiency and debug. */
        uint64_t reserved_61_63        : 3;
#endif /* Word 0 - End */
    } s;
    struct bdk_cgxx_gmp_gmix_tx_eee_cfg1_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_61_63        : 3;
        uint64_t sync2lpi_time         : 21; /**< [ 60: 40](R/W) Reserved.
                                                                 Internal:
                                                                 Time from sync_status FAIL to OK to when TX can assert LPI. 802.3-2012 35.2.1 specifies no
                                                                 LPI when link_status=FAIL and for one second after status transitions to OK.
                                                                 Time units are microseconds based on 100Mhz reference clock and
                                                                 CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD].
                                                                 (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] == 99 default results in 1 us time unit)

                                                                 sync_status is observable in CGX()_GMP_PCS()_STATUS1[RECEIVE_LINK_STATUS] and
                                                                 CGX()_GMP_PCS_RX()_SYNC[SYNC].
                                                                 Microsecond unit is determined by divider on the 100mhz reference clock.
                                                                 1 us = 100 MHz reference period * (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] + 1)
                                                                 Simulation and PSV can change value to improve simulation efficiency and debug. */
        uint64_t reserved_37_39        : 3;
        uint64_t tx_eee_enable         : 1;  /**< [ 36: 36](R/W) Reserved.
                                                                 Internal:
                                                                 Enable bit for TX LPI. If clear, disables EEE, disables [FORCE_LPI], [AUTO_LPI]
                                                                 CGX()_GMP_GMI()_TX_EEE[WAKEUP]. Setting [TX_EEE_ENABLE] is illegal in
                                                                 half-duplex mode, and software must make sure it is cleared. */
        uint64_t reserved_32_35        : 4;
        uint64_t reserved_24_31        : 8;
        uint64_t wake2data_time        : 24; /**< [ 23:  0](R/W) Reserved.
                                                                 Internal:
                                                                 The amount of time GMP must send /I/ (idle) after /LI/ before it starts sending data.
                                                                 Units are 10 ns (100 MHz reference clock ticks).  Allows maximum of 167 ms.
                                                                 Reset value gives 13.26 us. */
#else /* Word 0 - Little Endian */
        uint64_t wake2data_time        : 24; /**< [ 23:  0](R/W) Reserved.
                                                                 Internal:
                                                                 The amount of time GMP must send /I/ (idle) after /LI/ before it starts sending data.
                                                                 Units are 10 ns (100 MHz reference clock ticks).  Allows maximum of 167 ms.
                                                                 Reset value gives 13.26 us. */
        uint64_t reserved_24_31        : 8;
        uint64_t reserved_32_35        : 4;
        uint64_t tx_eee_enable         : 1;  /**< [ 36: 36](R/W) Reserved.
                                                                 Internal:
                                                                 Enable bit for TX LPI. If clear, disables EEE, disables [FORCE_LPI], [AUTO_LPI]
                                                                 CGX()_GMP_GMI()_TX_EEE[WAKEUP]. Setting [TX_EEE_ENABLE] is illegal in
                                                                 half-duplex mode, and software must make sure it is cleared. */
        uint64_t reserved_37_39        : 3;
        uint64_t sync2lpi_time         : 21; /**< [ 60: 40](R/W) Reserved.
                                                                 Internal:
                                                                 Time from sync_status FAIL to OK to when TX can assert LPI. 802.3-2012 35.2.1 specifies no
                                                                 LPI when link_status=FAIL and for one second after status transitions to OK.
                                                                 Time units are microseconds based on 100Mhz reference clock and
                                                                 CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD].
                                                                 (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] == 99 default results in 1 us time unit)

                                                                 sync_status is observable in CGX()_GMP_PCS()_STATUS1[RECEIVE_LINK_STATUS] and
                                                                 CGX()_GMP_PCS_RX()_SYNC[SYNC].
                                                                 Microsecond unit is determined by divider on the 100mhz reference clock.
                                                                 1 us = 100 MHz reference period * (CGX()_GMP_PCS()_DBG_CONTROL[US_CLK_PERIOD] + 1)
                                                                 Simulation and PSV can change value to improve simulation efficiency and debug. */
        uint64_t reserved_61_63        : 3;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_cgxx_gmp_gmix_tx_eee_cfg1 bdk_cgxx_gmp_gmix_tx_eee_cfg1_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038808ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038808ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038808ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038808ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_TX_EEE_CFG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(a,b) bdk_cgxx_gmp_gmix_tx_eee_cfg1_t
#define bustype_BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(a,b) "CGXX_GMP_GMIX_TX_EEE_CFG1"
#define device_bar_BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_TX_EEE_CFG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_wol_int
 *
 * CGX GMP GMI RX WOL Interrupt Registers
 * These registers allow WOL interrupts to be sent to the control processor.
 */
union bdk_cgxx_gmp_gmix_wol_int
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_wol_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Wake-on-LAN packet detected. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Wake-on-LAN packet detected. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmix_wol_int_s cn; */
};
typedef union bdk_cgxx_gmp_gmix_wol_int bdk_cgxx_gmp_gmix_wol_int_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a80ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038a80ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a80ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038a80ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_WOL_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_WOL_INT(a,b) bdk_cgxx_gmp_gmix_wol_int_t
#define bustype_BDK_CGXX_GMP_GMIX_WOL_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_WOL_INT(a,b) "CGXX_GMP_GMIX_WOL_INT"
#define device_bar_BDK_CGXX_GMP_GMIX_WOL_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_WOL_INT(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_WOL_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1c
 *
 * CGX GMP GMI RX WOL Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_gmp_gmix_wol_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_wol_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmix_wol_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_gmp_gmix_wol_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_gmp_gmix_wol_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmix_wol_int_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_gmp_gmix_wol_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmix_wol_int_ena_w1c bdk_cgxx_gmp_gmix_wol_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a90ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038a90ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a90ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038a90ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_WOL_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(a,b) bdk_cgxx_gmp_gmix_wol_int_ena_w1c_t
#define bustype_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(a,b) "CGXX_GMP_GMIX_WOL_INT_ENA_W1C"
#define device_bar_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1s
 *
 * CGX GMP GMI RX WOL Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_gmp_gmix_wol_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_wol_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmix_wol_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_gmp_gmix_wol_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_gmp_gmix_wol_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmix_wol_int_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_gmp_gmix_wol_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmix_wol_int_ena_w1s bdk_cgxx_gmp_gmix_wol_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a98ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038a98ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a98ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038a98ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_WOL_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(a,b) bdk_cgxx_gmp_gmix_wol_int_ena_w1s_t
#define bustype_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(a,b) "CGXX_GMP_GMIX_WOL_INT_ENA_W1S"
#define device_bar_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi#_wol_int_w1s
 *
 * CGX GMP GMI RX WOL Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_gmp_gmix_wol_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmix_wol_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmix_wol_int_w1s_s cn9; */
    /* struct bdk_cgxx_gmp_gmix_wol_int_w1s_s cn96xx; */
    struct bdk_cgxx_gmp_gmix_wol_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmix_wol_int_w1s_s cnf95xx; */
    struct bdk_cgxx_gmp_gmix_wol_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI(0..3)_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmix_wol_int_w1s bdk_cgxx_gmp_gmix_wol_int_w1s_t;

static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMIX_WOL_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a88ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038a88ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038a88ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038a88ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMIX_WOL_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMIX_WOL_INT_W1S(a,b) bdk_cgxx_gmp_gmix_wol_int_w1s_t
#define bustype_BDK_CGXX_GMP_GMIX_WOL_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMIX_WOL_INT_W1S(a,b) "CGXX_GMP_GMIX_WOL_INT_W1S"
#define device_bar_BDK_CGXX_GMP_GMIX_WOL_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMIX_WOL_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMIX_WOL_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_prt#_cfg
 *
 * CGX GMP GMI LMAC Configuration Registers
 * This register controls the configuration of the LMAC.
 */
union bdk_cgxx_gmp_gmi_prtx_cfg
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_prtx_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t tx_idle               : 1;  /**< [ 13: 13](RO/H) TX machine is idle. */
        uint64_t rx_idle               : 1;  /**< [ 12: 12](RO/H) RX machine is idle. */
        uint64_t reserved_9_11         : 3;
        uint64_t speed_msb             : 1;  /**< [  8:  8](R/W) Link speed MSB (SGMII/QSGMII/1000Base-X only). See [SPEED]. */
        uint64_t reserved_4_7          : 4;
        uint64_t slottime              : 1;  /**< [  3:  3](R/W) Slot time for half-duplex operation
                                                                 (SGMII/QSGMII/1000Base-X only):
                                                                 0 = 512 bit times (10/100 Mb/s operation).
                                                                 1 = 4096 bit times (1000 Mb/s operation). */
        uint64_t duplex                : 1;  /**< [  2:  2](R/W) Duplex mode
                                                                 (SGMII/QSGMII/1000Base-X only):
                                                                 0 = half-duplex (collisions/extensions/bursts):
                                                                 1 = full-duplex. */
        uint64_t speed                 : 1;  /**< [  1:  1](R/W) Link Speed LSB (SGMII/QSGMII/1000Base-X only):
                                                                 _ [SPEED_MSB,SPEED] = 0x0: 100 Mb/s operation.
                                                                 _ [SPEED_MSB,SPEED] = 0x1: 1000 Mb/s operation.
                                                                 _ [SPEED_MSB,SPEED] = 0x2: 10 Mb/s operation.
                                                                 _ [SPEED_MSB,SPEED] = 0x3: Reserved. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t speed                 : 1;  /**< [  1:  1](R/W) Link Speed LSB (SGMII/QSGMII/1000Base-X only):
                                                                 _ [SPEED_MSB,SPEED] = 0x0: 100 Mb/s operation.
                                                                 _ [SPEED_MSB,SPEED] = 0x1: 1000 Mb/s operation.
                                                                 _ [SPEED_MSB,SPEED] = 0x2: 10 Mb/s operation.
                                                                 _ [SPEED_MSB,SPEED] = 0x3: Reserved. */
        uint64_t duplex                : 1;  /**< [  2:  2](R/W) Duplex mode
                                                                 (SGMII/QSGMII/1000Base-X only):
                                                                 0 = half-duplex (collisions/extensions/bursts):
                                                                 1 = full-duplex. */
        uint64_t slottime              : 1;  /**< [  3:  3](R/W) Slot time for half-duplex operation
                                                                 (SGMII/QSGMII/1000Base-X only):
                                                                 0 = 512 bit times (10/100 Mb/s operation).
                                                                 1 = 4096 bit times (1000 Mb/s operation). */
        uint64_t reserved_4_7          : 4;
        uint64_t speed_msb             : 1;  /**< [  8:  8](R/W) Link speed MSB (SGMII/QSGMII/1000Base-X only). See [SPEED]. */
        uint64_t reserved_9_11         : 3;
        uint64_t rx_idle               : 1;  /**< [ 12: 12](RO/H) RX machine is idle. */
        uint64_t tx_idle               : 1;  /**< [ 13: 13](RO/H) TX machine is idle. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_prtx_cfg_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_prtx_cfg bdk_cgxx_gmp_gmi_prtx_cfg_t;

static inline uint64_t BDK_CGXX_GMP_GMI_PRTX_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_PRTX_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_PRTX_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_PRTX_CFG(a,b) bdk_cgxx_gmp_gmi_prtx_cfg_t
#define bustype_BDK_CGXX_GMP_GMI_PRTX_CFG(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_PRTX_CFG(a,b) "CGXX_GMP_GMI_PRTX_CFG"
#define device_bar_BDK_CGXX_GMP_GMI_PRTX_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_PRTX_CFG(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_PRTX_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_decision
 *
 * CGX GMP Packet-Decision Registers
 * This register specifies the byte count used to determine when to accept or to filter a packet.
 * As each byte in a packet is received by GMI, the L2 byte count is compared against
 * [CNT]. In normal operation, the L2 header begins after the
 * PREAMBLE + SFD (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any optional UDD skip
 * data (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
 *
 * Internal:
 * Notes:
 * As each byte in a packet is received by GMI, the L2 byte count is compared
 * against the [CNT].  The L2 byte count is the number of bytes
 * from the beginning of the L2 header (DMAC).  In normal operation, the L2
 * header begins after the PREAMBLE+SFD (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]=1) and any
 * optional UDD skip data (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
 * When CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are prepended to the
 * packet and would require UDD skip length to account for them.
 *
 * Full Duplex:
 * _   L2 Size \<  [CNT] - Accept packet. No filtering is applied.
 * _   L2 Size \>= [CNT] - Apply filter. Accept packet based on PAUSE packet filter.
 *
 * Half Duplex:
 * _   L2 Size \<  [CNT] - Drop packet. Packet is unconditionally dropped.
 * _   L2 Size \>= [CNT] - Accept packet.
 *
 * where L2_size = MAX(0, total_packet_size - CGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
 *                        ((CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8)).
 */
union bdk_cgxx_gmp_gmi_rxx_decision
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_decision_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t cnt                   : 5;  /**< [  4:  0](R/W) The byte count used to decide when to accept or filter a packet. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 5;  /**< [  4:  0](R/W) The byte count used to decide when to accept or filter a packet. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_decision_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_rxx_decision bdk_cgxx_gmp_gmi_rxx_decision_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_DECISION(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_DECISION(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038040ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_DECISION", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_DECISION(a,b) bdk_cgxx_gmp_gmi_rxx_decision_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_DECISION(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_DECISION(a,b) "CGXX_GMP_GMI_RXX_DECISION"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_DECISION(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_DECISION(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_DECISION(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_frm_chk
 *
 * CGX GMP Frame Check Registers
 */
union bdk_cgxx_gmp_gmi_rxx_frm_chk
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_frm_chk_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t skperr                : 1;  /**< [  8:  8](R/W) Skipper error. */
        uint64_t rcverr                : 1;  /**< [  7:  7](R/W) Frame was received with data-reception error. */
        uint64_t reserved_5_6          : 2;
        uint64_t fcserr                : 1;  /**< [  4:  4](R/W) Frame was received with FCS/CRC error. */
        uint64_t jabber                : 1;  /**< [  3:  3](R/W) Frame was received with length \> sys_length. */
        uint64_t reserved_2            : 1;
        uint64_t carext                : 1;  /**< [  1:  1](R/W) Carrier extend error. SGMII/QSGMII/1000Base-X only. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W) PAUSE frame was received with length \< minFrameSize. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W) PAUSE frame was received with length \< minFrameSize. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W) Carrier extend error. SGMII/QSGMII/1000Base-X only. */
        uint64_t reserved_2            : 1;
        uint64_t jabber                : 1;  /**< [  3:  3](R/W) Frame was received with length \> sys_length. */
        uint64_t fcserr                : 1;  /**< [  4:  4](R/W) Frame was received with FCS/CRC error. */
        uint64_t reserved_5_6          : 2;
        uint64_t rcverr                : 1;  /**< [  7:  7](R/W) Frame was received with data-reception error. */
        uint64_t skperr                : 1;  /**< [  8:  8](R/W) Skipper error. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_frm_chk_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_rxx_frm_chk bdk_cgxx_gmp_gmi_rxx_frm_chk_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_FRM_CHK(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_FRM_CHK(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_FRM_CHK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_FRM_CHK(a,b) bdk_cgxx_gmp_gmi_rxx_frm_chk_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_FRM_CHK(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_FRM_CHK(a,b) "CGXX_GMP_GMI_RXX_FRM_CHK"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_FRM_CHK(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_FRM_CHK(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_FRM_CHK(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_frm_ctl
 *
 * CGX GMP Frame Control Registers
 * This register controls the handling of the frames.
 * The [CTL_BCK] and [CTL_DRP] bits control how the hardware handles incoming PAUSE packets. The
 * most
 * common modes of operation:
 * _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything.
 * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames.
 * _ [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored.
 *
 * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex mode. Since
 * PAUSE
 * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
 * which should be handled by the processing cores. PAUSE packets should not be forwarded.
 *
 * Internal:
 * Notes:
 * [PRE_STRP]:
 * When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP]
 * determines if the PREAMBLE+SFD bytes are thrown away or sent to the Octane
 * core as part of the packet.
 * In either mode, the PREAMBLE+SFD bytes are not counted toward the packet
 * size when checking against the MIN and MAX bounds.  Furthermore, the bytes
 * are skipped when locating the start of the L2 header for DMAC and Control
 * frame recognition.
 */
union bdk_cgxx_gmp_gmi_rxx_frm_ctl
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_frm_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t rx_fc_type            : 1;  /**< [ 13: 13](R/W) Receive side flow control type select.
                                                                 0 = GMI MAC receives and processes ITU G.999.1 pause frames.
                                                                 1 = GMI MAC receives and processes 802.3 pause frames. */
        uint64_t ptp_mode              : 1;  /**< [ 12: 12](R/W) Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                                 packet.

                                                                 The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                                 receive byte count. This implies that the CGX()_GMP_GMI_RX()_JABBER,
                                                                 CGX()_GMP_GMI_RX()_DECISION, CGX()_GMP_GMI_RX()_UDD_SKP, and
                                                                 CGX()_CMR()_RX_STAT0..CGX()_CMR()_RX_STAT8
                                                                 do not require any adjustment as they operate on the received
                                                                 packet size. When the packet reaches NIX, its size reflects the additional bytes. */
        uint64_t reserved_11           : 1;
        uint64_t null_dis              : 1;  /**< [ 10: 10](R/W) When set, do not modify the MOD bits on NULL ticks due to partial packets. */
        uint64_t pre_align             : 1;  /**< [  9:  9](R/W) When set, PREAMBLE parser aligns the SFD byte regardless of the number of previous
                                                                 PREAMBLE nibbles. In this mode, [PRE_STRP] should be set to account for the variable
                                                                 nature of the PREAMBLE. [PRE_CHK] must be set to enable this and all PREAMBLE features.
                                                                 SGMII at 10/100Mbs only. */
        uint64_t reserved_7_8          : 2;
        uint64_t pre_free              : 1;  /**< [  6:  6](RO/H) When set, PREAMBLE checking is less strict. GMI will begin the frame at the first SFD.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features. SGMII/QSGMII/1000Base-X
                                                                 only. */
        uint64_t ctl_smac              : 1;  /**< [  5:  5](R/W) Control PAUSE frames can match station SMAC. */
        uint64_t ctl_mcst              : 1;  /**< [  4:  4](R/W) Control PAUSE frames can match globally assigned multicast address. */
        uint64_t ctl_bck               : 1;  /**< [  3:  3](R/W) Forward PAUSE information to TX block. */
        uint64_t ctl_drp               : 1;  /**< [  2:  2](R/W) Drop control-PAUSE frames. */
        uint64_t pre_strp              : 1;  /**< [  1:  1](R/W) Strip off the preamble (when present).
                                                                 0 = PREAMBLE + SFD is sent to core as part of frame.
                                                                 1 = PREAMBLE + SFD is dropped.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features.

                                                                 If [PTP_MODE]=1 and [PRE_CHK]=1, [PRE_STRP] must be 1.

                                                                 When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
                                                                 if
                                                                 the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                                 either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                                 against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                                 of the L2 header for DMAC and control frame recognition. */
        uint64_t pre_chk               : 1;  /**< [  0:  0](R/W) Check the preamble for correctness. This port is configured to send a valid 802.3 PREAMBLE
                                                                 to begin every frame. GMI checks that a valid PREAMBLE is received (based on [PRE_FREE]).
                                                                 When a problem does occur within the PREAMBLE sequence, the frame is marked as bad and not
                                                                 sent into the core. The CGX()_GMP_GMI_RX()_INT[PCTERR] interrupt is also raised. */
#else /* Word 0 - Little Endian */
        uint64_t pre_chk               : 1;  /**< [  0:  0](R/W) Check the preamble for correctness. This port is configured to send a valid 802.3 PREAMBLE
                                                                 to begin every frame. GMI checks that a valid PREAMBLE is received (based on [PRE_FREE]).
                                                                 When a problem does occur within the PREAMBLE sequence, the frame is marked as bad and not
                                                                 sent into the core. The CGX()_GMP_GMI_RX()_INT[PCTERR] interrupt is also raised. */
        uint64_t pre_strp              : 1;  /**< [  1:  1](R/W) Strip off the preamble (when present).
                                                                 0 = PREAMBLE + SFD is sent to core as part of frame.
                                                                 1 = PREAMBLE + SFD is dropped.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features.

                                                                 If [PTP_MODE]=1 and [PRE_CHK]=1, [PRE_STRP] must be 1.

                                                                 When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
                                                                 if
                                                                 the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                                 either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                                 against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                                 of the L2 header for DMAC and control frame recognition. */
        uint64_t ctl_drp               : 1;  /**< [  2:  2](R/W) Drop control-PAUSE frames. */
        uint64_t ctl_bck               : 1;  /**< [  3:  3](R/W) Forward PAUSE information to TX block. */
        uint64_t ctl_mcst              : 1;  /**< [  4:  4](R/W) Control PAUSE frames can match globally assigned multicast address. */
        uint64_t ctl_smac              : 1;  /**< [  5:  5](R/W) Control PAUSE frames can match station SMAC. */
        uint64_t pre_free              : 1;  /**< [  6:  6](RO/H) When set, PREAMBLE checking is less strict. GMI will begin the frame at the first SFD.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features. SGMII/QSGMII/1000Base-X
                                                                 only. */
        uint64_t reserved_7_8          : 2;
        uint64_t pre_align             : 1;  /**< [  9:  9](R/W) When set, PREAMBLE parser aligns the SFD byte regardless of the number of previous
                                                                 PREAMBLE nibbles. In this mode, [PRE_STRP] should be set to account for the variable
                                                                 nature of the PREAMBLE. [PRE_CHK] must be set to enable this and all PREAMBLE features.
                                                                 SGMII at 10/100Mbs only. */
        uint64_t null_dis              : 1;  /**< [ 10: 10](R/W) When set, do not modify the MOD bits on NULL ticks due to partial packets. */
        uint64_t reserved_11           : 1;
        uint64_t ptp_mode              : 1;  /**< [ 12: 12](R/W) Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                                 packet.

                                                                 The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                                 receive byte count. This implies that the CGX()_GMP_GMI_RX()_JABBER,
                                                                 CGX()_GMP_GMI_RX()_DECISION, CGX()_GMP_GMI_RX()_UDD_SKP, and
                                                                 CGX()_CMR()_RX_STAT0..CGX()_CMR()_RX_STAT8
                                                                 do not require any adjustment as they operate on the received
                                                                 packet size. When the packet reaches NIX, its size reflects the additional bytes. */
        uint64_t rx_fc_type            : 1;  /**< [ 13: 13](R/W) Receive side flow control type select.
                                                                 0 = GMI MAC receives and processes ITU G.999.1 pause frames.
                                                                 1 = GMI MAC receives and processes 802.3 pause frames. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    struct bdk_cgxx_gmp_gmi_rxx_frm_ctl_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t rx_fc_type            : 1;  /**< [ 13: 13](R/W) Receive side flow control type select.
                                                                 0 = GMI MAC receives and processes ITU G.999.1 pause frames.
                                                                 1 = GMI MAC receives and processes 802.3 pause frames. */
        uint64_t ptp_mode              : 1;  /**< [ 12: 12](R/W) Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                                 packet.

                                                                 The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                                 receive byte count. This implies that the CGX()_GMP_GMI_RX()_JABBER,
                                                                 CGX()_GMP_GMI_RX()_DECISION, CGX()_GMP_GMI_RX()_UDD_SKP, and
                                                                 CGX()_CMR()_RX_STAT0..CGX()_CMR()_RX_STAT8
                                                                 do not require any adjustment as they operate on the received
                                                                 packet size. When the packet reaches NIX, its size reflects the additional bytes. */
        uint64_t reserved_11           : 1;
        uint64_t null_dis              : 1;  /**< [ 10: 10](R/W) When set, do not modify the MOD bits on NULL ticks due to partial packets. */
        uint64_t pre_align             : 1;  /**< [  9:  9](R/W) When set, PREAMBLE parser aligns the SFD byte regardless of the number of previous
                                                                 PREAMBLE nibbles. In this mode, [PRE_STRP] should be set to account for the variable
                                                                 nature of the PREAMBLE. [PRE_CHK] must be set to enable this and all PREAMBLE features.
                                                                 SGMII at 10/100Mbs only. */
        uint64_t reserved_8            : 1;
        uint64_t reserved_7            : 1;
        uint64_t pre_free              : 1;  /**< [  6:  6](RO/H) When set, PREAMBLE checking is less strict. GMI will begin the frame at the first SFD.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features. SGMII/QSGMII/1000Base-X
                                                                 only. */
        uint64_t ctl_smac              : 1;  /**< [  5:  5](R/W) Control PAUSE frames can match station SMAC. */
        uint64_t ctl_mcst              : 1;  /**< [  4:  4](R/W) Control PAUSE frames can match globally assigned multicast address. */
        uint64_t ctl_bck               : 1;  /**< [  3:  3](R/W) Forward PAUSE information to TX block. */
        uint64_t ctl_drp               : 1;  /**< [  2:  2](R/W) Drop control-PAUSE frames. */
        uint64_t pre_strp              : 1;  /**< [  1:  1](R/W) Strip off the preamble (when present).
                                                                 0 = PREAMBLE + SFD is sent to core as part of frame.
                                                                 1 = PREAMBLE + SFD is dropped.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features.

                                                                 If [PTP_MODE]=1 and [PRE_CHK]=1, [PRE_STRP] must be 1.

                                                                 When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
                                                                 if
                                                                 the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                                 either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                                 against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                                 of the L2 header for DMAC and control frame recognition. */
        uint64_t pre_chk               : 1;  /**< [  0:  0](R/W) Check the preamble for correctness. This port is configured to send a valid 802.3 PREAMBLE
                                                                 to begin every frame. GMI checks that a valid PREAMBLE is received (based on [PRE_FREE]).
                                                                 When a problem does occur within the PREAMBLE sequence, the frame is marked as bad and not
                                                                 sent into the core. The CGX()_GMP_GMI_RX()_INT[PCTERR] interrupt is also raised. */
#else /* Word 0 - Little Endian */
        uint64_t pre_chk               : 1;  /**< [  0:  0](R/W) Check the preamble for correctness. This port is configured to send a valid 802.3 PREAMBLE
                                                                 to begin every frame. GMI checks that a valid PREAMBLE is received (based on [PRE_FREE]).
                                                                 When a problem does occur within the PREAMBLE sequence, the frame is marked as bad and not
                                                                 sent into the core. The CGX()_GMP_GMI_RX()_INT[PCTERR] interrupt is also raised. */
        uint64_t pre_strp              : 1;  /**< [  1:  1](R/W) Strip off the preamble (when present).
                                                                 0 = PREAMBLE + SFD is sent to core as part of frame.
                                                                 1 = PREAMBLE + SFD is dropped.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features.

                                                                 If [PTP_MODE]=1 and [PRE_CHK]=1, [PRE_STRP] must be 1.

                                                                 When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
                                                                 if
                                                                 the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                                 either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                                 against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                                 of the L2 header for DMAC and control frame recognition. */
        uint64_t ctl_drp               : 1;  /**< [  2:  2](R/W) Drop control-PAUSE frames. */
        uint64_t ctl_bck               : 1;  /**< [  3:  3](R/W) Forward PAUSE information to TX block. */
        uint64_t ctl_mcst              : 1;  /**< [  4:  4](R/W) Control PAUSE frames can match globally assigned multicast address. */
        uint64_t ctl_smac              : 1;  /**< [  5:  5](R/W) Control PAUSE frames can match station SMAC. */
        uint64_t pre_free              : 1;  /**< [  6:  6](RO/H) When set, PREAMBLE checking is less strict. GMI will begin the frame at the first SFD.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features. SGMII/QSGMII/1000Base-X
                                                                 only. */
        uint64_t reserved_7            : 1;
        uint64_t reserved_8            : 1;
        uint64_t pre_align             : 1;  /**< [  9:  9](R/W) When set, PREAMBLE parser aligns the SFD byte regardless of the number of previous
                                                                 PREAMBLE nibbles. In this mode, [PRE_STRP] should be set to account for the variable
                                                                 nature of the PREAMBLE. [PRE_CHK] must be set to enable this and all PREAMBLE features.
                                                                 SGMII at 10/100Mbs only. */
        uint64_t null_dis              : 1;  /**< [ 10: 10](R/W) When set, do not modify the MOD bits on NULL ticks due to partial packets. */
        uint64_t reserved_11           : 1;
        uint64_t ptp_mode              : 1;  /**< [ 12: 12](R/W) Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                                 packet.

                                                                 The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                                 receive byte count. This implies that the CGX()_GMP_GMI_RX()_JABBER,
                                                                 CGX()_GMP_GMI_RX()_DECISION, CGX()_GMP_GMI_RX()_UDD_SKP, and
                                                                 CGX()_CMR()_RX_STAT0..CGX()_CMR()_RX_STAT8
                                                                 do not require any adjustment as they operate on the received
                                                                 packet size. When the packet reaches NIX, its size reflects the additional bytes. */
        uint64_t rx_fc_type            : 1;  /**< [ 13: 13](R/W) Receive side flow control type select.
                                                                 0 = GMI MAC receives and processes ITU G.999.1 pause frames.
                                                                 1 = GMI MAC receives and processes 802.3 pause frames. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_cgxx_gmp_gmi_rxx_frm_ctl bdk_cgxx_gmp_gmi_rxx_frm_ctl_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_FRM_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_FRM_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_FRM_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_FRM_CTL(a,b) bdk_cgxx_gmp_gmi_rxx_frm_ctl_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_FRM_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_FRM_CTL(a,b) "CGXX_GMP_GMI_RXX_FRM_CTL"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_FRM_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_FRM_CTL(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_FRM_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_ifg
 *
 * CGX GMI Minimum Interframe-Gap Cycles Registers
 * This register specifies the minimum number of interframe-gap (IFG) cycles between packets.
 */
union bdk_cgxx_gmp_gmi_rxx_ifg
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_ifg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t ifg                   : 4;  /**< [  3:  0](R/W) Min IFG (in IFG * 8 bits) between packets used to determine IFGERR. Normally IFG is 96
                                                                 bits. Must be greater than 4.

                                                                 Note that in some operating modes, IFG cycles can be inserted or removed in order to
                                                                 achieve clock rate adaptation. For these reasons, the default value is slightly
                                                                 conservative and does not check up to the full 96 bits of IFG.
                                                                 (SGMII/QSGMII/1000Base-X only)

                                                                 Also used for RX LED Active extension. See CGX()_CMR()_LED_TIMING. */
#else /* Word 0 - Little Endian */
        uint64_t ifg                   : 4;  /**< [  3:  0](R/W) Min IFG (in IFG * 8 bits) between packets used to determine IFGERR. Normally IFG is 96
                                                                 bits. Must be greater than 4.

                                                                 Note that in some operating modes, IFG cycles can be inserted or removed in order to
                                                                 achieve clock rate adaptation. For these reasons, the default value is slightly
                                                                 conservative and does not check up to the full 96 bits of IFG.
                                                                 (SGMII/QSGMII/1000Base-X only)

                                                                 Also used for RX LED Active extension. See CGX()_CMR()_LED_TIMING. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_ifg_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_rxx_ifg bdk_cgxx_gmp_gmi_rxx_ifg_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_IFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_IFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038058ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_IFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_IFG(a,b) bdk_cgxx_gmp_gmi_rxx_ifg_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_IFG(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_IFG(a,b) "CGXX_GMP_GMI_RXX_IFG"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_IFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_IFG(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_IFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_int
 *
 * CGX GMP GMI RX Interrupt Registers
 * These registers allow interrupts to be sent to the control processor.
 * * Exception conditions \<10:0\> can also set the rcv/opcode in the received packet's work-queue
 * entry. CGX()_GMP_GMI_RX()_FRM_CHK provides a bit mask for configuring which conditions
 * set the error.
 * In half duplex operation, the expectation is that collisions will appear as either MINERR or
 * CAREXT errors.
 *
 * Internal:
 * Notes:
 * (1) exception conditions 10:0 can also set the rcv/opcode in the received
 * packet's workQ entry.  The CGX()_GMP_GMI_RX()_FRM_CHK register provides a bit mask
 * for configuring which conditions set the error.
 *
 * (2) in half duplex operation, the expectation is that collisions will appear
 * as either MINERR o r CAREXT errors.
 *
 * (3) JABBER An RX jabber error indicates that a packet was received which
 * is longer than the maximum allowed packet as defined by the
 * system.  GMI will truncate the packet at the JABBER count.
 * Failure to do so could lead to system instabilty.
 *
 * (4) NIBERR This error is illegal at 1000Mbs speeds
 * (CGX()_GMP_GMI_PRT()_CFG[SPEED]==0) and will never assert.
 *
 * (5) MINERR total frame DA+SA+TL+DATA+PAD+FCS \< 64
 *
 * (6) ALNERR Indicates that the packet received was not an integer number of
 * bytes.  If FCS checking is enabled, ALNERR will only assert if
 * the FCS is bad.  If FCS checking is disabled, ALNERR will
 * assert in all non-integer frame cases.
 *
 * (7) Collisions Collisions can only occur in half-duplex mode.  A collision
 * is assumed by the receiver when the slottime
 * (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,
 * this will result in a frame \< SLOTTIME.  In 1000 mode, it
 * could result either in frame \< SLOTTIME or a carrier extend
 * error with the SLOTTIME.  These conditions are visible by...
 * . transfer ended before slottime COLDET
 * . carrier extend error           CAREXT
 *
 * (A) LENERR Length errors occur when the received packet does not match the
 * length field.  LENERR is only checked for packets between 64
 * and 1500 bytes.  For untagged frames, the length must exact
 * match.  For tagged frames the length or length+4 must match.
 *
 * (B) PCTERR checks that the frame begins with a valid PREAMBLE sequence.
 * Does not check the number of PREAMBLE cycles.
 *
 * (C) OVRERR *DON'T PUT IN HRM*
 * OVRERR is an architectural assertion check internal to GMI to
 * make sure no assumption was violated.  In a correctly operating
 * system, this interrupt can never fire.
 * GMI has an internal arbiter which selects which of four ports to
 * buffer in the main RX FIFO.  If we normally buffer eight bytes,
 * then each port will typically push a tick every eight cycles if
 * the packet interface is going as fast as possible.  If there
 * are four ports, they push every two cycles.  So that's the
 * assumption.  That the inbound module will always be able to
 * consume the tick before another is produced.  If that doesn't
 * happen that's when OVRERR will assert."
 */
union bdk_cgxx_gmp_gmi_rxx_int
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Interframe gap violation. Does not necessarily indicate a failure. SGMII/QSGMII/1000Base-X only. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Collision detection. Collisions can only occur in half-duplex mode. A collision is assumed
                                                                 by the receiver when the slottime (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not
                                                                 satisfied. In 10/100 mode, this will result in a frame \< SLOTTIME. In 1000 mode, it could
                                                                 result either in frame \< SLOTTIME or a carrier extend error with the SLOTTIME. These
                                                                 conditions are visible by 1) transfer ended before slottime - COLDET or 2) carrier extend
                                                                 error - CAREXT. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) False-carrier error, or carrier-extend error after slottime is satisfied.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Detected reserved opcode. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Bad preamble/protocol error. Checks that the frame begins with a valid PREAMBLE sequence.
                                                                 Does not check the number of PREAMBLE cycles. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Internal data aggregation overflow. This interrupt should never assert.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Skipper error. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Data-reception error. Frame was received with data-reception error. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) FCS/CRC error. Frame was received with FCS/CRC error. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) System-length error: frame was received with length \> sys_length.
                                                                 An RX Jabber error indicates that a packet was received which is longer than the maximum
                                                                 allowed packet as defined by the system. GMI truncates the packet at the JABBER count.
                                                                 Failure to do so could lead to system instability. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Carrier-extend error. (SGMII/QSGMII/1000Base-X only) */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) PAUSE frame was received with length \< minFrameSize. Frame length checks are typically
                                                                 handled in NIX, but PAUSE frames are normally discarded before being inspected by NIX.
                                                                 Total frame DA+SA+TL+DATA+PAD+FCS \< 64. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) PAUSE frame was received with length \< minFrameSize. Frame length checks are typically
                                                                 handled in NIX, but PAUSE frames are normally discarded before being inspected by NIX.
                                                                 Total frame DA+SA+TL+DATA+PAD+FCS \< 64. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Carrier-extend error. (SGMII/QSGMII/1000Base-X only) */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) System-length error: frame was received with length \> sys_length.
                                                                 An RX Jabber error indicates that a packet was received which is longer than the maximum
                                                                 allowed packet as defined by the system. GMI truncates the packet at the JABBER count.
                                                                 Failure to do so could lead to system instability. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) FCS/CRC error. Frame was received with FCS/CRC error. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Data-reception error. Frame was received with data-reception error. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Skipper error. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Internal data aggregation overflow. This interrupt should never assert.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Bad preamble/protocol error. Checks that the frame begins with a valid PREAMBLE sequence.
                                                                 Does not check the number of PREAMBLE cycles. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Detected reserved opcode. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) False-carrier error, or carrier-extend error after slottime is satisfied.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Collision detection. Collisions can only occur in half-duplex mode. A collision is assumed
                                                                 by the receiver when the slottime (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not
                                                                 satisfied. In 10/100 mode, this will result in a frame \< SLOTTIME. In 1000 mode, it could
                                                                 result either in frame \< SLOTTIME or a carrier extend error with the SLOTTIME. These
                                                                 conditions are visible by 1) transfer ended before slottime - COLDET or 2) carrier extend
                                                                 error - CAREXT. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Interframe gap violation. Does not necessarily indicate a failure. SGMII/QSGMII/1000Base-X only. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    struct bdk_cgxx_gmp_gmi_rxx_int_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Interframe gap violation. Does not necessarily indicate a failure. SGMII/QSGMII/1000Base-X only. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Collision detection. Collisions can only occur in half-duplex mode. A collision is assumed
                                                                 by the receiver when the slottime (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not
                                                                 satisfied. In 10/100 mode, this will result in a frame \< SLOTTIME. In 1000 mode, it could
                                                                 result either in frame \< SLOTTIME or a carrier extend error with the SLOTTIME. These
                                                                 conditions are visible by 1) transfer ended before slottime - COLDET or 2) carrier extend
                                                                 error - CAREXT. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) False-carrier error, or carrier-extend error after slottime is satisfied.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Detected reserved opcode. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Bad preamble/protocol error. Checks that the frame begins with a valid PREAMBLE sequence.
                                                                 Does not check the number of PREAMBLE cycles. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Internal data aggregation overflow. This interrupt should never assert.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Skipper error. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Data-reception error. Frame was received with data-reception error. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) FCS/CRC error. Frame was received with FCS/CRC error. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) System-length error: frame was received with length \> sys_length.
                                                                 An RX Jabber error indicates that a packet was received which is longer than the maximum
                                                                 allowed packet as defined by the system. GMI truncates the packet at the JABBER count.
                                                                 Failure to do so could lead to system instability. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Carrier-extend error. (SGMII/QSGMII/1000Base-X only) */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) PAUSE frame was received with length \< minFrameSize. Frame length checks are typically
                                                                 handled in NIX, but PAUSE frames are normally discarded before being inspected by NIX.
                                                                 Total frame DA+SA+TL+DATA+PAD+FCS \< 64. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) PAUSE frame was received with length \< minFrameSize. Frame length checks are typically
                                                                 handled in NIX, but PAUSE frames are normally discarded before being inspected by NIX.
                                                                 Total frame DA+SA+TL+DATA+PAD+FCS \< 64. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Carrier-extend error. (SGMII/QSGMII/1000Base-X only) */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) System-length error: frame was received with length \> sys_length.
                                                                 An RX Jabber error indicates that a packet was received which is longer than the maximum
                                                                 allowed packet as defined by the system. GMI truncates the packet at the JABBER count.
                                                                 Failure to do so could lead to system instability. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) FCS/CRC error. Frame was received with FCS/CRC error. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Data-reception error. Frame was received with data-reception error. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Skipper error. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Internal data aggregation overflow. This interrupt should never assert.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Bad preamble/protocol error. Checks that the frame begins with a valid PREAMBLE sequence.
                                                                 Does not check the number of PREAMBLE cycles. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Detected reserved opcode. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) False-carrier error, or carrier-extend error after slottime is satisfied.
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Collision detection. Collisions can only occur in half-duplex mode. A collision is assumed
                                                                 by the receiver when the slottime (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not
                                                                 satisfied. In 10/100 mode, this will result in a frame \< SLOTTIME. In 1000 mode, it could
                                                                 result either in frame \< SLOTTIME or a carrier extend error with the SLOTTIME. These
                                                                 conditions are visible by 1) transfer ended before slottime - COLDET or 2) carrier extend
                                                                 error - CAREXT. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Interframe gap violation. Does not necessarily indicate a failure. SGMII/QSGMII/1000Base-X only. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_cgxx_gmp_gmi_rxx_int bdk_cgxx_gmp_gmi_rxx_int_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_INT(a,b) bdk_cgxx_gmp_gmi_rxx_int_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_INT(a,b) "CGXX_GMP_GMI_RXX_INT"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_INT(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1c
 *
 * CGX GMP GMI RX Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_gmp_gmi_rxx_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_s cn9; */
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_cn96xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn96xx;
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_cn96xx cnf95xx; */
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmi_rxx_int_ena_w1c bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(a,b) bdk_cgxx_gmp_gmi_rxx_int_ena_w1c_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(a,b) "CGXX_GMP_GMI_RXX_INT_ENA_W1C"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1s
 *
 * CGX GMP GMI RX Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_gmp_gmi_rxx_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_s cn9; */
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_cn96xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn96xx;
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_cn96xx cnf95xx; */
    struct bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmi_rxx_int_ena_w1s bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(a,b) bdk_cgxx_gmp_gmi_rxx_int_ena_w1s_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(a,b) "CGXX_GMP_GMI_RXX_INT_ENA_W1S"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_int_w1s
 *
 * CGX GMP GMI RX Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_gmp_gmi_rxx_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_int_w1s_s cn9; */
    struct bdk_cgxx_gmp_gmi_rxx_int_w1s_cn96xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn96xx;
    struct bdk_cgxx_gmp_gmi_rxx_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmi_rxx_int_w1s_cn96xx cnf95xx; */
    struct bdk_cgxx_gmp_gmi_rxx_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reserved_12_15        : 4;
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[MINERR]. */
#else /* Word 0 - Little Endian */
        uint64_t minerr                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[MINERR]. */
        uint64_t carext                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[CAREXT]. */
        uint64_t jabber                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[SKPERR]. */
        uint64_t ovrerr                : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[OVRERR]. */
        uint64_t pcterr                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[RSVERR]. */
        uint64_t falerr                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[FALERR]. */
        uint64_t coldet                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[COLDET]. */
        uint64_t ifgerr                : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_RX(0..3)_INT[IFGERR]. */
        uint64_t reserved_12_15        : 4;
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmi_rxx_int_w1s bdk_cgxx_gmp_gmi_rxx_int_w1s_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_INT_W1S(a,b) bdk_cgxx_gmp_gmi_rxx_int_w1s_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_INT_W1S(a,b) "CGXX_GMP_GMI_RXX_INT_W1S"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_jabber
 *
 * CGX GMP Maximum Packet-Size Registers
 * This register specifies the maximum size for packets, beyond which the GMI truncates.
 */
union bdk_cgxx_gmp_gmi_rxx_jabber
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_jabber_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t cnt                   : 16; /**< [ 15:  0](R/W) Byte count for jabber check. Failing packets set the JABBER interrupt and are optionally
                                                                 sent with opcode = JABBER. GMI truncates the packet to [CNT] bytes.
                                                                 [CNT] must be 8-byte aligned such that CNT\<2:0\> = 000. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 16; /**< [ 15:  0](R/W) Byte count for jabber check. Failing packets set the JABBER interrupt and are optionally
                                                                 sent with opcode = JABBER. GMI truncates the packet to [CNT] bytes.
                                                                 [CNT] must be 8-byte aligned such that CNT\<2:0\> = 000. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_jabber_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_rxx_jabber bdk_cgxx_gmp_gmi_rxx_jabber_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_JABBER(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_JABBER(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_JABBER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_JABBER(a,b) bdk_cgxx_gmp_gmi_rxx_jabber_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_JABBER(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_JABBER(a,b) "CGXX_GMP_GMI_RXX_JABBER"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_JABBER(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_JABBER(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_JABBER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_rx#_udd_skp
 *
 * CGX GMP GMI User-Defined Data Skip Registers
 * This register specifies the amount of user-defined data (UDD) added before the start of the
 * L2C data.
 *
 * Internal:
 * Notes:
 * (1) The skip bytes are part of the packet and will be handled by NIX.
 *
 * (2) The system can determine if the UDD bytes are included in the FCS check
 * by using the FCSSEL field - if the FCS check is enabled.
 *
 * (3) Assume that the preamble/sfd is always at the start of the frame - even
 * before UDD bytes.  In most cases, there will be no preamble in these
 * cases since it will be packet interface in direct communication to
 * another packet interface (MAC to MAC) without a PHY involved.
 *
 * (4) We can still do address filtering and control packet filtering is the
 * user desires.
 *
 * (5) CGX()_GMP_GMI_RX()_UDD_SKP[LEN] must be 0 in half-duplex operation unless
 * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear.  If CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is
 * clear,
 * then CGX()_GMP_GMI_RX()_UDD_SKP[LEN] will normally be 8.
 *
 * (6) In all cases, the UDD bytes will be sent down the packet interface as
 * part of the packet.  The UDD bytes are never stripped from the actual
 * packet.
 */
union bdk_cgxx_gmp_gmi_rxx_udd_skp
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_rxx_udd_skp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t fcssel                : 1;  /**< [  8:  8](R/W) Include the skip bytes in the FCS calculation.
                                                                 0 = All skip bytes are included in FCS.
                                                                 1 = The skip bytes are not included in FCS.

                                                                 The skip bytes are part of the packet and are
                                                                 handled by NIX. The system can determine if the UDD bytes are included in the FCS check by
                                                                 using [FCSSEL], if the FCS check is enabled. */
        uint64_t reserved_7            : 1;
        uint64_t len                   : 7;  /**< [  6:  0](R/W) Amount of user-defined data before the start of the L2C data, in bytes.
                                                                 Setting to 0 means L2C comes first; maximum value is 64.
                                                                 LEN must be 0x0 in half-duplex operation.

                                                                 If LEN != 0, then CGX()_GMP_GMI_RX()_FRM_CHK[MINERR] will be disabled and
                                                                 CGX()_GMP_GMI_RX()_INT[MINERR] will be zero. */
#else /* Word 0 - Little Endian */
        uint64_t len                   : 7;  /**< [  6:  0](R/W) Amount of user-defined data before the start of the L2C data, in bytes.
                                                                 Setting to 0 means L2C comes first; maximum value is 64.
                                                                 LEN must be 0x0 in half-duplex operation.

                                                                 If LEN != 0, then CGX()_GMP_GMI_RX()_FRM_CHK[MINERR] will be disabled and
                                                                 CGX()_GMP_GMI_RX()_INT[MINERR] will be zero. */
        uint64_t reserved_7            : 1;
        uint64_t fcssel                : 1;  /**< [  8:  8](R/W) Include the skip bytes in the FCS calculation.
                                                                 0 = All skip bytes are included in FCS.
                                                                 1 = The skip bytes are not included in FCS.

                                                                 The skip bytes are part of the packet and are
                                                                 handled by NIX. The system can determine if the UDD bytes are included in the FCS check by
                                                                 using [FCSSEL], if the FCS check is enabled. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_rxx_udd_skp_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_rxx_udd_skp bdk_cgxx_gmp_gmi_rxx_udd_skp_t;

static inline uint64_t BDK_CGXX_GMP_GMI_RXX_UDD_SKP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_RXX_UDD_SKP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038048ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_RXX_UDD_SKP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_RXX_UDD_SKP(a,b) bdk_cgxx_gmp_gmi_rxx_udd_skp_t
#define bustype_BDK_CGXX_GMP_GMI_RXX_UDD_SKP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_RXX_UDD_SKP(a,b) "CGXX_GMP_GMI_RXX_UDD_SKP"
#define device_bar_BDK_CGXX_GMP_GMI_RXX_UDD_SKP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_RXX_UDD_SKP(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_RXX_UDD_SKP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_smac#
 *
 * CGX GMI SMAC Registers
 */
union bdk_cgxx_gmp_gmi_smacx
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_smacx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t smac                  : 48; /**< [ 47:  0](R/W) The [SMAC] field is used for generating and accepting control PAUSE packets. */
#else /* Word 0 - Little Endian */
        uint64_t smac                  : 48; /**< [ 47:  0](R/W) The [SMAC] field is used for generating and accepting control PAUSE packets. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_smacx_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_smacx bdk_cgxx_gmp_gmi_smacx_t;

static inline uint64_t BDK_CGXX_GMP_GMI_SMACX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_SMACX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038230ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_SMACX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_SMACX(a,b) bdk_cgxx_gmp_gmi_smacx_t
#define bustype_BDK_CGXX_GMP_GMI_SMACX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_SMACX(a,b) "CGXX_GMP_GMI_SMACX"
#define device_bar_BDK_CGXX_GMP_GMI_SMACX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_SMACX(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_SMACX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_append
 *
 * CGX GMI TX Append Control Registers
 */
union bdk_cgxx_gmp_gmi_txx_append
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_append_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t force_fcs             : 1;  /**< [  3:  3](R/W) Append the Ethernet FCS on each PAUSE packet. */
        uint64_t fcs                   : 1;  /**< [  2:  2](R/W) Append the Ethernet FCS on each packet. */
        uint64_t pad                   : 1;  /**< [  1:  1](R/W) Append PAD bytes such that minimum-sized packet is transmitted. */
        uint64_t preamble              : 1;  /**< [  0:  0](R/W) Prepend the Ethernet preamble on each transfer. */
#else /* Word 0 - Little Endian */
        uint64_t preamble              : 1;  /**< [  0:  0](R/W) Prepend the Ethernet preamble on each transfer. */
        uint64_t pad                   : 1;  /**< [  1:  1](R/W) Append PAD bytes such that minimum-sized packet is transmitted. */
        uint64_t fcs                   : 1;  /**< [  2:  2](R/W) Append the Ethernet FCS on each packet. */
        uint64_t force_fcs             : 1;  /**< [  3:  3](R/W) Append the Ethernet FCS on each PAUSE packet. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_append_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_append bdk_cgxx_gmp_gmi_txx_append_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_APPEND(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_APPEND(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038218ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_APPEND", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_APPEND(a,b) bdk_cgxx_gmp_gmi_txx_append_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_APPEND(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_APPEND(a,b) "CGXX_GMP_GMI_TXX_APPEND"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_APPEND(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_APPEND(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_APPEND(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_burst
 *
 * CGX GMI TX Burst-Counter Registers
 */
union bdk_cgxx_gmp_gmi_txx_burst
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_burst_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t burst                 : 16; /**< [ 15:  0](R/W) Burst (refer to 802.3 to set correctly). Only valid for 1000 Mb/s half-duplex operation as
                                                                 follows:
                                                                 half duplex/1000 Mb/s: 0x2000
                                                                 all other modes: 0x0
                                                                 SGMII/QSGMII/1000Base-X only. */
#else /* Word 0 - Little Endian */
        uint64_t burst                 : 16; /**< [ 15:  0](R/W) Burst (refer to 802.3 to set correctly). Only valid for 1000 Mb/s half-duplex operation as
                                                                 follows:
                                                                 half duplex/1000 Mb/s: 0x2000
                                                                 all other modes: 0x0
                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_burst_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_burst bdk_cgxx_gmp_gmi_txx_burst_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_BURST(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_BURST(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038228ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038228ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038228ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038228ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_BURST", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_BURST(a,b) bdk_cgxx_gmp_gmi_txx_burst_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_BURST(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_BURST(a,b) "CGXX_GMP_GMI_TXX_BURST"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_BURST(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_BURST(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_BURST(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_ctl
 *
 * CGX GMI Transmit Control Registers
 */
union bdk_cgxx_gmp_gmi_txx_ctl
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t link_drain            : 1;  /**< [  3:  3](R/W) Enable dropping of full packets to allow CGX and NIX to drain their FIFOs. */
        uint64_t tx_fc_type            : 1;  /**< [  2:  2](R/W) Transmit side flow control type select.
                                                                 0 = GMI MAC transmits ITU G.999.1 pause frames.
                                                                 1 = GMI MAC transmits 802.3 pause frames. */
        uint64_t xsdef_en              : 1;  /**< [  1:  1](R/W) Enables the excessive-deferral check for statistics and interrupts. SGMII/1000Base-X half-
                                                                 duplex only. */
        uint64_t xscol_en              : 1;  /**< [  0:  0](R/W) Enables the excessive-collision check for statistics and interrupts. SGMII/1000Base-X
                                                                 half-duplex only. */
#else /* Word 0 - Little Endian */
        uint64_t xscol_en              : 1;  /**< [  0:  0](R/W) Enables the excessive-collision check for statistics and interrupts. SGMII/1000Base-X
                                                                 half-duplex only. */
        uint64_t xsdef_en              : 1;  /**< [  1:  1](R/W) Enables the excessive-deferral check for statistics and interrupts. SGMII/1000Base-X half-
                                                                 duplex only. */
        uint64_t tx_fc_type            : 1;  /**< [  2:  2](R/W) Transmit side flow control type select.
                                                                 0 = GMI MAC transmits ITU G.999.1 pause frames.
                                                                 1 = GMI MAC transmits 802.3 pause frames. */
        uint64_t link_drain            : 1;  /**< [  3:  3](R/W) Enable dropping of full packets to allow CGX and NIX to drain their FIFOs. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_ctl_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_ctl bdk_cgxx_gmp_gmi_txx_ctl_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038270ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038270ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038270ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038270ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_CTL(a,b) bdk_cgxx_gmp_gmi_txx_ctl_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_CTL(a,b) "CGXX_GMP_GMI_TXX_CTL"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_CTL(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_int
 *
 * CGX GMI TX Interrupt Registers
 */
union bdk_cgxx_gmp_gmi_txx_int
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) A packet with a PTP request was not able to be sent due to XSCOL. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) TX late collision. (SGMII/1000BASE-X half-duplex only) */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) TX excessive deferral. (SGMII/1000BASE-X half-duplex only) */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) TX excessive collisions. (SGMII/1000BASE-X half-duplex only) */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) TX underflow. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) TX underflow. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) TX excessive collisions. (SGMII/1000BASE-X half-duplex only) */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) TX excessive deferral. (SGMII/1000BASE-X half-duplex only) */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) TX late collision. (SGMII/1000BASE-X half-duplex only) */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) A packet with a PTP request was not able to be sent due to XSCOL. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    struct bdk_cgxx_gmp_gmi_txx_int_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) A packet with a PTP request was not able to be sent due to XSCOL. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) TX late collision. (SGMII/1000BASE-X half-duplex only) */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) TX excessive deferral. (SGMII/1000BASE-X half-duplex only) */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) TX excessive collisions. (SGMII/1000BASE-X half-duplex only) */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) TX underflow. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) TX underflow. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) TX excessive collisions. (SGMII/1000BASE-X half-duplex only) */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) TX excessive deferral. (SGMII/1000BASE-X half-duplex only) */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) TX late collision. (SGMII/1000BASE-X half-duplex only) */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) A packet with a PTP request was not able to be sent due to XSCOL. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_cgxx_gmp_gmi_txx_int bdk_cgxx_gmp_gmi_txx_int_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038500ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038500ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038500ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038500ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_INT(a,b) bdk_cgxx_gmp_gmi_txx_int_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_INT(a,b) "CGXX_GMP_GMI_TXX_INT"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_INT(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1c
 *
 * CGX GMI TX Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_gmp_gmi_txx_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_int_ena_w1c_s cn9; */
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1c_cn96xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn96xx;
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmi_txx_int_ena_w1c_cn96xx cnf95xx; */
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmi_txx_int_ena_w1c bdk_cgxx_gmp_gmi_txx_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(a,b) bdk_cgxx_gmp_gmi_txx_int_ena_w1c_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(a,b) "CGXX_GMP_GMI_TXX_INT_ENA_W1C"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1s
 *
 * CGX GMI TX Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_gmp_gmi_txx_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_int_ena_w1s_s cn9; */
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1s_cn96xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn96xx;
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmi_txx_int_ena_w1s_cn96xx cnf95xx; */
    struct bdk_cgxx_gmp_gmi_txx_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmi_txx_int_ena_w1s bdk_cgxx_gmp_gmi_txx_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(a,b) bdk_cgxx_gmp_gmi_txx_int_ena_w1s_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(a,b) "CGXX_GMP_GMI_TXX_INT_ENA_W1S"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_int_w1s
 *
 * CGX GMI TX Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_gmp_gmi_txx_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_int_w1s_s cn9; */
    struct bdk_cgxx_gmp_gmi_txx_int_w1s_cn96xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn96xx;
    struct bdk_cgxx_gmp_gmi_txx_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_gmi_txx_int_w1s_cn96xx cnf95xx; */
    struct bdk_cgxx_gmp_gmi_txx_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_8            : 1;
        uint64_t reserved_5_7          : 3;
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[UNDFLW]. */
        uint64_t xscol                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSCOL]. */
        uint64_t xsdef                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[XSDEF]. */
        uint64_t late_col              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[LATE_COL]. */
        uint64_t ptp_lost              : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_GMP_GMI_TX(0..3)_INT[PTP_LOST]. */
        uint64_t reserved_5_7          : 3;
        uint64_t reserved_8            : 1;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_gmi_txx_int_w1s bdk_cgxx_gmp_gmi_txx_int_w1s_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038508ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038508ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038508ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038508ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_INT_W1S(a,b) bdk_cgxx_gmp_gmi_txx_int_w1s_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_INT_W1S(a,b) "CGXX_GMP_GMI_TXX_INT_W1S"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_min_pkt
 *
 * CGX GMI TX Minimum-Size-Packet Registers
 */
union bdk_cgxx_gmp_gmi_txx_min_pkt
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_min_pkt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t min_size              : 8;  /**< [  7:  0](R/W) Minimum frame size in bytes before the FCS is applied.
                                                                 Padding is only appended when CGX()_GMP_GMI_TX()_APPEND[PAD] for the corresponding
                                                                 LMAC is set.

                                                                 When LMAC_TYPE=SGMII/QSGMII, packets are padded to [MIN_SIZE]+1. The reset value pads to
                                                                 60
                                                                 bytes. */
#else /* Word 0 - Little Endian */
        uint64_t min_size              : 8;  /**< [  7:  0](R/W) Minimum frame size in bytes before the FCS is applied.
                                                                 Padding is only appended when CGX()_GMP_GMI_TX()_APPEND[PAD] for the corresponding
                                                                 LMAC is set.

                                                                 When LMAC_TYPE=SGMII/QSGMII, packets are padded to [MIN_SIZE]+1. The reset value pads to
                                                                 60
                                                                 bytes. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_min_pkt_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_min_pkt bdk_cgxx_gmp_gmi_txx_min_pkt_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_MIN_PKT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_MIN_PKT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038240ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038240ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038240ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038240ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_MIN_PKT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_MIN_PKT(a,b) bdk_cgxx_gmp_gmi_txx_min_pkt_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_MIN_PKT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_MIN_PKT(a,b) "CGXX_GMP_GMI_TXX_MIN_PKT"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_MIN_PKT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_MIN_PKT(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_MIN_PKT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_pause_pkt_interval
 *
 * CGX GMI TX PAUSE-Packet Transmission-Interval Registers
 * This register specifies how often PAUSE packets are sent.
 * Internal:
 * Notes:
 * Choosing proper values of CGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME] and
 * CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system
 * designer.  It is suggested that TIME be much greater than INTERVAL and
 * CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE
 * count and then when the backpressure condition is lifted, a PAUSE packet
 * with TIME==0 will be sent indicating that Octane is ready for additional
 * data.
 *
 * If the system chooses to not set CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND], then it is
 * suggested that TIME and INTERVAL are programmed such that they satisify the
 * following rule:
 *
 * _ INTERVAL \<= TIME - (largest_pkt_size + IFG + pause_pkt_size)
 *
 * where largest_pkt_size is that largest packet that the system can send
 * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size
 * of the PAUSE packet (normally 64B).
 */
union bdk_cgxx_gmp_gmi_txx_pause_pkt_interval
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_pause_pkt_interval_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t interval              : 16; /**< [ 15:  0](R/W) Arbitrate for a 802.3 PAUSE packet every ([INTERVAL] * 512)
                                                                 bit-times. Normally, 0 \< [INTERVAL] \< CGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME].

                                                                 [INTERVAL] = 0 only sends a single PAUSE packet for each backpressure event.
                                                                 CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] must be 1 when [INTERVAL] = 0.
                                                                 [INTERVAL] should be 0x0 if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
#else /* Word 0 - Little Endian */
        uint64_t interval              : 16; /**< [ 15:  0](R/W) Arbitrate for a 802.3 PAUSE packet every ([INTERVAL] * 512)
                                                                 bit-times. Normally, 0 \< [INTERVAL] \< CGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME].

                                                                 [INTERVAL] = 0 only sends a single PAUSE packet for each backpressure event.
                                                                 CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] must be 1 when [INTERVAL] = 0.
                                                                 [INTERVAL] should be 0x0 if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_pause_pkt_interval_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_pause_pkt_interval bdk_cgxx_gmp_gmi_txx_pause_pkt_interval_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038248ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038248ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038248ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038248ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(a,b) bdk_cgxx_gmp_gmi_txx_pause_pkt_interval_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(a,b) "CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_pause_pkt_time
 *
 * CGX GMI TX PAUSE Packet PAUSE-Time Registers
 */
union bdk_cgxx_gmp_gmi_txx_pause_pkt_time
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_pause_pkt_time_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ptime                 : 16; /**< [ 15:  0](R/W) Provides the pause_time field placed in outbound 802.3 PAUSE packets
                                                                 in 512 bit-times. Normally, [PTIME] \>
                                                                 CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL]. For programming information see
                                                                 CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL.
                                                                 [PTIME] should be 0x0 if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
#else /* Word 0 - Little Endian */
        uint64_t ptime                 : 16; /**< [ 15:  0](R/W) Provides the pause_time field placed in outbound 802.3 PAUSE packets
                                                                 in 512 bit-times. Normally, [PTIME] \>
                                                                 CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL]. For programming information see
                                                                 CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL.
                                                                 [PTIME] should be 0x0 if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_pause_pkt_time_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_pause_pkt_time bdk_cgxx_gmp_gmi_txx_pause_pkt_time_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038238ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038238ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038238ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038238ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(a,b) bdk_cgxx_gmp_gmi_txx_pause_pkt_time_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(a,b) "CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_pause_togo
 *
 * CGX GMI TX Time-to-Backpressure Registers
 */
union bdk_cgxx_gmp_gmi_txx_pause_togo
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_pause_togo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ptime                 : 16; /**< [ 15:  0](RO/H) Amount of time remaining to backpressure, from the standard 802.3 PAUSE timer. */
#else /* Word 0 - Little Endian */
        uint64_t ptime                 : 16; /**< [ 15:  0](RO/H) Amount of time remaining to backpressure, from the standard 802.3 PAUSE timer. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_pause_togo_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_pause_togo bdk_cgxx_gmp_gmi_txx_pause_togo_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038258ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038258ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038258ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038258ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_PAUSE_TOGO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(a,b) bdk_cgxx_gmp_gmi_txx_pause_togo_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(a,b) "CGXX_GMP_GMI_TXX_PAUSE_TOGO"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_PAUSE_TOGO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_pause_zero
 *
 * CGX GMI TX PAUSE-Zero-Enable Registers
 */
union bdk_cgxx_gmp_gmi_txx_pause_zero
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_pause_zero_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t send                  : 1;  /**< [  0:  0](R/W) Send PAUSE-zero enable. When this bit is set, and the backpressure condition is clear, it
                                                                 allows sending a PAUSE packet with pause_time of 0 to enable the channel.
                                                                 [SEND] should be set if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
#else /* Word 0 - Little Endian */
        uint64_t send                  : 1;  /**< [  0:  0](R/W) Send PAUSE-zero enable. When this bit is set, and the backpressure condition is clear, it
                                                                 allows sending a PAUSE packet with pause_time of 0 to enable the channel.
                                                                 [SEND] should be set if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_pause_zero_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_pause_zero bdk_cgxx_gmp_gmi_txx_pause_zero_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038260ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038260ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038260ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038260ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_PAUSE_ZERO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(a,b) bdk_cgxx_gmp_gmi_txx_pause_zero_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(a,b) "CGXX_GMP_GMI_TXX_PAUSE_ZERO"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_PAUSE_ZERO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_sgmii_ctl
 *
 * CGX SGMII Control Registers
 */
union bdk_cgxx_gmp_gmi_txx_sgmii_ctl
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_sgmii_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t align                 : 1;  /**< [  0:  0](R/W) Align the transmission to even cycles: (SGMII/1000BASE-X half-duplex only)
                                                                 Recommended value is: [ALIGN] = !CGX()_GMP_GMI_TX()_APPEND[PREAMBLE].
                                                                 (See Transmit Conversion to Code groups, Transmit Conversion to Code Groups for a complete
                                                                 discussion.)

                                                                 _ 0 = Data can be sent on any cycle. In this mode, the interface functions at maximum
                                                                 bandwidth. It is possible for the TX PCS machine to drop the first byte of the TX frame.
                                                                 When CGX()_GMP_GMI_TX()_APPEND[PREAMBLE] is set, the first byte is a preamble
                                                                 byte, which can be dropped to compensate for an extended IPG.

                                                                 _ 1 = Data is only sent on even cycles. In this mode, there can be bandwidth implications
                                                                 when sending odd-byte packets as the IPG can extend an extra cycle. There will be no loss
                                                                 of data. */
#else /* Word 0 - Little Endian */
        uint64_t align                 : 1;  /**< [  0:  0](R/W) Align the transmission to even cycles: (SGMII/1000BASE-X half-duplex only)
                                                                 Recommended value is: [ALIGN] = !CGX()_GMP_GMI_TX()_APPEND[PREAMBLE].
                                                                 (See Transmit Conversion to Code groups, Transmit Conversion to Code Groups for a complete
                                                                 discussion.)

                                                                 _ 0 = Data can be sent on any cycle. In this mode, the interface functions at maximum
                                                                 bandwidth. It is possible for the TX PCS machine to drop the first byte of the TX frame.
                                                                 When CGX()_GMP_GMI_TX()_APPEND[PREAMBLE] is set, the first byte is a preamble
                                                                 byte, which can be dropped to compensate for an extended IPG.

                                                                 _ 1 = Data is only sent on even cycles. In this mode, there can be bandwidth implications
                                                                 when sending odd-byte packets as the IPG can extend an extra cycle. There will be no loss
                                                                 of data. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_sgmii_ctl_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_sgmii_ctl bdk_cgxx_gmp_gmi_txx_sgmii_ctl_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038300ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038300ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038300ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038300ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_SGMII_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(a,b) bdk_cgxx_gmp_gmi_txx_sgmii_ctl_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(a,b) "CGXX_GMP_GMI_TXX_SGMII_CTL"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_SGMII_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_slot
 *
 * CGX GMI TX Slottime Counter Registers
 */
union bdk_cgxx_gmp_gmi_txx_slot
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_slot_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t slot                  : 10; /**< [  9:  0](R/W) Slottime (refer to IEEE 802.3 to set correctly):
                                                                 10/100 Mb/s: Set [SLOT] to 0x40.
                                                                 1000 Mb/s: Set [SLOT] to 0x200.

                                                                 SGMII/QSGMII/1000Base-X only. */
#else /* Word 0 - Little Endian */
        uint64_t slot                  : 10; /**< [  9:  0](R/W) Slottime (refer to IEEE 802.3 to set correctly):
                                                                 10/100 Mb/s: Set [SLOT] to 0x40.
                                                                 1000 Mb/s: Set [SLOT] to 0x200.

                                                                 SGMII/QSGMII/1000Base-X only. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_slot_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_slot bdk_cgxx_gmp_gmi_txx_slot_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_SLOT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_SLOT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038220ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_SLOT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_SLOT(a,b) bdk_cgxx_gmp_gmi_txx_slot_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_SLOT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_SLOT(a,b) "CGXX_GMP_GMI_TXX_SLOT"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_SLOT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_SLOT(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_SLOT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_soft_pause
 *
 * CGX GMI TX Software PAUSE Registers
 */
union bdk_cgxx_gmp_gmi_txx_soft_pause
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_soft_pause_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ptime                 : 16; /**< [ 15:  0](R/W) Back off the TX bus for ([PTIME] * 512) bit-times.
                                                                 [PTIME] should be 0x0 if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
#else /* Word 0 - Little Endian */
        uint64_t ptime                 : 16; /**< [ 15:  0](R/W) Back off the TX bus for ([PTIME] * 512) bit-times.
                                                                 [PTIME] should be 0x0 if CGX()_GMP_GMI_TX()_CTL[TX_FC_TYPE] is clear (G.999.1). */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_soft_pause_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_soft_pause bdk_cgxx_gmp_gmi_txx_soft_pause_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038250ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038250ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038250ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038250ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_SOFT_PAUSE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(a,b) bdk_cgxx_gmp_gmi_txx_soft_pause_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(a,b) "CGXX_GMP_GMI_TXX_SOFT_PAUSE"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_SOFT_PAUSE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx#_thresh
 *
 * CGX GMI TX Threshold Registers
 */
union bdk_cgxx_gmp_gmi_txx_thresh
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_txx_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t cnt                   : 11; /**< [ 10:  0](R/W) Number of 128-bit words to accumulate in the TX FIFO before sending on the packet
                                                                 interface. This field should be large enough to prevent underflow on the packet interface
                                                                 and must never be set to 0x0. The recommended setting for

                                                                 In all modes, this register cannot exceed the TX FIFO depth configured by
                                                                 CGX()_CMR_TX_LMACS[LMACS]. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 11; /**< [ 10:  0](R/W) Number of 128-bit words to accumulate in the TX FIFO before sending on the packet
                                                                 interface. This field should be large enough to prevent underflow on the packet interface
                                                                 and must never be set to 0x0. The recommended setting for

                                                                 In all modes, this register cannot exceed the TX FIFO depth configured by
                                                                 CGX()_CMR_TX_LMACS[LMACS]. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_txx_thresh_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_txx_thresh bdk_cgxx_gmp_gmi_txx_thresh_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TXX_THRESH(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TXX_THRESH(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038210ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0038210ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0038210ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0038210ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TXX_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TXX_THRESH(a,b) bdk_cgxx_gmp_gmi_txx_thresh_t
#define bustype_BDK_CGXX_GMP_GMI_TXX_THRESH(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TXX_THRESH(a,b) "CGXX_GMP_GMI_TXX_THRESH"
#define device_bar_BDK_CGXX_GMP_GMI_TXX_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TXX_THRESH(a,b) (a)
#define arguments_BDK_CGXX_GMP_GMI_TXX_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx_col_attempt
 *
 * CGX TX Collision Attempts Before Dropping Frame Registers
 */
union bdk_cgxx_gmp_gmi_tx_col_attempt
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_tx_col_attempt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t limit                 : 5;  /**< [  4:  0](R/W) Number of collision attempts allowed. (SGMII/1000BASE-X half-duplex only.) */
#else /* Word 0 - Little Endian */
        uint64_t limit                 : 5;  /**< [  4:  0](R/W) Number of collision attempts allowed. (SGMII/1000BASE-X half-duplex only.) */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_tx_col_attempt_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_tx_col_attempt bdk_cgxx_gmp_gmi_tx_col_attempt_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0039010ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0039010ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0039010ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0039010ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TX_COL_ATTEMPT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(a) bdk_cgxx_gmp_gmi_tx_col_attempt_t
#define bustype_BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(a) "CGXX_GMP_GMI_TX_COL_ATTEMPT"
#define device_bar_BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(a) (a)
#define arguments_BDK_CGXX_GMP_GMI_TX_COL_ATTEMPT(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx_ifg
 *
 * CGX GMI TX Interframe-Gap Cycles Registers
 * Consider the following when programming IFG1 and IFG2:
 * * For 10/100/1000 Mb/s half-duplex systems that require IEEE 802.3 compatibility, IFG1 must be
 * in the range of 1-8, [IFG2] must be in the range of 4-12, and the [IFG1] + [IFG2] sum must be 12.
 * * For 10/100/1000 Mb/s full-duplex systems that require IEEE 802.3 compatibility, IFG1 must be
 * in the range of 1-11, [IFG2] must be in the range of 1-11, and the [IFG1] + [IFG2] sum must be 12.
 * For all other systems, IFG1 and IFG2 can be any value in the range of 1-15, allowing for a
 * total possible IFG sum of 2-30.
 */
union bdk_cgxx_gmp_gmi_tx_ifg
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_tx_ifg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t ifg2                  : 4;  /**< [  7:  4](R/W) Remainder of interFrameGap timing, equal to interFrameGap - IFG1 (in IFG2 * 8 bits). If
                                                                 CRS is detected during IFG2, the interFrameSpacing timer is not reset and a frame is
                                                                 transmitted once the timer expires. */
        uint64_t ifg1                  : 4;  /**< [  3:  0](R/W) First portion of interFrameGap timing, in the range of 0 to 2/3 (in IFG2 * 8 bits). If CRS
                                                                 is detected during IFG1, the interFrameSpacing timer is reset and a frame is not
                                                                 transmitted. */
#else /* Word 0 - Little Endian */
        uint64_t ifg1                  : 4;  /**< [  3:  0](R/W) First portion of interFrameGap timing, in the range of 0 to 2/3 (in IFG2 * 8 bits). If CRS
                                                                 is detected during IFG1, the interFrameSpacing timer is reset and a frame is not
                                                                 transmitted. */
        uint64_t ifg2                  : 4;  /**< [  7:  4](R/W) Remainder of interFrameGap timing, equal to interFrameGap - IFG1 (in IFG2 * 8 bits). If
                                                                 CRS is detected during IFG2, the interFrameSpacing timer is not reset and a frame is
                                                                 transmitted once the timer expires. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_tx_ifg_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_tx_ifg bdk_cgxx_gmp_gmi_tx_ifg_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TX_IFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TX_IFG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0039000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0039000ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0039000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0039000ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TX_IFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TX_IFG(a) bdk_cgxx_gmp_gmi_tx_ifg_t
#define bustype_BDK_CGXX_GMP_GMI_TX_IFG(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TX_IFG(a) "CGXX_GMP_GMI_TX_IFG"
#define device_bar_BDK_CGXX_GMP_GMI_TX_IFG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TX_IFG(a) (a)
#define arguments_BDK_CGXX_GMP_GMI_TX_IFG(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx_jam
 *
 * CGX GMI TX JAM Pattern Registers
 * This register provides the pattern used in JAM bytes.
 */
union bdk_cgxx_gmp_gmi_tx_jam
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_tx_jam_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t jam                   : 8;  /**< [  7:  0](R/W) JAM pattern. (SGMII/1000BASE-X half-duplex only.) */
#else /* Word 0 - Little Endian */
        uint64_t jam                   : 8;  /**< [  7:  0](R/W) JAM pattern. (SGMII/1000BASE-X half-duplex only.) */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_tx_jam_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_tx_jam bdk_cgxx_gmp_gmi_tx_jam_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TX_JAM(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TX_JAM(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0039008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0039008ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0039008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0039008ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TX_JAM", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TX_JAM(a) bdk_cgxx_gmp_gmi_tx_jam_t
#define bustype_BDK_CGXX_GMP_GMI_TX_JAM(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TX_JAM(a) "CGXX_GMP_GMI_TX_JAM"
#define device_bar_BDK_CGXX_GMP_GMI_TX_JAM(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TX_JAM(a) (a)
#define arguments_BDK_CGXX_GMP_GMI_TX_JAM(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx_lfsr
 *
 * CGX GMI TX LFSR Registers
 * This register shows the contents of the linear feedback shift register (LFSR), which is used
 * to implement truncated binary exponential backoff.
 */
union bdk_cgxx_gmp_gmi_tx_lfsr
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_tx_lfsr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lfsr                  : 16; /**< [ 15:  0](R/W/H) Contains the current state of the LFSR, which is used to feed random numbers to compute
                                                                 truncated binary exponential backoff. (SGMII/1000Base-X half-duplex only.) */
#else /* Word 0 - Little Endian */
        uint64_t lfsr                  : 16; /**< [ 15:  0](R/W/H) Contains the current state of the LFSR, which is used to feed random numbers to compute
                                                                 truncated binary exponential backoff. (SGMII/1000Base-X half-duplex only.) */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_tx_lfsr_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_tx_lfsr bdk_cgxx_gmp_gmi_tx_lfsr_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TX_LFSR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TX_LFSR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0039028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0039028ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0039028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0039028ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TX_LFSR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TX_LFSR(a) bdk_cgxx_gmp_gmi_tx_lfsr_t
#define bustype_BDK_CGXX_GMP_GMI_TX_LFSR(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TX_LFSR(a) "CGXX_GMP_GMI_TX_LFSR"
#define device_bar_BDK_CGXX_GMP_GMI_TX_LFSR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TX_LFSR(a) (a)
#define arguments_BDK_CGXX_GMP_GMI_TX_LFSR(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx_pause_pkt_dmac
 *
 * CGX TX PAUSE-Packet DMAC-Field Registers
 */
union bdk_cgxx_gmp_gmi_tx_pause_pkt_dmac
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_tx_pause_pkt_dmac_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The DMAC field, which is placed in outbound PAUSE packets. */
#else /* Word 0 - Little Endian */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The DMAC field, which is placed in outbound PAUSE packets. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_tx_pause_pkt_dmac_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_tx_pause_pkt_dmac bdk_cgxx_gmp_gmi_tx_pause_pkt_dmac_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0039018ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0039018ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0039018ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0039018ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(a) bdk_cgxx_gmp_gmi_tx_pause_pkt_dmac_t
#define bustype_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(a) "CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC"
#define device_bar_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(a) (a)
#define arguments_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_gmp_gmi_tx_pause_pkt_type
 *
 * CGX GMI TX PAUSE-Packet-PTYPE Field Registers
 * This register provides the PTYPE field that is placed in outbound PAUSE packets.
 */
union bdk_cgxx_gmp_gmi_tx_pause_pkt_type
{
    uint64_t u;
    struct bdk_cgxx_gmp_gmi_tx_pause_pkt_type_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ptype                 : 16; /**< [ 15:  0](R/W) The PTYPE field placed in outbound PAUSE packets. */
#else /* Word 0 - Little Endian */
        uint64_t ptype                 : 16; /**< [ 15:  0](R/W) The PTYPE field placed in outbound PAUSE packets. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_gmi_tx_pause_pkt_type_s cn; */
};
typedef union bdk_cgxx_gmp_gmi_tx_pause_pkt_type bdk_cgxx_gmp_gmi_tx_pause_pkt_type_t;

static inline uint64_t BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0039020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0039020ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0039020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0039020ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(a) bdk_cgxx_gmp_gmi_tx_pause_pkt_type_t
#define bustype_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(a) "CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE"
#define device_bar_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(a) (a)
#define arguments_BDK_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_gmp_misc#_cfg
 *
 * CGX GMP PCS Miscellaneous Control Registers
 * This register contains general configuration that should not need to be changed from reset
 * settings.
 *
 * Internal:
 * Per lmac diagnostic and chicken bits.
 */
union bdk_cgxx_gmp_miscx_cfg
{
    uint64_t u;
    struct bdk_cgxx_gmp_miscx_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_19_63        : 45;
        uint64_t rx_cgp_edet_qlm_val   : 1;  /**< [ 18: 18](R/W) Reserved.
                                                                 Internal:
                                                                 Ignore QLM valid when edet=0.

                                                                 0 = Valid from QLM will push data to FIFO for processing.
                                                                 1 = Edet=0 will turn off pushing to FIFO. */
        uint64_t rx_cgp_edet_filter    : 1;  /**< [ 17: 17](R/W) Reserved.
                                                                 Internal:
                                                                 Delay edet to PCS based on in-flight codegroups.

                                                                 0 = Flush. Forward edet as quickly as possible.  Bytes in CGP are flushed while edet=0.
                                                                 1 = Filter. Wait for CGP to finish processing codegroups before edet=0 before
                                                                 dropping edet to PCS.

                                                                 CGP has a FIFO + 3 stages of FLOPS after the input register. These registers can
                                                                 contain codegroups sent before edet drops. */
        uint64_t rx_cgp_gser_throttle  : 1;  /**< [ 16: 16](R/W) Emulate BGX operation by sending PCS two consecutive codegroups at a time.
                                                                 Internal:
                                                                 "Bit is ignored in QSGMII mode.
                                                                   0 = CGX mode.  Serialize GSER transfers into bytes as fast as possible.
                                                                   1 = Throttle to act more like earlier chips' BGX. Idle bus to PCS for two
                                                                 cycles after sending every pair of bytes.

                                                                 Normally CGP takes a 4 codegroup transfer and serializes the data into 4 consecutive
                                                                 single codegroup transfers to PCS.  With minimum IPG of 2B, GMI EOP pipelining can cause
                                                                 back to back packets to collide and merge.  This is probably not a realistic scenario, but
                                                                 BGX did handle this correctly because of GSER width of only 2 codegroups. Setting this bit
                                                                 will allow CGX to split up a GSER transfer as follows:
                                                                   send byte0 ##1 send byte1 ##3 send byte2 ##1 send byte3 ##3 Potentially start sending
                                                                 byte0 of next GSER transfer." */
        uint64_t reserved_14_15        : 2;
        uint64_t rx_pcs_alt_qlb2i      : 1;  /**< [ 13: 13](R/W) For QSGMII mode, enable use of alternate state machine to control idle insertion
                                                                 for RX clk \< TX clk. Not used unless LMAC is doing QSGMII LOOPBCK2 (RX
                                                                 loopback).

                                                                 Internal:
                                                                 QSGMII single byte/xfer/lmac can prevent BGX from inserting idles.
                                                                    0 = Use traditional idle insertion.
                                                                    1 = Use state machine to insert idles. */
        uint64_t rx_pcs_802_rx_k       : 1;  /**< [ 12: 12](R/W) Reserved.
                                                                 Internal:
                                                                 Enable RX_K Control to exit RX_K per 802.3
                                                                 BGX stayed in RX_K if xmit==DATA and a control character.
                                                                 0 = BGX mode.  xmit == DATA and control will hold in RX_K.
                                                                 1 = 802.3 mode. xmit == DATA and control will transition to IDLE_D. */
        uint64_t rx_pcs_lpi_enable     : 1;  /**< [ 11: 11](R/W) Reserved.
                                                                 Internal:
                                                                 Enable LPI decoding in RX PCS.
                                                                 "0 = Disable LPI processing.  /L/ acts like /I/
                                                                 1 = Enable LPI Processing. Default." */
        uint64_t rx_pcs_eee_mode_enable : 1; /**< [ 10: 10](R/W) Reserved.
                                                                 Internal:
                                                                 Enable RX to send QUIET.  For debug. 0 = force MODE=DATA at all times. */
        uint64_t rx_pcs_sync_timeout   : 1;  /**< [  9:  9](R/W) Reserved.
                                                                 Internal:
                                                                 BGX Synchronization mode

                                                                 See 802.3-2012, Figure 36-9 Synchronization State Diagram.
                                                                    0 = CGX mode. Ignore bit lock.
                                                                    1 = BGX mode. Use bit_lock in place of signal_detect in RX synchronization.
                                                                  bit_lock is a timeout on GSER transfers.  If no transfers occur for 64 cycles, bit_lock
                                                                  is lost.

                                                                  Either [RX_PCS_SYNC_TIMEOUT] or_PCS_SYNC_SIGNAL_DETECT] must be set. */
        uint64_t rx_pcs_sync_signal_detect : 1;/**< [  8:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Allow signal_detect to control PCS RX synchronization.
                                                                 See 802.3-2012, Figure 36-9 Synchronization State Diagram.
                                                                   0 = BGX mode. Ignore signal_detect.
                                                                   1 = Use signal_detect (edet) from GSER.

                                                                  Either [RX_PCS_SYNC_TIMEOUT] or_PCS_SYNC_SIGNAL_DETECT] must be set. */
        uint64_t reserved_5_7          : 3;
        uint64_t pcs_alt_an            : 1;  /**< [  4:  4](R/W) Flip auto-negotiate mode.
                                                                 Internal:
                                                                 Allows GMP AN to behave like BGX did on t8x, o7x. Setting this bit
                                                                 inverts csr__an_sgi_mode from the normal behavior of ! pcs_misc_ctl_reg_data[i].mode. */
        uint64_t tx_eee_rx_sync_status_enable : 1;/**< [  3:  3](RAZ) Reserved.
                                                                 Internal:
                                                                 Enables RX sync status to enable TX EEE operation
                                                                    0 = TX side ignores sync_status for RX.  TX EEE is enabled even when sync_status=0.
                                                                    1 = TX side requires RX sync_status=1 + delay after  CGX()_GMP_GMI()_TX_EEE_CFG1[SYNC2LPI_TIME]. */
        uint64_t tx_qsgmii_port0_init  : 1;  /**< [  2:  2](R/W) Reserved.
                                                                 Internal:
                                                                 Forces QSGMII startup sequence to wait for port0 data before starting to send
                                                                 data; LMAC1..3 are unused. This bit slows down the GMP's first data sent to
                                                                 GSER. For diagnostic use only. */
        uint64_t tx_eee_wait_gmi_fast_idle : 1;/**< [  1:  1](R/W) Reserved.
                                                                 Internal:
                                                                 Normally the CGX GMI BCK FIFO is loaded with ASSERT_LPI when in low power mode.
                                                                 This bit enables swapping ASSERT_LPI with normal idles so that PCS starts processing
                                                                 idles for GMI-\>PCS data transfers following TX_LPI-\>TX_LPI_WAIT transition.
                                                                 For diagnostic use only. */
        uint64_t tx_eee_quiet_credit_mode : 1;/**< [  0:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Enable PCS state machines to transition out of LPI states without sending data
                                                                 to GSER. Sending of data and state machines normally advance when a credit is
                                                                 returned from the GSER. For diagnostic use only.
                                                                 0 = PCS LPI state machines can transition to TX_ACTIVE
                                                                 with no TX_OSET.indicate, meaning GSER might not send credits.
                                                                 1 = Stricter interpretation where all transitions are governed by GSER returning
                                                                 credits. */
#else /* Word 0 - Little Endian */
        uint64_t tx_eee_quiet_credit_mode : 1;/**< [  0:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Enable PCS state machines to transition out of LPI states without sending data
                                                                 to GSER. Sending of data and state machines normally advance when a credit is
                                                                 returned from the GSER. For diagnostic use only.
                                                                 0 = PCS LPI state machines can transition to TX_ACTIVE
                                                                 with no TX_OSET.indicate, meaning GSER might not send credits.
                                                                 1 = Stricter interpretation where all transitions are governed by GSER returning
                                                                 credits. */
        uint64_t tx_eee_wait_gmi_fast_idle : 1;/**< [  1:  1](R/W) Reserved.
                                                                 Internal:
                                                                 Normally the CGX GMI BCK FIFO is loaded with ASSERT_LPI when in low power mode.
                                                                 This bit enables swapping ASSERT_LPI with normal idles so that PCS starts processing
                                                                 idles for GMI-\>PCS data transfers following TX_LPI-\>TX_LPI_WAIT transition.
                                                                 For diagnostic use only. */
        uint64_t tx_qsgmii_port0_init  : 1;  /**< [  2:  2](R/W) Reserved.
                                                                 Internal:
                                                                 Forces QSGMII startup sequence to wait for port0 data before starting to send
                                                                 data; LMAC1..3 are unused. This bit slows down the GMP's first data sent to
                                                                 GSER. For diagnostic use only. */
        uint64_t tx_eee_rx_sync_status_enable : 1;/**< [  3:  3](RAZ) Reserved.
                                                                 Internal:
                                                                 Enables RX sync status to enable TX EEE operation
                                                                    0 = TX side ignores sync_status for RX.  TX EEE is enabled even when sync_status=0.
                                                                    1 = TX side requires RX sync_status=1 + delay after  CGX()_GMP_GMI()_TX_EEE_CFG1[SYNC2LPI_TIME]. */
        uint64_t pcs_alt_an            : 1;  /**< [  4:  4](R/W) Flip auto-negotiate mode.
                                                                 Internal:
                                                                 Allows GMP AN to behave like BGX did on t8x, o7x. Setting this bit
                                                                 inverts csr__an_sgi_mode from the normal behavior of ! pcs_misc_ctl_reg_data[i].mode. */
        uint64_t reserved_5_7          : 3;
        uint64_t rx_pcs_sync_signal_detect : 1;/**< [  8:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Allow signal_detect to control PCS RX synchronization.
                                                                 See 802.3-2012, Figure 36-9 Synchronization State Diagram.
                                                                   0 = BGX mode. Ignore signal_detect.
                                                                   1 = Use signal_detect (edet) from GSER.

                                                                  Either [RX_PCS_SYNC_TIMEOUT] or_PCS_SYNC_SIGNAL_DETECT] must be set. */
        uint64_t rx_pcs_sync_timeout   : 1;  /**< [  9:  9](R/W) Reserved.
                                                                 Internal:
                                                                 BGX Synchronization mode

                                                                 See 802.3-2012, Figure 36-9 Synchronization State Diagram.
                                                                    0 = CGX mode. Ignore bit lock.
                                                                    1 = BGX mode. Use bit_lock in place of signal_detect in RX synchronization.
                                                                  bit_lock is a timeout on GSER transfers.  If no transfers occur for 64 cycles, bit_lock
                                                                  is lost.

                                                                  Either [RX_PCS_SYNC_TIMEOUT] or_PCS_SYNC_SIGNAL_DETECT] must be set. */
        uint64_t rx_pcs_eee_mode_enable : 1; /**< [ 10: 10](R/W) Reserved.
                                                                 Internal:
                                                                 Enable RX to send QUIET.  For debug. 0 = force MODE=DATA at all times. */
        uint64_t rx_pcs_lpi_enable     : 1;  /**< [ 11: 11](R/W) Reserved.
                                                                 Internal:
                                                                 Enable LPI decoding in RX PCS.
                                                                 "0 = Disable LPI processing.  /L/ acts like /I/
                                                                 1 = Enable LPI Processing. Default." */
        uint64_t rx_pcs_802_rx_k       : 1;  /**< [ 12: 12](R/W) Reserved.
                                                                 Internal:
                                                                 Enable RX_K Control to exit RX_K per 802.3
                                                                 BGX stayed in RX_K if xmit==DATA and a control character.
                                                                 0 = BGX mode.  xmit == DATA and control will hold in RX_K.
                                                                 1 = 802.3 mode. xmit == DATA and control will transition to IDLE_D. */
        uint64_t rx_pcs_alt_qlb2i      : 1;  /**< [ 13: 13](R/W) For QSGMII mode, enable use of alternate state machine to control idle insertion
                                                                 for RX clk \< TX clk. Not used unless LMAC is doing QSGMII LOOPBCK2 (RX
                                                                 loopback).

                                                                 Internal:
                                                                 QSGMII single byte/xfer/lmac can prevent BGX from inserting idles.
                                                                    0 = Use traditional idle insertion.
                                                                    1 = Use state machine to insert idles. */
        uint64_t reserved_14_15        : 2;
        uint64_t rx_cgp_gser_throttle  : 1;  /**< [ 16: 16](R/W) Emulate BGX operation by sending PCS two consecutive codegroups at a time.
                                                                 Internal:
                                                                 "Bit is ignored in QSGMII mode.
                                                                   0 = CGX mode.  Serialize GSER transfers into bytes as fast as possible.
                                                                   1 = Throttle to act more like earlier chips' BGX. Idle bus to PCS for two
                                                                 cycles after sending every pair of bytes.

                                                                 Normally CGP takes a 4 codegroup transfer and serializes the data into 4 consecutive
                                                                 single codegroup transfers to PCS.  With minimum IPG of 2B, GMI EOP pipelining can cause
                                                                 back to back packets to collide and merge.  This is probably not a realistic scenario, but
                                                                 BGX did handle this correctly because of GSER width of only 2 codegroups. Setting this bit
                                                                 will allow CGX to split up a GSER transfer as follows:
                                                                   send byte0 ##1 send byte1 ##3 send byte2 ##1 send byte3 ##3 Potentially start sending
                                                                 byte0 of next GSER transfer." */
        uint64_t rx_cgp_edet_filter    : 1;  /**< [ 17: 17](R/W) Reserved.
                                                                 Internal:
                                                                 Delay edet to PCS based on in-flight codegroups.

                                                                 0 = Flush. Forward edet as quickly as possible.  Bytes in CGP are flushed while edet=0.
                                                                 1 = Filter. Wait for CGP to finish processing codegroups before edet=0 before
                                                                 dropping edet to PCS.

                                                                 CGP has a FIFO + 3 stages of FLOPS after the input register. These registers can
                                                                 contain codegroups sent before edet drops. */
        uint64_t rx_cgp_edet_qlm_val   : 1;  /**< [ 18: 18](R/W) Reserved.
                                                                 Internal:
                                                                 Ignore QLM valid when edet=0.

                                                                 0 = Valid from QLM will push data to FIFO for processing.
                                                                 1 = Edet=0 will turn off pushing to FIFO. */
        uint64_t reserved_19_63        : 45;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_miscx_cfg_s cn; */
};
typedef union bdk_cgxx_gmp_miscx_cfg bdk_cgxx_gmp_miscx_cfg_t;

static inline uint64_t BDK_CGXX_GMP_MISCX_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_MISCX_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0034000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0034000ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0034000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0034000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_MISCX_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_MISCX_CFG(a,b) bdk_cgxx_gmp_miscx_cfg_t
#define bustype_BDK_CGXX_GMP_MISCX_CFG(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_MISCX_CFG(a,b) "CGXX_GMP_MISCX_CFG"
#define device_bar_BDK_CGXX_GMP_MISCX_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_MISCX_CFG(a,b) (a)
#define arguments_BDK_CGXX_GMP_MISCX_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_an_expansion
 *
 * CGX GMP PCS AN Expansion register Register 6
 * AN status
 */
union bdk_cgxx_gmp_pcsx_an_expansion
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_an_expansion_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t next_page_able        : 1;  /**< [  2:  2](RO/H) 0 = Local device is not next page able.
                                                                 1 = Local device is next page able.

                                                                 Always set in CGX. */
        uint64_t page_received         : 1;  /**< [  1:  1](R/W1C/H) 0 = A new page has not been received.
                                                                 1 = A new page has been received.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t page_received         : 1;  /**< [  1:  1](R/W1C/H) 0 = A new page has not been received.
                                                                 1 = A new page has been received.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t next_page_able        : 1;  /**< [  2:  2](RO/H) 0 = Local device is not next page able.
                                                                 1 = Local device is next page able.

                                                                 Always set in CGX. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_an_expansion_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_an_expansion bdk_cgxx_gmp_pcsx_an_expansion_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_AN_EXPANSION(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_AN_EXPANSION(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030a60ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030a60ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030a60ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030a60ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_AN_EXPANSION", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_AN_EXPANSION(a,b) bdk_cgxx_gmp_pcsx_an_expansion_t
#define bustype_BDK_CGXX_GMP_PCSX_AN_EXPANSION(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_AN_EXPANSION(a,b) "CGXX_GMP_PCSX_AN_EXPANSION"
#define device_bar_BDK_CGXX_GMP_PCSX_AN_EXPANSION(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_AN_EXPANSION(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_AN_EXPANSION(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_an_lp_abil_np
 *
 * CGX GMP PCS AN Link Partner Ability Next Page Register 8
 * This register contains the advertised ability of the link partners Next Page. The definition
 * for this register is provided in 32.5.4.2 for changes to 28.2.4.1.4.
 */
union bdk_cgxx_gmp_pcsx_an_lp_abil_np
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_an_lp_abil_np_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge: Always 0 in this register. */
        uint64_t mp                    : 1;  /**< [ 13: 13](RO/H) Message page. Set to indicate that this register contains a message next page. Clear to
                                                                 indicate that the register contains an unformatted next page. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](RO/H) Acknowledge 2. Indicates that the receiver is able to act on the information (or perform
                                                                 the task) defined in the message. */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO/H) This bit is ignored by hardware. The value of the TOGGLE bit in transmitted next pages is
                                                                 automatically generated by hardware. Value is the current value that hardware is using in
                                                                 next page transmission. */
        uint64_t m_u                   : 11; /**< [ 10:  0](RO/H) Message/unformatted code field. When the MP bit is set, this field contains the message
                                                                 code field (M) of the message next page. When MP is clear, this field contains the
                                                                 unformatted
                                                                 code field. */
#else /* Word 0 - Little Endian */
        uint64_t m_u                   : 11; /**< [ 10:  0](RO/H) Message/unformatted code field. When the MP bit is set, this field contains the message
                                                                 code field (M) of the message next page. When MP is clear, this field contains the
                                                                 unformatted
                                                                 code field. */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO/H) This bit is ignored by hardware. The value of the TOGGLE bit in transmitted next pages is
                                                                 automatically generated by hardware. Value is the current value that hardware is using in
                                                                 next page transmission. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](RO/H) Acknowledge 2. Indicates that the receiver is able to act on the information (or perform
                                                                 the task) defined in the message. */
        uint64_t mp                    : 1;  /**< [ 13: 13](RO/H) Message page. Set to indicate that this register contains a message next page. Clear to
                                                                 indicate that the register contains an unformatted next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge: Always 0 in this register. */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_an_lp_abil_np_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_an_lp_abil_np bdk_cgxx_gmp_pcsx_an_lp_abil_np_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030a80ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030a80ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030a80ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030a80ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_AN_LP_ABIL_NP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(a,b) bdk_cgxx_gmp_pcsx_an_lp_abil_np_t
#define bustype_BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(a,b) "CGXX_GMP_PCSX_AN_LP_ABIL_NP"
#define device_bar_BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_AN_LP_ABIL_NP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_an_np_tx
 *
 * CGX GMP PCS AN Next Page Transmit Register 7
 * Software programs this register with the contents of the AN message next page or unformatted
 * next page link code word to be transmitted during autonegotiation. Next page exchange occurs
 * after the base link code words have been exchanged if either end of the link segment sets the
 * NP bit to 1, indicating that it has at least one next page to send. Once initiated, next page
 * exchange continues until both ends of the link segment set their NP bits to 0.
 * Both sides must be NP capable to use NP exchanges.
 */
union bdk_cgxx_gmp_pcsx_an_np_tx
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_an_np_tx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge: Always 0 in this register. */
        uint64_t mp                    : 1;  /**< [ 13: 13](R/W) Message page. Set to indicate that this register contains a message next page. Clear to
                                                                 indicate that the register contains an unformatted next page. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](R/W) Acknowledge 2. Indicates that the receiver is able to act on the information (or perform
                                                                 the task) defined in the message. */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO) This bit is ignored by hardware. The value of the TOGGLE bit in transmitted next pages is
                                                                 automatically generated by hardware. Value is the current value that hardware is using in
                                                                 next page transmission. */
        uint64_t m_u                   : 11; /**< [ 10:  0](R/W) Message/unformatted code field. When the MP bit is set, this field contains the message
                                                                 code field (M) of the message next page. When MP is clear, this field contains the
                                                                 unformatted code field. */
#else /* Word 0 - Little Endian */
        uint64_t m_u                   : 11; /**< [ 10:  0](R/W) Message/unformatted code field. When the MP bit is set, this field contains the message
                                                                 code field (M) of the message next page. When MP is clear, this field contains the
                                                                 unformatted code field. */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO) This bit is ignored by hardware. The value of the TOGGLE bit in transmitted next pages is
                                                                 automatically generated by hardware. Value is the current value that hardware is using in
                                                                 next page transmission. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](R/W) Acknowledge 2. Indicates that the receiver is able to act on the information (or perform
                                                                 the task) defined in the message. */
        uint64_t mp                    : 1;  /**< [ 13: 13](R/W) Message page. Set to indicate that this register contains a message next page. Clear to
                                                                 indicate that the register contains an unformatted next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge: Always 0 in this register. */
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_an_np_tx_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_an_np_tx bdk_cgxx_gmp_pcsx_an_np_tx_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_AN_NP_TX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_AN_NP_TX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030a70ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030a70ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030a70ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030a70ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_AN_NP_TX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_AN_NP_TX(a,b) bdk_cgxx_gmp_pcsx_an_np_tx_t
#define bustype_BDK_CGXX_GMP_PCSX_AN_NP_TX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_AN_NP_TX(a,b) "CGXX_GMP_PCSX_AN_NP_TX"
#define device_bar_BDK_CGXX_GMP_PCSX_AN_NP_TX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_AN_NP_TX(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_AN_NP_TX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_dbg_control
 *
 * CGX PCS Debug Control Registers
 */
union bdk_cgxx_gmp_pcsx_dbg_control
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_dbg_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t us_clk_period         : 7;  /**< [  6:  0](R/W) Microsecond clock period. Specifies the number of 10 ns cycles per microseconds, minus one.
                                                                 The default value of 99 (0x63) results in a 1 us interval and should be used during
                                                                 normal operation. Other values may be used for test/debug purposes. Used for microsecond
                                                                 source for CGX()_GMP_PCS_LINK()_TIMER[COUNT].
                                                                 Units = global 10 ns clock ticks.

                                                                 Internal:
                                                                 Also used for millisecond timer for CGX()_GMP_GMI()_TX_EEE_CFG1[SYNC2LPI_TIME]. */
#else /* Word 0 - Little Endian */
        uint64_t us_clk_period         : 7;  /**< [  6:  0](R/W) Microsecond clock period. Specifies the number of 10 ns cycles per microseconds, minus one.
                                                                 The default value of 99 (0x63) results in a 1 us interval and should be used during
                                                                 normal operation. Other values may be used for test/debug purposes. Used for microsecond
                                                                 source for CGX()_GMP_PCS_LINK()_TIMER[COUNT].
                                                                 Units = global 10 ns clock ticks.

                                                                 Internal:
                                                                 Also used for millisecond timer for CGX()_GMP_GMI()_TX_EEE_CFG1[SYNC2LPI_TIME]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_dbg_control_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_dbg_control bdk_cgxx_gmp_pcsx_dbg_control_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_DBG_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_DBG_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0031000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0031000ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0031000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0031000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_DBG_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_DBG_CONTROL(a,b) bdk_cgxx_gmp_pcsx_dbg_control_t
#define bustype_BDK_CGXX_GMP_PCSX_DBG_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_DBG_CONTROL(a,b) "CGXX_GMP_PCSX_DBG_CONTROL"
#define device_bar_BDK_CGXX_GMP_PCSX_DBG_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_DBG_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_DBG_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_rx_eee_wake
 *
 * INTERNAL: CGX GMP PCS  RX EEE Wake Error Counter  Registers
 *
 * Reserved.
 * Internal:
 * This register is used by PHY types that support EEE to count wake time faults where
 * the PHY fails to complete its normal wake sequence within the time required for the
 * specific PHY type. The definition of the fault event to be counted is defined for
 * each PHY and may occur during a refresh or a wake-up as defined by the PHY. This
 * 16-bit counter shall be reset to all zeros upon execution of the PCS reset. This
 * counter shall be held at all ones in the case of overflow.
 */
union bdk_cgxx_gmp_pcsx_rx_eee_wake
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_rx_eee_wake_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t error_counter         : 16; /**< [ 15:  0](R/W/H) Reserved.
                                                                 Internal:
                                                                 Accumulation of wake time faults.
                                                                 This register is writeable to clear. Writes of nonzero values are for diagnostic use.
                                                                 This register is reset by pcs__sw_rst.
                                                                 Error events that occur after read and before write will be lost.
                                                                 NOTE 802.3-2012 calls out RC/H but do not want read side effects. */
#else /* Word 0 - Little Endian */
        uint64_t error_counter         : 16; /**< [ 15:  0](R/W/H) Reserved.
                                                                 Internal:
                                                                 Accumulation of wake time faults.
                                                                 This register is writeable to clear. Writes of nonzero values are for diagnostic use.
                                                                 This register is reset by pcs__sw_rst.
                                                                 Error events that occur after read and before write will be lost.
                                                                 NOTE 802.3-2012 calls out RC/H but do not want read side effects. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_rx_eee_wake_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_rx_eee_wake bdk_cgxx_gmp_pcsx_rx_eee_wake_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030910ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030910ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030910ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030910ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_RX_EEE_WAKE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(a,b) bdk_cgxx_gmp_pcsx_rx_eee_wake_t
#define bustype_BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(a,b) "CGXX_GMP_PCSX_RX_EEE_WAKE"
#define device_bar_BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_RX_EEE_WAKE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_rx_lpi_timing
 *
 * INTERNAL: CGX GMP PCS  RX EEE LPI Timing Parameters Registers
 *
 * Reserved.
 * Internal:
 * Receiver LPI timing parameters Tqr, Twr and Twtf.
 */
union bdk_cgxx_gmp_pcsx_rx_lpi_timing
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_rx_lpi_timing_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t tqr                   : 20; /**< [ 51: 32](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits for signal detect to be set to OK while in the
                                                                 LP_IDLE_D, LPI_K, and RX_QUIET states before asserting rx_fault.
                                                                 802.3 Table 36-9, Figure 36-7c. Table specifies min of 3 ms, max of 4 ms.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 4 ms.
                                                                 Maximum = 10.49 ms. */
        uint64_t twr                   : 12; /**< [ 31: 20](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits in RX_WAKE state before indicating wake time fault (WTF)
                                                                 802.3 Table 36-9, Figure 36-7c. Table specifies max of 11 us.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 11 us.
                                                                 Maximum = 40.95 us. */
        uint64_t reserved_18_19        : 2;
        uint64_t twtf                  : 18; /**< [ 17:  0](R/W) Reserved.
                                                                 Internal:
                                                                 EEE wake time fault recovery. 802.3 Table 36-9, Figure 36-7c.
                                                                 Table specifies maximum of 1 ms.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 1 ms.
                                                                 Maximum = 2.621 ms. */
#else /* Word 0 - Little Endian */
        uint64_t twtf                  : 18; /**< [ 17:  0](R/W) Reserved.
                                                                 Internal:
                                                                 EEE wake time fault recovery. 802.3 Table 36-9, Figure 36-7c.
                                                                 Table specifies maximum of 1 ms.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 1 ms.
                                                                 Maximum = 2.621 ms. */
        uint64_t reserved_18_19        : 2;
        uint64_t twr                   : 12; /**< [ 31: 20](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits in RX_WAKE state before indicating wake time fault (WTF)
                                                                 802.3 Table 36-9, Figure 36-7c. Table specifies max of 11 us.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 11 us.
                                                                 Maximum = 40.95 us. */
        uint64_t tqr                   : 20; /**< [ 51: 32](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits for signal detect to be set to OK while in the
                                                                 LP_IDLE_D, LPI_K, and RX_QUIET states before asserting rx_fault.
                                                                 802.3 Table 36-9, Figure 36-7c. Table specifies min of 3 ms, max of 4 ms.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 4 ms.
                                                                 Maximum = 10.49 ms. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_rx_lpi_timing_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_rx_lpi_timing bdk_cgxx_gmp_pcsx_rx_lpi_timing_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030900ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030900ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030900ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030900ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_RX_LPI_TIMING", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(a,b) bdk_cgxx_gmp_pcsx_rx_lpi_timing_t
#define bustype_BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(a,b) "CGXX_GMP_PCSX_RX_LPI_TIMING"
#define device_bar_BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_RX_LPI_TIMING(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_status1
 *
 * CGX GMP PCS Status 1 Register
 * PCS LPI Status, Link OK.  Register 3.1
 */
union bdk_cgxx_gmp_pcsx_status1
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t tx_lpi_received       : 1;  /**< [ 11: 11](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [TX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t rx_lpi_received       : 1;  /**< [ 10: 10](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [RX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t tx_lpi_indication     : 1;  /**< [  9:  9](RO/H) Reserved.
                                                                 Internal:
                                                                 TX sending LPI.  TX LPI State not in TX_ACTIVE.  802.3-2012 Figure 36-10. */
        uint64_t rx_lpi_indication     : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 RX receiving LPI.  rx_lpi_active = TRUE. 802.3-2012, Figure 36-7a-c. */
        uint64_t reserved_3_7          : 5;
        uint64_t receive_link_status   : 1;  /**< [  2:  2](R/W1S/H) Sync state:
                                                                    0 = Not synchronized.
                                                                    1 = Synchronized.

                                                                 Captures the state of the sync_status variable as defined in 802.3 section
                                                                 36.2.5.1.3 When set, indicates that a link sync_status has been
                                                                 established. When clear, indicates that the sync_status has been lost after this
                                                                 bit was last set by software.  Latching low bit; stays clear until a 1 is
                                                                 written by software.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-set
                                                                 bit, rather than latching low read- only as specified in 802.3. */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t receive_link_status   : 1;  /**< [  2:  2](R/W1S/H) Sync state:
                                                                    0 = Not synchronized.
                                                                    1 = Synchronized.

                                                                 Captures the state of the sync_status variable as defined in 802.3 section
                                                                 36.2.5.1.3 When set, indicates that a link sync_status has been
                                                                 established. When clear, indicates that the sync_status has been lost after this
                                                                 bit was last set by software.  Latching low bit; stays clear until a 1 is
                                                                 written by software.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-set
                                                                 bit, rather than latching low read- only as specified in 802.3. */
        uint64_t reserved_3_7          : 5;
        uint64_t rx_lpi_indication     : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 RX receiving LPI.  rx_lpi_active = TRUE. 802.3-2012, Figure 36-7a-c. */
        uint64_t tx_lpi_indication     : 1;  /**< [  9:  9](RO/H) Reserved.
                                                                 Internal:
                                                                 TX sending LPI.  TX LPI State not in TX_ACTIVE.  802.3-2012 Figure 36-10. */
        uint64_t rx_lpi_received       : 1;  /**< [ 10: 10](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [RX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t tx_lpi_received       : 1;  /**< [ 11: 11](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [TX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_status1_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_status1 bdk_cgxx_gmp_pcsx_status1_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030880ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030880ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030880ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030880ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_STATUS1(a,b) bdk_cgxx_gmp_pcsx_status1_t
#define bustype_BDK_CGXX_GMP_PCSX_STATUS1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_STATUS1(a,b) "CGXX_GMP_PCSX_STATUS1"
#define device_bar_BDK_CGXX_GMP_PCSX_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_STATUS1(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs#_tx_lpi_timing
 *
 * INTERNAL: CGX GMP GMI  TX EEE LPI Timing Parameters Registers
 *
 * Reserved.
 * Internal:
 * Transmitter LPI timing parameters Tsl, Tql and Tul.
 */
union bdk_cgxx_gmp_pcsx_tx_lpi_timing
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcsx_tx_lpi_timing_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_60_63        : 4;
        uint64_t tsl                   : 12; /**< [ 59: 48](R/W) Reserved.
                                                                 Internal:
                                                                 Local sleep time from entering the TX_SLEEP state to when tx_quiet is set to TRUE
                                                                 802.3 Table 36-8, Figure 36-10. Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 20 us.
                                                                 Maximum = 40.95 us. */
        uint64_t reserved_44_47        : 4;
        uint64_t tul                   : 12; /**< [ 43: 32](R/W) Reserved.
                                                                 Internal:
                                                                 Local refresh time from entry into the TX_REFRESH state to entry into the TX_QUIET state.
                                                                 802.3 Table 36-8, Figure 36-10. Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Reset value is 20 us.
                                                                 Maximum = 40.95 us. */
        uint64_t reserved_19_31        : 13;
        uint64_t tql                   : 19; /**< [ 18:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Local quiet time from when tx_quiet is set to TRUE to entry into the TX_REFRESH state
                                                                 802.3 Table 36-8, Figure 36-10. Table specifies min of 2.5 ms, max of 2.6 ms.
                                                                 Reset value is 2.55 ms.
                                                                 Maximum = 5.243 ms. */
#else /* Word 0 - Little Endian */
        uint64_t tql                   : 19; /**< [ 18:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Local quiet time from when tx_quiet is set to TRUE to entry into the TX_REFRESH state
                                                                 802.3 Table 36-8, Figure 36-10. Table specifies min of 2.5 ms, max of 2.6 ms.
                                                                 Reset value is 2.55 ms.
                                                                 Maximum = 5.243 ms. */
        uint64_t reserved_19_31        : 13;
        uint64_t tul                   : 12; /**< [ 43: 32](R/W) Reserved.
                                                                 Internal:
                                                                 Local refresh time from entry into the TX_REFRESH state to entry into the TX_QUIET state.
                                                                 802.3 Table 36-8, Figure 36-10. Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Reset value is 20 us.
                                                                 Maximum = 40.95 us. */
        uint64_t reserved_44_47        : 4;
        uint64_t tsl                   : 12; /**< [ 59: 48](R/W) Reserved.
                                                                 Internal:
                                                                 Local sleep time from entering the TX_SLEEP state to when tx_quiet is set to TRUE
                                                                 802.3 Table 36-8, Figure 36-10. Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value is 20 us.
                                                                 Maximum = 40.95 us. */
        uint64_t reserved_60_63        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcsx_tx_lpi_timing_s cn; */
};
typedef union bdk_cgxx_gmp_pcsx_tx_lpi_timing bdk_cgxx_gmp_pcsx_tx_lpi_timing_t;

static inline uint64_t BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030800ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCSX_TX_LPI_TIMING", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(a,b) bdk_cgxx_gmp_pcsx_tx_lpi_timing_t
#define bustype_BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(a,b) "CGXX_GMP_PCSX_TX_LPI_TIMING"
#define device_bar_BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCSX_TX_LPI_TIMING(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_an#_adv
 *
 * CGX GMP PCS Autonegotiation Advertisement Registers
 */
union bdk_cgxx_gmp_pcs_anx_adv
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_anx_adv_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page capable. */
        uint64_t reserved_14           : 1;
        uint64_t rem_flt               : 2;  /**< [ 13: 12](R/W/H) Remote fault.
                                                                 0x0 = Link OK, XMIT = DATA.
                                                                 0x1 = Link failure (loss of sync, XMIT !=DATA).
                                                                 0x2 = Local device offline.
                                                                 0x3 = Autonegotiation error; failure to complete autonegotiation. AN error is set if
                                                                 resolution function precludes operation with link partner. */
        uint64_t reserved_9_11         : 3;
        uint64_t pause                 : 2;  /**< [  8:  7](R/W) PAUSE frame flow capability across link, exchanged during autonegotiation as follows:
                                                                 0x0 = No PAUSE.
                                                                 0x1 = Symmetric PAUSE.
                                                                 0x2 = Asymmetric PAUSE.
                                                                 0x3 = Both symmetric and asymmetric PAUSE to local device. */
        uint64_t hfd                   : 1;  /**< [  6:  6](R/W) Half-duplex. When set, local device is half-duplex capable. */
        uint64_t fd                    : 1;  /**< [  5:  5](R/W) Full-duplex. When set, local device is full-duplex capable. */
        uint64_t reserved_0_4          : 5;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_4          : 5;
        uint64_t fd                    : 1;  /**< [  5:  5](R/W) Full-duplex. When set, local device is full-duplex capable. */
        uint64_t hfd                   : 1;  /**< [  6:  6](R/W) Half-duplex. When set, local device is half-duplex capable. */
        uint64_t pause                 : 2;  /**< [  8:  7](R/W) PAUSE frame flow capability across link, exchanged during autonegotiation as follows:
                                                                 0x0 = No PAUSE.
                                                                 0x1 = Symmetric PAUSE.
                                                                 0x2 = Asymmetric PAUSE.
                                                                 0x3 = Both symmetric and asymmetric PAUSE to local device. */
        uint64_t reserved_9_11         : 3;
        uint64_t rem_flt               : 2;  /**< [ 13: 12](R/W/H) Remote fault.
                                                                 0x0 = Link OK, XMIT = DATA.
                                                                 0x1 = Link failure (loss of sync, XMIT !=DATA).
                                                                 0x2 = Local device offline.
                                                                 0x3 = Autonegotiation error; failure to complete autonegotiation. AN error is set if
                                                                 resolution function precludes operation with link partner. */
        uint64_t reserved_14           : 1;
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page capable. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_anx_adv_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_anx_adv bdk_cgxx_gmp_pcs_anx_adv_t;

static inline uint64_t BDK_CGXX_GMP_PCS_ANX_ADV(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_ANX_ADV(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_ANX_ADV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_ANX_ADV(a,b) bdk_cgxx_gmp_pcs_anx_adv_t
#define bustype_BDK_CGXX_GMP_PCS_ANX_ADV(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_ANX_ADV(a,b) "CGXX_GMP_PCS_ANX_ADV"
#define device_bar_BDK_CGXX_GMP_PCS_ANX_ADV(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_ANX_ADV(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_ANX_ADV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_an#_ext_st
 *
 * CGX GMO PCS Autonegotiation Extended Status Registers
 */
union bdk_cgxx_gmp_pcs_anx_ext_st
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_anx_ext_st_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t thou_xfd              : 1;  /**< [ 15: 15](RO/H) When set, PHY is 1000 BASE-X full duplex capable. */
        uint64_t thou_xhd              : 1;  /**< [ 14: 14](RO/H) When set, PHY is 1000 BASE-X half duplex capable. */
        uint64_t thou_tfd              : 1;  /**< [ 13: 13](RO/H) When set, PHY is 1000 BASE-T full duplex capable. */
        uint64_t thou_thd              : 1;  /**< [ 12: 12](RO/H) When set, PHY is 1000 BASE-T half duplex capable. */
        uint64_t reserved_0_11         : 12;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_11         : 12;
        uint64_t thou_thd              : 1;  /**< [ 12: 12](RO/H) When set, PHY is 1000 BASE-T half duplex capable. */
        uint64_t thou_tfd              : 1;  /**< [ 13: 13](RO/H) When set, PHY is 1000 BASE-T full duplex capable. */
        uint64_t thou_xhd              : 1;  /**< [ 14: 14](RO/H) When set, PHY is 1000 BASE-X half duplex capable. */
        uint64_t thou_xfd              : 1;  /**< [ 15: 15](RO/H) When set, PHY is 1000 BASE-X full duplex capable. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_anx_ext_st_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_anx_ext_st bdk_cgxx_gmp_pcs_anx_ext_st_t;

static inline uint64_t BDK_CGXX_GMP_PCS_ANX_EXT_ST(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_ANX_EXT_ST(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_ANX_EXT_ST", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_ANX_EXT_ST(a,b) bdk_cgxx_gmp_pcs_anx_ext_st_t
#define bustype_BDK_CGXX_GMP_PCS_ANX_EXT_ST(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_ANX_EXT_ST(a,b) "CGXX_GMP_PCS_ANX_EXT_ST"
#define device_bar_BDK_CGXX_GMP_PCS_ANX_EXT_ST(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_ANX_EXT_ST(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_ANX_EXT_ST(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_an#_lp_abil
 *
 * CGX GMP PCS Autonegotiation Link Partner Ability Registers
 * This is the autonegotiation link partner ability register 5 as per IEEE 802.3, Clause 37.
 */
union bdk_cgxx_gmp_pcs_anx_lp_abil
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_anx_lp_abil_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page capable:
                                                                 0 = Link partner not next page capable.
                                                                 1 = Link partner next page capable. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) When set, indicates acknowledgement received. */
        uint64_t rem_flt               : 2;  /**< [ 13: 12](RO/H) Link partner's link status as follows:
                                                                 0x0 = Link OK.
                                                                 0x1 = Offline.
                                                                 0x2 = Link failure.
                                                                 0x3 = Autonegotiation error. */
        uint64_t reserved_9_11         : 3;
        uint64_t pause                 : 2;  /**< [  8:  7](RO/H) Link partner PAUSE setting as follows:
                                                                 0x0 = No PAUSE.
                                                                 0x1 = Symmetric PAUSE.
                                                                 0x2 = Asymmetric PAUSE.
                                                                 0x3 = Both symmetric and asymmetric PAUSE to local device. */
        uint64_t hfd                   : 1;  /**< [  6:  6](RO/H) Half-duplex. When set, link partner is half-duplex capable. */
        uint64_t fd                    : 1;  /**< [  5:  5](RO/H) Full-duplex. When set, link partner is full-duplex capable. */
        uint64_t reserved_0_4          : 5;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_4          : 5;
        uint64_t fd                    : 1;  /**< [  5:  5](RO/H) Full-duplex. When set, link partner is full-duplex capable. */
        uint64_t hfd                   : 1;  /**< [  6:  6](RO/H) Half-duplex. When set, link partner is half-duplex capable. */
        uint64_t pause                 : 2;  /**< [  8:  7](RO/H) Link partner PAUSE setting as follows:
                                                                 0x0 = No PAUSE.
                                                                 0x1 = Symmetric PAUSE.
                                                                 0x2 = Asymmetric PAUSE.
                                                                 0x3 = Both symmetric and asymmetric PAUSE to local device. */
        uint64_t reserved_9_11         : 3;
        uint64_t rem_flt               : 2;  /**< [ 13: 12](RO/H) Link partner's link status as follows:
                                                                 0x0 = Link OK.
                                                                 0x1 = Offline.
                                                                 0x2 = Link failure.
                                                                 0x3 = Autonegotiation error. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) When set, indicates acknowledgement received. */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page capable:
                                                                 0 = Link partner not next page capable.
                                                                 1 = Link partner next page capable. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_anx_lp_abil_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_anx_lp_abil bdk_cgxx_gmp_pcs_anx_lp_abil_t;

static inline uint64_t BDK_CGXX_GMP_PCS_ANX_LP_ABIL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_ANX_LP_ABIL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_ANX_LP_ABIL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_ANX_LP_ABIL(a,b) bdk_cgxx_gmp_pcs_anx_lp_abil_t
#define bustype_BDK_CGXX_GMP_PCS_ANX_LP_ABIL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_ANX_LP_ABIL(a,b) "CGXX_GMP_PCS_ANX_LP_ABIL"
#define device_bar_BDK_CGXX_GMP_PCS_ANX_LP_ABIL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_ANX_LP_ABIL(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_ANX_LP_ABIL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_an#_results
 *
 * CGX GMP PCS Autonegotiation Results Registers
 * This register is not valid when CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 1. If
 * CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 0 and
 * CGX()_GMP_PCS_AN()_RESULTS[AN_CPT] is set to 1, this register is valid.
 */
union bdk_cgxx_gmp_pcs_anx_results
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_anx_results_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t pause                 : 2;  /**< [  6:  5](RO/H) PAUSE selection ('don't care' for SGMII/QSGMII) as follows:
                                                                 0x0 = Disable PAUSE, TX and RX.
                                                                 0x1 = Enable PAUSE frames, RX only.
                                                                 0x2 = Enable PAUSE frames, TX only.
                                                                 0x3 = Enable PAUSE frames, TX and RX. */
        uint64_t spd                   : 2;  /**< [  4:  3](RO/H) Link speed selection as follows:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t an_cpt                : 1;  /**< [  2:  2](RO/H) Autonegotiation completed.  802.3-2012 Figure 37-6 mr_an_complete
                                                                 1 = Autonegotiation completed.
                                                                 0 = Autonegotiation not completed or failed. */
        uint64_t dup                   : 1;  /**< [  1:  1](RO/H) Duplex mode. 1 = full duplex, 0 = half duplex. */
        uint64_t link_ok               : 1;  /**< [  0:  0](RO/H) Link status .  Non-latched version of CGX()_GMP_PCS_MR()_STATUS[LNK_ST]
                                                                   0 = link down.  802.3-2012 Figure 37-6 xmit!=DATA.
                                                                   1 = link up (OK).  802.3-2012 Figure 37-6 xmit==DATA. */
#else /* Word 0 - Little Endian */
        uint64_t link_ok               : 1;  /**< [  0:  0](RO/H) Link status .  Non-latched version of CGX()_GMP_PCS_MR()_STATUS[LNK_ST]
                                                                   0 = link down.  802.3-2012 Figure 37-6 xmit!=DATA.
                                                                   1 = link up (OK).  802.3-2012 Figure 37-6 xmit==DATA. */
        uint64_t dup                   : 1;  /**< [  1:  1](RO/H) Duplex mode. 1 = full duplex, 0 = half duplex. */
        uint64_t an_cpt                : 1;  /**< [  2:  2](RO/H) Autonegotiation completed.  802.3-2012 Figure 37-6 mr_an_complete
                                                                 1 = Autonegotiation completed.
                                                                 0 = Autonegotiation not completed or failed. */
        uint64_t spd                   : 2;  /**< [  4:  3](RO/H) Link speed selection as follows:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t pause                 : 2;  /**< [  6:  5](RO/H) PAUSE selection ('don't care' for SGMII/QSGMII) as follows:
                                                                 0x0 = Disable PAUSE, TX and RX.
                                                                 0x1 = Enable PAUSE frames, RX only.
                                                                 0x2 = Enable PAUSE frames, TX only.
                                                                 0x3 = Enable PAUSE frames, TX and RX. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_anx_results_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_anx_results bdk_cgxx_gmp_pcs_anx_results_t;

static inline uint64_t BDK_CGXX_GMP_PCS_ANX_RESULTS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_ANX_RESULTS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_ANX_RESULTS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_ANX_RESULTS(a,b) bdk_cgxx_gmp_pcs_anx_results_t
#define bustype_BDK_CGXX_GMP_PCS_ANX_RESULTS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_ANX_RESULTS(a,b) "CGXX_GMP_PCS_ANX_RESULTS"
#define device_bar_BDK_CGXX_GMP_PCS_ANX_RESULTS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_ANX_RESULTS(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_ANX_RESULTS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_int#
 *
 * CGX GMP PCS Interrupt Registers
 */
union bdk_cgxx_gmp_pcs_intx
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_intx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Auto-negotiation sequence has completed. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Received an auto-negotiation page.  Either a base page or next page. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Code group sync failure debug help. CGX()_GMP_PCS_INT()[DBG_SYNC] interrupt fires when
                                                                 code group
                                                                 synchronization state machine makes a transition from SYNC_ACQUIRED_1 state to
                                                                 SYNC_ACQUIRED_2 state. (See IEEE 802.3-2005, figure 37-9). It indicates that a bad code
                                                                 group was received after code group synchronization was achieved. This interrupt should be
                                                                 disabled during normal link operation. Use it as a debug help feature only. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Set whenever duplex mode changes on the link. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Set by hardware whenever RX sync state machine reaches a bad state. Should never be set
                                                                 during normal operation. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Set by hardware whenever autonegotiation state machine reaches a bad state. Should never
                                                                 be set during normal operation. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Set by hardware whenever code group sync or bit lock failure occurs. Cannot fire in loopback1 mode. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Set by hardware whenever RX state machine reaches a bad state. Should never be set during
                                                                 normal operation. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Set whenever RX receives a code group error in 10-bit to 8-bit decode logic. Cannot fire
                                                                 in loopback1 mode. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Set by hardware whenever TX state machine reaches a bad state. Should never be set during
                                                                 normal operation. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Set whenever hardware detects a TX FIFO overflow condition. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Set whenever hardware detects a TX FIFO underflow condition. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Autonegotiation error; AN resolution function failed. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Set whenever hardware detects a change in the XMIT variable. XMIT variable states are
                                                                 IDLE, CONFIG and DATA. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Set by hardware whenever link speed has changed. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Set by hardware whenever link speed has changed. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Set whenever hardware detects a change in the XMIT variable. XMIT variable states are
                                                                 IDLE, CONFIG and DATA. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Autonegotiation error; AN resolution function failed. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Set whenever hardware detects a TX FIFO underflow condition. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Set whenever hardware detects a TX FIFO overflow condition. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Set by hardware whenever TX state machine reaches a bad state. Should never be set during
                                                                 normal operation. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Set whenever RX receives a code group error in 10-bit to 8-bit decode logic. Cannot fire
                                                                 in loopback1 mode. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Set by hardware whenever RX state machine reaches a bad state. Should never be set during
                                                                 normal operation. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Set by hardware whenever code group sync or bit lock failure occurs. Cannot fire in loopback1 mode. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Set by hardware whenever autonegotiation state machine reaches a bad state. Should never
                                                                 be set during normal operation. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Set by hardware whenever RX sync state machine reaches a bad state. Should never be set
                                                                 during normal operation. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Set whenever duplex mode changes on the link. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Code group sync failure debug help. CGX()_GMP_PCS_INT()[DBG_SYNC] interrupt fires when
                                                                 code group
                                                                 synchronization state machine makes a transition from SYNC_ACQUIRED_1 state to
                                                                 SYNC_ACQUIRED_2 state. (See IEEE 802.3-2005, figure 37-9). It indicates that a bad code
                                                                 group was received after code group synchronization was achieved. This interrupt should be
                                                                 disabled during normal link operation. Use it as a debug help feature only. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Received an auto-negotiation page.  Either a base page or next page. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Auto-negotiation sequence has completed. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_intx_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_intx bdk_cgxx_gmp_pcs_intx_t;

static inline uint64_t BDK_CGXX_GMP_PCS_INTX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_INTX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_INTX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_INTX(a,b) bdk_cgxx_gmp_pcs_intx_t
#define bustype_BDK_CGXX_GMP_PCS_INTX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_INTX(a,b) "CGXX_GMP_PCS_INTX"
#define device_bar_BDK_CGXX_GMP_PCS_INTX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_INTX(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_INTX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_int#_ena_w1c
 *
 * CGX GMP PCS Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_gmp_pcs_intx_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_intx_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_intx_ena_w1c_s cn9; */
    /* struct bdk_cgxx_gmp_pcs_intx_ena_w1c_s cn96xx; */
    struct bdk_cgxx_gmp_pcs_intx_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_pcs_intx_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_gmp_pcs_intx_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_pcs_intx_ena_w1c bdk_cgxx_gmp_pcs_intx_ena_w1c_t;

static inline uint64_t BDK_CGXX_GMP_PCS_INTX_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_INTX_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_INTX_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_INTX_ENA_W1C(a,b) bdk_cgxx_gmp_pcs_intx_ena_w1c_t
#define bustype_BDK_CGXX_GMP_PCS_INTX_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_INTX_ENA_W1C(a,b) "CGXX_GMP_PCS_INTX_ENA_W1C"
#define device_bar_BDK_CGXX_GMP_PCS_INTX_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_INTX_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_INTX_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_int#_ena_w1s
 *
 * CGX GMP PCS Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_gmp_pcs_intx_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_intx_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_intx_ena_w1s_s cn9; */
    /* struct bdk_cgxx_gmp_pcs_intx_ena_w1s_s cn96xx; */
    struct bdk_cgxx_gmp_pcs_intx_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_pcs_intx_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_gmp_pcs_intx_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_pcs_intx_ena_w1s bdk_cgxx_gmp_pcs_intx_ena_w1s_t;

static inline uint64_t BDK_CGXX_GMP_PCS_INTX_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_INTX_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_INTX_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_INTX_ENA_W1S(a,b) bdk_cgxx_gmp_pcs_intx_ena_w1s_t
#define bustype_BDK_CGXX_GMP_PCS_INTX_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_INTX_ENA_W1S(a,b) "CGXX_GMP_PCS_INTX_ENA_W1S"
#define device_bar_BDK_CGXX_GMP_PCS_INTX_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_INTX_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_INTX_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_int#_w1s
 *
 * CGX GMP PCS Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_gmp_pcs_intx_w1s
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_intx_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets CGX(0..2)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_intx_w1s_s cn9; */
    /* struct bdk_cgxx_gmp_pcs_intx_w1s_s cn96xx; */
    struct bdk_cgxx_gmp_pcs_intx_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets CGX(0..4)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_gmp_pcs_intx_w1s_s cnf95xx; */
    struct bdk_cgxx_gmp_pcs_intx_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t reserved_18_19        : 2;
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t reserved_13_15        : 3;
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[LNKSPD]. */
#else /* Word 0 - Little Endian */
        uint64_t lnkspd                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[LNKSPD]. */
        uint64_t xmit                  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[XMIT]. */
        uint64_t an_err                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_ERR]. */
        uint64_t txfifu                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFU]. */
        uint64_t txfifo                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[TXFIFO]. */
        uint64_t txbad                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[TXBAD]. */
        uint64_t rxerr                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[RXERR]. */
        uint64_t rxbad                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[RXBAD]. */
        uint64_t rxlock                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[RXLOCK]. */
        uint64_t an_bad                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_BAD]. */
        uint64_t sync_bad              : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[SYNC_BAD]. */
        uint64_t dup                   : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[DUP]. */
        uint64_t dbg_sync              : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[DBG_SYNC]. */
        uint64_t reserved_13_15        : 3;
        uint64_t an_page_received      : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_PAGE_RECEIVED]. */
        uint64_t an_complete           : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[AN_COMPLETE]. */
        uint64_t reserved_18_19        : 2;
        uint64_t eee_tx_change         : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[EEE_TX_CHANGE].
                                                                 Internal:
                                                                 PCS TX entered or left XMIT_LPIDLE state. 802.3 Figure 36-5, B or C transitions. */
        uint64_t eee_rx_change         : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_CHANGE].
                                                                 Internal:
                                                                 PCS RX entered or left EEE state.  Basically entered or
                                                                 left 802.3 Figure 36-7c.
                                                                 Transitions include RX_K to RX_SLEEP, RX_LINK_FAIL to LINK_FAILED,
                                                                 and LPI_K to RX_CB, RX_INVALID, or IDLE_D.
                                                                 Change in rx_lpi_active state. */
        uint64_t eee_rx_link_fail      : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets CGX(0..3)_GMP_PCS_INT(0..3)[EEE_RX_LINK_FAIL].
                                                                 Internal:
                                                                 PCS RX entered RX_LINK_FAIL state.  Indicates that RX LPI Sequence described
                                                                 in 802.3-2012 Figure 36-7c has being violated. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_gmp_pcs_intx_w1s bdk_cgxx_gmp_pcs_intx_w1s_t;

static inline uint64_t BDK_CGXX_GMP_PCS_INTX_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_INTX_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_INTX_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_INTX_W1S(a,b) bdk_cgxx_gmp_pcs_intx_w1s_t
#define bustype_BDK_CGXX_GMP_PCS_INTX_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_INTX_W1S(a,b) "CGXX_GMP_PCS_INTX_W1S"
#define device_bar_BDK_CGXX_GMP_PCS_INTX_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_INTX_W1S(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_INTX_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_link#_timer
 *
 * CGX GMP PCS Link Timer Registers
 * This is the 1.6 ms nominal link timer register.
 */
union bdk_cgxx_gmp_pcs_linkx_timer
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_linkx_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t count                 : 16; /**< [ 15:  0](R/W) Should be 1.6 ms for SGMII/QSGMII and 10 ms otherwise. Units are microseconds.
                                                                 (100*number of rst__gbl_100mhz_sclk_edge edges: 100 MHz or 10 ns).
                                                                 Reset value results in a 1.6 ms link timer. */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 16; /**< [ 15:  0](R/W) Should be 1.6 ms for SGMII/QSGMII and 10 ms otherwise. Units are microseconds.
                                                                 (100*number of rst__gbl_100mhz_sclk_edge edges: 100 MHz or 10 ns).
                                                                 Reset value results in a 1.6 ms link timer. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_linkx_timer_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_linkx_timer bdk_cgxx_gmp_pcs_linkx_timer_t;

static inline uint64_t BDK_CGXX_GMP_PCS_LINKX_TIMER(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_LINKX_TIMER(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_LINKX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_LINKX_TIMER(a,b) bdk_cgxx_gmp_pcs_linkx_timer_t
#define bustype_BDK_CGXX_GMP_PCS_LINKX_TIMER(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_LINKX_TIMER(a,b) "CGXX_GMP_PCS_LINKX_TIMER"
#define device_bar_BDK_CGXX_GMP_PCS_LINKX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_LINKX_TIMER(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_LINKX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_misc#_ctl
 *
 * CGX GMP SGMII Miscellaneous Control Registers
 * Internal:
 * SGMII bit [12] is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate SGMII or
 * 1000Base-X modes.
 *
 * Note: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if
 * [MAC_PHY] is set (1=PHY mode). If the bit is not set (0=MAC mode), the
 * tx_Config_Reg\<14\> becomes ACK bit and tx_Config_Reg\<0\> is always 1.
 * All other bits in tx_Config_Reg sent will be 0. The PHY dictates the Auto Negotiation results.
 */
union bdk_cgxx_gmp_pcs_miscx_ctl
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_miscx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t qsgmii_comma_wd_en    : 1;  /**< [ 32: 32](R/W) QSGMII comma watchdog byte counter enable. */
        uint64_t qsgmii_comma_wd       : 16; /**< [ 31: 16](R/W) QSGMII comma watchdog byte counter. This counter is used in QSGMII mode and
                                                                 counts incoming bytes to ensure state transitions in the PCS receive side state
                                                                 machine when disparity enable is turned off and bad code groups and commas are
                                                                 not communicated from the code group processor after code group lock. */
        uint64_t reserved_14_15        : 2;
        uint64_t disp_en               : 1;  /**< [ 13: 13](R/W) Disparity check enable. When using CGX_LMAC_TYPES_E::QSGMII the running
                                                                 disparity check should be disabled to prevent propagation across ports. */
        uint64_t reserved_12           : 1;
        uint64_t gmxeno                : 1;  /**< [ 11: 11](R/W) GMI enable override. When set, forces GMI to appear disabled. The enable/disable status of
                                                                 GMI is checked only at SOP of every packet. */
        uint64_t loopbck2              : 1;  /**< [ 10: 10](R/W) Sets external loopback mode to return RX data back out via the TX data path. 0 = No
                                                                 loopback. 1 = Loopback.
                                                                 LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
        uint64_t mac_phy               : 1;  /**< [  9:  9](R/W) MAC/PHY.
                                                                 0 = MAC.
                                                                 1 = PHY decides the tx_Config_Reg value to be sent during autonegotiation. */
        uint64_t mode                  : 1;  /**< [  8:  8](R/W) Mode bit.

                                                                 0 = SGMII mode is selected and the following note applies.
                                                                 The SGMII AN advertisement register (CGX()_GMP_PCS_SGM()_AN_ADV) is sent during
                                                                 autonegotiation if CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
                                                                 = 0 (MAC mode), the tx_Config_Reg\<14\> becomes ACK bit and \<0\> is always 1. All other bits
                                                                 in tx_Config_Reg sent are 0. The PHY dictates the autonegotiation results.

                                                                 1 = 1000Base-X mode is selected. Autonegotiation follows IEEE 802.3 clause 37. */
        uint64_t an_ovrd               : 1;  /**< [  7:  7](R/W) Autonegotiation results override:
                                                                 0 = Disable.
                                                                 1 = Enable override. Autonegotiation is allowed to happen but the results are ignored
                                                                 when this bit is set.  Duplex and Link speed values are set from CGX()_GMP_PCS_MISC()_CTL. */
        uint64_t samp_pt               : 7;  /**< [  6:  0](R/W) Byte number in elongated frames for 10/100 Mb/s operation for data sampling on RX side in
                                                                 PCS. Recommended values are 0x5 for 100 Mb/s operation and 0x32 for 10 Mb/s operation.

                                                                 For 10 Mb/s operation, this field should be set to a value less than 99 and greater than
                                                                 0.
                                                                 If set out of this range, a value of 50 is used for actual sampling internally without
                                                                 affecting the CSR field.

                                                                 For 100 Mb/s operation this field should be set to a value less than 9 and greater than 0.
                                                                 If set out of this range, a value of 5 is used for actual sampling internally without
                                                                 affecting the CSR field. */
#else /* Word 0 - Little Endian */
        uint64_t samp_pt               : 7;  /**< [  6:  0](R/W) Byte number in elongated frames for 10/100 Mb/s operation for data sampling on RX side in
                                                                 PCS. Recommended values are 0x5 for 100 Mb/s operation and 0x32 for 10 Mb/s operation.

                                                                 For 10 Mb/s operation, this field should be set to a value less than 99 and greater than
                                                                 0.
                                                                 If set out of this range, a value of 50 is used for actual sampling internally without
                                                                 affecting the CSR field.

                                                                 For 100 Mb/s operation this field should be set to a value less than 9 and greater than 0.
                                                                 If set out of this range, a value of 5 is used for actual sampling internally without
                                                                 affecting the CSR field. */
        uint64_t an_ovrd               : 1;  /**< [  7:  7](R/W) Autonegotiation results override:
                                                                 0 = Disable.
                                                                 1 = Enable override. Autonegotiation is allowed to happen but the results are ignored
                                                                 when this bit is set.  Duplex and Link speed values are set from CGX()_GMP_PCS_MISC()_CTL. */
        uint64_t mode                  : 1;  /**< [  8:  8](R/W) Mode bit.

                                                                 0 = SGMII mode is selected and the following note applies.
                                                                 The SGMII AN advertisement register (CGX()_GMP_PCS_SGM()_AN_ADV) is sent during
                                                                 autonegotiation if CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
                                                                 = 0 (MAC mode), the tx_Config_Reg\<14\> becomes ACK bit and \<0\> is always 1. All other bits
                                                                 in tx_Config_Reg sent are 0. The PHY dictates the autonegotiation results.

                                                                 1 = 1000Base-X mode is selected. Autonegotiation follows IEEE 802.3 clause 37. */
        uint64_t mac_phy               : 1;  /**< [  9:  9](R/W) MAC/PHY.
                                                                 0 = MAC.
                                                                 1 = PHY decides the tx_Config_Reg value to be sent during autonegotiation. */
        uint64_t loopbck2              : 1;  /**< [ 10: 10](R/W) Sets external loopback mode to return RX data back out via the TX data path. 0 = No
                                                                 loopback. 1 = Loopback.
                                                                 LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
        uint64_t gmxeno                : 1;  /**< [ 11: 11](R/W) GMI enable override. When set, forces GMI to appear disabled. The enable/disable status of
                                                                 GMI is checked only at SOP of every packet. */
        uint64_t reserved_12           : 1;
        uint64_t disp_en               : 1;  /**< [ 13: 13](R/W) Disparity check enable. When using CGX_LMAC_TYPES_E::QSGMII the running
                                                                 disparity check should be disabled to prevent propagation across ports. */
        uint64_t reserved_14_15        : 2;
        uint64_t qsgmii_comma_wd       : 16; /**< [ 31: 16](R/W) QSGMII comma watchdog byte counter. This counter is used in QSGMII mode and
                                                                 counts incoming bytes to ensure state transitions in the PCS receive side state
                                                                 machine when disparity enable is turned off and bad code groups and commas are
                                                                 not communicated from the code group processor after code group lock. */
        uint64_t qsgmii_comma_wd_en    : 1;  /**< [ 32: 32](R/W) QSGMII comma watchdog byte counter enable. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    struct bdk_cgxx_gmp_pcs_miscx_ctl_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t reserved_33_35        : 3;
        uint64_t qsgmii_comma_wd_en    : 1;  /**< [ 32: 32](R/W) QSGMII comma watchdog byte counter enable. */
        uint64_t qsgmii_comma_wd       : 16; /**< [ 31: 16](R/W) QSGMII comma watchdog byte counter. This counter is used in QSGMII mode and
                                                                 counts incoming bytes to ensure state transitions in the PCS receive side state
                                                                 machine when disparity enable is turned off and bad code groups and commas are
                                                                 not communicated from the code group processor after code group lock. */
        uint64_t reserved_14_15        : 2;
        uint64_t disp_en               : 1;  /**< [ 13: 13](R/W) Disparity check enable. When using CGX_LMAC_TYPES_E::QSGMII the running
                                                                 disparity check should be disabled to prevent propagation across ports. */
        uint64_t reserved_12           : 1;
        uint64_t gmxeno                : 1;  /**< [ 11: 11](R/W) GMI enable override. When set, forces GMI to appear disabled. The enable/disable status of
                                                                 GMI is checked only at SOP of every packet. */
        uint64_t loopbck2              : 1;  /**< [ 10: 10](R/W) Sets external loopback mode to return RX data back out via the TX data path. 0 = No
                                                                 loopback. 1 = Loopback.
                                                                 LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
        uint64_t mac_phy               : 1;  /**< [  9:  9](R/W) MAC/PHY.
                                                                 0 = MAC.
                                                                 1 = PHY decides the tx_Config_Reg value to be sent during autonegotiation. */
        uint64_t mode                  : 1;  /**< [  8:  8](R/W) Mode bit.

                                                                 0 = SGMII mode is selected and the following note applies.
                                                                 The SGMII AN advertisement register (CGX()_GMP_PCS_SGM()_AN_ADV) is sent during
                                                                 autonegotiation if CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
                                                                 = 0 (MAC mode), the tx_Config_Reg\<14\> becomes ACK bit and \<0\> is always 1. All other bits
                                                                 in tx_Config_Reg sent are 0. The PHY dictates the autonegotiation results.

                                                                 1 = 1000Base-X mode is selected. Autonegotiation follows IEEE 802.3 clause 37. */
        uint64_t an_ovrd               : 1;  /**< [  7:  7](R/W) Autonegotiation results override:
                                                                 0 = Disable.
                                                                 1 = Enable override. Autonegotiation is allowed to happen but the results are ignored
                                                                 when this bit is set.  Duplex and Link speed values are set from CGX()_GMP_PCS_MISC()_CTL. */
        uint64_t samp_pt               : 7;  /**< [  6:  0](R/W) Byte number in elongated frames for 10/100 Mb/s operation for data sampling on RX side in
                                                                 PCS. Recommended values are 0x5 for 100 Mb/s operation and 0x32 for 10 Mb/s operation.

                                                                 For 10 Mb/s operation, this field should be set to a value less than 99 and greater than
                                                                 0.
                                                                 If set out of this range, a value of 50 is used for actual sampling internally without
                                                                 affecting the CSR field.

                                                                 For 100 Mb/s operation this field should be set to a value less than 9 and greater than 0.
                                                                 If set out of this range, a value of 5 is used for actual sampling internally without
                                                                 affecting the CSR field. */
#else /* Word 0 - Little Endian */
        uint64_t samp_pt               : 7;  /**< [  6:  0](R/W) Byte number in elongated frames for 10/100 Mb/s operation for data sampling on RX side in
                                                                 PCS. Recommended values are 0x5 for 100 Mb/s operation and 0x32 for 10 Mb/s operation.

                                                                 For 10 Mb/s operation, this field should be set to a value less than 99 and greater than
                                                                 0.
                                                                 If set out of this range, a value of 50 is used for actual sampling internally without
                                                                 affecting the CSR field.

                                                                 For 100 Mb/s operation this field should be set to a value less than 9 and greater than 0.
                                                                 If set out of this range, a value of 5 is used for actual sampling internally without
                                                                 affecting the CSR field. */
        uint64_t an_ovrd               : 1;  /**< [  7:  7](R/W) Autonegotiation results override:
                                                                 0 = Disable.
                                                                 1 = Enable override. Autonegotiation is allowed to happen but the results are ignored
                                                                 when this bit is set.  Duplex and Link speed values are set from CGX()_GMP_PCS_MISC()_CTL. */
        uint64_t mode                  : 1;  /**< [  8:  8](R/W) Mode bit.

                                                                 0 = SGMII mode is selected and the following note applies.
                                                                 The SGMII AN advertisement register (CGX()_GMP_PCS_SGM()_AN_ADV) is sent during
                                                                 autonegotiation if CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
                                                                 = 0 (MAC mode), the tx_Config_Reg\<14\> becomes ACK bit and \<0\> is always 1. All other bits
                                                                 in tx_Config_Reg sent are 0. The PHY dictates the autonegotiation results.

                                                                 1 = 1000Base-X mode is selected. Autonegotiation follows IEEE 802.3 clause 37. */
        uint64_t mac_phy               : 1;  /**< [  9:  9](R/W) MAC/PHY.
                                                                 0 = MAC.
                                                                 1 = PHY decides the tx_Config_Reg value to be sent during autonegotiation. */
        uint64_t loopbck2              : 1;  /**< [ 10: 10](R/W) Sets external loopback mode to return RX data back out via the TX data path. 0 = No
                                                                 loopback. 1 = Loopback.
                                                                 LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
        uint64_t gmxeno                : 1;  /**< [ 11: 11](R/W) GMI enable override. When set, forces GMI to appear disabled. The enable/disable status of
                                                                 GMI is checked only at SOP of every packet. */
        uint64_t reserved_12           : 1;
        uint64_t disp_en               : 1;  /**< [ 13: 13](R/W) Disparity check enable. When using CGX_LMAC_TYPES_E::QSGMII the running
                                                                 disparity check should be disabled to prevent propagation across ports. */
        uint64_t reserved_14_15        : 2;
        uint64_t qsgmii_comma_wd       : 16; /**< [ 31: 16](R/W) QSGMII comma watchdog byte counter. This counter is used in QSGMII mode and
                                                                 counts incoming bytes to ensure state transitions in the PCS receive side state
                                                                 machine when disparity enable is turned off and bad code groups and commas are
                                                                 not communicated from the code group processor after code group lock. */
        uint64_t qsgmii_comma_wd_en    : 1;  /**< [ 32: 32](R/W) QSGMII comma watchdog byte counter enable. */
        uint64_t reserved_33_35        : 3;
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_cgxx_gmp_pcs_miscx_ctl bdk_cgxx_gmp_pcs_miscx_ctl_t;

static inline uint64_t BDK_CGXX_GMP_PCS_MISCX_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_MISCX_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030078ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_MISCX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_MISCX_CTL(a,b) bdk_cgxx_gmp_pcs_miscx_ctl_t
#define bustype_BDK_CGXX_GMP_PCS_MISCX_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_MISCX_CTL(a,b) "CGXX_GMP_PCS_MISCX_CTL"
#define device_bar_BDK_CGXX_GMP_PCS_MISCX_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_MISCX_CTL(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_MISCX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_mr#_control
 *
 * CGX GMP PCS Control Registers
 */
union bdk_cgxx_gmp_pcs_mrx_control
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_mrx_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) Set to reset.
                                                                 0 = Normal operation.
                                                                 1 = Software PCS reset.

                                                                 The bit returns to 0 after PCS has been reset. Takes 32 coprocessor-clock cycles to reset
                                                                 PCS. This bit, when set, also drains the TX GMI FIFO and can be used as a FIFO draining
                                                                 mechanism for both SerDes reset conditions and for XCV reset conditions. */
        uint64_t loopbck1              : 1;  /**< [ 14: 14](R/W) Enable loopback:
                                                                   0 = Normal operation.
                                                                   1 = Internal loopback mode.

                                                                 The loopback mode returns loopback TX data from GMII TX back to GMII RX interface. The
                                                                 loopback happens in the PCS module. Autonegotiation is disabled even if [AN_EN] is set
                                                                 during loopback. */
        uint64_t spdlsb                : 1;  /**< [ 13: 13](R/W) Least-significant bit of the link-speed field, i.e. SPD\<0\>. Refer to SPDMSB. */
        uint64_t an_en                 : 1;  /**< [ 12: 12](R/W) Autonegotiation enable. */
        uint64_t pwr_dn                : 1;  /**< [ 11: 11](R/W) Power down:
                                                                   0 = Normal operation.
                                                                   1 = Power down (hardware reset). */
        uint64_t reserved_10           : 1;
        uint64_t rst_an                : 1;  /**< [  9:  9](R/W/H) Reset autonegotiation. When set, if [AN_EN] = 1 and
                                                                 CGX()_GMP_PCS_MR()_STATUS[AN_ABIL] = 1, autonegotiation begins. Otherwise,
                                                                 software write requests are ignored and this bit remains at 0. This bit clears itself to
                                                                 0, when autonegotiation starts. */
        uint64_t dup                   : 1;  /**< [  8:  8](R/W) Duplex mode:
                                                                   0 = half duplex; effective only if autonegotiation is disabled.
                                                                   1 = full duplex.

                                                                 If CGX()_GMP_PCS_MR()_STATUS \<15:9\> and
                                                                 CGX()_GMP_PCS_AN()_ADV\<15:12\> allow only one duplex mode, this bit corresponds to
                                                                 that value and any attempts to write are ignored. */
        uint64_t coltst                : 1;  /**< [  7:  7](R/W) Enable COL signal test.
                                                                 During COL test, the COL signal reflects the GMII TX_EN signal with less than 16BT delay. */
        uint64_t spdmsb                : 1;  /**< [  6:  6](R/W) Link speed most-significant bit, i.e SPD\<1\>; effective only if autonegotiation is
                                                                 disabled.

                                                                 \<pre\>
                                                                 [SPDMSB]   [SPDLSB]   Link Speed
                                                                  0          0         10 Mb/s
                                                                  0          1         100 Mb/s
                                                                  1          0         1000 Mb/s
                                                                  1          1         reserved
                                                                 \</pre\> */
        uint64_t uni                   : 1;  /**< [  5:  5](R/W) Unidirectional (IEEE 802.3-2005, Clause 66.2). When set to 1, this bit overrides [AN_EN]
                                                                 and
                                                                 disables the autonegotiation variable mr_an_enable. Used in both 1000BASE-X and
                                                                 SGMII/QSGMII
                                                                 modes. */
        uint64_t reserved_0_4          : 5;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_4          : 5;
        uint64_t uni                   : 1;  /**< [  5:  5](R/W) Unidirectional (IEEE 802.3-2005, Clause 66.2). When set to 1, this bit overrides [AN_EN]
                                                                 and
                                                                 disables the autonegotiation variable mr_an_enable. Used in both 1000BASE-X and
                                                                 SGMII/QSGMII
                                                                 modes. */
        uint64_t spdmsb                : 1;  /**< [  6:  6](R/W) Link speed most-significant bit, i.e SPD\<1\>; effective only if autonegotiation is
                                                                 disabled.

                                                                 \<pre\>
                                                                 [SPDMSB]   [SPDLSB]   Link Speed
                                                                  0          0         10 Mb/s
                                                                  0          1         100 Mb/s
                                                                  1          0         1000 Mb/s
                                                                  1          1         reserved
                                                                 \</pre\> */
        uint64_t coltst                : 1;  /**< [  7:  7](R/W) Enable COL signal test.
                                                                 During COL test, the COL signal reflects the GMII TX_EN signal with less than 16BT delay. */
        uint64_t dup                   : 1;  /**< [  8:  8](R/W) Duplex mode:
                                                                   0 = half duplex; effective only if autonegotiation is disabled.
                                                                   1 = full duplex.

                                                                 If CGX()_GMP_PCS_MR()_STATUS \<15:9\> and
                                                                 CGX()_GMP_PCS_AN()_ADV\<15:12\> allow only one duplex mode, this bit corresponds to
                                                                 that value and any attempts to write are ignored. */
        uint64_t rst_an                : 1;  /**< [  9:  9](R/W/H) Reset autonegotiation. When set, if [AN_EN] = 1 and
                                                                 CGX()_GMP_PCS_MR()_STATUS[AN_ABIL] = 1, autonegotiation begins. Otherwise,
                                                                 software write requests are ignored and this bit remains at 0. This bit clears itself to
                                                                 0, when autonegotiation starts. */
        uint64_t reserved_10           : 1;
        uint64_t pwr_dn                : 1;  /**< [ 11: 11](R/W) Power down:
                                                                   0 = Normal operation.
                                                                   1 = Power down (hardware reset). */
        uint64_t an_en                 : 1;  /**< [ 12: 12](R/W) Autonegotiation enable. */
        uint64_t spdlsb                : 1;  /**< [ 13: 13](R/W) Least-significant bit of the link-speed field, i.e. SPD\<0\>. Refer to SPDMSB. */
        uint64_t loopbck1              : 1;  /**< [ 14: 14](R/W) Enable loopback:
                                                                   0 = Normal operation.
                                                                   1 = Internal loopback mode.

                                                                 The loopback mode returns loopback TX data from GMII TX back to GMII RX interface. The
                                                                 loopback happens in the PCS module. Autonegotiation is disabled even if [AN_EN] is set
                                                                 during loopback. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) Set to reset.
                                                                 0 = Normal operation.
                                                                 1 = Software PCS reset.

                                                                 The bit returns to 0 after PCS has been reset. Takes 32 coprocessor-clock cycles to reset
                                                                 PCS. This bit, when set, also drains the TX GMI FIFO and can be used as a FIFO draining
                                                                 mechanism for both SerDes reset conditions and for XCV reset conditions. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_mrx_control_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_mrx_control bdk_cgxx_gmp_pcs_mrx_control_t;

static inline uint64_t BDK_CGXX_GMP_PCS_MRX_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_MRX_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_MRX_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_MRX_CONTROL(a,b) bdk_cgxx_gmp_pcs_mrx_control_t
#define bustype_BDK_CGXX_GMP_PCS_MRX_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_MRX_CONTROL(a,b) "CGXX_GMP_PCS_MRX_CONTROL"
#define device_bar_BDK_CGXX_GMP_PCS_MRX_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_MRX_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_MRX_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_mr#_status
 *
 * CGX GMP PCS Status Registers
 * Bits \<15:9\> in this register indicate the ability to operate when
 * CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set to MAC mode. Bits \<15:9\> are always read as
 * 0, indicating that the chip cannot operate in the corresponding modes. The field [RM_FLT] is a
 * 'don't care' when the selected mode is SGMII/QSGMII.
 */
union bdk_cgxx_gmp_pcs_mrx_status
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_mrx_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t hun_t4                : 1;  /**< [ 15: 15](RO/H) Indicates 100BASE-T4 capable. */
        uint64_t hun_xfd               : 1;  /**< [ 14: 14](RO/H) Indicates 100BASE-X full duplex. */
        uint64_t hun_xhd               : 1;  /**< [ 13: 13](RO/H) Indicates 100BASE-X half duplex. */
        uint64_t ten_fd                : 1;  /**< [ 12: 12](RO/H) Indicates 10Mb/s full duplex. */
        uint64_t ten_hd                : 1;  /**< [ 11: 11](RO/H) Indicates 10Mb/s half duplex. */
        uint64_t hun_t2fd              : 1;  /**< [ 10: 10](RO/H) Indicates 100BASE-T2 full duplex. */
        uint64_t hun_t2hd              : 1;  /**< [  9:  9](RO/H) Indicates 100BASE-T2 half duplex. */
        uint64_t ext_st                : 1;  /**< [  8:  8](RO/H) Extended status information. When set to 1, indicates that additional status data is
                                                                 available in CGX()_GMP_PCS_AN()_EXT_ST. */
        uint64_t reserved_7            : 1;
        uint64_t prb_sup               : 1;  /**< [  6:  6](RO/H) Preamble not needed.
                                                                 0 = Cannot accept frames without preamble bytes.
                                                                 1 = Can work without preamble bytes at the beginning of frames. */
        uint64_t an_cpt                : 1;  /**< [  5:  5](RO/H) Indicates autonegotiation is complete; the contents of the
                                                                 CGX()_GMP_PCS_AN()_RESULTS are valid. */
        uint64_t rm_flt                : 1;  /**< [  4:  4](RO/H) Indicates remote fault condition occurred. This bit implements a latching-high behavior.
                                                                 It is cleared when software reads this register or when
                                                                 CGX()_GMP_PCS_MR()_CONTROL[RESET] is asserted.
                                                                 See CGX()_GMP_PCS_AN()_ADV[REM_FLT] for fault conditions. */
        uint64_t an_abil               : 1;  /**< [  3:  3](RO/H) Indicates autonegotiation capable. */
        uint64_t lnk_st                : 1;  /**< [  2:  2](RO/H) Link state:
                                                                   0 = link down.
                                                                   1 = link up.

                                                                 Set during autonegotiation process. Set whenever XMIT = DATA. Latching-low behavior when
                                                                 link goes down. Link down value of the bit stays low until software reads the register. */
        uint64_t reserved_1            : 1;
        uint64_t extnd                 : 1;  /**< [  0:  0](RO/H) This field is always 0, extended capability registers not present. */
#else /* Word 0 - Little Endian */
        uint64_t extnd                 : 1;  /**< [  0:  0](RO/H) This field is always 0, extended capability registers not present. */
        uint64_t reserved_1            : 1;
        uint64_t lnk_st                : 1;  /**< [  2:  2](RO/H) Link state:
                                                                   0 = link down.
                                                                   1 = link up.

                                                                 Set during autonegotiation process. Set whenever XMIT = DATA. Latching-low behavior when
                                                                 link goes down. Link down value of the bit stays low until software reads the register. */
        uint64_t an_abil               : 1;  /**< [  3:  3](RO/H) Indicates autonegotiation capable. */
        uint64_t rm_flt                : 1;  /**< [  4:  4](RO/H) Indicates remote fault condition occurred. This bit implements a latching-high behavior.
                                                                 It is cleared when software reads this register or when
                                                                 CGX()_GMP_PCS_MR()_CONTROL[RESET] is asserted.
                                                                 See CGX()_GMP_PCS_AN()_ADV[REM_FLT] for fault conditions. */
        uint64_t an_cpt                : 1;  /**< [  5:  5](RO/H) Indicates autonegotiation is complete; the contents of the
                                                                 CGX()_GMP_PCS_AN()_RESULTS are valid. */
        uint64_t prb_sup               : 1;  /**< [  6:  6](RO/H) Preamble not needed.
                                                                 0 = Cannot accept frames without preamble bytes.
                                                                 1 = Can work without preamble bytes at the beginning of frames. */
        uint64_t reserved_7            : 1;
        uint64_t ext_st                : 1;  /**< [  8:  8](RO/H) Extended status information. When set to 1, indicates that additional status data is
                                                                 available in CGX()_GMP_PCS_AN()_EXT_ST. */
        uint64_t hun_t2hd              : 1;  /**< [  9:  9](RO/H) Indicates 100BASE-T2 half duplex. */
        uint64_t hun_t2fd              : 1;  /**< [ 10: 10](RO/H) Indicates 100BASE-T2 full duplex. */
        uint64_t ten_hd                : 1;  /**< [ 11: 11](RO/H) Indicates 10Mb/s half duplex. */
        uint64_t ten_fd                : 1;  /**< [ 12: 12](RO/H) Indicates 10Mb/s full duplex. */
        uint64_t hun_xhd               : 1;  /**< [ 13: 13](RO/H) Indicates 100BASE-X half duplex. */
        uint64_t hun_xfd               : 1;  /**< [ 14: 14](RO/H) Indicates 100BASE-X full duplex. */
        uint64_t hun_t4                : 1;  /**< [ 15: 15](RO/H) Indicates 100BASE-T4 capable. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_mrx_status_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_mrx_status bdk_cgxx_gmp_pcs_mrx_status_t;

static inline uint64_t BDK_CGXX_GMP_PCS_MRX_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_MRX_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_MRX_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_MRX_STATUS(a,b) bdk_cgxx_gmp_pcs_mrx_status_t
#define bustype_BDK_CGXX_GMP_PCS_MRX_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_MRX_STATUS(a,b) "CGXX_GMP_PCS_MRX_STATUS"
#define device_bar_BDK_CGXX_GMP_PCS_MRX_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_MRX_STATUS(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_MRX_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_rx#_states
 *
 * CGX GMP PCS RX State-Machines States Registers
 */
union bdk_cgxx_gmp_pcs_rxx_states
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_rxx_states_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rx_bad                : 1;  /**< [ 15: 15](RO/H) Receive state machine is in an illegal state. */
        uint64_t rx_st                 : 5;  /**< [ 14: 10](RO/H) Receive state-machine state. */
        uint64_t sync_bad              : 1;  /**< [  9:  9](RO/H) Receive synchronization state machine is in an illegal state. */
        uint64_t sync                  : 4;  /**< [  8:  5](RO/H) Receive synchronization state-machine state. */
        uint64_t an_bad                : 1;  /**< [  4:  4](RO/H) Autonegotiation state machine is in an illegal state. */
        uint64_t an_st                 : 4;  /**< [  3:  0](RO/H) Autonegotiation state-machine state. */
#else /* Word 0 - Little Endian */
        uint64_t an_st                 : 4;  /**< [  3:  0](RO/H) Autonegotiation state-machine state. */
        uint64_t an_bad                : 1;  /**< [  4:  4](RO/H) Autonegotiation state machine is in an illegal state. */
        uint64_t sync                  : 4;  /**< [  8:  5](RO/H) Receive synchronization state-machine state. */
        uint64_t sync_bad              : 1;  /**< [  9:  9](RO/H) Receive synchronization state machine is in an illegal state. */
        uint64_t rx_st                 : 5;  /**< [ 14: 10](RO/H) Receive state-machine state. */
        uint64_t rx_bad                : 1;  /**< [ 15: 15](RO/H) Receive state machine is in an illegal state. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_rxx_states_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_rxx_states bdk_cgxx_gmp_pcs_rxx_states_t;

static inline uint64_t BDK_CGXX_GMP_PCS_RXX_STATES(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_RXX_STATES(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030058ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_RXX_STATES", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_RXX_STATES(a,b) bdk_cgxx_gmp_pcs_rxx_states_t
#define bustype_BDK_CGXX_GMP_PCS_RXX_STATES(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_RXX_STATES(a,b) "CGXX_GMP_PCS_RXX_STATES"
#define device_bar_BDK_CGXX_GMP_PCS_RXX_STATES(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_RXX_STATES(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_RXX_STATES(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_rx#_sync
 *
 * CGX GMP PCS Code Group Synchronization Registers
 */
union bdk_cgxx_gmp_pcs_rxx_sync
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_rxx_sync_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t sync                  : 1;  /**< [  1:  1](RO/H) When set, code group synchronization achieved. 802.3-2012 Clause 36 code_sync_status. */
        uint64_t bit_lock              : 1;  /**< [  0:  0](RO/H) When set, bit lock achieved. */
#else /* Word 0 - Little Endian */
        uint64_t bit_lock              : 1;  /**< [  0:  0](RO/H) When set, bit lock achieved. */
        uint64_t sync                  : 1;  /**< [  1:  1](RO/H) When set, code group synchronization achieved. 802.3-2012 Clause 36 code_sync_status. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_rxx_sync_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_rxx_sync bdk_cgxx_gmp_pcs_rxx_sync_t;

static inline uint64_t BDK_CGXX_GMP_PCS_RXX_SYNC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_RXX_SYNC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030050ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_RXX_SYNC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_RXX_SYNC(a,b) bdk_cgxx_gmp_pcs_rxx_sync_t
#define bustype_BDK_CGXX_GMP_PCS_RXX_SYNC(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_RXX_SYNC(a,b) "CGXX_GMP_PCS_RXX_SYNC"
#define device_bar_BDK_CGXX_GMP_PCS_RXX_SYNC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_RXX_SYNC(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_RXX_SYNC(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_sgm#_an_adv
 *
 * CGX GMP PCS SGMII Autonegotiation Advertisement Registers
 * This is the SGMII autonegotiation advertisement register (sent out as tx_Config_Reg\<15:0\> as
 * defined in IEEE 802.3 clause 37). This register is sent during autonegotiation if
 * CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is not set (0 =
 * MAC mode), then tx_Config_Reg\<14\> becomes ACK bit and tx_Config_Reg\<0\> is always 1. All other
 * bits in tx_Config_Reg sent will be 0. The PHY dictates the autonegotiation results.
 */
union bdk_cgxx_gmp_pcs_sgmx_an_adv
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_sgmx_an_adv_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t link                  : 1;  /**< [ 15: 15](R/W) Link status: 1 = Link up. 0 = Link down. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Autonegotiation acknowledgement. */
        uint64_t reserved_13           : 1;
        uint64_t dup                   : 1;  /**< [ 12: 12](R/W) Duplex mode: 1 = full duplex, 0 = half duplex. */
        uint64_t speed                 : 2;  /**< [ 11: 10](R/W) Link speed:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t reserved_1_9          : 9;
        uint64_t one                   : 1;  /**< [  0:  0](RO/H) Always set to match tx_Config_Reg\<0\>. */
#else /* Word 0 - Little Endian */
        uint64_t one                   : 1;  /**< [  0:  0](RO/H) Always set to match tx_Config_Reg\<0\>. */
        uint64_t reserved_1_9          : 9;
        uint64_t speed                 : 2;  /**< [ 11: 10](R/W) Link speed:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t dup                   : 1;  /**< [ 12: 12](R/W) Duplex mode: 1 = full duplex, 0 = half duplex. */
        uint64_t reserved_13           : 1;
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Autonegotiation acknowledgement. */
        uint64_t link                  : 1;  /**< [ 15: 15](R/W) Link status: 1 = Link up. 0 = Link down. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_sgmx_an_adv_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_sgmx_an_adv bdk_cgxx_gmp_pcs_sgmx_an_adv_t;

static inline uint64_t BDK_CGXX_GMP_PCS_SGMX_AN_ADV(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_SGMX_AN_ADV(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030068ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_SGMX_AN_ADV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_SGMX_AN_ADV(a,b) bdk_cgxx_gmp_pcs_sgmx_an_adv_t
#define bustype_BDK_CGXX_GMP_PCS_SGMX_AN_ADV(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_SGMX_AN_ADV(a,b) "CGXX_GMP_PCS_SGMX_AN_ADV"
#define device_bar_BDK_CGXX_GMP_PCS_SGMX_AN_ADV(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_SGMX_AN_ADV(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_SGMX_AN_ADV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_sgm#_lp_adv
 *
 * CGX GMP PCS SGMII Link-Partner-Advertisement Registers
 * This is the SGMII link partner advertisement register (received as rx_Config_Reg\<15:0\> as
 * defined in IEEE 802.3 clause 37).
 */
union bdk_cgxx_gmp_pcs_sgmx_lp_adv
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_sgmx_lp_adv_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t link                  : 1;  /**< [ 15: 15](RO/H) Link status: 1 = Link up. 0 = Link down. */
        uint64_t reserved_13_14        : 2;
        uint64_t dup                   : 1;  /**< [ 12: 12](RO/H) Duplex mode: 1 = Full duplex, 0 = Half duplex. */
        uint64_t speed                 : 2;  /**< [ 11: 10](RO/H) Link speed:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t reserved_1_9          : 9;
        uint64_t one                   : 1;  /**< [  0:  0](RO/H) Always set to match tx_Config_Reg\<0\> */
#else /* Word 0 - Little Endian */
        uint64_t one                   : 1;  /**< [  0:  0](RO/H) Always set to match tx_Config_Reg\<0\> */
        uint64_t reserved_1_9          : 9;
        uint64_t speed                 : 2;  /**< [ 11: 10](RO/H) Link speed:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t dup                   : 1;  /**< [ 12: 12](RO/H) Duplex mode: 1 = Full duplex, 0 = Half duplex. */
        uint64_t reserved_13_14        : 2;
        uint64_t link                  : 1;  /**< [ 15: 15](RO/H) Link status: 1 = Link up. 0 = Link down. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    struct bdk_cgxx_gmp_pcs_sgmx_lp_adv_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t link                  : 1;  /**< [ 15: 15](RO/H) Link status: 1 = Link up. 0 = Link down. */
        uint64_t reserved_14           : 1;
        uint64_t reserved_13           : 1;
        uint64_t dup                   : 1;  /**< [ 12: 12](RO/H) Duplex mode: 1 = Full duplex, 0 = Half duplex. */
        uint64_t speed                 : 2;  /**< [ 11: 10](RO/H) Link speed:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t reserved_1_9          : 9;
        uint64_t one                   : 1;  /**< [  0:  0](RO/H) Always set to match tx_Config_Reg\<0\> */
#else /* Word 0 - Little Endian */
        uint64_t one                   : 1;  /**< [  0:  0](RO/H) Always set to match tx_Config_Reg\<0\> */
        uint64_t reserved_1_9          : 9;
        uint64_t speed                 : 2;  /**< [ 11: 10](RO/H) Link speed:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = Reserved. */
        uint64_t dup                   : 1;  /**< [ 12: 12](RO/H) Duplex mode: 1 = Full duplex, 0 = Half duplex. */
        uint64_t reserved_13           : 1;
        uint64_t reserved_14           : 1;
        uint64_t link                  : 1;  /**< [ 15: 15](RO/H) Link status: 1 = Link up. 0 = Link down. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_cgxx_gmp_pcs_sgmx_lp_adv bdk_cgxx_gmp_pcs_sgmx_lp_adv_t;

static inline uint64_t BDK_CGXX_GMP_PCS_SGMX_LP_ADV(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_SGMX_LP_ADV(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030070ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_SGMX_LP_ADV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_SGMX_LP_ADV(a,b) bdk_cgxx_gmp_pcs_sgmx_lp_adv_t
#define bustype_BDK_CGXX_GMP_PCS_SGMX_LP_ADV(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_SGMX_LP_ADV(a,b) "CGXX_GMP_PCS_SGMX_LP_ADV"
#define device_bar_BDK_CGXX_GMP_PCS_SGMX_LP_ADV(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_SGMX_LP_ADV(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_SGMX_LP_ADV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_tx#_states
 *
 * CGX GMP PCS TX State-Machines States Registers
 */
union bdk_cgxx_gmp_pcs_txx_states
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_txx_states_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t xmit                  : 2;  /**< [  6:  5](RO/H) 0x0 = Undefined.
                                                                 0x1 = Config.
                                                                 0x2 = Idle.
                                                                 0x3 = Data. */
        uint64_t tx_bad                : 1;  /**< [  4:  4](RO/H) Transmit state machine in an illegal state. */
        uint64_t ord_st                : 4;  /**< [  3:  0](RO/H) Transmit ordered set state-machine state. */
#else /* Word 0 - Little Endian */
        uint64_t ord_st                : 4;  /**< [  3:  0](RO/H) Transmit ordered set state-machine state. */
        uint64_t tx_bad                : 1;  /**< [  4:  4](RO/H) Transmit state machine in an illegal state. */
        uint64_t xmit                  : 2;  /**< [  6:  5](RO/H) 0x0 = Undefined.
                                                                 0x1 = Config.
                                                                 0x2 = Idle.
                                                                 0x3 = Data. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_txx_states_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_txx_states bdk_cgxx_gmp_pcs_txx_states_t;

static inline uint64_t BDK_CGXX_GMP_PCS_TXX_STATES(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_TXX_STATES(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030060ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_TXX_STATES", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_TXX_STATES(a,b) bdk_cgxx_gmp_pcs_txx_states_t
#define bustype_BDK_CGXX_GMP_PCS_TXX_STATES(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_TXX_STATES(a,b) "CGXX_GMP_PCS_TXX_STATES"
#define device_bar_BDK_CGXX_GMP_PCS_TXX_STATES(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_TXX_STATES(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_TXX_STATES(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_gmp_pcs_tx_rx#_polarity
 *
 * CGX GMP PCS TX/RX Polarity Registers
 * CGX()_GMP_PCS_TX_RX()_POLARITY[AUTORXPL] shows correct polarity needed on the link
 * receive path after code group synchronization is achieved.  When LMAC_TYPE=QSGMII, only lane 0
 * polarity data and settings are relevant and settings for lanes 1, 2 and 3 are unused.
 */
union bdk_cgxx_gmp_pcs_tx_rxx_polarity
{
    uint64_t u;
    struct bdk_cgxx_gmp_pcs_tx_rxx_polarity_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t rxovrd                : 1;  /**< [  3:  3](R/W) RX polarity override.
                                                                 0 = [AUTORXPL] determines polarity.
                                                                 1 = [RXPLRT] determines polarity. */
        uint64_t autorxpl              : 1;  /**< [  2:  2](RO/H) Auto RX polarity detected:
                                                                 0 = Normal polarity.
                                                                 1 = Inverted polarity.

                                                                 This bit always represents the correct RX polarity setting needed for successful RX path
                                                                 operation, once a successful code group sync is obtained. */
        uint64_t rxplrt                : 1;  /**< [  1:  1](R/W) RX polarity: 0 = Normal polarity, 1 = Inverted polarity. */
        uint64_t txplrt                : 1;  /**< [  0:  0](R/W) TX polarity: 0 = Normal polarity, 1 = Inverted polarity. */
#else /* Word 0 - Little Endian */
        uint64_t txplrt                : 1;  /**< [  0:  0](R/W) TX polarity: 0 = Normal polarity, 1 = Inverted polarity. */
        uint64_t rxplrt                : 1;  /**< [  1:  1](R/W) RX polarity: 0 = Normal polarity, 1 = Inverted polarity. */
        uint64_t autorxpl              : 1;  /**< [  2:  2](RO/H) Auto RX polarity detected:
                                                                 0 = Normal polarity.
                                                                 1 = Inverted polarity.

                                                                 This bit always represents the correct RX polarity setting needed for successful RX path
                                                                 operation, once a successful code group sync is obtained. */
        uint64_t rxovrd                : 1;  /**< [  3:  3](R/W) RX polarity override.
                                                                 0 = [AUTORXPL] determines polarity.
                                                                 1 = [RXPLRT] determines polarity. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_gmp_pcs_tx_rxx_polarity_s cn; */
};
typedef union bdk_cgxx_gmp_pcs_tx_rxx_polarity bdk_cgxx_gmp_pcs_tx_rxx_polarity_t;

static inline uint64_t BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0030048ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0030048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0030048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_GMP_PCS_TX_RXX_POLARITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(a,b) bdk_cgxx_gmp_pcs_tx_rxx_polarity_t
#define bustype_BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(a,b) "CGXX_GMP_PCS_TX_RXX_POLARITY"
#define device_bar_BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(a,b) (a)
#define arguments_BDK_CGXX_GMP_PCS_TX_RXX_POLARITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_msix_pba#
 *
 * CGX MSI-X Pending Bit Array Registers
 * This register is the MSI-X PBA table, the bit number is indexed by the CGX_INT_VEC_E
 * enumeration.
 */
union bdk_cgxx_msix_pbax
{
    uint64_t u;
    struct bdk_cgxx_msix_pbax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated CGX()_MSIX_VEC()_CTL, enumerated by CGX_INT_VEC_E.
                                                                 Bits that have no associated CGX_INT_VEC_E are zero. */
#else /* Word 0 - Little Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated CGX()_MSIX_VEC()_CTL, enumerated by CGX_INT_VEC_E.
                                                                 Bits that have no associated CGX_INT_VEC_E are zero. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_msix_pbax_s cn; */
};
typedef union bdk_cgxx_msix_pbax bdk_cgxx_msix_pbax_t;

static inline uint64_t BDK_CGXX_MSIX_PBAX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_MSIX_PBAX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b==0)))
        return 0x87e0e04f0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b==0)))
        return 0x87e0e04f0000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b==0)))
        return 0x87e0e04f0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b==0)))
        return 0x87e0e04f0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    __bdk_csr_fatal("CGXX_MSIX_PBAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_MSIX_PBAX(a,b) bdk_cgxx_msix_pbax_t
#define bustype_BDK_CGXX_MSIX_PBAX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_MSIX_PBAX(a,b) "CGXX_MSIX_PBAX"
#define device_bar_BDK_CGXX_MSIX_PBAX(a,b) 0x4 /* PF_BAR4 */
#define busnum_BDK_CGXX_MSIX_PBAX(a,b) (a)
#define arguments_BDK_CGXX_MSIX_PBAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_msix_vec#_addr
 *
 * CGX MSI-X Vector Table Address Registers
 * This register is the MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
 */
union bdk_cgxx_msix_vecx_addr
{
    uint64_t u;
    struct bdk_cgxx_msix_vecx_addr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's CGX()_MSIX_VEC()_ADDR, CGX()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of CGX()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_CGX()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's CGX()_MSIX_VEC()_ADDR, CGX()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of CGX()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_CGX()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_msix_vecx_addr_s cn9; */
    /* struct bdk_cgxx_msix_vecx_addr_s cn96xxp1; */
    struct bdk_cgxx_msix_vecx_addr_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 The vector's IOVA is sent to the SMMU as nonsecure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1).

                                                                 1 = This vector's CGX()_MSIX_VEC()_ADDR, CGX()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of CGX()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.
                                                                 The vector's IOVA is sent to the SMMU as secure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1 or
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1).

                                                                 If PCCPF_CGX()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set.

                                                                 Also note the following:
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_EN]=1, all secure vectors (including secure
                                                                 VF vectors) will act as if PCCPF/PCCVF_XXX_MSIX_CAP_HDR[MSIXEN]=1,
                                                                 PCCPF/PCCVF_XXX_MSIX_CAP_HDR[FUNM]=0 and PCCPF/PCCVF_XXX_CMD[ME]=1.
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1, all secure vectors (including
                                                                 secure VF vectors) are considered physical, regardless of
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 The vector's IOVA is sent to the SMMU as nonsecure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1).

                                                                 1 = This vector's CGX()_MSIX_VEC()_ADDR, CGX()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of CGX()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.
                                                                 The vector's IOVA is sent to the SMMU as secure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1 or
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1).

                                                                 If PCCPF_CGX()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set.

                                                                 Also note the following:
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_EN]=1, all secure vectors (including secure
                                                                 VF vectors) will act as if PCCPF/PCCVF_XXX_MSIX_CAP_HDR[MSIXEN]=1,
                                                                 PCCPF/PCCVF_XXX_MSIX_CAP_HDR[FUNM]=0 and PCCPF/PCCVF_XXX_CMD[ME]=1.
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1, all secure vectors (including
                                                                 secure VF vectors) are considered physical, regardless of
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_cgxx_msix_vecx_addr_cn96xxp3 cn98xx; */
    /* struct bdk_cgxx_msix_vecx_addr_cn96xxp3 cnf95xx; */
    /* struct bdk_cgxx_msix_vecx_addr_cn96xxp3 loki; */
};
typedef union bdk_cgxx_msix_vecx_addr bdk_cgxx_msix_vecx_addr_t;

static inline uint64_t BDK_CGXX_MSIX_VECX_ADDR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_MSIX_VECX_ADDR(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS1_X) && ((a<=2) && (b<=37)))
        return 0x87e0e0400000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=2) && (b<=41)))
        return 0x87e0e0400000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=41)))
        return 0x87e0e0400000ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=37)))
        return 0x87e0e0400000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=37)))
        return 0x87e0e0400000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    __bdk_csr_fatal("CGXX_MSIX_VECX_ADDR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_MSIX_VECX_ADDR(a,b) bdk_cgxx_msix_vecx_addr_t
#define bustype_BDK_CGXX_MSIX_VECX_ADDR(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_MSIX_VECX_ADDR(a,b) "CGXX_MSIX_VECX_ADDR"
#define device_bar_BDK_CGXX_MSIX_VECX_ADDR(a,b) 0x4 /* PF_BAR4 */
#define busnum_BDK_CGXX_MSIX_VECX_ADDR(a,b) (a)
#define arguments_BDK_CGXX_MSIX_VECX_ADDR(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_msix_vec#_ctl
 *
 * CGX MSI-X Vector Table Control and Data Registers
 * This register is the MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
 */
union bdk_cgxx_msix_vecx_ctl
{
    uint64_t u;
    struct bdk_cgxx_msix_vecx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_msix_vecx_ctl_s cn; */
};
typedef union bdk_cgxx_msix_vecx_ctl bdk_cgxx_msix_vecx_ctl_t;

static inline uint64_t BDK_CGXX_MSIX_VECX_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_MSIX_VECX_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS1_X) && ((a<=2) && (b<=37)))
        return 0x87e0e0400008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=2) && (b<=41)))
        return 0x87e0e0400008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=41)))
        return 0x87e0e0400008ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=37)))
        return 0x87e0e0400008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=37)))
        return 0x87e0e0400008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3f);
    __bdk_csr_fatal("CGXX_MSIX_VECX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_MSIX_VECX_CTL(a,b) bdk_cgxx_msix_vecx_ctl_t
#define bustype_BDK_CGXX_MSIX_VECX_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_MSIX_VECX_CTL(a,b) "CGXX_MSIX_VECX_CTL"
#define device_bar_BDK_CGXX_MSIX_VECX_CTL(a,b) 0x4 /* PF_BAR4 */
#define busnum_BDK_CGXX_MSIX_VECX_CTL(a,b) (a)
#define arguments_BDK_CGXX_MSIX_VECX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_bp_test
 *
 * INTERNAL: CGX SMU TX Backpressure Test Registers
 */
union bdk_cgxx_smux_bp_test
{
    uint64_t u;
    struct bdk_cgxx_smux_bp_test_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t enable                : 4;  /**< [ 51: 48](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<51\> = Randomly defer TX.
                                                                 \<50\> = Mask LMAC TX ELB FIFO NPA (Next Packet Available) indication (introduce
                                                                 more IFG) and only works in RX to TX loopback mode.
                                                                 \<49\> = Mask LMAC TX FIFO NPA (Next Packet Available) indication (introduce more IFG).
                                                                 \<48\> = Mask LMAC PMAC TX length FIFO valid .
                                                                 NOTE: Setting multiple ENABLEs could slow down TX pipe significantly. */
        uint64_t reserved_24_47        : 24;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                    \<23:22\> = Config 3.
                                                                    \<21:20\> = Config 2.
                                                                    \<19:18\> = Config 1.
                                                                    \<17:16\> = Config 0.

                                                                  When using 0x0, the constant backpressure means the testbench must toggle the
                                                                  corresponding [ENABLE] bit to keep traffic flowing. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                    \<23:22\> = Config 3.
                                                                    \<21:20\> = Config 2.
                                                                    \<19:18\> = Config 1.
                                                                    \<17:16\> = Config 0.

                                                                  When using 0x0, the constant backpressure means the testbench must toggle the
                                                                  corresponding [ENABLE] bit to keep traffic flowing. */
        uint64_t reserved_24_47        : 24;
        uint64_t enable                : 4;  /**< [ 51: 48](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<51\> = Randomly defer TX.
                                                                 \<50\> = Mask LMAC TX ELB FIFO NPA (Next Packet Available) indication (introduce
                                                                 more IFG) and only works in RX to TX loopback mode.
                                                                 \<49\> = Mask LMAC TX FIFO NPA (Next Packet Available) indication (introduce more IFG).
                                                                 \<48\> = Mask LMAC PMAC TX length FIFO valid .
                                                                 NOTE: Setting multiple ENABLEs could slow down TX pipe significantly. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_bp_test_s cn; */
};
typedef union bdk_cgxx_smux_bp_test bdk_cgxx_smux_bp_test_t;

static inline uint64_t BDK_CGXX_SMUX_BP_TEST(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_BP_TEST(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020230ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_BP_TEST", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_BP_TEST(a,b) bdk_cgxx_smux_bp_test_t
#define bustype_BDK_CGXX_SMUX_BP_TEST(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_BP_TEST(a,b) "CGXX_SMUX_BP_TEST"
#define device_bar_BDK_CGXX_SMUX_BP_TEST(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_BP_TEST(a,b) (a)
#define arguments_BDK_CGXX_SMUX_BP_TEST(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_cbfc_ctl
 *
 * CGX SMU PFC Control Registers
 * Internal:
 * INTERNAL: XOFF for a specific class/channel \<i\> is XOFF\<i\> = ([PHYS_EN]\<i\> & cmr_rx_phys_bp) |
 * ([LOGL_EN]\<i\> & cmr_rx_logl_xoff\<i\>).
 */
union bdk_cgxx_smux_cbfc_ctl
{
    uint64_t u;
    struct bdk_cgxx_smux_cbfc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t phys_en               : 16; /**< [ 63: 48](R/W) Physical backpressure enable. Determines which classes/channels in the class enable vector
                                                                 field of a transmitted PFC packet can be asserted due to RX physical backpressure. */
        uint64_t logl_en               : 16; /**< [ 47: 32](R/W) Logical backpressure enable. Determines which classes/channels in the class enable vector
                                                                 field of a transmitted PFC packet can be asserted due to RX logical backpressure. */
        uint64_t reserved_4_31         : 28;
        uint64_t bck_en                : 1;  /**< [  3:  3](R/W) Forward PFC information to the backpressure block. */
        uint64_t drp_en                : 1;  /**< [  2:  2](R/W) Drop-control enable. When set, drop PFC frames. */
        uint64_t tx_en                 : 1;  /**< [  1:  1](R/W) Transmit enable. When set, allow for PFC packets. Must be clear in HiGig2 mode
                                                                 i.e. when CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN] =
                                                                 16. */
        uint64_t rx_en                 : 1;  /**< [  0:  0](R/W) Receive enable. When set, allow for PFC packets. Must be clear in HiGig2 mode
                                                                 i.e. when CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN] =
                                                                 16. */
#else /* Word 0 - Little Endian */
        uint64_t rx_en                 : 1;  /**< [  0:  0](R/W) Receive enable. When set, allow for PFC packets. Must be clear in HiGig2 mode
                                                                 i.e. when CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN] =
                                                                 16. */
        uint64_t tx_en                 : 1;  /**< [  1:  1](R/W) Transmit enable. When set, allow for PFC packets. Must be clear in HiGig2 mode
                                                                 i.e. when CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN] =
                                                                 16. */
        uint64_t drp_en                : 1;  /**< [  2:  2](R/W) Drop-control enable. When set, drop PFC frames. */
        uint64_t bck_en                : 1;  /**< [  3:  3](R/W) Forward PFC information to the backpressure block. */
        uint64_t reserved_4_31         : 28;
        uint64_t logl_en               : 16; /**< [ 47: 32](R/W) Logical backpressure enable. Determines which classes/channels in the class enable vector
                                                                 field of a transmitted PFC packet can be asserted due to RX logical backpressure. */
        uint64_t phys_en               : 16; /**< [ 63: 48](R/W) Physical backpressure enable. Determines which classes/channels in the class enable vector
                                                                 field of a transmitted PFC packet can be asserted due to RX physical backpressure. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_cbfc_ctl_s cn; */
};
typedef union bdk_cgxx_smux_cbfc_ctl bdk_cgxx_smux_cbfc_ctl_t;

static inline uint64_t BDK_CGXX_SMUX_CBFC_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_CBFC_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020218ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_CBFC_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_CBFC_CTL(a,b) bdk_cgxx_smux_cbfc_ctl_t
#define bustype_BDK_CGXX_SMUX_CBFC_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_CBFC_CTL(a,b) "CGXX_SMUX_CBFC_CTL"
#define device_bar_BDK_CGXX_SMUX_CBFC_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_CBFC_CTL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_CBFC_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_ctrl
 *
 * CGX SMU Control Registers
 */
union bdk_cgxx_smux_ctrl
{
    uint64_t u;
    struct bdk_cgxx_smux_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t tx_idle               : 1;  /**< [  1:  1](RO/H) TX machine is idle. This indication pertains to the framer FSM and ignores the effects on
                                                                 the data-path controls or values which occur when CGX()_SMU()_TX_CTL[LS_BYP] is
                                                                 set. */
        uint64_t rx_idle               : 1;  /**< [  0:  0](RO/H) RX machine is idle. */
#else /* Word 0 - Little Endian */
        uint64_t rx_idle               : 1;  /**< [  0:  0](RO/H) RX machine is idle. */
        uint64_t tx_idle               : 1;  /**< [  1:  1](RO/H) TX machine is idle. This indication pertains to the framer FSM and ignores the effects on
                                                                 the data-path controls or values which occur when CGX()_SMU()_TX_CTL[LS_BYP] is
                                                                 set. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_ctrl_s cn; */
};
typedef union bdk_cgxx_smux_ctrl bdk_cgxx_smux_ctrl_t;

static inline uint64_t BDK_CGXX_SMUX_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020200ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020200ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020200ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020200ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_CTRL(a,b) bdk_cgxx_smux_ctrl_t
#define bustype_BDK_CGXX_SMUX_CTRL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_CTRL(a,b) "CGXX_SMUX_CTRL"
#define device_bar_BDK_CGXX_SMUX_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_CTRL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_ext_loopback
 *
 * CGX SMU External Loopback Registers
 * In loopback mode, the IFG1+IFG2 of local and remote parties must match exactly; otherwise
 * loopback FIFO will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
 */
union bdk_cgxx_smux_ext_loopback
{
    uint64_t u;
    struct bdk_cgxx_smux_ext_loopback_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t en                    : 1;  /**< [ 16: 16](R/W) Loopback enable. Puts the packet interface in external loopback mode where the RX lines
                                                                 are reflected on the TX lines. */
        uint64_t reserved_14_15        : 2;
        uint64_t depth                 : 6;  /**< [ 13:  8](RO) Depth of the LMAC loopback TX FIFO in term of 128-bit entries. */
        uint64_t reserved_6_7          : 2;
        uint64_t thresh                : 6;  /**< [  5:  0](R/W) Threshold on the loopback TX FIFO per LMAC before a packet is sent. Software should use the
                                                                 reset value ([DEPTH/2]). This value must never be set greater than [DEPTH]. */
#else /* Word 0 - Little Endian */
        uint64_t thresh                : 6;  /**< [  5:  0](R/W) Threshold on the loopback TX FIFO per LMAC before a packet is sent. Software should use the
                                                                 reset value ([DEPTH/2]). This value must never be set greater than [DEPTH]. */
        uint64_t reserved_6_7          : 2;
        uint64_t depth                 : 6;  /**< [ 13:  8](RO) Depth of the LMAC loopback TX FIFO in term of 128-bit entries. */
        uint64_t reserved_14_15        : 2;
        uint64_t en                    : 1;  /**< [ 16: 16](R/W) Loopback enable. Puts the packet interface in external loopback mode where the RX lines
                                                                 are reflected on the TX lines. */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_ext_loopback_s cn; */
};
typedef union bdk_cgxx_smux_ext_loopback bdk_cgxx_smux_ext_loopback_t;

static inline uint64_t BDK_CGXX_SMUX_EXT_LOOPBACK(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_EXT_LOOPBACK(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020208ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020208ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020208ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020208ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_EXT_LOOPBACK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_EXT_LOOPBACK(a,b) bdk_cgxx_smux_ext_loopback_t
#define bustype_BDK_CGXX_SMUX_EXT_LOOPBACK(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_EXT_LOOPBACK(a,b) "CGXX_SMUX_EXT_LOOPBACK"
#define device_bar_BDK_CGXX_SMUX_EXT_LOOPBACK(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_EXT_LOOPBACK(a,b) (a)
#define arguments_BDK_CGXX_SMUX_EXT_LOOPBACK(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_hg2_control
 *
 * CGX SMU HiGig2 Control Registers
 * HiGig2 TX- and RX-enable are normally set together for HiGig2 messaging. Setting just the TX
 * or RX bit results in only the HG2 message transmit or receive capability.
 *
 * Setting [PHYS_EN] and [LOGL_EN] to 1 allows link PAUSE or backpressure to NIX as per the
 * received HiGig2 message. Setting these fields to 0 disables link PAUSE and backpressure to NIX
 * in response to received messages.
 *
 * CGX()_SMU()_TX_CTL[HG_EN] must be set (to enable HiGig) whenever either [HG2TX_EN] or
 * [HG2RX_EN] are set. CGX()_SMU()_RX_UDD_SKP[LEN] must be set to 16 (to select HiGig2)
 * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
 *
 * CGX()_CMR_RX_OVR_BP[EN]\<0\> must be set and CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared
 * to 0 (to forcibly disable hardware-automatic 802.3 PAUSE packet generation) with the HiGig2
 * Protocol when [HG2TX_EN] = 0. (The HiGig2 protocol is indicated
 * by CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16.) Hardware
 * can only autogenerate backpressure via HiGig2 messages (optionally, when [HG2TX_EN] = 1) with
 * the HiGig2 protocol.
 */
union bdk_cgxx_smux_hg2_control
{
    uint64_t u;
    struct bdk_cgxx_smux_hg2_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_19_63        : 45;
        uint64_t hg2tx_en              : 1;  /**< [ 18: 18](R/W) Enable transmission of HG2 physical and logical messages. When set, also disables hardware
                                                                 autogenerated 802.3 PAUSE and PFC frames. (CNXXXX cannot generate proper 802.3 or
                                                                 PFC frames in HiGig2 mode.) */
        uint64_t hg2rx_en              : 1;  /**< [ 17: 17](R/W) Enable extraction and processing of HG2 message packet from RX flow. Physical and logical
                                                                 PAUSE information is used to PAUSE physical-link, backpressure NIX. This field must be set
                                                                 when HiGig2 messages are present in the receive stream. This bit is also forwarded to CMR
                                                                 so it can generate the required deferring signals to SMU TX and backpressure signals to
                                                                 NIX. */
        uint64_t phys_en               : 1;  /**< [ 16: 16](R/W) Physical-link backpressure enable for received physical HiGig2 messages. This bit enables
                                                                 the SMU TX to CMR HG2 deferring counter to be set every time SMU RX receives and filters
                                                                 out a valid physical HG2 message. */
        uint64_t logl_en               : 16; /**< [ 15:  0](R/W) 16-bit logical-link backpressure enables for received HiGig2 messages or PFC packets. */
#else /* Word 0 - Little Endian */
        uint64_t logl_en               : 16; /**< [ 15:  0](R/W) 16-bit logical-link backpressure enables for received HiGig2 messages or PFC packets. */
        uint64_t phys_en               : 1;  /**< [ 16: 16](R/W) Physical-link backpressure enable for received physical HiGig2 messages. This bit enables
                                                                 the SMU TX to CMR HG2 deferring counter to be set every time SMU RX receives and filters
                                                                 out a valid physical HG2 message. */
        uint64_t hg2rx_en              : 1;  /**< [ 17: 17](R/W) Enable extraction and processing of HG2 message packet from RX flow. Physical and logical
                                                                 PAUSE information is used to PAUSE physical-link, backpressure NIX. This field must be set
                                                                 when HiGig2 messages are present in the receive stream. This bit is also forwarded to CMR
                                                                 so it can generate the required deferring signals to SMU TX and backpressure signals to
                                                                 NIX. */
        uint64_t hg2tx_en              : 1;  /**< [ 18: 18](R/W) Enable transmission of HG2 physical and logical messages. When set, also disables hardware
                                                                 autogenerated 802.3 PAUSE and PFC frames. (CNXXXX cannot generate proper 802.3 or
                                                                 PFC frames in HiGig2 mode.) */
        uint64_t reserved_19_63        : 45;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_hg2_control_s cn; */
};
typedef union bdk_cgxx_smux_hg2_control bdk_cgxx_smux_hg2_control_t;

static inline uint64_t BDK_CGXX_SMUX_HG2_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_HG2_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020210ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020210ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020210ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020210ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_HG2_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_HG2_CONTROL(a,b) bdk_cgxx_smux_hg2_control_t
#define bustype_BDK_CGXX_SMUX_HG2_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_HG2_CONTROL(a,b) "CGXX_SMUX_HG2_CONTROL"
#define device_bar_BDK_CGXX_SMUX_HG2_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_HG2_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_HG2_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_mmsi_ctl_sta
 *
 * CGX SMU MAC Merge Service Interface (MMSI) Control/Status Registers
 * MMSI control and status registers for frame preemption mode. Refer to IEEE 802.3br, Clause 99.
 */
union bdk_cgxx_smux_mmsi_ctl_sta
{
    uint64_t u;
    struct bdk_cgxx_smux_mmsi_ctl_sta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t v_time                : 24; /**< [ 55: 32](R/W) Verify time. The nominal wait time (IEEE verifyTime in ms) between verification
                                                                 attempts in number of 100 MHz reference clock cyucles. Valid range of verifyTime
                                                                 is from 1 ms to 128 ms inclusive. The default value 0xF4240 represents 10 ms.

                                                                 _ [V_TIME] = verifyTime * 0x186A0 where verifyTime is in [1, 128].

                                                                 Internal:
                                                                 This field can be set to less than 0x186A0 for diagnostic use to speed up
                                                                 verification. */
        uint64_t reserved_8_31         : 24;
        uint64_t tx_pactive            : 1;  /**< [  7:  7](RO/H) Transmit preemption status.  See also [DIS_V].
                                                                 0 = Transmit preemption is inactive (disabled or enabled but not verified).
                                                                 1 = Transmit preemption is active (enabled and verified). */
        uint64_t v_sta                 : 3;  /**< [  6:  4](RO/H) Verify state machine status. Refer to IEEE 802.3br Figure 99-8(a).
                                                                 0x0 = Initial.
                                                                 0x1 = Verifying.
                                                                 0x2 = Succeeded.
                                                                 0x3 = Failed.
                                                                 0x4 = Disabled. */
        uint64_t afs                   : 2;  /**< [  3:  2](R/W) Additional fragment size. This variable is used to extend the minimum fragment
                                                                 size for non-final fragments, defined as 64 * (1+ [AFS]) - 4 bytes. */
        uint64_t dis_v                 : 1;  /**< [  1:  1](R/W) Disable verify. Verification checks that the link can support the preemption capability.
                                                                 If verification is enabled, the preemption capability shall be active only after
                                                                 verification has completed successfully.
                                                                 0 = Preemption verify is enabled.
                                                                 1 = Preemption verify is disabled. */
        uint64_t p_en                  : 1;  /**< [  0:  0](R/W/H) Preemption enable (IEEE pEnable). Hardware clears [P_EN] when link failure is received.
                                                                 0 = Preemption is disabled.
                                                                 1 = Preemption is enabled.

                                                                 When preemption is enabled, note the following:
                                                                 CGX()_SMU()_TX_APPEND[FCS_D] must be 1.
                                                                 CGX()_SMU()_RX_UDD_SKP[LEN] must be 0.
                                                                 CGX()_SMU()_RX_FRM_CTL[PRE_CHK] must be 1.
                                                                 CGX()_SMU()_RX_DECISION applies to re-assembled frames.
                                                                 CGX()_SMU()_RX_JABBER applies to re-assembled frames. */
#else /* Word 0 - Little Endian */
        uint64_t p_en                  : 1;  /**< [  0:  0](R/W/H) Preemption enable (IEEE pEnable). Hardware clears [P_EN] when link failure is received.
                                                                 0 = Preemption is disabled.
                                                                 1 = Preemption is enabled.

                                                                 When preemption is enabled, note the following:
                                                                 CGX()_SMU()_TX_APPEND[FCS_D] must be 1.
                                                                 CGX()_SMU()_RX_UDD_SKP[LEN] must be 0.
                                                                 CGX()_SMU()_RX_FRM_CTL[PRE_CHK] must be 1.
                                                                 CGX()_SMU()_RX_DECISION applies to re-assembled frames.
                                                                 CGX()_SMU()_RX_JABBER applies to re-assembled frames. */
        uint64_t dis_v                 : 1;  /**< [  1:  1](R/W) Disable verify. Verification checks that the link can support the preemption capability.
                                                                 If verification is enabled, the preemption capability shall be active only after
                                                                 verification has completed successfully.
                                                                 0 = Preemption verify is enabled.
                                                                 1 = Preemption verify is disabled. */
        uint64_t afs                   : 2;  /**< [  3:  2](R/W) Additional fragment size. This variable is used to extend the minimum fragment
                                                                 size for non-final fragments, defined as 64 * (1+ [AFS]) - 4 bytes. */
        uint64_t v_sta                 : 3;  /**< [  6:  4](RO/H) Verify state machine status. Refer to IEEE 802.3br Figure 99-8(a).
                                                                 0x0 = Initial.
                                                                 0x1 = Verifying.
                                                                 0x2 = Succeeded.
                                                                 0x3 = Failed.
                                                                 0x4 = Disabled. */
        uint64_t tx_pactive            : 1;  /**< [  7:  7](RO/H) Transmit preemption status.  See also [DIS_V].
                                                                 0 = Transmit preemption is inactive (disabled or enabled but not verified).
                                                                 1 = Transmit preemption is active (enabled and verified). */
        uint64_t reserved_8_31         : 24;
        uint64_t v_time                : 24; /**< [ 55: 32](R/W) Verify time. The nominal wait time (IEEE verifyTime in ms) between verification
                                                                 attempts in number of 100 MHz reference clock cyucles. Valid range of verifyTime
                                                                 is from 1 ms to 128 ms inclusive. The default value 0xF4240 represents 10 ms.

                                                                 _ [V_TIME] = verifyTime * 0x186A0 where verifyTime is in [1, 128].

                                                                 Internal:
                                                                 This field can be set to less than 0x186A0 for diagnostic use to speed up
                                                                 verification. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_mmsi_ctl_sta_s cn; */
};
typedef union bdk_cgxx_smux_mmsi_ctl_sta bdk_cgxx_smux_mmsi_ctl_sta_t;

static inline uint64_t BDK_CGXX_SMUX_MMSI_CTL_STA(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_MMSI_CTL_STA(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020220ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_MMSI_CTL_STA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_MMSI_CTL_STA(a,b) bdk_cgxx_smux_mmsi_ctl_sta_t
#define bustype_BDK_CGXX_SMUX_MMSI_CTL_STA(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_MMSI_CTL_STA(a,b) "CGXX_SMUX_MMSI_CTL_STA"
#define device_bar_BDK_CGXX_SMUX_MMSI_CTL_STA(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_MMSI_CTL_STA(a,b) (a)
#define arguments_BDK_CGXX_SMUX_MMSI_CTL_STA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_bad_col_ctrl
 *
 * CGX SMU RX Bad Column High Registers
 */
union bdk_cgxx_smux_rx_bad_col_ctrl
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_bad_col_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t val                   : 1;  /**< [ 19: 19](R/W1C/H) Set when CGX()_SMU()_RX_INT[PCTERR] is set. */
        uint64_t state                 : 3;  /**< [ 18: 16](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, contains the receive state at the time of
                                                                 the error. */
        uint64_t lane_rxc              : 16; /**< [ 15:  0](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, contains the RXC column at the time of the error. */
#else /* Word 0 - Little Endian */
        uint64_t lane_rxc              : 16; /**< [ 15:  0](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, contains the RXC column at the time of the error. */
        uint64_t state                 : 3;  /**< [ 18: 16](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, contains the receive state at the time of
                                                                 the error. */
        uint64_t val                   : 1;  /**< [ 19: 19](R/W1C/H) Set when CGX()_SMU()_RX_INT[PCTERR] is set. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_bad_col_ctrl_s cn; */
};
typedef union bdk_cgxx_smux_rx_bad_col_ctrl bdk_cgxx_smux_rx_bad_col_ctrl_t;

static inline uint64_t BDK_CGXX_SMUX_RX_BAD_COL_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_BAD_COL_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020060ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_BAD_COL_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_BAD_COL_CTRL(a,b) bdk_cgxx_smux_rx_bad_col_ctrl_t
#define bustype_BDK_CGXX_SMUX_RX_BAD_COL_CTRL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_BAD_COL_CTRL(a,b) "CGXX_SMUX_RX_BAD_COL_CTRL"
#define device_bar_BDK_CGXX_SMUX_RX_BAD_COL_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_BAD_COL_CTRL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_BAD_COL_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_bad_col_data_hi
 *
 * CGX SMU RX Bad Column Low Registers
 */
union bdk_cgxx_smux_rx_bad_col_data_hi
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_bad_col_data_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lane_rxd              : 64; /**< [ 63:  0](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, [LANE_RXD] contains the upper 64 data bits of the
                                                                 at the time of the error. */
#else /* Word 0 - Little Endian */
        uint64_t lane_rxd              : 64; /**< [ 63:  0](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, [LANE_RXD] contains the upper 64 data bits of the
                                                                 at the time of the error. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_bad_col_data_hi_s cn; */
};
typedef union bdk_cgxx_smux_rx_bad_col_data_hi bdk_cgxx_smux_rx_bad_col_data_hi_t;

static inline uint64_t BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020058ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020058ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_BAD_COL_DATA_HI", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(a,b) bdk_cgxx_smux_rx_bad_col_data_hi_t
#define bustype_BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(a,b) "CGXX_SMUX_RX_BAD_COL_DATA_HI"
#define device_bar_BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_BAD_COL_DATA_HI(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_bad_col_data_lo
 *
 * CGX SMU RX Bad Column Low Registers
 */
union bdk_cgxx_smux_rx_bad_col_data_lo
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_bad_col_data_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lane_rxd              : 64; /**< [ 63:  0](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, [LANE_RXD] contains the lower 64 data bits of the
                                                                 column at the time of the error. */
#else /* Word 0 - Little Endian */
        uint64_t lane_rxd              : 64; /**< [ 63:  0](RO/H) When CGX()_SMU()_RX_INT[PCTERR] is set, [LANE_RXD] contains the lower 64 data bits of the
                                                                 column at the time of the error. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_bad_col_data_lo_s cn; */
};
typedef union bdk_cgxx_smux_rx_bad_col_data_lo bdk_cgxx_smux_rx_bad_col_data_lo_t;

static inline uint64_t BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020050ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_BAD_COL_DATA_LO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(a,b) bdk_cgxx_smux_rx_bad_col_data_lo_t
#define bustype_BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(a,b) "CGXX_SMUX_RX_BAD_COL_DATA_LO"
#define device_bar_BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_BAD_COL_DATA_LO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_ctl
 *
 * CGX SMU RX Control Registers
 */
union bdk_cgxx_smux_rx_ctl
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t status                : 2;  /**< [  1:  0](RO/H) Link status.
                                                                 0x0 = Link OK.
                                                                 0x1 = Local fault.
                                                                 0x2 = Remote fault.
                                                                 0x3 = Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t status                : 2;  /**< [  1:  0](RO/H) Link status.
                                                                 0x0 = Link OK.
                                                                 0x1 = Local fault.
                                                                 0x2 = Remote fault.
                                                                 0x3 = Reserved. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_ctl_s cn; */
};
typedef union bdk_cgxx_smux_rx_ctl bdk_cgxx_smux_rx_ctl_t;

static inline uint64_t BDK_CGXX_SMUX_RX_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020048ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_CTL(a,b) bdk_cgxx_smux_rx_ctl_t
#define bustype_BDK_CGXX_SMUX_RX_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_CTL(a,b) "CGXX_SMUX_RX_CTL"
#define device_bar_BDK_CGXX_SMUX_RX_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_CTL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_decision
 *
 * CGX SMU Packet Decision Registers
 * This register specifies the byte count used to determine when to accept or to filter a packet.
 * As each byte in a packet is received by CGX, the L2 byte count (i.e. the number of bytes from
 * the beginning of the L2 header (DMAC)) is compared against CNT. In normal operation, the L2
 * header begins after the PREAMBLE + SFD (CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 1) and any
 * optional UDD skip data (CGX()_SMU()_RX_UDD_SKP[LEN]).
 */
union bdk_cgxx_smux_rx_decision
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_decision_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t cnt                   : 5;  /**< [  4:  0](R/W) The byte count to decide when to accept or filter a packet. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 5;  /**< [  4:  0](R/W) The byte count to decide when to accept or filter a packet. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_decision_s cn; */
};
typedef union bdk_cgxx_smux_rx_decision bdk_cgxx_smux_rx_decision_t;

static inline uint64_t BDK_CGXX_SMUX_RX_DECISION(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_DECISION(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_DECISION", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_DECISION(a,b) bdk_cgxx_smux_rx_decision_t
#define bustype_BDK_CGXX_SMUX_RX_DECISION(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_DECISION(a,b) "CGXX_SMUX_RX_DECISION"
#define device_bar_BDK_CGXX_SMUX_RX_DECISION(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_DECISION(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_DECISION(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_frm_chk
 *
 * CGX SMU RX Frame Check Registers
 * The CSRs provide the enable bits for a subset of errors passed to CMR encoded.
 */
union bdk_cgxx_smux_rx_frm_chk
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_frm_chk_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t skperr                : 1;  /**< [  8:  8](R/W) Skipper error. */
        uint64_t rcverr                : 1;  /**< [  7:  7](R/W) Frame was received with data-reception error. */
        uint64_t reserved_6            : 1;
        uint64_t fcserr_c              : 1;  /**< [  5:  5](R/W) Control frame was received with FCS/CRC error. */
        uint64_t fcserr_d              : 1;  /**< [  4:  4](R/W) Data frame was received with FCS/CRC error. */
        uint64_t jabber                : 1;  /**< [  3:  3](R/W) Frame was received with length \> sys_length. */
        uint64_t reserved_0_2          : 3;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_2          : 3;
        uint64_t jabber                : 1;  /**< [  3:  3](R/W) Frame was received with length \> sys_length. */
        uint64_t fcserr_d              : 1;  /**< [  4:  4](R/W) Data frame was received with FCS/CRC error. */
        uint64_t fcserr_c              : 1;  /**< [  5:  5](R/W) Control frame was received with FCS/CRC error. */
        uint64_t reserved_6            : 1;
        uint64_t rcverr                : 1;  /**< [  7:  7](R/W) Frame was received with data-reception error. */
        uint64_t skperr                : 1;  /**< [  8:  8](R/W) Skipper error. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_frm_chk_s cn; */
};
typedef union bdk_cgxx_smux_rx_frm_chk bdk_cgxx_smux_rx_frm_chk_t;

static inline uint64_t BDK_CGXX_SMUX_RX_FRM_CHK(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_FRM_CHK(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_FRM_CHK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_FRM_CHK(a,b) bdk_cgxx_smux_rx_frm_chk_t
#define bustype_BDK_CGXX_SMUX_RX_FRM_CHK(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_FRM_CHK(a,b) "CGXX_SMUX_RX_FRM_CHK"
#define device_bar_BDK_CGXX_SMUX_RX_FRM_CHK(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_FRM_CHK(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_FRM_CHK(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_frm_ctl
 *
 * CGX SMU RX Frame Control Registers
 * This register controls the handling of the frames.
 * The [CTL_BCK] and [CTL_DRP] bits control how the hardware handles incoming PAUSE packets. The
 * most
 * common modes of operation:
 * _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything
 * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames
 * _ [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored
 *
 * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex mode. Since
 * PAUSE
 * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
 * which should be handled by the processing cores. PAUSE packets should not be forwarded.
 */
union bdk_cgxx_smux_rx_frm_ctl
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_frm_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t ptp_mode              : 1;  /**< [ 12: 12](R/W) Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                                 packet.

                                                                 The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                                 receive byte count. This implies that the CGX()_SMU()_RX_JABBER,
                                                                 CGX()_SMU()_RX_DECISION, and CGX()_SMU()_RX_UDD_SKP do not require any
                                                                 adjustment as they operate on the received packet size. When the packet reaches NIX, its
                                                                 size reflects the additional bytes. */
        uint64_t reserved_6_11         : 6;
        uint64_t ctl_smac              : 1;  /**< [  5:  5](R/W) Control PAUSE frames can match station SMAC. */
        uint64_t ctl_mcst              : 1;  /**< [  4:  4](R/W) Control PAUSE frames can match globally assigned multicast address. */
        uint64_t ctl_bck               : 1;  /**< [  3:  3](R/W) Forward PAUSE information to TX block. */
        uint64_t ctl_drp               : 1;  /**< [  2:  2](R/W) Drop control-PAUSE frames. */
        uint64_t pre_strp              : 1;  /**< [  1:  1](R/W) Strip off the preamble (when present).

                                                                 0 = PREAMBLE + SFD is sent to core as part of frame.
                                                                 1 = PREAMBLE + SFD is dropped.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features.

                                                                 If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1.

                                                                 When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
                                                                 if
                                                                 the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                                 either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                                 against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                                 of the L2 header for DMAC and control frame recognition. */
        uint64_t pre_chk               : 1;  /**< [  0:  0](R/W) Check the preamble for correctness.
                                                                 This port is configured to send a valid 802.3 PREAMBLE to begin every frame. CGX checks
                                                                 that a valid PREAMBLE is received. When a problem does occur within
                                                                 the PREAMBLE sequence, the frame is marked as bad and not sent into the core. The
                                                                 CGX()_SMU()_RX_INT[PCTERR] interrupt is also raised.

                                                                 When CGX()_SMU()_TX_CTL[HG_EN] is set, [PRE_CHK] must be 0.
                                                                 When CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, [PRE_CHK] must be 0.

                                                                 If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1. */
#else /* Word 0 - Little Endian */
        uint64_t pre_chk               : 1;  /**< [  0:  0](R/W) Check the preamble for correctness.
                                                                 This port is configured to send a valid 802.3 PREAMBLE to begin every frame. CGX checks
                                                                 that a valid PREAMBLE is received. When a problem does occur within
                                                                 the PREAMBLE sequence, the frame is marked as bad and not sent into the core. The
                                                                 CGX()_SMU()_RX_INT[PCTERR] interrupt is also raised.

                                                                 When CGX()_SMU()_TX_CTL[HG_EN] is set, [PRE_CHK] must be 0.
                                                                 When CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, [PRE_CHK] must be 0.

                                                                 If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1. */
        uint64_t pre_strp              : 1;  /**< [  1:  1](R/W) Strip off the preamble (when present).

                                                                 0 = PREAMBLE + SFD is sent to core as part of frame.
                                                                 1 = PREAMBLE + SFD is dropped.
                                                                 [PRE_CHK] must be set to enable this and all PREAMBLE features.

                                                                 If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1.

                                                                 When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
                                                                 if
                                                                 the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                                 either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                                 against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                                 of the L2 header for DMAC and control frame recognition. */
        uint64_t ctl_drp               : 1;  /**< [  2:  2](R/W) Drop control-PAUSE frames. */
        uint64_t ctl_bck               : 1;  /**< [  3:  3](R/W) Forward PAUSE information to TX block. */
        uint64_t ctl_mcst              : 1;  /**< [  4:  4](R/W) Control PAUSE frames can match globally assigned multicast address. */
        uint64_t ctl_smac              : 1;  /**< [  5:  5](R/W) Control PAUSE frames can match station SMAC. */
        uint64_t reserved_6_11         : 6;
        uint64_t ptp_mode              : 1;  /**< [ 12: 12](R/W) Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                                 packet.

                                                                 The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                                 receive byte count. This implies that the CGX()_SMU()_RX_JABBER,
                                                                 CGX()_SMU()_RX_DECISION, and CGX()_SMU()_RX_UDD_SKP do not require any
                                                                 adjustment as they operate on the received packet size. When the packet reaches NIX, its
                                                                 size reflects the additional bytes. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_frm_ctl_s cn; */
};
typedef union bdk_cgxx_smux_rx_frm_ctl bdk_cgxx_smux_rx_frm_ctl_t;

static inline uint64_t BDK_CGXX_SMUX_RX_FRM_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_FRM_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_FRM_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_FRM_CTL(a,b) bdk_cgxx_smux_rx_frm_ctl_t
#define bustype_BDK_CGXX_SMUX_RX_FRM_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_FRM_CTL(a,b) "CGXX_SMUX_RX_FRM_CTL"
#define device_bar_BDK_CGXX_SMUX_RX_FRM_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_FRM_CTL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_FRM_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_int
 *
 * CGX SMU Receive Interrupt Registers
 * SMU Interrupt Register.
 * Internal:
 * Exception conditions \<9\> and \<4:0\> can also set the rcv/opcode in the received packet's work
 * queue entry. CGX()_SMU()_RX_FRM_CHK provides a bit mask for configuring which
 * conditions set the error.
 */
union bdk_cgxx_smux_rx_int
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Received frame preemption response packet with bad mCRC. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Received frame preemption verify packet with bad mCRC. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) HiGig2 received message CRC or control-character error. Set when either a CRC8 error is
                                                                 detected, or when a control character is found in the message bytes after the K.SOM.
                                                                 HG2CC has higher priority than HG2FLD, which means that a HiGig2 message that results in
                                                                 HG2CC getting set never sets HG2FLD. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) HiGig2 received message field error:

                                                                 Msg_type field not 0x0, i.e. it is not a flow-control message, which is the only defined
                                                                 type for HiGig2.

                                                                 Fwd_type field not 0x0, i.e. it is not a link-level message, which is the only defined
                                                                 type for HiGig2.

                                                                 Fc_object field is neither 0x0 for physical link, nor 0x2 for logical link. Those are the
                                                                 only two defined types in HiGig2 */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Frame is terminated by control character other than /T/. The error
                                                                 propagation control character /E/ will be included as part of the frame and does not cause
                                                                 a frame termination. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Detected reserved sequence. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Remote-fault sequence detected. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Local-fault sequence detected. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Detected reserved opcode. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Bad preamble/protocol. The column of data that was bad is logged in
                                                                 CGX()_SMU()_RX_BAD_COL_DATA_LO ,CGX()_SMU()_RX_BAD_COL_DATA_HI, and
                                                                 CGX()_SMU()_RX_BAD_COL_CTRL.
                                                                 PCTERR checks that the frame begins with a valid
                                                                 PREAMBLE sequence. Does not check the number of PREAMBLE cycles. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Skipper error. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Frame was received with data-reception error. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Frame was received with FCS/CRC error. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Frame was received with length \> sys_length. An RX Jabber error indicates that a packet
                                                                 was received which is longer than the maximum allowed packet as defined by the system. CGX
                                                                 terminates the packet with an EOP on the beat on which JABBER was exceeded. The beat on
                                                                 which JABBER was exceeded is left unchanged and all subsequent data beats are dropped.
                                                                 Failure to truncate could lead to system instability. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Frame was received with length \> sys_length. An RX Jabber error indicates that a packet
                                                                 was received which is longer than the maximum allowed packet as defined by the system. CGX
                                                                 terminates the packet with an EOP on the beat on which JABBER was exceeded. The beat on
                                                                 which JABBER was exceeded is left unchanged and all subsequent data beats are dropped.
                                                                 Failure to truncate could lead to system instability. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Frame was received with FCS/CRC error. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Frame was received with data-reception error. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Skipper error. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Bad preamble/protocol. The column of data that was bad is logged in
                                                                 CGX()_SMU()_RX_BAD_COL_DATA_LO ,CGX()_SMU()_RX_BAD_COL_DATA_HI, and
                                                                 CGX()_SMU()_RX_BAD_COL_CTRL.
                                                                 PCTERR checks that the frame begins with a valid
                                                                 PREAMBLE sequence. Does not check the number of PREAMBLE cycles. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Detected reserved opcode. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Local-fault sequence detected. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Remote-fault sequence detected. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Detected reserved sequence. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Frame is terminated by control character other than /T/. The error
                                                                 propagation control character /E/ will be included as part of the frame and does not cause
                                                                 a frame termination. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) HiGig2 received message field error:

                                                                 Msg_type field not 0x0, i.e. it is not a flow-control message, which is the only defined
                                                                 type for HiGig2.

                                                                 Fwd_type field not 0x0, i.e. it is not a link-level message, which is the only defined
                                                                 type for HiGig2.

                                                                 Fc_object field is neither 0x0 for physical link, nor 0x2 for logical link. Those are the
                                                                 only two defined types in HiGig2 */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) HiGig2 received message CRC or control-character error. Set when either a CRC8 error is
                                                                 detected, or when a control character is found in the message bytes after the K.SOM.
                                                                 HG2CC has higher priority than HG2FLD, which means that a HiGig2 message that results in
                                                                 HG2CC getting set never sets HG2FLD. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Received frame preemption verify packet with bad mCRC. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Received frame preemption response packet with bad mCRC. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_int_s cn; */
};
typedef union bdk_cgxx_smux_rx_int bdk_cgxx_smux_rx_int_t;

static inline uint64_t BDK_CGXX_SMUX_RX_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_INT(a,b) bdk_cgxx_smux_rx_int_t
#define bustype_BDK_CGXX_SMUX_RX_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_INT(a,b) "CGXX_SMUX_RX_INT"
#define device_bar_BDK_CGXX_SMUX_RX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_INT(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_int_ena_w1c
 *
 * CGX SMU Receive Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_smux_rx_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_smux_rx_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_smux_rx_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_rx_int_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_smux_rx_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_rx_int_ena_w1c bdk_cgxx_smux_rx_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_SMUX_RX_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_INT_ENA_W1C(a,b) bdk_cgxx_smux_rx_int_ena_w1c_t
#define bustype_BDK_CGXX_SMUX_RX_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_INT_ENA_W1C(a,b) "CGXX_SMUX_RX_INT_ENA_W1C"
#define device_bar_BDK_CGXX_SMUX_RX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_int_ena_w1s
 *
 * CGX SMU Receive Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_smux_rx_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_smux_rx_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_smux_rx_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_rx_int_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_smux_rx_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_rx_int_ena_w1s bdk_cgxx_smux_rx_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_SMUX_RX_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_INT_ENA_W1S(a,b) bdk_cgxx_smux_rx_int_ena_w1s_t
#define bustype_BDK_CGXX_SMUX_RX_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_INT_ENA_W1S(a,b) "CGXX_SMUX_RX_INT_ENA_W1S"
#define device_bar_BDK_CGXX_SMUX_RX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_int_w1s
 *
 * CGX SMU Receive Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_smux_rx_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_int_w1s_s cn9; */
    /* struct bdk_cgxx_smux_rx_int_w1s_s cn96xx; */
    struct bdk_cgxx_smux_rx_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_rx_int_w1s_s cnf95xx; */
    struct bdk_cgxx_smux_rx_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[JABBER]. */
#else /* Word 0 - Little Endian */
        uint64_t jabber                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[JABBER]. */
        uint64_t fcserr                : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[FCSERR]. */
        uint64_t rcverr                : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[RCVERR]. */
        uint64_t skperr                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[SKPERR]. */
        uint64_t pcterr                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[PCTERR]. */
        uint64_t rsverr                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[RSVERR]. */
        uint64_t loc_fault             : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[LOC_FAULT]. */
        uint64_t rem_fault             : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[REM_FAULT]. */
        uint64_t bad_seq               : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BAD_SEQ]. */
        uint64_t bad_term              : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BAD_TERM]. */
        uint64_t hg2fld                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[HG2FLD]. */
        uint64_t hg2cc                 : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[HG2CC]. */
        uint64_t badver                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BADVER]. */
        uint64_t badrsp                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_INT[BADRSP]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_rx_int_w1s bdk_cgxx_smux_rx_int_w1s_t;

static inline uint64_t BDK_CGXX_SMUX_RX_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_INT_W1S(a,b) bdk_cgxx_smux_rx_int_w1s_t
#define bustype_BDK_CGXX_SMUX_RX_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_INT_W1S(a,b) "CGXX_SMUX_RX_INT_W1S"
#define device_bar_BDK_CGXX_SMUX_RX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_jabber
 *
 * CGX SMU Maximum Packet-Size Registers
 * This register specifies the maximum size for packets, beyond which the SMU truncates.
 * Internal:
 * JABBER[CNT] is checked against the packet that arrives from SPU.  The checking
 * is performed before preamble is stripped or PTP is inserted.  If present, preamble is
 * counted as eight bytes of the incoming packet.
 */
union bdk_cgxx_smux_rx_jabber
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_jabber_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t cnt                   : 16; /**< [ 15:  0](R/W) Byte count for jabber check. Failing packets set the JABBER interrupt and are optionally
                                                                 sent with opcode = JABBER. CGX truncates the packet to CNT+1 to CNT+16 bytes.
                                                                 CNT must be 16-byte aligned such that CNT\<3:0\> = 000. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 16; /**< [ 15:  0](R/W) Byte count for jabber check. Failing packets set the JABBER interrupt and are optionally
                                                                 sent with opcode = JABBER. CGX truncates the packet to CNT+1 to CNT+16 bytes.
                                                                 CNT must be 16-byte aligned such that CNT\<3:0\> = 000. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_jabber_s cn; */
};
typedef union bdk_cgxx_smux_rx_jabber bdk_cgxx_smux_rx_jabber_t;

static inline uint64_t BDK_CGXX_SMUX_RX_JABBER(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_JABBER(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_JABBER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_JABBER(a,b) bdk_cgxx_smux_rx_jabber_t
#define bustype_BDK_CGXX_SMUX_RX_JABBER(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_JABBER(a,b) "CGXX_SMUX_RX_JABBER"
#define device_bar_BDK_CGXX_SMUX_RX_JABBER(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_JABBER(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_JABBER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_udd_skp
 *
 * CGX SMU User-Defined Data Skip Registers
 * Internal:
 * (1) The skip bytes are part of the packet and will be sent down the NCB
 * packet interface and will be handled by NIX.
 *
 * (2) The system can determine if the UDD bytes are included in the FCS check
 * by using the FCSSEL field if the FCS check is enabled.
 *
 * (3) Assume that the preamble/sfd is always at the start of the frame even
 * before UDD bytes.  In most cases, there will be no preamble in these
 * cases since it will be packet interface in direct communication to
 * another packet interface (MAC to MAC) without a PHY involved.
 *
 * (4) We can still do address filtering and control packet filtering if the
 * user desires.
 *
 * (5) In all cases, the UDD bytes will be sent down the packet interface as
 * part of the packet.  The UDD bytes are never stripped from the actual
 * packet.
 */
union bdk_cgxx_smux_rx_udd_skp
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_udd_skp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t fcssel                : 1;  /**< [  8:  8](R/W) Include the skip bytes in the FCS calculation.
                                                                 0 = All skip bytes are included in FCS.
                                                                 1 = The skip bytes are not included in FCS.

                                                                 When CGX()_SMU()_TX_CTL[HG_EN] is set, this field must be 0.
                                                                 When CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, this field must be 0.
                                                                 The skip bytes are part of the packet and are sent through the NCB packet interface and
                                                                 are handled by NIX. The system can determine if the UDD bytes are included in the FCS
                                                                 check by using the FCSSEL field, if the FCS check is enabled. */
        uint64_t reserved_7            : 1;
        uint64_t len                   : 7;  /**< [  6:  0](R/W) Amount of user-defined data before the start of the L2C data, in bytes.
                                                                 Setting to 0 means L2C comes first; maximum value is 64.
                                                                 LEN must be 0x0 in half-duplex operation.

                                                                 When CGX()_SMU()_TX_CTL[HG_EN] is set, this field must be set to 12 or 16
                                                                 (depending on HiGig header size) to account for the HiGig header.
                                                                 LEN = 12 selects HiGig/HiGig+; LEN = 16 selects HiGig2.

                                                                 When CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, this field must be set to 8. */
#else /* Word 0 - Little Endian */
        uint64_t len                   : 7;  /**< [  6:  0](R/W) Amount of user-defined data before the start of the L2C data, in bytes.
                                                                 Setting to 0 means L2C comes first; maximum value is 64.
                                                                 LEN must be 0x0 in half-duplex operation.

                                                                 When CGX()_SMU()_TX_CTL[HG_EN] is set, this field must be set to 12 or 16
                                                                 (depending on HiGig header size) to account for the HiGig header.
                                                                 LEN = 12 selects HiGig/HiGig+; LEN = 16 selects HiGig2.

                                                                 When CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, this field must be set to 8. */
        uint64_t reserved_7            : 1;
        uint64_t fcssel                : 1;  /**< [  8:  8](R/W) Include the skip bytes in the FCS calculation.
                                                                 0 = All skip bytes are included in FCS.
                                                                 1 = The skip bytes are not included in FCS.

                                                                 When CGX()_SMU()_TX_CTL[HG_EN] is set, this field must be 0.
                                                                 When CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::USXGMII and optional PCH headers
                                                                 are present in the received frames, this field must be 0.
                                                                 The skip bytes are part of the packet and are sent through the NCB packet interface and
                                                                 are handled by NIX. The system can determine if the UDD bytes are included in the FCS
                                                                 check by using the FCSSEL field, if the FCS check is enabled. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_udd_skp_s cn; */
};
typedef union bdk_cgxx_smux_rx_udd_skp bdk_cgxx_smux_rx_udd_skp_t;

static inline uint64_t BDK_CGXX_SMUX_RX_UDD_SKP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_UDD_SKP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_UDD_SKP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_UDD_SKP(a,b) bdk_cgxx_smux_rx_udd_skp_t
#define bustype_BDK_CGXX_SMUX_RX_UDD_SKP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_UDD_SKP(a,b) "CGXX_SMUX_RX_UDD_SKP"
#define device_bar_BDK_CGXX_SMUX_RX_UDD_SKP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_UDD_SKP(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_UDD_SKP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_wol_ctrl0
 *
 * CGX SMU RX Wake-on-LAN Control 0 Registers
 */
union bdk_cgxx_smux_rx_wol_ctrl0
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_wol_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t pswd_len              : 4;  /**< [ 51: 48](R/W) Byte length of the optional wake-on-LAN password. A value of 0x0 indicates a
                                                                 password is not enabled. When non-zero, the least significant bytes of
                                                                 CGX()_SMU()_RX_WOL_CTRL1 are used for the password match. Values 0x9 to 0xF are
                                                                 reserved. */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The MAC address to compare against received wake-on-LAN packets. */
#else /* Word 0 - Little Endian */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The MAC address to compare against received wake-on-LAN packets. */
        uint64_t pswd_len              : 4;  /**< [ 51: 48](R/W) Byte length of the optional wake-on-LAN password. A value of 0x0 indicates a
                                                                 password is not enabled. When non-zero, the least significant bytes of
                                                                 CGX()_SMU()_RX_WOL_CTRL1 are used for the password match. Values 0x9 to 0xF are
                                                                 reserved. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_wol_ctrl0_s cn; */
};
typedef union bdk_cgxx_smux_rx_wol_ctrl0 bdk_cgxx_smux_rx_wol_ctrl0_t;

static inline uint64_t BDK_CGXX_SMUX_RX_WOL_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_WOL_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020068ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_WOL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_WOL_CTRL0(a,b) bdk_cgxx_smux_rx_wol_ctrl0_t
#define bustype_BDK_CGXX_SMUX_RX_WOL_CTRL0(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_WOL_CTRL0(a,b) "CGXX_SMUX_RX_WOL_CTRL0"
#define device_bar_BDK_CGXX_SMUX_RX_WOL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_WOL_CTRL0(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_WOL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_wol_ctrl1
 *
 * CGX SMU RX Wake-on-LAN Control 1 Registers
 */
union bdk_cgxx_smux_rx_wol_ctrl1
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_wol_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pswd                  : 64; /**< [ 63:  0](R/W) The optional password to compare against received Wake-on-LAN packets. The length of the
                                                                 valid password is indicated by CGX()_SMU()_RX_WOL_CTRL0[PSWD_LEN]. */
#else /* Word 0 - Little Endian */
        uint64_t pswd                  : 64; /**< [ 63:  0](R/W) The optional password to compare against received Wake-on-LAN packets. The length of the
                                                                 valid password is indicated by CGX()_SMU()_RX_WOL_CTRL0[PSWD_LEN]. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_wol_ctrl1_s cn; */
};
typedef union bdk_cgxx_smux_rx_wol_ctrl1 bdk_cgxx_smux_rx_wol_ctrl1_t;

static inline uint64_t BDK_CGXX_SMUX_RX_WOL_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_WOL_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_WOL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_WOL_CTRL1(a,b) bdk_cgxx_smux_rx_wol_ctrl1_t
#define bustype_BDK_CGXX_SMUX_RX_WOL_CTRL1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_WOL_CTRL1(a,b) "CGXX_SMUX_RX_WOL_CTRL1"
#define device_bar_BDK_CGXX_SMUX_RX_WOL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_WOL_CTRL1(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_WOL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_wol_int
 *
 * CGX SMU RX WOL Interrupt Registers
 * These registers allow WOL interrupts to be sent to the control processor.
 */
union bdk_cgxx_smux_rx_wol_int
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_wol_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Wake-on-LAN packet detected. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Wake-on-LAN packet detected. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_wol_int_s cn; */
};
typedef union bdk_cgxx_smux_rx_wol_int bdk_cgxx_smux_rx_wol_int_t;

static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_WOL_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_WOL_INT(a,b) bdk_cgxx_smux_rx_wol_int_t
#define bustype_BDK_CGXX_SMUX_RX_WOL_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_WOL_INT(a,b) "CGXX_SMUX_RX_WOL_INT"
#define device_bar_BDK_CGXX_SMUX_RX_WOL_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_WOL_INT(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_WOL_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1c
 *
 * CGX SMU RX WOL Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_smux_rx_wol_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_wol_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_wol_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_smux_rx_wol_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_smux_rx_wol_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_rx_wol_int_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_smux_rx_wol_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_rx_wol_int_ena_w1c bdk_cgxx_smux_rx_wol_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020088ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_WOL_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(a,b) bdk_cgxx_smux_rx_wol_int_ena_w1c_t
#define bustype_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(a,b) "CGXX_SMUX_RX_WOL_INT_ENA_W1C"
#define device_bar_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1s
 *
 * CGX SMU RX WOL Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_smux_rx_wol_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_wol_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_wol_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_smux_rx_wol_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_smux_rx_wol_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_rx_wol_int_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_smux_rx_wol_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_rx_wol_int_ena_w1s bdk_cgxx_smux_rx_wol_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020090ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_WOL_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(a,b) bdk_cgxx_smux_rx_wol_int_ena_w1s_t
#define bustype_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(a,b) "CGXX_SMUX_RX_WOL_INT_ENA_W1S"
#define device_bar_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_WOL_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_rx_wol_int_w1s
 *
 * CGX SMU RX WOL Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_smux_rx_wol_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_smux_rx_wol_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_rx_wol_int_w1s_s cn9; */
    /* struct bdk_cgxx_smux_rx_wol_int_w1s_s cn96xx; */
    struct bdk_cgxx_smux_rx_wol_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_rx_wol_int_w1s_s cnf95xx; */
    struct bdk_cgxx_smux_rx_wol_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
#else /* Word 0 - Little Endian */
        uint64_t wol_rcvd              : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_RX_WOL_INT[WOL_RCVD]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_rx_wol_int_w1s bdk_cgxx_smux_rx_wol_int_w1s_t;

static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_RX_WOL_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020080ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_RX_WOL_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_RX_WOL_INT_W1S(a,b) bdk_cgxx_smux_rx_wol_int_w1s_t
#define bustype_BDK_CGXX_SMUX_RX_WOL_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_RX_WOL_INT_W1S(a,b) "CGXX_SMUX_RX_WOL_INT_W1S"
#define device_bar_BDK_CGXX_SMUX_RX_WOL_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_RX_WOL_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_SMUX_RX_WOL_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_smac
 *
 * CGX SMU SMAC Registers
 */
union bdk_cgxx_smux_smac
{
    uint64_t u;
    struct bdk_cgxx_smux_smac_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t smac                  : 48; /**< [ 47:  0](R/W) The [SMAC] field is used for generating and accepting control PAUSE packets. */
#else /* Word 0 - Little Endian */
        uint64_t smac                  : 48; /**< [ 47:  0](R/W) The [SMAC] field is used for generating and accepting control PAUSE packets. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_smac_s cn; */
};
typedef union bdk_cgxx_smux_smac bdk_cgxx_smux_smac_t;

static inline uint64_t BDK_CGXX_SMUX_SMAC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_SMAC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_SMAC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_SMAC(a,b) bdk_cgxx_smux_smac_t
#define bustype_BDK_CGXX_SMUX_SMAC(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_SMAC(a,b) "CGXX_SMUX_SMAC"
#define device_bar_BDK_CGXX_SMUX_SMAC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_SMAC(a,b) (a)
#define arguments_BDK_CGXX_SMUX_SMAC(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_append
 *
 * CGX SMU TX Append Control Registers
 * For more details on the interactions between FCS and PAD, see also the description of
 * CGX()_SMU()_TX_MIN_PKT[MIN_SIZE].
 */
union bdk_cgxx_smux_tx_append
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_append_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t fcs_c                 : 1;  /**< [  3:  3](R/W) Append the Ethernet FCS on each PAUSE packet. PAUSE packets are normally padded to 60
                                                                 bytes. If CGX()_SMU()_TX_MIN_PKT[MIN_SIZE] exceeds 59, then [FCS_C] is not used. */
        uint64_t fcs_d                 : 1;  /**< [  2:  2](R/W) Append the Ethernet FCS on each data packet. */
        uint64_t pad                   : 1;  /**< [  1:  1](R/W) Append PAD bytes such that minimum-sized packet is transmitted. */
        uint64_t preamble              : 1;  /**< [  0:  0](R/W) Prepend the Ethernet preamble on each transfer. When CGX()_SMU()_TX_CTL[HG_EN] is
                                                                 set, [PREAMBLE] must be 0. */
#else /* Word 0 - Little Endian */
        uint64_t preamble              : 1;  /**< [  0:  0](R/W) Prepend the Ethernet preamble on each transfer. When CGX()_SMU()_TX_CTL[HG_EN] is
                                                                 set, [PREAMBLE] must be 0. */
        uint64_t pad                   : 1;  /**< [  1:  1](R/W) Append PAD bytes such that minimum-sized packet is transmitted. */
        uint64_t fcs_d                 : 1;  /**< [  2:  2](R/W) Append the Ethernet FCS on each data packet. */
        uint64_t fcs_c                 : 1;  /**< [  3:  3](R/W) Append the Ethernet FCS on each PAUSE packet. PAUSE packets are normally padded to 60
                                                                 bytes. If CGX()_SMU()_TX_MIN_PKT[MIN_SIZE] exceeds 59, then [FCS_C] is not used. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_append_s cn; */
};
typedef union bdk_cgxx_smux_tx_append bdk_cgxx_smux_tx_append_t;

static inline uint64_t BDK_CGXX_SMUX_TX_APPEND(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_APPEND(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_APPEND", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_APPEND(a,b) bdk_cgxx_smux_tx_append_t
#define bustype_BDK_CGXX_SMUX_TX_APPEND(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_APPEND(a,b) "CGXX_SMUX_TX_APPEND"
#define device_bar_BDK_CGXX_SMUX_TX_APPEND(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_APPEND(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_APPEND(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_ctl
 *
 * CGX SMU Transmit Control Registers
 */
union bdk_cgxx_smux_tx_ctl
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t hg_pause_hgi          : 2;  /**< [ 10:  9](R/W) HGI field for hardware-generated HiGig PAUSE packets. */
        uint64_t hg_en                 : 1;  /**< [  8:  8](R/W) Enable HiGig mode.
                                                                 When this field is set and CGX()_SMU()_RX_UDD_SKP[LEN] = 12, the interface is in
                                                                 HiGig/HiGig+ mode and the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN] = 12.
                                                                 * CGX()_SMU()_TX_APPEND[PREAMBLE] = 0.

                                                                 When this field is set and CGX()_SMU()_RX_UDD_SKP[LEN] = 16, the interface is in
                                                                 HiGig2 mode and the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN] = 16.
                                                                 * CGX()_SMU()_TX_APPEND[PREAMBLE] = 0.
                                                                 * CGX()_SMU()_CBFC_CTL[RX_EN] = 0.
                                                                 * CGX()_SMU()_CBFC_CTL[TX_EN] = 0. */
        uint64_t l2p_bp_conv           : 1;  /**< [  7:  7](R/W) If set, causes TX to generate 802.3 pause packets when CMR applies logical backpressure
                                                                 (XOFF), if and only if CGX()_SMU()_CBFC_CTL[TX_EN] is clear and
                                                                 CGX()_SMU()_HG2_CONTROL[HG2TX_EN] is clear. */
        uint64_t ls_byp                : 1;  /**< [  6:  6](R/W) Bypass the link status, as determined by the XGMII receiver, and set the link status of
                                                                 the transmitter to LS. */
        uint64_t ls                    : 2;  /**< [  5:  4](R/W) Link status.
                                                                 0 = Link OK; link runs normally. RS passes MAC data to PCS.
                                                                 1 = Local fault. RS layer sends continuous remote fault sequences.
                                                                 2 = Remote fault. RS layer sends continuous idle sequences.
                                                                 3 = Link drain. RS layer drops full packets to allow CGX and NIX to drain their FIFOs. */
        uint64_t mia_en                : 1;  /**< [  3:  3](R/W) Marker (alignment and/or RS FEC marker) idle adjustment enable. Valid
                                                                 when [DIC_EN] is set. SMU will treat each marker as 8 IDLE octets into the deficit IFG
                                                                 averaging. The current counter value can be read through CGX()_SMU()_TX_IFG[MIA_CNT]. */
        uint64_t x4a_dis               : 1;  /**< [  2:  2](R/W) Disable 4-byte SOP align (effectively force 8-byte SOP align) for the following modes:
                                                                 XAUI, RXAUI, 10G, 25G, USXGMII. */
        uint64_t uni_en                : 1;  /**< [  1:  1](R/W) Enable unidirectional mode (IEEE Clause 66). */
        uint64_t dic_en                : 1;  /**< [  0:  0](R/W) Enable the deficit idle counter for IFG averaging. */
#else /* Word 0 - Little Endian */
        uint64_t dic_en                : 1;  /**< [  0:  0](R/W) Enable the deficit idle counter for IFG averaging. */
        uint64_t uni_en                : 1;  /**< [  1:  1](R/W) Enable unidirectional mode (IEEE Clause 66). */
        uint64_t x4a_dis               : 1;  /**< [  2:  2](R/W) Disable 4-byte SOP align (effectively force 8-byte SOP align) for the following modes:
                                                                 XAUI, RXAUI, 10G, 25G, USXGMII. */
        uint64_t mia_en                : 1;  /**< [  3:  3](R/W) Marker (alignment and/or RS FEC marker) idle adjustment enable. Valid
                                                                 when [DIC_EN] is set. SMU will treat each marker as 8 IDLE octets into the deficit IFG
                                                                 averaging. The current counter value can be read through CGX()_SMU()_TX_IFG[MIA_CNT]. */
        uint64_t ls                    : 2;  /**< [  5:  4](R/W) Link status.
                                                                 0 = Link OK; link runs normally. RS passes MAC data to PCS.
                                                                 1 = Local fault. RS layer sends continuous remote fault sequences.
                                                                 2 = Remote fault. RS layer sends continuous idle sequences.
                                                                 3 = Link drain. RS layer drops full packets to allow CGX and NIX to drain their FIFOs. */
        uint64_t ls_byp                : 1;  /**< [  6:  6](R/W) Bypass the link status, as determined by the XGMII receiver, and set the link status of
                                                                 the transmitter to LS. */
        uint64_t l2p_bp_conv           : 1;  /**< [  7:  7](R/W) If set, causes TX to generate 802.3 pause packets when CMR applies logical backpressure
                                                                 (XOFF), if and only if CGX()_SMU()_CBFC_CTL[TX_EN] is clear and
                                                                 CGX()_SMU()_HG2_CONTROL[HG2TX_EN] is clear. */
        uint64_t hg_en                 : 1;  /**< [  8:  8](R/W) Enable HiGig mode.
                                                                 When this field is set and CGX()_SMU()_RX_UDD_SKP[LEN] = 12, the interface is in
                                                                 HiGig/HiGig+ mode and the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN] = 12.
                                                                 * CGX()_SMU()_TX_APPEND[PREAMBLE] = 0.

                                                                 When this field is set and CGX()_SMU()_RX_UDD_SKP[LEN] = 16, the interface is in
                                                                 HiGig2 mode and the following must be set:
                                                                 * CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
                                                                 * CGX()_SMU()_RX_UDD_SKP[LEN] = 16.
                                                                 * CGX()_SMU()_TX_APPEND[PREAMBLE] = 0.
                                                                 * CGX()_SMU()_CBFC_CTL[RX_EN] = 0.
                                                                 * CGX()_SMU()_CBFC_CTL[TX_EN] = 0. */
        uint64_t hg_pause_hgi          : 2;  /**< [ 10:  9](R/W) HGI field for hardware-generated HiGig PAUSE packets. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_ctl_s cn; */
};
typedef union bdk_cgxx_smux_tx_ctl bdk_cgxx_smux_tx_ctl_t;

static inline uint64_t BDK_CGXX_SMUX_TX_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020178ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020178ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020178ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020178ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_CTL(a,b) bdk_cgxx_smux_tx_ctl_t
#define bustype_BDK_CGXX_SMUX_TX_CTL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_CTL(a,b) "CGXX_SMUX_TX_CTL"
#define device_bar_BDK_CGXX_SMUX_TX_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_CTL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_dack
 *
 * CGX SMU TX Drop Counters Registers
 */
union bdk_cgxx_smux_tx_dack
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_dack_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dpi_sdrop_ack         : 16; /**< [ 15:  0](R/W/H) Number of decrements to CGX()_SMU()_TX_DCNT[DPI_SDROP_CNT]. Read returns
                                                                 CGX()_SMU()_TX_DCNT[DPI_SDROP_CNT]. */
#else /* Word 0 - Little Endian */
        uint64_t dpi_sdrop_ack         : 16; /**< [ 15:  0](R/W/H) Number of decrements to CGX()_SMU()_TX_DCNT[DPI_SDROP_CNT]. Read returns
                                                                 CGX()_SMU()_TX_DCNT[DPI_SDROP_CNT]. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_dack_s cn; */
};
typedef union bdk_cgxx_smux_tx_dack bdk_cgxx_smux_tx_dack_t;

static inline uint64_t BDK_CGXX_SMUX_TX_DACK(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_DACK(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00201b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00201b0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00201b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00201b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_DACK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_DACK(a,b) bdk_cgxx_smux_tx_dack_t
#define bustype_BDK_CGXX_SMUX_TX_DACK(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_DACK(a,b) "CGXX_SMUX_TX_DACK"
#define device_bar_BDK_CGXX_SMUX_TX_DACK(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_DACK(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_DACK(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_dcnt
 *
 * CGX SMU TX Drop Counters Registers
 */
union bdk_cgxx_smux_tx_dcnt
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_dcnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dpi_sdrop_cnt         : 16; /**< [ 15:  0](RO/H) Loopback short packet drop counter. The interrupt bit for this counter is
                                                                 CGX()_SMU()_TX_INT[DPI_SDROP]. This counter saturates at 0xffff. Software
                                                                 acknowledges this field through CGX()_SMU()_TX_DACK[DPI_SDROP_ACK]. */
#else /* Word 0 - Little Endian */
        uint64_t dpi_sdrop_cnt         : 16; /**< [ 15:  0](RO/H) Loopback short packet drop counter. The interrupt bit for this counter is
                                                                 CGX()_SMU()_TX_INT[DPI_SDROP]. This counter saturates at 0xffff. Software
                                                                 acknowledges this field through CGX()_SMU()_TX_DACK[DPI_SDROP_ACK]. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_dcnt_s cn; */
};
typedef union bdk_cgxx_smux_tx_dcnt bdk_cgxx_smux_tx_dcnt_t;

static inline uint64_t BDK_CGXX_SMUX_TX_DCNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_DCNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_DCNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_DCNT(a,b) bdk_cgxx_smux_tx_dcnt_t
#define bustype_BDK_CGXX_SMUX_TX_DCNT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_DCNT(a,b) "CGXX_SMUX_TX_DCNT"
#define device_bar_BDK_CGXX_SMUX_TX_DCNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_DCNT(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_DCNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_eee
 *
 * INTERNAL: CGX SMU TX EEE Configure Registers
 *
 * Resvered.
 * Internal:
 * These registers control when SMU TX requests to enter or exist LPI. Those registers
 * take effect only when EEE is supported and enabled for a given LMAC.
 */
union bdk_cgxx_smux_tx_eee
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_eee_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_lpi                : 1;  /**< [ 63: 63](RO/H) Reserved.
                                                                 Internal:
                                                                 SMU TX is in LPI state. */
        uint64_t tx_lpi_wake           : 1;  /**< [ 62: 62](RO/H) Reserved.
                                                                 Internal:
                                                                 SMU TX is in LPI WAKE state. */
        uint64_t reserved_60_61        : 2;
        uint64_t idle_cnt              : 28; /**< [ 59: 32](RO/H) Reserved.
                                                                 Internal:
                                                                 The current idle counter value is only valid when [AUTO_LPI] is set. The counter
                                                                 will be increased during idle state while 128 bits have been transmitted. The
                                                                 counter will be saturated at [IDLE_THRESH]. */
        uint64_t auto_lpi              : 1;  /**< [ 31: 31](R/W) Reserved.
                                                                 Internal:
                                                                 SMU TX will send LPI requests to SPU when the bit is set and the idle counter
                                                                 reaches [IDLE_THRESH]. While in LPI state, SMU TX will switch to send idle once
                                                                 the transmitter has packets (including flow control packets) to send or [WAKEUP]
                                                                 is set by software. */
        uint64_t wakeup                : 1;  /**< [ 30: 30](R/W/H) Reserved.
                                                                 Internal:
                                                                 [WAKEUP] is valid only when [AUTO_LPI] is set and only writable by software
                                                                 when the transmitter is in LPI state. While SMU transmitter is in LPI state,
                                                                 software can use this bit to switch SMU TX from sending LPI to sending idle to
                                                                 SPU. [WAKEUP] will be automatically cleared by CGX when the switching is
                                                                 initiated by CGX. */
        uint64_t force_lpi             : 1;  /**< [ 29: 29](R/W) Reserved.
                                                                 Internal:
                                                                 [FORCE_LPI] is only valid when [AUTO_LPI] is cleared. SMU TX will send LPI
                                                                 requests to SPU immediately after the current packet is transmitted when the bit
                                                                 is set. While in LPI mode, SMU transmitter will switch to send idle once the bit
                                                                 is cleared. */
        uint64_t reserved_28           : 1;
        uint64_t idle_thresh           : 28; /**< [ 27:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Idle threshold. [IDLE_THRESH] is only used when [AUTO_LPI] is set. SMU
                                                                 transmitter will send LPI requests to SPU when the idle counter reaches this
                                                                 threshold. The units of this value are 128-bit word (or a SPU heart beat). Note
                                                                 that active flow control of a enabled LMAC will keep the corresponding LMAC not
                                                                 idle. */
#else /* Word 0 - Little Endian */
        uint64_t idle_thresh           : 28; /**< [ 27:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Idle threshold. [IDLE_THRESH] is only used when [AUTO_LPI] is set. SMU
                                                                 transmitter will send LPI requests to SPU when the idle counter reaches this
                                                                 threshold. The units of this value are 128-bit word (or a SPU heart beat). Note
                                                                 that active flow control of a enabled LMAC will keep the corresponding LMAC not
                                                                 idle. */
        uint64_t reserved_28           : 1;
        uint64_t force_lpi             : 1;  /**< [ 29: 29](R/W) Reserved.
                                                                 Internal:
                                                                 [FORCE_LPI] is only valid when [AUTO_LPI] is cleared. SMU TX will send LPI
                                                                 requests to SPU immediately after the current packet is transmitted when the bit
                                                                 is set. While in LPI mode, SMU transmitter will switch to send idle once the bit
                                                                 is cleared. */
        uint64_t wakeup                : 1;  /**< [ 30: 30](R/W/H) Reserved.
                                                                 Internal:
                                                                 [WAKEUP] is valid only when [AUTO_LPI] is set and only writable by software
                                                                 when the transmitter is in LPI state. While SMU transmitter is in LPI state,
                                                                 software can use this bit to switch SMU TX from sending LPI to sending idle to
                                                                 SPU. [WAKEUP] will be automatically cleared by CGX when the switching is
                                                                 initiated by CGX. */
        uint64_t auto_lpi              : 1;  /**< [ 31: 31](R/W) Reserved.
                                                                 Internal:
                                                                 SMU TX will send LPI requests to SPU when the bit is set and the idle counter
                                                                 reaches [IDLE_THRESH]. While in LPI state, SMU TX will switch to send idle once
                                                                 the transmitter has packets (including flow control packets) to send or [WAKEUP]
                                                                 is set by software. */
        uint64_t idle_cnt              : 28; /**< [ 59: 32](RO/H) Reserved.
                                                                 Internal:
                                                                 The current idle counter value is only valid when [AUTO_LPI] is set. The counter
                                                                 will be increased during idle state while 128 bits have been transmitted. The
                                                                 counter will be saturated at [IDLE_THRESH]. */
        uint64_t reserved_60_61        : 2;
        uint64_t tx_lpi_wake           : 1;  /**< [ 62: 62](RO/H) Reserved.
                                                                 Internal:
                                                                 SMU TX is in LPI WAKE state. */
        uint64_t tx_lpi                : 1;  /**< [ 63: 63](RO/H) Reserved.
                                                                 Internal:
                                                                 SMU TX is in LPI state. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_eee_s cn; */
};
typedef union bdk_cgxx_smux_tx_eee bdk_cgxx_smux_tx_eee_t;

static inline uint64_t BDK_CGXX_SMUX_TX_EEE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_EEE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_EEE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_EEE(a,b) bdk_cgxx_smux_tx_eee_t
#define bustype_BDK_CGXX_SMUX_TX_EEE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_EEE(a,b) "CGXX_SMUX_TX_EEE"
#define device_bar_BDK_CGXX_SMUX_TX_EEE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_EEE(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_EEE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_eee_timer_status
 *
 * INTERNAL: CGX SMU TX EEE TIMER STATUS Registers
 *
 * Reserved.
 * Internal:
 * These registers configure SMU TX EEE timing parameters.
 */
union bdk_cgxx_smux_tx_eee_timer_status
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_eee_timer_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t link_timer_done       : 1;  /**< [ 63: 63](RO/H) Reserved. */
        uint64_t reserved_62           : 1;
        uint64_t link_ok_cnt           : 30; /**< [ 61: 32](RO/H) Reserved.
                                                                 Internal:
                                                                 The current value of LINK OK timer. The timer will saturated at
                                                                 CGX()_SMU()_TX_EEE_TIMING[LINK_OK_MIN] when [LINK_TIMER_DONE] is set. */
        uint64_t wake_timer_done       : 1;  /**< [ 31: 31](RO/H) Reserved. */
        uint64_t reserved_16_30        : 15;
        uint64_t lpi_wake_cnt          : 16; /**< [ 15:  0](RO/H) Reserved.
                                                                 Internal:
                                                                 The current value of LPI wake timer. The timer will saturated at
                                                                 CGX()_SMU()_TX_EEE_TIMING[W_SYS_TX_MIN] when [WAKE_TIMER_DONE]
                                                                 is set. */
#else /* Word 0 - Little Endian */
        uint64_t lpi_wake_cnt          : 16; /**< [ 15:  0](RO/H) Reserved.
                                                                 Internal:
                                                                 The current value of LPI wake timer. The timer will saturated at
                                                                 CGX()_SMU()_TX_EEE_TIMING[W_SYS_TX_MIN] when [WAKE_TIMER_DONE]
                                                                 is set. */
        uint64_t reserved_16_30        : 15;
        uint64_t wake_timer_done       : 1;  /**< [ 31: 31](RO/H) Reserved. */
        uint64_t link_ok_cnt           : 30; /**< [ 61: 32](RO/H) Reserved.
                                                                 Internal:
                                                                 The current value of LINK OK timer. The timer will saturated at
                                                                 CGX()_SMU()_TX_EEE_TIMING[LINK_OK_MIN] when [LINK_TIMER_DONE] is set. */
        uint64_t reserved_62           : 1;
        uint64_t link_timer_done       : 1;  /**< [ 63: 63](RO/H) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_eee_timer_status_s cn; */
};
typedef union bdk_cgxx_smux_tx_eee_timer_status bdk_cgxx_smux_tx_eee_timer_status_t;

static inline uint64_t BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_EEE_TIMER_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(a,b) bdk_cgxx_smux_tx_eee_timer_status_t
#define bustype_BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(a,b) "CGXX_SMUX_TX_EEE_TIMER_STATUS"
#define device_bar_BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_EEE_TIMER_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_eee_timing
 *
 * INTERNAL: CGX SMU TX EEE TIMING Parameter Registers
 *
 * Reserved.
 * Internal:
 * These registers configure SMU TX EEE timing parameters.
 */
union bdk_cgxx_smux_tx_eee_timing
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_eee_timing_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t link_ok_min           : 30; /**< [ 61: 32](R/W) Reserved.
                                                                 Internal:
                                                                 LPI request shall not be asserted unless the attached link has been operational
                                                                 for at least one second (i.e link_status == OK according to the underlying
                                                                 PCS/PMA). See clause 81.1.7 of IEEE 802.3bj-2014 for this requirement for
                                                                 100 Gbps/40 Gbps operation and clause 46.1.7 for 10 Gbps. Reset value gives one
                                                                 second delay. Time units are 10 ns based on 100 MHz reference clock. */
        uint64_t reserved_16_31        : 16;
        uint64_t w_sys_tx_min          : 16; /**< [ 15:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Parameter employed by the system that corresponds to its requirement. This is
                                                                 the minimal requirement of period of time the system has to wait between a
                                                                 request to transmit and its readiness to transmit. See Table 78-4 of IEEE Std
                                                                 802.3bj-2014 for the summary of the LPI timing parameters for supported PHYs or
                                                                 interfaces. Reset values gives 5.5 us delay. Time units are 10 ns based on 100
                                                                 MHz reference clock. */
#else /* Word 0 - Little Endian */
        uint64_t w_sys_tx_min          : 16; /**< [ 15:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Parameter employed by the system that corresponds to its requirement. This is
                                                                 the minimal requirement of period of time the system has to wait between a
                                                                 request to transmit and its readiness to transmit. See Table 78-4 of IEEE Std
                                                                 802.3bj-2014 for the summary of the LPI timing parameters for supported PHYs or
                                                                 interfaces. Reset values gives 5.5 us delay. Time units are 10 ns based on 100
                                                                 MHz reference clock. */
        uint64_t reserved_16_31        : 16;
        uint64_t link_ok_min           : 30; /**< [ 61: 32](R/W) Reserved.
                                                                 Internal:
                                                                 LPI request shall not be asserted unless the attached link has been operational
                                                                 for at least one second (i.e link_status == OK according to the underlying
                                                                 PCS/PMA). See clause 81.1.7 of IEEE 802.3bj-2014 for this requirement for
                                                                 100 Gbps/40 Gbps operation and clause 46.1.7 for 10 Gbps. Reset value gives one
                                                                 second delay. Time units are 10 ns based on 100 MHz reference clock. */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_eee_timing_s cn; */
};
typedef union bdk_cgxx_smux_tx_eee_timing bdk_cgxx_smux_tx_eee_timing_t;

static inline uint64_t BDK_CGXX_SMUX_TX_EEE_TIMING(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_EEE_TIMING(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_EEE_TIMING", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_EEE_TIMING(a,b) bdk_cgxx_smux_tx_eee_timing_t
#define bustype_BDK_CGXX_SMUX_TX_EEE_TIMING(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_EEE_TIMING(a,b) "CGXX_SMUX_TX_EEE_TIMING"
#define device_bar_BDK_CGXX_SMUX_TX_EEE_TIMING(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_EEE_TIMING(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_EEE_TIMING(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_ifg
 *
 * CGX SMU TX Interframe-Gap Cycles Registers
 * Programming IFG1 and IFG2:
 * * For XAUI/RXAUI/10G/25G/40G/50G/100G systems that require IEEE 802.3
 * compatibility, the [IFG1]+[IFG2] sum must be 12.
 * * In loopback mode, the [IFG1]+[IFG2] of local and remote parties must match exactly;
 * otherwise loopback FIFO will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
 * * When CGX()_SMU()_TX_CTL[DIC_EN] is set, [IFG1]+[IFG2] sum must be at least 8.
 * The behavior of smaller values is un-determined.
 * * When CGX()_SMU()_TX_CTL[DIC_EN] is cleared, the minimum value of [IFG1]+[IFG2] is 1
 * for 40G/50G/100G LMAC_TYPE configurations and 5 for all other values. The behavior
 * of smaller values is un-determined.
 *
 * Internal:
 * When CGX()_SMU()_TX_CTL[DIC_EN] is set, SMU TX treats ([IFG1]+[IFG2]) \< 8 as 8 for
 * 40G/50G/100G MACs and ([IFG1]+[IFG2]) \< 8 as 8 for other MACs. When
 * CGX()_SMU()_TX_CTL[DIC_EN] is cleared, SMU TX can work correctly with any IFG1 and
 * IFG2.
 */
union bdk_cgxx_smux_tx_ifg
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_ifg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t mia_cnt               : 8;  /**< [ 23: 16](RO/H) The current value of the marker idle adjustment counter. The MIA counter will be
                                                                 increased by 8 or 16 when SMU receives a
                                                                 marker heartbeat from SPU and may be decreased when IFG is generated. The
                                                                 counter does not rollover past the maximum value and will be reset
                                                                 once CGX()_SMU()_TX_CTL[DIC_EN] is cleared or the LMAC is idle. */
        uint64_t reserved_10_15        : 6;
        uint64_t mia_amt               : 2;  /**< [  9:  8](R/W) Marker (alignment and/or RS FEC marker) idle adjustment amount. Only used
                                                                 when CGX()_SMU()_TX_CTL[DIC_EN] and CGX()_SMU()_TX_CTL[MIA_EN] are set. During
                                                                 marker idle adjustment, IFG will be temporily reduced to [IFG1]+[IFG2] -
                                                                 [MIA_AMT]. It is recommended that [IFG1]+[IFG2] - [MIA_AMT] \>= 8. When frame
                                                                 preemption is enabled, [MIA_AMT] must remain at the default value when both
                                                                 CGX()_SMU()_TX_CTL[DIC_EN] and CGX()_SMU()_TX_CTL[MIA_EN] are set.

                                                                 For 40G/50G/100G LMAC_TYPE configurations, the minimum IFG may temporarily be smaller
                                                                 than 5 octets during MIA. For 10G/25G LMAC_TYPE configurations, the minimum IFG may
                                                                 temporarily be smaller than 9 octets during MIA. When [MIA_AMT] is programmed to be
                                                                 0x0, MIA may not be achieved due to SOP alignment and minimal IFG requirements. */
        uint64_t ifg2                  : 4;  /**< [  7:  4](R/W) 1/2 of the interframe gap timing (in IFG2*8 bits). */
        uint64_t ifg1                  : 4;  /**< [  3:  0](R/W) 1/2 of the interframe gap timing (in IFG1*8 bits). */
#else /* Word 0 - Little Endian */
        uint64_t ifg1                  : 4;  /**< [  3:  0](R/W) 1/2 of the interframe gap timing (in IFG1*8 bits). */
        uint64_t ifg2                  : 4;  /**< [  7:  4](R/W) 1/2 of the interframe gap timing (in IFG2*8 bits). */
        uint64_t mia_amt               : 2;  /**< [  9:  8](R/W) Marker (alignment and/or RS FEC marker) idle adjustment amount. Only used
                                                                 when CGX()_SMU()_TX_CTL[DIC_EN] and CGX()_SMU()_TX_CTL[MIA_EN] are set. During
                                                                 marker idle adjustment, IFG will be temporily reduced to [IFG1]+[IFG2] -
                                                                 [MIA_AMT]. It is recommended that [IFG1]+[IFG2] - [MIA_AMT] \>= 8. When frame
                                                                 preemption is enabled, [MIA_AMT] must remain at the default value when both
                                                                 CGX()_SMU()_TX_CTL[DIC_EN] and CGX()_SMU()_TX_CTL[MIA_EN] are set.

                                                                 For 40G/50G/100G LMAC_TYPE configurations, the minimum IFG may temporarily be smaller
                                                                 than 5 octets during MIA. For 10G/25G LMAC_TYPE configurations, the minimum IFG may
                                                                 temporarily be smaller than 9 octets during MIA. When [MIA_AMT] is programmed to be
                                                                 0x0, MIA may not be achieved due to SOP alignment and minimal IFG requirements. */
        uint64_t reserved_10_15        : 6;
        uint64_t mia_cnt               : 8;  /**< [ 23: 16](RO/H) The current value of the marker idle adjustment counter. The MIA counter will be
                                                                 increased by 8 or 16 when SMU receives a
                                                                 marker heartbeat from SPU and may be decreased when IFG is generated. The
                                                                 counter does not rollover past the maximum value and will be reset
                                                                 once CGX()_SMU()_TX_CTL[DIC_EN] is cleared or the LMAC is idle. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_ifg_s cn; */
};
typedef union bdk_cgxx_smux_tx_ifg bdk_cgxx_smux_tx_ifg_t;

static inline uint64_t BDK_CGXX_SMUX_TX_IFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_IFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_IFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_IFG(a,b) bdk_cgxx_smux_tx_ifg_t
#define bustype_BDK_CGXX_SMUX_TX_IFG(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_IFG(a,b) "CGXX_SMUX_TX_IFG"
#define device_bar_BDK_CGXX_SMUX_TX_IFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_IFG(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_IFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_int
 *
 * CGX SMU TX Interrupt Registers
 */
union bdk_cgxx_smux_tx_int
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) TX dropped short packet(s) with length \< 16 bytes. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) TX loopback overflow. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) TX loopback underflow. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) SMU TX started a packet with PTP on SOP and has not seen a commit for it from SPU TX after seeing
                                                                 128 SPU heartbeats so it faked a commit to CMR. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Link status changed. This denotes a change to CGX()_SMU()_RX_CTL[STATUS]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) TX underflow. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) TX underflow. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Link status changed. This denotes a change to CGX()_SMU()_RX_CTL[STATUS]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) SMU TX started a packet with PTP on SOP and has not seen a commit for it from SPU TX after seeing
                                                                 128 SPU heartbeats so it faked a commit to CMR. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) TX loopback underflow. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) TX loopback overflow. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) TX dropped short packet(s) with length \< 16 bytes. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_int_s cn; */
};
typedef union bdk_cgxx_smux_tx_int bdk_cgxx_smux_tx_int_t;

static inline uint64_t BDK_CGXX_SMUX_TX_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_INT(a,b) bdk_cgxx_smux_tx_int_t
#define bustype_BDK_CGXX_SMUX_TX_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_INT(a,b) "CGXX_SMUX_TX_INT"
#define device_bar_BDK_CGXX_SMUX_TX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_INT(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_int_ena_w1c
 *
 * CGX SMU TX Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_smux_tx_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_smux_tx_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_smux_tx_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_tx_int_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_smux_tx_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_tx_int_ena_w1c bdk_cgxx_smux_tx_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_SMUX_TX_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_INT_ENA_W1C(a,b) bdk_cgxx_smux_tx_int_ena_w1c_t
#define bustype_BDK_CGXX_SMUX_TX_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_INT_ENA_W1C(a,b) "CGXX_SMUX_TX_INT_ENA_W1C"
#define device_bar_BDK_CGXX_SMUX_TX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_int_ena_w1s
 *
 * CGX SMU TX Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_smux_tx_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_smux_tx_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_smux_tx_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_tx_int_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_smux_tx_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_tx_int_ena_w1s bdk_cgxx_smux_tx_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_SMUX_TX_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_INT_ENA_W1S(a,b) bdk_cgxx_smux_tx_int_ena_w1s_t
#define bustype_BDK_CGXX_SMUX_TX_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_INT_ENA_W1S(a,b) "CGXX_SMUX_TX_INT_ENA_W1S"
#define device_bar_BDK_CGXX_SMUX_TX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_int_w1s
 *
 * CGX SMU TX Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_smux_tx_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_int_w1s_s cn9; */
    /* struct bdk_cgxx_smux_tx_int_w1s_s cn96xx; */
    struct bdk_cgxx_smux_tx_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_smux_tx_int_w1s_s cnf95xx; */
    struct bdk_cgxx_smux_tx_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[UNDFLW]. */
#else /* Word 0 - Little Endian */
        uint64_t undflw                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[UNDFLW]. */
        uint64_t xchange               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[XCHANGE]. */
        uint64_t fake_commit           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[FAKE_COMMIT]. */
        uint64_t lb_undflw             : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[LB_UNDFLW]. */
        uint64_t lb_ovrflw             : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[LB_OVRFLW]. */
        uint64_t dpi_sdrop             : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_SMU(0..3)_TX_INT[DPI_SDROP]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_smux_tx_int_w1s bdk_cgxx_smux_tx_int_w1s_t;

static inline uint64_t BDK_CGXX_SMUX_TX_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_INT_W1S(a,b) bdk_cgxx_smux_tx_int_w1s_t
#define bustype_BDK_CGXX_SMUX_TX_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_INT_W1S(a,b) "CGXX_SMUX_TX_INT_W1S"
#define device_bar_BDK_CGXX_SMUX_TX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_min_pkt
 *
 * CGX SMU TX Minimum-Size-Packet Registers
 * Internal:
 * [MIN_SIZE] less than 16 will be ignored by hardware which will use 16 instead.
 */
union bdk_cgxx_smux_tx_min_pkt
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_min_pkt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t min_size              : 8;  /**< [  7:  0](R/W) Min frame size in bytes inclusive of FCS, if applied. Padding is only appended when
                                                                 CGX()_SMU()_TX_APPEND[PAD] for the corresponding port is set. When FCS is added to
                                                                 a packet which was padded, the FCS always appears in the four octets preceding /T/ or /E/. */
#else /* Word 0 - Little Endian */
        uint64_t min_size              : 8;  /**< [  7:  0](R/W) Min frame size in bytes inclusive of FCS, if applied. Padding is only appended when
                                                                 CGX()_SMU()_TX_APPEND[PAD] for the corresponding port is set. When FCS is added to
                                                                 a packet which was padded, the FCS always appears in the four octets preceding /T/ or /E/. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_min_pkt_s cn; */
};
typedef union bdk_cgxx_smux_tx_min_pkt bdk_cgxx_smux_tx_min_pkt_t;

static inline uint64_t BDK_CGXX_SMUX_TX_MIN_PKT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_MIN_PKT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_MIN_PKT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_MIN_PKT(a,b) bdk_cgxx_smux_tx_min_pkt_t
#define bustype_BDK_CGXX_SMUX_TX_MIN_PKT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_MIN_PKT(a,b) "CGXX_SMUX_TX_MIN_PKT"
#define device_bar_BDK_CGXX_SMUX_TX_MIN_PKT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_MIN_PKT(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_MIN_PKT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_pause_pkt_dmac
 *
 * CGX SMU TX PAUSE-Packet DMAC-Field Registers
 * This register provides the DMAC value that is placed in outbound PAUSE packets.
 */
union bdk_cgxx_smux_tx_pause_pkt_dmac
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_pause_pkt_dmac_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The DMAC field that is placed in outbound PAUSE packets. */
#else /* Word 0 - Little Endian */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) The DMAC field that is placed in outbound PAUSE packets. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_pause_pkt_dmac_s cn; */
};
typedef union bdk_cgxx_smux_tx_pause_pkt_dmac bdk_cgxx_smux_tx_pause_pkt_dmac_t;

static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_PAUSE_PKT_DMAC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(a,b) bdk_cgxx_smux_tx_pause_pkt_dmac_t
#define bustype_BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(a,b) "CGXX_SMUX_TX_PAUSE_PKT_DMAC"
#define device_bar_BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_PAUSE_PKT_DMAC(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_pause_pkt_interval
 *
 * CGX SMU TX PAUSE-Packet Transmission-Interval Registers
 * This register specifies how often PAUSE packets are sent.
 */
union bdk_cgxx_smux_tx_pause_pkt_interval
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_pause_pkt_interval_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t hg2_intra_en          : 1;  /**< [ 32: 32](R/W) Allow intrapacket HiGig2 message generation. Relevant only if HiGig2 message generation is enabled. */
        uint64_t hg2_intra_interval    : 16; /**< [ 31: 16](R/W) Arbitrate for a HiGig2 message, every (INTERVAL*512) bit-times while sending regular
                                                                 packet data. Relevant only if HiGig2 message generation and [HG2_INTRA_EN] are both set.
                                                                 Normally, 0 \< INTERVAL \< CGX()_SMU()_TX_PAUSE_PKT_TIME.

                                                                 INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
        uint64_t interval              : 16; /**< [ 15:  0](R/W) Arbitrate for a 802.3 PAUSE packet, HiGig2 message, or PFC packet every
                                                                 (INTERVAL * 512) bit-times.
                                                                 Normally, 0 \< INTERVAL \< CGX()_SMU()_TX_PAUSE_PKT_TIME[P_TIME].

                                                                 INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
#else /* Word 0 - Little Endian */
        uint64_t interval              : 16; /**< [ 15:  0](R/W) Arbitrate for a 802.3 PAUSE packet, HiGig2 message, or PFC packet every
                                                                 (INTERVAL * 512) bit-times.
                                                                 Normally, 0 \< INTERVAL \< CGX()_SMU()_TX_PAUSE_PKT_TIME[P_TIME].

                                                                 INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
        uint64_t hg2_intra_interval    : 16; /**< [ 31: 16](R/W) Arbitrate for a HiGig2 message, every (INTERVAL*512) bit-times while sending regular
                                                                 packet data. Relevant only if HiGig2 message generation and [HG2_INTRA_EN] are both set.
                                                                 Normally, 0 \< INTERVAL \< CGX()_SMU()_TX_PAUSE_PKT_TIME.

                                                                 INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
        uint64_t hg2_intra_en          : 1;  /**< [ 32: 32](R/W) Allow intrapacket HiGig2 message generation. Relevant only if HiGig2 message generation is enabled. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_pause_pkt_interval_s cn; */
};
typedef union bdk_cgxx_smux_tx_pause_pkt_interval bdk_cgxx_smux_tx_pause_pkt_interval_t;

static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_PAUSE_PKT_INTERVAL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(a,b) bdk_cgxx_smux_tx_pause_pkt_interval_t
#define bustype_BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(a,b) "CGXX_SMUX_TX_PAUSE_PKT_INTERVAL"
#define device_bar_BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_pause_pkt_time
 *
 * CGX SMU TX PAUSE Packet Time Registers
 */
union bdk_cgxx_smux_tx_pause_pkt_time
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_pause_pkt_time_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t p_time                : 16; /**< [ 15:  0](R/W) Provides the pause_time field placed in outbound 802.3 PAUSE packets, HiGig2 messages, or
                                                                 PFC packets in 512 bit-times. Normally, [P_TIME] \>
                                                                 CGX()_SMU()_TX_PAUSE_PKT_INTERVAL[INTERVAL]. See programming notes in
                                                                 CGX()_SMU()_TX_PAUSE_PKT_INTERVAL. */
#else /* Word 0 - Little Endian */
        uint64_t p_time                : 16; /**< [ 15:  0](R/W) Provides the pause_time field placed in outbound 802.3 PAUSE packets, HiGig2 messages, or
                                                                 PFC packets in 512 bit-times. Normally, [P_TIME] \>
                                                                 CGX()_SMU()_TX_PAUSE_PKT_INTERVAL[INTERVAL]. See programming notes in
                                                                 CGX()_SMU()_TX_PAUSE_PKT_INTERVAL. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_pause_pkt_time_s cn; */
};
typedef union bdk_cgxx_smux_tx_pause_pkt_time bdk_cgxx_smux_tx_pause_pkt_time_t;

static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_PAUSE_PKT_TIME", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(a,b) bdk_cgxx_smux_tx_pause_pkt_time_t
#define bustype_BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(a,b) "CGXX_SMUX_TX_PAUSE_PKT_TIME"
#define device_bar_BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_PAUSE_PKT_TIME(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_pause_pkt_type
 *
 * CGX SMU TX PAUSE-Packet P_TYPE-Field Registers
 * This register provides the P_TYPE field that is placed in outbound PAUSE packets.
 */
union bdk_cgxx_smux_tx_pause_pkt_type
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_pause_pkt_type_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t p_type                : 16; /**< [ 15:  0](R/W) The P_TYPE field that is placed in outbound PAUSE packets. */
#else /* Word 0 - Little Endian */
        uint64_t p_type                : 16; /**< [ 15:  0](R/W) The P_TYPE field that is placed in outbound PAUSE packets. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_pause_pkt_type_s cn; */
};
typedef union bdk_cgxx_smux_tx_pause_pkt_type bdk_cgxx_smux_tx_pause_pkt_type_t;

static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020170ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020170ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020170ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020170ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_PAUSE_PKT_TYPE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(a,b) bdk_cgxx_smux_tx_pause_pkt_type_t
#define bustype_BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(a,b) "CGXX_SMUX_TX_PAUSE_PKT_TYPE"
#define device_bar_BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_PAUSE_PKT_TYPE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_pause_togo
 *
 * CGX SMU TX Time-to-Backpressure Registers
 */
union bdk_cgxx_smux_tx_pause_togo
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_pause_togo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t msg_time              : 16; /**< [ 31: 16](RO/H) Amount of time remaining to backpressure, from the HiGig2 physical message PAUSE timer
                                                                 (only valid on port0). */
        uint64_t p_time                : 16; /**< [ 15:  0](RO/H) Amount of time remaining to backpressure, from the standard 802.3 PAUSE timer. */
#else /* Word 0 - Little Endian */
        uint64_t p_time                : 16; /**< [ 15:  0](RO/H) Amount of time remaining to backpressure, from the standard 802.3 PAUSE timer. */
        uint64_t msg_time              : 16; /**< [ 31: 16](RO/H) Amount of time remaining to backpressure, from the HiGig2 physical message PAUSE timer
                                                                 (only valid on port0). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_pause_togo_s cn; */
};
typedef union bdk_cgxx_smux_tx_pause_togo bdk_cgxx_smux_tx_pause_togo_t;

static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_TOGO(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_TOGO(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_PAUSE_TOGO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_PAUSE_TOGO(a,b) bdk_cgxx_smux_tx_pause_togo_t
#define bustype_BDK_CGXX_SMUX_TX_PAUSE_TOGO(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_PAUSE_TOGO(a,b) "CGXX_SMUX_TX_PAUSE_TOGO"
#define device_bar_BDK_CGXX_SMUX_TX_PAUSE_TOGO(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_PAUSE_TOGO(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_PAUSE_TOGO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_pause_zero
 *
 * CGX SMU TX PAUSE Zero Registers
 */
union bdk_cgxx_smux_tx_pause_zero
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_pause_zero_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t send                  : 1;  /**< [  0:  0](R/W) Send PAUSE-zero enable. When this bit is set, and the backpressure condition is clear, it
                                                                 allows sending a PAUSE packet with pause_time of 0 to enable the channel. */
#else /* Word 0 - Little Endian */
        uint64_t send                  : 1;  /**< [  0:  0](R/W) Send PAUSE-zero enable. When this bit is set, and the backpressure condition is clear, it
                                                                 allows sending a PAUSE packet with pause_time of 0 to enable the channel. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_pause_zero_s cn; */
};
typedef union bdk_cgxx_smux_tx_pause_zero bdk_cgxx_smux_tx_pause_zero_t;

static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_ZERO(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_PAUSE_ZERO(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_PAUSE_ZERO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_PAUSE_ZERO(a,b) bdk_cgxx_smux_tx_pause_zero_t
#define bustype_BDK_CGXX_SMUX_TX_PAUSE_ZERO(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_PAUSE_ZERO(a,b) "CGXX_SMUX_TX_PAUSE_ZERO"
#define device_bar_BDK_CGXX_SMUX_TX_PAUSE_ZERO(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_PAUSE_ZERO(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_PAUSE_ZERO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_soft_pause
 *
 * CGX SMU TX Soft PAUSE Registers
 */
union bdk_cgxx_smux_tx_soft_pause
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_soft_pause_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t p_time                : 16; /**< [ 15:  0](R/W) Back off the TX bus for ([P_TIME] * 512) bit-times */
#else /* Word 0 - Little Endian */
        uint64_t p_time                : 16; /**< [ 15:  0](R/W) Back off the TX bus for ([P_TIME] * 512) bit-times */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_soft_pause_s cn; */
};
typedef union bdk_cgxx_smux_tx_soft_pause bdk_cgxx_smux_tx_soft_pause_t;

static inline uint64_t BDK_CGXX_SMUX_TX_SOFT_PAUSE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_SOFT_PAUSE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_SOFT_PAUSE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_SOFT_PAUSE(a,b) bdk_cgxx_smux_tx_soft_pause_t
#define bustype_BDK_CGXX_SMUX_TX_SOFT_PAUSE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_SOFT_PAUSE(a,b) "CGXX_SMUX_TX_SOFT_PAUSE"
#define device_bar_BDK_CGXX_SMUX_TX_SOFT_PAUSE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_SOFT_PAUSE(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_SOFT_PAUSE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_smu#_tx_thresh
 *
 * CGX SMU TX Threshold Registers
 */
union bdk_cgxx_smux_tx_thresh
{
    uint64_t u;
    struct bdk_cgxx_smux_tx_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t ecnt                  : 12; /**< [ 43: 32](R/W) Number of 128-bit words (16 bytes) to accumulate in the CMR EMAC TX FIFO before sending on the
                                                                 packet interface. This field should be large enough to prevent underflow on the packet interface.

                                                                 In all modes, this field cannot exceed the TX FIFO depth configured by
                                                                 CGX()_CMR_TX_LMACS[LMACS] (in terms of total bytes for each corresponding LMAC). */
        uint64_t reserved_29_31        : 3;
        uint64_t dpi_depth             : 5;  /**< [ 28: 24](RO) SMU LMAC DPI TX FIFO depth (in terms of 128-bit data entry). */
        uint64_t reserved_21_23        : 3;
        uint64_t dpi_thresh            : 5;  /**< [ 20: 16](R/W) Number of 128-bit words (16 bytes) to accumulate in the SMU LMAC TX DPI FIFO before
                                                                 sending on the packet interface. This field should be large enough to prevent underflow on
                                                                 the packet interface
                                                                 and generally it should be set to the round trip SMU/CMR read latency which must be less
                                                                 than [DPI_DEPTH] when there
                                                                 are multiple super LMACs enabled. Software must never set this value greater than [DPI_DEPTH]. */
        uint64_t reserved_12_15        : 4;
        uint64_t cnt                   : 12; /**< [ 11:  0](R/W) Number of 128-bit words (16 bytes) to accumulate in the CMR TX PMAC FIFO before sending on the
                                                                 packet interface. This field should be large enough to prevent underflow on the packet interface.

                                                                 In all modes, this field cannot exceed the TX FIFO depth configured by
                                                                 CGX()_CMR_TX_LMACS[LMACS] (in terms of total bytes for each corresponding LMAC). */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 12; /**< [ 11:  0](R/W) Number of 128-bit words (16 bytes) to accumulate in the CMR TX PMAC FIFO before sending on the
                                                                 packet interface. This field should be large enough to prevent underflow on the packet interface.

                                                                 In all modes, this field cannot exceed the TX FIFO depth configured by
                                                                 CGX()_CMR_TX_LMACS[LMACS] (in terms of total bytes for each corresponding LMAC). */
        uint64_t reserved_12_15        : 4;
        uint64_t dpi_thresh            : 5;  /**< [ 20: 16](R/W) Number of 128-bit words (16 bytes) to accumulate in the SMU LMAC TX DPI FIFO before
                                                                 sending on the packet interface. This field should be large enough to prevent underflow on
                                                                 the packet interface
                                                                 and generally it should be set to the round trip SMU/CMR read latency which must be less
                                                                 than [DPI_DEPTH] when there
                                                                 are multiple super LMACs enabled. Software must never set this value greater than [DPI_DEPTH]. */
        uint64_t reserved_21_23        : 3;
        uint64_t dpi_depth             : 5;  /**< [ 28: 24](RO) SMU LMAC DPI TX FIFO depth (in terms of 128-bit data entry). */
        uint64_t reserved_29_31        : 3;
        uint64_t ecnt                  : 12; /**< [ 43: 32](R/W) Number of 128-bit words (16 bytes) to accumulate in the CMR EMAC TX FIFO before sending on the
                                                                 packet interface. This field should be large enough to prevent underflow on the packet interface.

                                                                 In all modes, this field cannot exceed the TX FIFO depth configured by
                                                                 CGX()_CMR_TX_LMACS[LMACS] (in terms of total bytes for each corresponding LMAC). */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_smux_tx_thresh_s cn; */
};
typedef union bdk_cgxx_smux_tx_thresh bdk_cgxx_smux_tx_thresh_t;

static inline uint64_t BDK_CGXX_SMUX_TX_THRESH(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SMUX_TX_THRESH(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020180ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0020180ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0020180ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0020180ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SMUX_TX_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SMUX_TX_THRESH(a,b) bdk_cgxx_smux_tx_thresh_t
#define bustype_BDK_CGXX_SMUX_TX_THRESH(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SMUX_TX_THRESH(a,b) "CGXX_SMUX_TX_THRESH"
#define device_bar_BDK_CGXX_SMUX_TX_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SMUX_TX_THRESH(a,b) (a)
#define arguments_BDK_CGXX_SMUX_TX_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_an_adv
 *
 * CGX SPU Autonegotiation Advertisement Registers
 * Software programs this register with the contents of the AN-link code word base page to be
 * transmitted during autonegotiation. (See IEEE 802.3 section 73.6 for details.) Any write
 * operations to this register prior to completion of autonegotiation, as indicated by
 * CGX()_SPU()_AN_STATUS[AN_COMPLETE], should be followed by a renegotiation in order for
 * the new values to take effect. Renegotiation is initiated by setting
 * CGX()_SPU()_AN_CONTROL[AN_RESTART]. Once autonegotiation has completed, software can
 * examine this register along with CGX()_SPU()_AN_LP_BASE to determine the highest
 * common denominator technology.
 */
union bdk_cgxx_spux_an_adv
{
    uint64_t u;
    struct bdk_cgxx_spux_an_adv_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t fec_req               : 1;  /**< [ 47: 47](R/W) 10G per-lane FEC requested. */
        uint64_t fec_able              : 1;  /**< [ 46: 46](R/W) 10G per-lane FEC ability. */
        uint64_t a25g_br_fec_req       : 1;  /**< [ 45: 45](R/W) 25G BASE-R FEC requested. */
        uint64_t a25g_rs_fec_req       : 1;  /**< [ 44: 44](R/W) 25G RS-FEC requested. */
        uint64_t arsv                  : 12; /**< [ 43: 32](R/W) Technology ability. Reserved bits, should always be 0. */
        uint64_t a25g_kr_cr            : 1;  /**< [ 31: 31](R/W) 25GBASE-KR or 25GBASE-CR ability. */
        uint64_t a25g_krs_crs          : 1;  /**< [ 30: 30](R/W) 25GBASE-KR-S or 25GBASE-CR-S ability. */
        uint64_t a100g_cr4             : 1;  /**< [ 29: 29](R/W) 100GBASE-CR4 ability. */
        uint64_t a100g_kr4             : 1;  /**< [ 28: 28](R/W) 100GBASE-KR4 ability. */
        uint64_t a100g_kp4             : 1;  /**< [ 27: 27](R/W) 100GBASE-KP4 ability. Should always be 0; 100GBASE-KP4 is not supported. */
        uint64_t a100g_cr10            : 1;  /**< [ 26: 26](R/W) 100GBASE-CR10 ability. Should always be 0; 100GBASE-CR10 is not supported. */
        uint64_t a40g_cr4              : 1;  /**< [ 25: 25](R/W) 40GBASE-CR4 ability. */
        uint64_t a40g_kr4              : 1;  /**< [ 24: 24](R/W) 40GBASE-KR4 ability. */
        uint64_t a10g_kr               : 1;  /**< [ 23: 23](R/W) 10GBASE-KR ability. */
        uint64_t a10g_kx4              : 1;  /**< [ 22: 22](R/W) 10GBASE-KX4 ability. */
        uint64_t a1g_kx                : 1;  /**< [ 21: 21](R/W) 1000BASE-KX ability. Should always be 0; autonegotiation is not supported for 1000Base-KX. */
        uint64_t t                     : 5;  /**< [ 20: 16](R/W/H) Transmitted nonce. This field is automatically updated with a pseudo-random value on entry
                                                                 to the AN ability detect state. */
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge. Always 0 in this register. */
        uint64_t rf                    : 1;  /**< [ 13: 13](R/W) Remote fault. */
        uint64_t xnp_able              : 1;  /**< [ 12: 12](R/W) Extended next page ability. */
        uint64_t asm_dir               : 1;  /**< [ 11: 11](R/W) Asymmetric PAUSE. */
        uint64_t pause                 : 1;  /**< [ 10: 10](R/W) PAUSE ability. */
        uint64_t e                     : 5;  /**< [  9:  5](R/W) Echoed nonce. Provides the echoed-nonce value to use when ACK = 0 in transmitted DME page.
                                                                 Should always be 0x0. */
        uint64_t s                     : 5;  /**< [  4:  0](R/W) Selector. Should be 0x1 (encoding for IEEE 802.3). */
#else /* Word 0 - Little Endian */
        uint64_t s                     : 5;  /**< [  4:  0](R/W) Selector. Should be 0x1 (encoding for IEEE 802.3). */
        uint64_t e                     : 5;  /**< [  9:  5](R/W) Echoed nonce. Provides the echoed-nonce value to use when ACK = 0 in transmitted DME page.
                                                                 Should always be 0x0. */
        uint64_t pause                 : 1;  /**< [ 10: 10](R/W) PAUSE ability. */
        uint64_t asm_dir               : 1;  /**< [ 11: 11](R/W) Asymmetric PAUSE. */
        uint64_t xnp_able              : 1;  /**< [ 12: 12](R/W) Extended next page ability. */
        uint64_t rf                    : 1;  /**< [ 13: 13](R/W) Remote fault. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge. Always 0 in this register. */
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page. */
        uint64_t t                     : 5;  /**< [ 20: 16](R/W/H) Transmitted nonce. This field is automatically updated with a pseudo-random value on entry
                                                                 to the AN ability detect state. */
        uint64_t a1g_kx                : 1;  /**< [ 21: 21](R/W) 1000BASE-KX ability. Should always be 0; autonegotiation is not supported for 1000Base-KX. */
        uint64_t a10g_kx4              : 1;  /**< [ 22: 22](R/W) 10GBASE-KX4 ability. */
        uint64_t a10g_kr               : 1;  /**< [ 23: 23](R/W) 10GBASE-KR ability. */
        uint64_t a40g_kr4              : 1;  /**< [ 24: 24](R/W) 40GBASE-KR4 ability. */
        uint64_t a40g_cr4              : 1;  /**< [ 25: 25](R/W) 40GBASE-CR4 ability. */
        uint64_t a100g_cr10            : 1;  /**< [ 26: 26](R/W) 100GBASE-CR10 ability. Should always be 0; 100GBASE-CR10 is not supported. */
        uint64_t a100g_kp4             : 1;  /**< [ 27: 27](R/W) 100GBASE-KP4 ability. Should always be 0; 100GBASE-KP4 is not supported. */
        uint64_t a100g_kr4             : 1;  /**< [ 28: 28](R/W) 100GBASE-KR4 ability. */
        uint64_t a100g_cr4             : 1;  /**< [ 29: 29](R/W) 100GBASE-CR4 ability. */
        uint64_t a25g_krs_crs          : 1;  /**< [ 30: 30](R/W) 25GBASE-KR-S or 25GBASE-CR-S ability. */
        uint64_t a25g_kr_cr            : 1;  /**< [ 31: 31](R/W) 25GBASE-KR or 25GBASE-CR ability. */
        uint64_t arsv                  : 12; /**< [ 43: 32](R/W) Technology ability. Reserved bits, should always be 0. */
        uint64_t a25g_rs_fec_req       : 1;  /**< [ 44: 44](R/W) 25G RS-FEC requested. */
        uint64_t a25g_br_fec_req       : 1;  /**< [ 45: 45](R/W) 25G BASE-R FEC requested. */
        uint64_t fec_able              : 1;  /**< [ 46: 46](R/W) 10G per-lane FEC ability. */
        uint64_t fec_req               : 1;  /**< [ 47: 47](R/W) 10G per-lane FEC requested. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_an_adv_s cn; */
};
typedef union bdk_cgxx_spux_an_adv bdk_cgxx_spux_an_adv_t;

static inline uint64_t BDK_CGXX_SPUX_AN_ADV(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_AN_ADV(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010198ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010198ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010198ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010198ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_AN_ADV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_AN_ADV(a,b) bdk_cgxx_spux_an_adv_t
#define bustype_BDK_CGXX_SPUX_AN_ADV(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_AN_ADV(a,b) "CGXX_SPUX_AN_ADV"
#define device_bar_BDK_CGXX_SPUX_AN_ADV(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_AN_ADV(a,b) (a)
#define arguments_BDK_CGXX_SPUX_AN_ADV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_an_bp_status
 *
 * CGX SPU Autonegotiation Backplane Ethernet & BASE-R Copper Status Registers
 * The contents of this register are updated during autonegotiation and are valid when
 * CGX()_SPU()_AN_STATUS[AN_COMPLETE] is set. At that time, one of the port type bits will be
 * set depending on the AN priority resolution. The port types are listed in order of decreasing
 * priority. If a BASE-R type is negotiated then [FEC] or [RS_FEC] will be set to indicate
 * whether/which FEC operation has been negotiated and will be clear otherwise.
 */
union bdk_cgxx_spux_an_bp_status
{
    uint64_t u;
    struct bdk_cgxx_spux_an_bp_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_18_63        : 46;
        uint64_t rs_fec                : 1;  /**< [ 17: 17](RO/H) Reed-Solomon FEC negotiated. */
        uint64_t fec                   : 1;  /**< [ 16: 16](RO/H) BASE-R FEC negotiated. */
        uint64_t n100g_cr4             : 1;  /**< [ 15: 15](RO/H) 100GBASE-CR4 negotiated. */
        uint64_t n100g_kr4             : 1;  /**< [ 14: 14](RO/H) 100GBASE-KR4 negotiated. */
        uint64_t n100g_kp4             : 1;  /**< [ 13: 13](RO/H) 100GBASE-KP4 negotiated. Should always be 0; 100GBASE-KP4 is not supported. */
        uint64_t n100g_cr10            : 1;  /**< [ 12: 12](RO/H) 100GBASE-CR10 negotiated. Should always be 0; 100GBASE-CR10 is not supported. */
        uint64_t n50g_cr2              : 1;  /**< [ 11: 11](RO/H) 50GBASE-CR2 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n50g_kr2              : 1;  /**< [ 10: 10](RO/H) 50GBASE-KR2 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n40g_cr4              : 1;  /**< [  9:  9](RO/H) 40GBASE-CR4 negotiated. */
        uint64_t n40g_kr4              : 1;  /**< [  8:  8](RO/H) 40GBASE-KR4 negotiated. */
        uint64_t n25g_kr_cr            : 1;  /**< [  7:  7](RO/H) 25GBASE-KR or 25GBSE-CR ability. */
        uint64_t n25g_krs_crs          : 1;  /**< [  6:  6](RO/H) 25GBASE-KR-S or 25GBSE-CR-S ability. */
        uint64_t n25g_cr1              : 1;  /**< [  5:  5](RO/H) 25GBASE-CR1 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n25g_kr1              : 1;  /**< [  4:  4](RO/H) 25GBASE-KR1 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n10g_kr               : 1;  /**< [  3:  3](RO/H) 10GBASE-KR negotiated. */
        uint64_t n10g_kx4              : 1;  /**< [  2:  2](RO/H) 10GBASE-KX4 or CX4 negotiated (XAUI). */
        uint64_t n1g_kx                : 1;  /**< [  1:  1](RO/H) 1000BASE-KX negotiated. Should always be 0; autonegotiation is not supported for 1000Base-KX. */
        uint64_t bp_an_able            : 1;  /**< [  0:  0](RO) Backplane or BASE-R copper AN Ability; always 1. */
#else /* Word 0 - Little Endian */
        uint64_t bp_an_able            : 1;  /**< [  0:  0](RO) Backplane or BASE-R copper AN Ability; always 1. */
        uint64_t n1g_kx                : 1;  /**< [  1:  1](RO/H) 1000BASE-KX negotiated. Should always be 0; autonegotiation is not supported for 1000Base-KX. */
        uint64_t n10g_kx4              : 1;  /**< [  2:  2](RO/H) 10GBASE-KX4 or CX4 negotiated (XAUI). */
        uint64_t n10g_kr               : 1;  /**< [  3:  3](RO/H) 10GBASE-KR negotiated. */
        uint64_t n25g_kr1              : 1;  /**< [  4:  4](RO/H) 25GBASE-KR1 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n25g_cr1              : 1;  /**< [  5:  5](RO/H) 25GBASE-CR1 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n25g_krs_crs          : 1;  /**< [  6:  6](RO/H) 25GBASE-KR-S or 25GBSE-CR-S ability. */
        uint64_t n25g_kr_cr            : 1;  /**< [  7:  7](RO/H) 25GBASE-KR or 25GBSE-CR ability. */
        uint64_t n40g_kr4              : 1;  /**< [  8:  8](RO/H) 40GBASE-KR4 negotiated. */
        uint64_t n40g_cr4              : 1;  /**< [  9:  9](RO/H) 40GBASE-CR4 negotiated. */
        uint64_t n50g_kr2              : 1;  /**< [ 10: 10](RO/H) 50GBASE-KR2 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n50g_cr2              : 1;  /**< [ 11: 11](RO/H) 50GBASE-CR2 negotiated (25G/50G Consortium spec 2.0). */
        uint64_t n100g_cr10            : 1;  /**< [ 12: 12](RO/H) 100GBASE-CR10 negotiated. Should always be 0; 100GBASE-CR10 is not supported. */
        uint64_t n100g_kp4             : 1;  /**< [ 13: 13](RO/H) 100GBASE-KP4 negotiated. Should always be 0; 100GBASE-KP4 is not supported. */
        uint64_t n100g_kr4             : 1;  /**< [ 14: 14](RO/H) 100GBASE-KR4 negotiated. */
        uint64_t n100g_cr4             : 1;  /**< [ 15: 15](RO/H) 100GBASE-CR4 negotiated. */
        uint64_t fec                   : 1;  /**< [ 16: 16](RO/H) BASE-R FEC negotiated. */
        uint64_t rs_fec                : 1;  /**< [ 17: 17](RO/H) Reed-Solomon FEC negotiated. */
        uint64_t reserved_18_63        : 46;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_an_bp_status_s cn; */
};
typedef union bdk_cgxx_spux_an_bp_status bdk_cgxx_spux_an_bp_status_t;

static inline uint64_t BDK_CGXX_SPUX_AN_BP_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_AN_BP_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101b8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101b8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101b8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101b8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_AN_BP_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_AN_BP_STATUS(a,b) bdk_cgxx_spux_an_bp_status_t
#define bustype_BDK_CGXX_SPUX_AN_BP_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_AN_BP_STATUS(a,b) "CGXX_SPUX_AN_BP_STATUS"
#define device_bar_BDK_CGXX_SPUX_AN_BP_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_AN_BP_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPUX_AN_BP_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_an_control
 *
 * CGX SPU Autonegotiation Control Registers
 */
union bdk_cgxx_spux_an_control
{
    uint64_t u;
    struct bdk_cgxx_spux_an_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_18_63        : 46;
        uint64_t usx_an_arb_link_chk_en : 1; /**< [ 17: 17](R/W) Enable USXGMII link status checking by autonegotiation arbitration state machine. When
                                                                 autonegotiation is enabled (CGX()_SPU()_USX_AN_CONTROL[AN_EN] is set), this bit controls
                                                                 the behavior of the autonegotiation arbitration state machine when it reaches the IDLE_DETECT
                                                                 CHECK state after AN page is successfully exchanged, as defined in Figure 37-6 in
                                                                 IEEE 802.3.

                                                                 Internal:
                                                                 FUTURE - compare to [AN_ARB_LINK_CHK_EN], complete description and
                                                                 implementation. Possible use in software USXGMII Auto-Negotiation. */
        uint64_t an_arb_link_chk_en    : 1;  /**< [ 16: 16](R/W) Enable link status checking by autonegotiation arbitration state machine. When
                                                                 autonegotiation is enabled (CGX()_SPU()_AN_CONTROL[AN_EN] is set), this bit controls
                                                                 the behavior of the autonegotiation arbitration state machine when it reaches the AN GOOD
                                                                 CHECK state after DME pages are successfully exchanged, as defined in Figure 73-11 in
                                                                 IEEE 802.3.

                                                                 When this bit is set and the negotiated highest common denominator (HCD) technology
                                                                 matches CGX()_CMR()_CONFIG[LMAC_TYPE], the autonegotiation arbitration SM
                                                                 performs the actions defined for the AN GOOD CHECK state in Figure 73-11, i.e. run the
                                                                 link_fail_inhibit timer and eventually transition to the AN GOOD or TRANSMIT DISABLE
                                                                 state.

                                                                 When this bit is clear or the HCD technology does not match CGX()_CMR()_CONFIG[LMAC_TYPE],
                                                                 the AN arbitration
                                                                 SM stays in the AN GOOD CHECK state, with the expectation that software will perform the
                                                                 appropriate actions to complete the autonegotiation protocol, as follows:

                                                                 * If this bit is clear and the HCD technology matches CGX()_CMR()_CONFIG[LMAC_TYPE], clear
                                                                 CGX()_SPU()_AN_CONTROL[AN_EN].

                                                                 * Otherwise, disable the LPCS by clearing the CGX()_CMR()_CONFIG[ENABLE], clear
                                                                 CGX()_SPU()_AN_CONTROL[AN_EN], reconfigure the LPCS with the correct
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE],
                                                                 and re-enable the LPCS by setting CGX()_CMR()_CONFIG[ENABLE].

                                                                 In both cases, software should implement the link_fail_inhibit timer and verify the link
                                                                 status as specified for the AN GOOD CHECK state. */
        uint64_t an_reset              : 1;  /**< [ 15: 15](R/W1S/H) Autonegotiation reset. Setting this bit or CGX()_SPU()_CONTROL1[RESET]
                                                                 or CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following to happen:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t reserved_14           : 1;
        uint64_t xnp_en                : 1;  /**< [ 13: 13](R/W) Extended next-page enable. */
        uint64_t an_en                 : 1;  /**< [ 12: 12](R/W) Autonegotiation enable. This bit should not be set when
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is set to RXAUI; autonegotiation is not supported
                                                                 in RXAUI mode. */
        uint64_t reserved_10_11        : 2;
        uint64_t an_restart            : 1;  /**< [  9:  9](R/W1S/H) Autonegotiation restart. Writing a 1 to this bit restarts the autonegotiation process if
                                                                 [AN_EN] is also set. This is a self-clearing bit. */
        uint64_t reserved_0_8          : 9;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_8          : 9;
        uint64_t an_restart            : 1;  /**< [  9:  9](R/W1S/H) Autonegotiation restart. Writing a 1 to this bit restarts the autonegotiation process if
                                                                 [AN_EN] is also set. This is a self-clearing bit. */
        uint64_t reserved_10_11        : 2;
        uint64_t an_en                 : 1;  /**< [ 12: 12](R/W) Autonegotiation enable. This bit should not be set when
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is set to RXAUI; autonegotiation is not supported
                                                                 in RXAUI mode. */
        uint64_t xnp_en                : 1;  /**< [ 13: 13](R/W) Extended next-page enable. */
        uint64_t reserved_14           : 1;
        uint64_t an_reset              : 1;  /**< [ 15: 15](R/W1S/H) Autonegotiation reset. Setting this bit or CGX()_SPU()_CONTROL1[RESET]
                                                                 or CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following to happen:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t an_arb_link_chk_en    : 1;  /**< [ 16: 16](R/W) Enable link status checking by autonegotiation arbitration state machine. When
                                                                 autonegotiation is enabled (CGX()_SPU()_AN_CONTROL[AN_EN] is set), this bit controls
                                                                 the behavior of the autonegotiation arbitration state machine when it reaches the AN GOOD
                                                                 CHECK state after DME pages are successfully exchanged, as defined in Figure 73-11 in
                                                                 IEEE 802.3.

                                                                 When this bit is set and the negotiated highest common denominator (HCD) technology
                                                                 matches CGX()_CMR()_CONFIG[LMAC_TYPE], the autonegotiation arbitration SM
                                                                 performs the actions defined for the AN GOOD CHECK state in Figure 73-11, i.e. run the
                                                                 link_fail_inhibit timer and eventually transition to the AN GOOD or TRANSMIT DISABLE
                                                                 state.

                                                                 When this bit is clear or the HCD technology does not match CGX()_CMR()_CONFIG[LMAC_TYPE],
                                                                 the AN arbitration
                                                                 SM stays in the AN GOOD CHECK state, with the expectation that software will perform the
                                                                 appropriate actions to complete the autonegotiation protocol, as follows:

                                                                 * If this bit is clear and the HCD technology matches CGX()_CMR()_CONFIG[LMAC_TYPE], clear
                                                                 CGX()_SPU()_AN_CONTROL[AN_EN].

                                                                 * Otherwise, disable the LPCS by clearing the CGX()_CMR()_CONFIG[ENABLE], clear
                                                                 CGX()_SPU()_AN_CONTROL[AN_EN], reconfigure the LPCS with the correct
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE],
                                                                 and re-enable the LPCS by setting CGX()_CMR()_CONFIG[ENABLE].

                                                                 In both cases, software should implement the link_fail_inhibit timer and verify the link
                                                                 status as specified for the AN GOOD CHECK state. */
        uint64_t usx_an_arb_link_chk_en : 1; /**< [ 17: 17](R/W) Enable USXGMII link status checking by autonegotiation arbitration state machine. When
                                                                 autonegotiation is enabled (CGX()_SPU()_USX_AN_CONTROL[AN_EN] is set), this bit controls
                                                                 the behavior of the autonegotiation arbitration state machine when it reaches the IDLE_DETECT
                                                                 CHECK state after AN page is successfully exchanged, as defined in Figure 37-6 in
                                                                 IEEE 802.3.

                                                                 Internal:
                                                                 FUTURE - compare to [AN_ARB_LINK_CHK_EN], complete description and
                                                                 implementation. Possible use in software USXGMII Auto-Negotiation. */
        uint64_t reserved_18_63        : 46;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_an_control_s cn; */
};
typedef union bdk_cgxx_spux_an_control bdk_cgxx_spux_an_control_t;

static inline uint64_t BDK_CGXX_SPUX_AN_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_AN_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010188ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010188ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010188ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010188ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_AN_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_AN_CONTROL(a,b) bdk_cgxx_spux_an_control_t
#define bustype_BDK_CGXX_SPUX_AN_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_AN_CONTROL(a,b) "CGXX_SPUX_AN_CONTROL"
#define device_bar_BDK_CGXX_SPUX_AN_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_AN_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_AN_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_an_lp_base
 *
 * CGX SPU Autonegotiation Link-Partner Base-Page Ability Registers
 * This register captures the contents of the latest AN link code word base page received from
 * the link partner during autonegotiation. (See IEEE 802.3 section 73.6 for details.)
 * CGX()_SPU()_AN_STATUS[PAGE_RX] is set when this register is updated by hardware.
 */
union bdk_cgxx_spux_an_lp_base
{
    uint64_t u;
    struct bdk_cgxx_spux_an_lp_base_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t fec_req               : 1;  /**< [ 47: 47](RO/H) 10G per-lane FEC requested. */
        uint64_t fec_able              : 1;  /**< [ 46: 46](RO/H) 10G per-lane FEC ability. */
        uint64_t a25g_br_fec_req       : 1;  /**< [ 45: 45](RO/H) 25G BASE-R FEC requested. */
        uint64_t a25g_rs_fec_req       : 1;  /**< [ 44: 44](RO/H) 25G RS-FEC requested. */
        uint64_t arsv                  : 12; /**< [ 43: 32](RO/H) Technology ability. Reserved bits, should always be 0. */
        uint64_t a25g_kr_cr            : 1;  /**< [ 31: 31](RO/H) 25GBASE-KR or 25GBASE-CR ability. */
        uint64_t a25g_krs_crs          : 1;  /**< [ 30: 30](RO/H) 25GBASE-KR-S or 25GBASE-CR-S ability. */
        uint64_t a100g_cr4             : 1;  /**< [ 29: 29](RO/H) 100GBASE-CR4 ability. */
        uint64_t a100g_kr4             : 1;  /**< [ 28: 28](RO/H) 100GBASE-KR4 ability. */
        uint64_t a100g_kp4             : 1;  /**< [ 27: 27](RO/H) 100GBASE-KP4 ability. Should always be 0; 100GBASE-KP4 is not supported. */
        uint64_t a100g_cr10            : 1;  /**< [ 26: 26](RO/H) 100GBASE-CR10 ability. Should always be 0; 100GBASE-CR10 is not supported. */
        uint64_t a40g_cr4              : 1;  /**< [ 25: 25](RO/H) 40GBASE-CR4 ability. */
        uint64_t a40g_kr4              : 1;  /**< [ 24: 24](RO/H) 40GBASE-KR4 ability. */
        uint64_t a10g_kr               : 1;  /**< [ 23: 23](RO/H) 10GBASE-KR ability. */
        uint64_t a10g_kx4              : 1;  /**< [ 22: 22](RO/H) 10GBASE-KX4 ability. */
        uint64_t a1g_kx                : 1;  /**< [ 21: 21](RO/H) 1000BASE-KX ability. */
        uint64_t t                     : 5;  /**< [ 20: 16](RO/H) Transmitted nonce. */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge. */
        uint64_t rf                    : 1;  /**< [ 13: 13](RO/H) Remote fault. */
        uint64_t xnp_able              : 1;  /**< [ 12: 12](RO/H) Extended next page ability. */
        uint64_t asm_dir               : 1;  /**< [ 11: 11](RO/H) Asymmetric PAUSE. */
        uint64_t pause                 : 1;  /**< [ 10: 10](RO/H) PAUSE ability. */
        uint64_t e                     : 5;  /**< [  9:  5](RO/H) Echoed nonce. */
        uint64_t s                     : 5;  /**< [  4:  0](RO/H) Selector. */
#else /* Word 0 - Little Endian */
        uint64_t s                     : 5;  /**< [  4:  0](RO/H) Selector. */
        uint64_t e                     : 5;  /**< [  9:  5](RO/H) Echoed nonce. */
        uint64_t pause                 : 1;  /**< [ 10: 10](RO/H) PAUSE ability. */
        uint64_t asm_dir               : 1;  /**< [ 11: 11](RO/H) Asymmetric PAUSE. */
        uint64_t xnp_able              : 1;  /**< [ 12: 12](RO/H) Extended next page ability. */
        uint64_t rf                    : 1;  /**< [ 13: 13](RO/H) Remote fault. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge. */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page. */
        uint64_t t                     : 5;  /**< [ 20: 16](RO/H) Transmitted nonce. */
        uint64_t a1g_kx                : 1;  /**< [ 21: 21](RO/H) 1000BASE-KX ability. */
        uint64_t a10g_kx4              : 1;  /**< [ 22: 22](RO/H) 10GBASE-KX4 ability. */
        uint64_t a10g_kr               : 1;  /**< [ 23: 23](RO/H) 10GBASE-KR ability. */
        uint64_t a40g_kr4              : 1;  /**< [ 24: 24](RO/H) 40GBASE-KR4 ability. */
        uint64_t a40g_cr4              : 1;  /**< [ 25: 25](RO/H) 40GBASE-CR4 ability. */
        uint64_t a100g_cr10            : 1;  /**< [ 26: 26](RO/H) 100GBASE-CR10 ability. Should always be 0; 100GBASE-CR10 is not supported. */
        uint64_t a100g_kp4             : 1;  /**< [ 27: 27](RO/H) 100GBASE-KP4 ability. Should always be 0; 100GBASE-KP4 is not supported. */
        uint64_t a100g_kr4             : 1;  /**< [ 28: 28](RO/H) 100GBASE-KR4 ability. */
        uint64_t a100g_cr4             : 1;  /**< [ 29: 29](RO/H) 100GBASE-CR4 ability. */
        uint64_t a25g_krs_crs          : 1;  /**< [ 30: 30](RO/H) 25GBASE-KR-S or 25GBASE-CR-S ability. */
        uint64_t a25g_kr_cr            : 1;  /**< [ 31: 31](RO/H) 25GBASE-KR or 25GBASE-CR ability. */
        uint64_t arsv                  : 12; /**< [ 43: 32](RO/H) Technology ability. Reserved bits, should always be 0. */
        uint64_t a25g_rs_fec_req       : 1;  /**< [ 44: 44](RO/H) 25G RS-FEC requested. */
        uint64_t a25g_br_fec_req       : 1;  /**< [ 45: 45](RO/H) 25G BASE-R FEC requested. */
        uint64_t fec_able              : 1;  /**< [ 46: 46](RO/H) 10G per-lane FEC ability. */
        uint64_t fec_req               : 1;  /**< [ 47: 47](RO/H) 10G per-lane FEC requested. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_an_lp_base_s cn; */
};
typedef union bdk_cgxx_spux_an_lp_base bdk_cgxx_spux_an_lp_base_t;

static inline uint64_t BDK_CGXX_SPUX_AN_LP_BASE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_AN_LP_BASE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101a0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101a0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_AN_LP_BASE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_AN_LP_BASE(a,b) bdk_cgxx_spux_an_lp_base_t
#define bustype_BDK_CGXX_SPUX_AN_LP_BASE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_AN_LP_BASE(a,b) "CGXX_SPUX_AN_LP_BASE"
#define device_bar_BDK_CGXX_SPUX_AN_LP_BASE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_AN_LP_BASE(a,b) (a)
#define arguments_BDK_CGXX_SPUX_AN_LP_BASE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_an_lp_xnp
 *
 * CGX SPU Autonegotiation Link Partner Extended Next Page Ability Registers
 * This register captures the contents of the latest next page code word received from the link
 * partner during autonegotiation, if any. See IEEE 802.3 section 73.7.7 for details.
 */
union bdk_cgxx_spux_an_lp_xnp
{
    uint64_t u;
    struct bdk_cgxx_spux_an_lp_xnp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t u                     : 32; /**< [ 47: 16](RO/H) Unformatted code field. */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge. */
        uint64_t mp                    : 1;  /**< [ 13: 13](RO/H) Message page. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](RO/H) Acknowledge 2. */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO/H) Toggle. */
        uint64_t m_u                   : 11; /**< [ 10:  0](RO/H) Message/unformatted code field. */
#else /* Word 0 - Little Endian */
        uint64_t m_u                   : 11; /**< [ 10:  0](RO/H) Message/unformatted code field. */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO/H) Toggle. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](RO/H) Acknowledge 2. */
        uint64_t mp                    : 1;  /**< [ 13: 13](RO/H) Message page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge. */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next page. */
        uint64_t u                     : 32; /**< [ 47: 16](RO/H) Unformatted code field. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_an_lp_xnp_s cn; */
};
typedef union bdk_cgxx_spux_an_lp_xnp bdk_cgxx_spux_an_lp_xnp_t;

static inline uint64_t BDK_CGXX_SPUX_AN_LP_XNP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_AN_LP_XNP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101b0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_AN_LP_XNP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_AN_LP_XNP(a,b) bdk_cgxx_spux_an_lp_xnp_t
#define bustype_BDK_CGXX_SPUX_AN_LP_XNP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_AN_LP_XNP(a,b) "CGXX_SPUX_AN_LP_XNP"
#define device_bar_BDK_CGXX_SPUX_AN_LP_XNP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_AN_LP_XNP(a,b) (a)
#define arguments_BDK_CGXX_SPUX_AN_LP_XNP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_an_status
 *
 * CGX SPU Autonegotiation Status Registers
 */
union bdk_cgxx_spux_an_status
{
    uint64_t u;
    struct bdk_cgxx_spux_an_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t prl_flt               : 1;  /**< [  9:  9](RO) Parallel detection fault. Always 0; SPU does not support parallel detection as part of the
                                                                 autonegotiation protocol. */
        uint64_t reserved_8            : 1;
        uint64_t xnp_stat              : 1;  /**< [  7:  7](RO/H) Extended next-page status. */
        uint64_t page_rx               : 1;  /**< [  6:  6](R/W1C/H) Page received. This latching-high bit is set when a new page has been received and stored
                                                                 in CGX()_SPU()_AN_LP_BASE or CGX()_SPU()_AN_LP_XNP; stays set until a 1 is
                                                                 written by software, autonegotiation is disabled or restarted, or next page exchange is
                                                                 initiated. Note that in order to avoid read side effects, this is implemented as a
                                                                 write-1-to-clear bit, rather than latching high read-only as specified in 802.3. */
        uint64_t an_complete           : 1;  /**< [  5:  5](RO/H) Autonegotiation complete. Set when the autonegotiation process has been completed and
                                                                 the link is up and running using the negotiated highest common denominator (HCD)
                                                                 technology. If AN is enabled (CGX()_SPU()_AN_CONTROL[AN_EN] = 1) and this bit is
                                                                 read as a zero, it indicates that the AN process has not been completed, and the contents
                                                                 of CGX()_SPU()_AN_LP_BASE, CGX()_SPU()_AN_XNP_TX, and
                                                                 CGX()_SPU()_AN_LP_XNP are as defined by the current state of the autonegotiation
                                                                 protocol, or as written for manual configuration. This bit is always zero when AN is
                                                                 disabled (CGX()_SPU()_AN_CONTROL[AN_EN] = 0). */
        uint64_t rmt_flt               : 1;  /**< [  4:  4](RO) Remote fault: Always 0. */
        uint64_t an_able               : 1;  /**< [  3:  3](RO) Autonegotiation ability: Always 1. */
        uint64_t link_status           : 1;  /**< [  2:  2](R/W1S/H) Link status. This bit captures the state of the link_status variable as defined in 802.3
                                                                 section 73.9.1. When set, indicates that a valid link has been established. When clear,
                                                                 indicates that the link has been invalid after this bit was last set by software. Latching
                                                                 low bit; stays clear until a 1 is written by software. Note that in order to avoid read
                                                                 side effects, this is implemented as a write-1-to-set bit, rather than latching low read-
                                                                 only as specified in 802.3. */
        uint64_t reserved_1            : 1;
        uint64_t lp_an_able            : 1;  /**< [  0:  0](RO/H) Link partner autonegotiation ability. Set to indicate that the link partner is able to
                                                                 participate in the autonegotiation function, and cleared otherwise. */
#else /* Word 0 - Little Endian */
        uint64_t lp_an_able            : 1;  /**< [  0:  0](RO/H) Link partner autonegotiation ability. Set to indicate that the link partner is able to
                                                                 participate in the autonegotiation function, and cleared otherwise. */
        uint64_t reserved_1            : 1;
        uint64_t link_status           : 1;  /**< [  2:  2](R/W1S/H) Link status. This bit captures the state of the link_status variable as defined in 802.3
                                                                 section 73.9.1. When set, indicates that a valid link has been established. When clear,
                                                                 indicates that the link has been invalid after this bit was last set by software. Latching
                                                                 low bit; stays clear until a 1 is written by software. Note that in order to avoid read
                                                                 side effects, this is implemented as a write-1-to-set bit, rather than latching low read-
                                                                 only as specified in 802.3. */
        uint64_t an_able               : 1;  /**< [  3:  3](RO) Autonegotiation ability: Always 1. */
        uint64_t rmt_flt               : 1;  /**< [  4:  4](RO) Remote fault: Always 0. */
        uint64_t an_complete           : 1;  /**< [  5:  5](RO/H) Autonegotiation complete. Set when the autonegotiation process has been completed and
                                                                 the link is up and running using the negotiated highest common denominator (HCD)
                                                                 technology. If AN is enabled (CGX()_SPU()_AN_CONTROL[AN_EN] = 1) and this bit is
                                                                 read as a zero, it indicates that the AN process has not been completed, and the contents
                                                                 of CGX()_SPU()_AN_LP_BASE, CGX()_SPU()_AN_XNP_TX, and
                                                                 CGX()_SPU()_AN_LP_XNP are as defined by the current state of the autonegotiation
                                                                 protocol, or as written for manual configuration. This bit is always zero when AN is
                                                                 disabled (CGX()_SPU()_AN_CONTROL[AN_EN] = 0). */
        uint64_t page_rx               : 1;  /**< [  6:  6](R/W1C/H) Page received. This latching-high bit is set when a new page has been received and stored
                                                                 in CGX()_SPU()_AN_LP_BASE or CGX()_SPU()_AN_LP_XNP; stays set until a 1 is
                                                                 written by software, autonegotiation is disabled or restarted, or next page exchange is
                                                                 initiated. Note that in order to avoid read side effects, this is implemented as a
                                                                 write-1-to-clear bit, rather than latching high read-only as specified in 802.3. */
        uint64_t xnp_stat              : 1;  /**< [  7:  7](RO/H) Extended next-page status. */
        uint64_t reserved_8            : 1;
        uint64_t prl_flt               : 1;  /**< [  9:  9](RO) Parallel detection fault. Always 0; SPU does not support parallel detection as part of the
                                                                 autonegotiation protocol. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_an_status_s cn; */
};
typedef union bdk_cgxx_spux_an_status bdk_cgxx_spux_an_status_t;

static inline uint64_t BDK_CGXX_SPUX_AN_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_AN_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010190ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010190ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010190ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010190ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_AN_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_AN_STATUS(a,b) bdk_cgxx_spux_an_status_t
#define bustype_BDK_CGXX_SPUX_AN_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_AN_STATUS(a,b) "CGXX_SPUX_AN_STATUS"
#define device_bar_BDK_CGXX_SPUX_AN_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_AN_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPUX_AN_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_an_xnp_tx
 *
 * CGX SPU Autonegotiation Extended Next Page Transmit Registers
 * Software programs this register with the contents of the AN message next page or unformatted
 * next page link code word to be transmitted during autonegotiation. Next page exchange occurs
 * after the base link code words have been exchanged if either end of the link segment sets the
 * NP bit to 1, indicating that it has at least one next page to send. Once initiated, next page
 * exchange continues until both ends of the link segment set their NP bits to 0. See IEEE
 * 802.3 section 73.7.7 for details.
 */
union bdk_cgxx_spux_an_xnp_tx
{
    uint64_t u;
    struct bdk_cgxx_spux_an_xnp_tx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t u                     : 32; /**< [ 47: 16](R/W) Unformatted code field. When the MP bit is set, this field contains the 32-bit unformatted
                                                                 code field of the message next page. When MP is clear, this field contains the upper 32
                                                                 bits of the 43-bit unformatted code field of the unformatted next page. */
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge: Always 0 in this register. */
        uint64_t mp                    : 1;  /**< [ 13: 13](R/W) Message page. Set to indicate that this register contains a message next page. Clear to
                                                                 indicate that the register contains an unformatted next page. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](R/W) Acknowledge 2. Indicates that the receiver is able to act on the information (or perform
                                                                 the task) defined in the message. */
        uint64_t toggle                : 1;  /**< [ 11: 11](R/W) This bit is ignored by hardware. The value of the TOGGLE bit in transmitted next pages is
                                                                 automatically generated by hardware. */
        uint64_t m_u                   : 11; /**< [ 10:  0](R/W) Message/unformatted code field: When the MP bit is set, this field contains the message
                                                                 code field (M) of the message next page. When MP is clear, this field contains the lower
                                                                 11 bits of the 43-bit unformatted code field of the unformatted next page. */
#else /* Word 0 - Little Endian */
        uint64_t m_u                   : 11; /**< [ 10:  0](R/W) Message/unformatted code field: When the MP bit is set, this field contains the message
                                                                 code field (M) of the message next page. When MP is clear, this field contains the lower
                                                                 11 bits of the 43-bit unformatted code field of the unformatted next page. */
        uint64_t toggle                : 1;  /**< [ 11: 11](R/W) This bit is ignored by hardware. The value of the TOGGLE bit in transmitted next pages is
                                                                 automatically generated by hardware. */
        uint64_t ack2                  : 1;  /**< [ 12: 12](R/W) Acknowledge 2. Indicates that the receiver is able to act on the information (or perform
                                                                 the task) defined in the message. */
        uint64_t mp                    : 1;  /**< [ 13: 13](R/W) Message page. Set to indicate that this register contains a message next page. Clear to
                                                                 indicate that the register contains an unformatted next page. */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge: Always 0 in this register. */
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next page. */
        uint64_t u                     : 32; /**< [ 47: 16](R/W) Unformatted code field. When the MP bit is set, this field contains the 32-bit unformatted
                                                                 code field of the message next page. When MP is clear, this field contains the upper 32
                                                                 bits of the 43-bit unformatted code field of the unformatted next page. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_an_xnp_tx_s cn; */
};
typedef union bdk_cgxx_spux_an_xnp_tx bdk_cgxx_spux_an_xnp_tx_t;

static inline uint64_t BDK_CGXX_SPUX_AN_XNP_TX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_AN_XNP_TX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101a8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_AN_XNP_TX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_AN_XNP_TX(a,b) bdk_cgxx_spux_an_xnp_tx_t
#define bustype_BDK_CGXX_SPUX_AN_XNP_TX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_AN_XNP_TX(a,b) "CGXX_SPUX_AN_XNP_TX"
#define device_bar_BDK_CGXX_SPUX_AN_XNP_TX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_AN_XNP_TX(a,b) (a)
#define arguments_BDK_CGXX_SPUX_AN_XNP_TX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_algn_status
 *
 * CGX SPU Multilane BASE-R PCS Alignment-Status Registers
 * This register implements the IEEE 802.3 multilane BASE-R PCS alignment status 1-4 registers
 * (3.50-3.53). It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R, 100GBASE-R,
 * (CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::FORTYG_R,FIFTYG_R,HUNDREDG_R), and always
 * returns 0x0 for all other LPCS
 * types. Service interfaces (lanes) 19-0 (100G) and 3-0 (all others) are mapped to PCS lanes
 * 19-0 or 3-0 via CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. For 100G, logical lane 0 fans out to
 * service interfaces 0-4, logical lane 1 fans out to service interfaces 5-9, ... etc. For all
 * other modes, logical lanes and service interfaces are identical. Logical interfaces (lanes)
 * map to SerDes lanes via CGX()_CMR()_CONFIG[LANE_TO_SDS] (programmable).
 */
union bdk_cgxx_spux_br_algn_status
{
    uint64_t u;
    struct bdk_cgxx_spux_br_algn_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_61_63        : 3;
        uint64_t marker_lock           : 20; /**< [ 60: 41](RO/H) Marker-locked status for PCS lanes 19-0 as achieved by AM-lock FSM (COUNT_2).
                                                                 0 = Not locked.
                                                                 1 = Locked.

                                                                 When USXGMII is enabled it indicates AM-lock for non-RS-FEC, CWM-lock for RS-FEC.
                                                                 For all other RS-FEC modes (25G, 50G, 100G) it also indicates marker-locked status
                                                                 for applicable FEC lanes and is synonymous with
                                                                 CGX()_SPU()_RSFEC_STATUS[AMPS_LOCK] for bits 0..3 only. */
        uint64_t reserved_31_40        : 10;
        uint64_t alignd                : 1;  /**< [ 30: 30](RO/H) All lanes are locked and aligned per DESKEW_SM FSM (ALIGN_ACQUIRED_1).
                                                                 This bit returns 1 when the logical PCS has locked and
                                                                 aligned all associated receive lanes; returns 0 otherwise. For all other PCS types, this
                                                                 bit always returns 0. In particular, all single-lane modes (10G, 25G, USXGMII) leave this
                                                                 bit 0. For all multi-lane RS-FEC modes (50G, 100G) this bit indicates all applicable FEC
                                                                 lanes are aligned. */
        uint64_t reserved_20_29        : 10;
        uint64_t block_lock            : 20; /**< [ 19:  0](RO/H) Block-lock status for PCS lanes 19-0:
                                                                   0 = Not locked.
                                                                   1 = Locked.
                                                                 In particular, all single-lane modes (10G, 25G, USXGMII) leave this field at 0. */
#else /* Word 0 - Little Endian */
        uint64_t block_lock            : 20; /**< [ 19:  0](RO/H) Block-lock status for PCS lanes 19-0:
                                                                   0 = Not locked.
                                                                   1 = Locked.
                                                                 In particular, all single-lane modes (10G, 25G, USXGMII) leave this field at 0. */
        uint64_t reserved_20_29        : 10;
        uint64_t alignd                : 1;  /**< [ 30: 30](RO/H) All lanes are locked and aligned per DESKEW_SM FSM (ALIGN_ACQUIRED_1).
                                                                 This bit returns 1 when the logical PCS has locked and
                                                                 aligned all associated receive lanes; returns 0 otherwise. For all other PCS types, this
                                                                 bit always returns 0. In particular, all single-lane modes (10G, 25G, USXGMII) leave this
                                                                 bit 0. For all multi-lane RS-FEC modes (50G, 100G) this bit indicates all applicable FEC
                                                                 lanes are aligned. */
        uint64_t reserved_31_40        : 10;
        uint64_t marker_lock           : 20; /**< [ 60: 41](RO/H) Marker-locked status for PCS lanes 19-0 as achieved by AM-lock FSM (COUNT_2).
                                                                 0 = Not locked.
                                                                 1 = Locked.

                                                                 When USXGMII is enabled it indicates AM-lock for non-RS-FEC, CWM-lock for RS-FEC.
                                                                 For all other RS-FEC modes (25G, 50G, 100G) it also indicates marker-locked status
                                                                 for applicable FEC lanes and is synonymous with
                                                                 CGX()_SPU()_RSFEC_STATUS[AMPS_LOCK] for bits 0..3 only. */
        uint64_t reserved_61_63        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_algn_status_s cn; */
};
typedef union bdk_cgxx_spux_br_algn_status bdk_cgxx_spux_br_algn_status_t;

static inline uint64_t BDK_CGXX_SPUX_BR_ALGN_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_ALGN_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010050ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010050ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_ALGN_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_ALGN_STATUS(a,b) bdk_cgxx_spux_br_algn_status_t
#define bustype_BDK_CGXX_SPUX_BR_ALGN_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_ALGN_STATUS(a,b) "CGXX_SPUX_BR_ALGN_STATUS"
#define device_bar_BDK_CGXX_SPUX_BR_ALGN_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_ALGN_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_ALGN_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_lane_map#
 *
 * CGX SPU 40,50,100GBASE-R Lane-Mapping Registers
 * This register implements the IEEE 802.3 lane 0-19 mapping registers
 * (3.400-3.403). It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R,
 * 100GBASE-R, USXGMII (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always
 * returns 0x0 for all other LPCS types. The LNx_MAPPING field for each programmed PCS
 * lane (called service interface in 802.3) is valid when that lane has achieved
 * alignment marker lock on the receive side (i.e. the associated
 * CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), and is invalid otherwise. When valid,
 * it returns the actual detected receive PCS lane number based on the received
 * alignment marker contents received on that service interface.
 *
 * In RS-FEC mode the LNx_MAPPING field is valid when that lane has achieved alignment
 * marker lock on the receive side (i.e. the associated
 * CGX(0..3)_SPU(0..3)_RSFEC_STATUS[AMPS_LOCK] = 1), and is invalid otherwise. When valid,
 * it returns the actual detected receive FEC lane number based on the received
 * alignment marker contents received on that logical lane therefore expect for RS-FEC
 * that LNx_MAPPING = x.
 *
 * The mapping is flexible because IEEE 802.3 allows multilane BASE-R receive lanes to
 * be re-ordered. Note that for the transmit side, each logical lane is mapped to a
 * physical SerDes lane based on the programming of
 * CGX()_CMR()_CONFIG[LANE_TO_SDS]. For the receive side,
 * CGX()_CMR()_CONFIG[LANE_TO_SDS] specifies the logical lane to physical SerDes
 * lane mapping, and this register specifies the service interface (or lane) to PCS
 * lane mapping.
 */
union bdk_cgxx_spux_br_lane_mapx
{
    uint64_t u;
    struct bdk_cgxx_spux_br_lane_mapx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t ln_mapping            : 6;  /**< [  5:  0](RO/H) PCS lane number received on service interface N where N is the (0..19) offset used to
                                                                 access this register. */
#else /* Word 0 - Little Endian */
        uint64_t ln_mapping            : 6;  /**< [  5:  0](RO/H) PCS lane number received on service interface N where N is the (0..19) offset used to
                                                                 access this register. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_lane_mapx_s cn; */
};
typedef union bdk_cgxx_spux_br_lane_mapx bdk_cgxx_spux_br_lane_mapx_t;

static inline uint64_t BDK_CGXX_SPUX_BR_LANE_MAPX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_LANE_MAPX(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010600ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=19)))
        return 0x87e0e0010600ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010600ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=19)))
        return 0x87e0e0010600ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    __bdk_csr_fatal("CGXX_SPUX_BR_LANE_MAPX", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_LANE_MAPX(a,b,c) bdk_cgxx_spux_br_lane_mapx_t
#define bustype_BDK_CGXX_SPUX_BR_LANE_MAPX(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_LANE_MAPX(a,b,c) "CGXX_SPUX_BR_LANE_MAPX"
#define device_bar_BDK_CGXX_SPUX_BR_LANE_MAPX(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_LANE_MAPX(a,b,c) (a)
#define arguments_BDK_CGXX_SPUX_BR_LANE_MAPX(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_spu#_br_pmd_control
 *
 * CGX SPU BASE-R PMD Control Registers
 */
union bdk_cgxx_spux_br_pmd_control
{
    uint64_t u;
    struct bdk_cgxx_spux_br_pmd_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t max_wait_disable      : 1;  /**< [  3:  3](R/W) Max wait timer disable. When [TRAIN_EN] is set and [MAX_WAIT_DISABLE] is
                                                                 clear, BASE-R link training is enabled with the 500ms max_wait_timer
                                                                 specified in 802.3-2012 CL 72.6.10. Hardware will set
                                                                 CGX()_SPU()_INT[TRAINING_DONE] if link training completes before the timer
                                                                 expires, and will otherwise set CGX()_SPU()_INT[TRAINING_FAILURE] when the
                                                                 timer expires.

                                                                 When [TRAIN_EN] and [MAX_WAIT_DISABLE] are both set, BASE-R link training
                                                                 is enabled, max_wait_timer is disabled and hardware will never set
                                                                 CGX()_SPU()_INT[TRAINING_FAILURE]. If link training does not complete
                                                                 (CGX()_SPU()_INT[TRAINING_DONE] is not set), software must clear [TRAIN_EN]
                                                                 to disable training.

                                                                 Software must not modify this bit while [TRAIN_EN] is set. */
        uint64_t use_lane_poly         : 1;  /**< [  2:  2](R/W) When this bit is 0, training will generate the pseudo-random sequence using the
                                                                 polynomial specified in 802.3-2012 section 5 CL 72.6.10.2.6 for all lanes. When
                                                                 this bit is 1, the per-physical-lane polynomials specified in 802.3bj-2014 CL
                                                                 92.7.12 will be used. */
        uint64_t train_en              : 1;  /**< [  1:  1](R/W) BASE-R training enable. */
        uint64_t train_restart         : 1;  /**< [  0:  0](R/W1S/H) BASE-R training restart. Writing a 1 to this bit restarts the training process if
                                                                 [TRAIN_EN] is also set. This is a self-clearing bit. Software should
                                                                 wait a minimum of 1.7 ms after CGX()_SPU()_INT[TRAINING_FAILURE] is set before
                                                                 restarting the training process. */
#else /* Word 0 - Little Endian */
        uint64_t train_restart         : 1;  /**< [  0:  0](R/W1S/H) BASE-R training restart. Writing a 1 to this bit restarts the training process if
                                                                 [TRAIN_EN] is also set. This is a self-clearing bit. Software should
                                                                 wait a minimum of 1.7 ms after CGX()_SPU()_INT[TRAINING_FAILURE] is set before
                                                                 restarting the training process. */
        uint64_t train_en              : 1;  /**< [  1:  1](R/W) BASE-R training enable. */
        uint64_t use_lane_poly         : 1;  /**< [  2:  2](R/W) When this bit is 0, training will generate the pseudo-random sequence using the
                                                                 polynomial specified in 802.3-2012 section 5 CL 72.6.10.2.6 for all lanes. When
                                                                 this bit is 1, the per-physical-lane polynomials specified in 802.3bj-2014 CL
                                                                 92.7.12 will be used. */
        uint64_t max_wait_disable      : 1;  /**< [  3:  3](R/W) Max wait timer disable. When [TRAIN_EN] is set and [MAX_WAIT_DISABLE] is
                                                                 clear, BASE-R link training is enabled with the 500ms max_wait_timer
                                                                 specified in 802.3-2012 CL 72.6.10. Hardware will set
                                                                 CGX()_SPU()_INT[TRAINING_DONE] if link training completes before the timer
                                                                 expires, and will otherwise set CGX()_SPU()_INT[TRAINING_FAILURE] when the
                                                                 timer expires.

                                                                 When [TRAIN_EN] and [MAX_WAIT_DISABLE] are both set, BASE-R link training
                                                                 is enabled, max_wait_timer is disabled and hardware will never set
                                                                 CGX()_SPU()_INT[TRAINING_FAILURE]. If link training does not complete
                                                                 (CGX()_SPU()_INT[TRAINING_DONE] is not set), software must clear [TRAIN_EN]
                                                                 to disable training.

                                                                 Software must not modify this bit while [TRAIN_EN] is set. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_pmd_control_s cn9; */
    struct bdk_cgxx_spux_br_pmd_control_cn96xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t use_lane_poly         : 1;  /**< [  2:  2](R/W) When this bit is 0, training will generate the pseudo-random sequence using the
                                                                 polynomial specified in 802.3-2012 section 5 CL 72.6.10.2.6 for all lanes. When
                                                                 this bit is 1, the per-physical-lane polynomials specified in 802.3bj-2014 CL
                                                                 92.7.12 will be used. */
        uint64_t train_en              : 1;  /**< [  1:  1](R/W) BASE-R training enable. */
        uint64_t train_restart         : 1;  /**< [  0:  0](R/W1S/H) BASE-R training restart. Writing a 1 to this bit restarts the training process if
                                                                 [TRAIN_EN] is also set. This is a self-clearing bit. Software should
                                                                 wait a minimum of 1.7 ms after CGX()_SPU()_INT[TRAINING_FAILURE] is set before
                                                                 restarting the training process. */
#else /* Word 0 - Little Endian */
        uint64_t train_restart         : 1;  /**< [  0:  0](R/W1S/H) BASE-R training restart. Writing a 1 to this bit restarts the training process if
                                                                 [TRAIN_EN] is also set. This is a self-clearing bit. Software should
                                                                 wait a minimum of 1.7 ms after CGX()_SPU()_INT[TRAINING_FAILURE] is set before
                                                                 restarting the training process. */
        uint64_t train_en              : 1;  /**< [  1:  1](R/W) BASE-R training enable. */
        uint64_t use_lane_poly         : 1;  /**< [  2:  2](R/W) When this bit is 0, training will generate the pseudo-random sequence using the
                                                                 polynomial specified in 802.3-2012 section 5 CL 72.6.10.2.6 for all lanes. When
                                                                 this bit is 1, the per-physical-lane polynomials specified in 802.3bj-2014 CL
                                                                 92.7.12 will be used. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn96xx;
    /* struct bdk_cgxx_spux_br_pmd_control_cn96xx cn98xx; */
    /* struct bdk_cgxx_spux_br_pmd_control_s cnf95xxp1; */
    /* struct bdk_cgxx_spux_br_pmd_control_cn96xx cnf95xxp2; */
    /* struct bdk_cgxx_spux_br_pmd_control_cn96xx loki; */
};
typedef union bdk_cgxx_spux_br_pmd_control bdk_cgxx_spux_br_pmd_control_t;

static inline uint64_t BDK_CGXX_SPUX_BR_PMD_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_PMD_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100a8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100a8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_PMD_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_PMD_CONTROL(a,b) bdk_cgxx_spux_br_pmd_control_t
#define bustype_BDK_CGXX_SPUX_BR_PMD_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_PMD_CONTROL(a,b) "CGXX_SPUX_BR_PMD_CONTROL"
#define device_bar_BDK_CGXX_SPUX_BR_PMD_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_PMD_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_PMD_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_pmd_ld_cup
 *
 * CGX SPU BASE-R PMD Local Device Coefficient Update Registers
 * This register implements MDIO register 1.154 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
 * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
 *
 * It implements  MDIO registers 1.1300-1.1303 for all other BASE-R modes (40G, 50G, 100G) per
 * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
 *
 * The fields in this register are read/write even though they are specified as read-only in 802.3.
 *
 * The register is automatically cleared at the start of training. When link training
 * is in progress, each field reflects the contents of the coefficient update field in the
 * associated lane's outgoing training frame.
 *
 * If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must be updated
 * by software during link training and hardware updates are disabled. If
 * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
 * updated by hardware, and it should not be written by software. The lane fields in this
 * register are indexed by logical PCS lane ID.
 */
union bdk_cgxx_spux_br_pmd_ld_cup
{
    uint64_t u;
    struct bdk_cgxx_spux_br_pmd_ld_cup_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ln3_cup               : 16; /**< [ 63: 48](R/W/H) PCS lane 3 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln2_cup               : 16; /**< [ 47: 32](R/W/H) PCS lane 2 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln1_cup               : 16; /**< [ 31: 16](R/W/H) PCS lane 1 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln0_cup               : 16; /**< [ 15:  0](R/W/H) PCS lane 0 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
#else /* Word 0 - Little Endian */
        uint64_t ln0_cup               : 16; /**< [ 15:  0](R/W/H) PCS lane 0 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln1_cup               : 16; /**< [ 31: 16](R/W/H) PCS lane 1 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln2_cup               : 16; /**< [ 47: 32](R/W/H) PCS lane 2 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln3_cup               : 16; /**< [ 63: 48](R/W/H) PCS lane 3 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_pmd_ld_cup_s cn; */
};
typedef union bdk_cgxx_spux_br_pmd_ld_cup bdk_cgxx_spux_br_pmd_ld_cup_t;

static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LD_CUP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LD_CUP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100c8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100c8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100c8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100c8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_PMD_LD_CUP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_PMD_LD_CUP(a,b) bdk_cgxx_spux_br_pmd_ld_cup_t
#define bustype_BDK_CGXX_SPUX_BR_PMD_LD_CUP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_PMD_LD_CUP(a,b) "CGXX_SPUX_BR_PMD_LD_CUP"
#define device_bar_BDK_CGXX_SPUX_BR_PMD_LD_CUP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_PMD_LD_CUP(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_PMD_LD_CUP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_pmd_ld_rep
 *
 * CGX SPU BASE-R PMD Local Device Status Report Registers
 * This register implements MDIO register 1.155 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
 * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
 *
 * It implements  MDIO registers 1.1400-1.1403 for all other BASE-R modes (40G, 50G, 100G) per
 * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
 *
 * The fields in this register are read/write even though they are specified as read-only in 802.3.
 *
 * The register is automatically cleared at the start of training. Each field
 * reflects the contents of the status report field in the associated lane's outgoing training
 * frame.
 *
 * If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must
 * be updated by software during link training and hardware updates are disabled. If
 * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
 * updated by hardware, and it should not be written by software. The lane fields in this
 * register are indexed by logical PCS lane ID.
 */
union bdk_cgxx_spux_br_pmd_ld_rep
{
    uint64_t u;
    struct bdk_cgxx_spux_br_pmd_ld_rep_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ln3_rep               : 16; /**< [ 63: 48](R/W/H) PCS lane 3 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln2_rep               : 16; /**< [ 47: 32](R/W/H) PCS lane 2 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln1_rep               : 16; /**< [ 31: 16](R/W/H) PCS lane 1 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln0_rep               : 16; /**< [ 15:  0](R/W/H) PCS lane 0 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
#else /* Word 0 - Little Endian */
        uint64_t ln0_rep               : 16; /**< [ 15:  0](R/W/H) PCS lane 0 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln1_rep               : 16; /**< [ 31: 16](R/W/H) PCS lane 1 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln2_rep               : 16; /**< [ 47: 32](R/W/H) PCS lane 2 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln3_rep               : 16; /**< [ 63: 48](R/W/H) PCS lane 3 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_pmd_ld_rep_s cn; */
};
typedef union bdk_cgxx_spux_br_pmd_ld_rep bdk_cgxx_spux_br_pmd_ld_rep_t;

static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LD_REP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LD_REP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100d0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100d0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100d0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100d0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_PMD_LD_REP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_PMD_LD_REP(a,b) bdk_cgxx_spux_br_pmd_ld_rep_t
#define bustype_BDK_CGXX_SPUX_BR_PMD_LD_REP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_PMD_LD_REP(a,b) "CGXX_SPUX_BR_PMD_LD_REP"
#define device_bar_BDK_CGXX_SPUX_BR_PMD_LD_REP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_PMD_LD_REP(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_PMD_LD_REP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_pmd_lp_cup
 *
 * CGX SPU BASE-R PMD Link Partner Coefficient Update Registers
 * This register implements MDIO register 1.152 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
 * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
 *
 * It implements  MDIO registers 1.1100-1.1103 for all other BASE-R modes (40G, 50G, 100G) per
 * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
 *
 * The register is automatically cleared at the start of training. Each field reflects
 * the contents of the coefficient update field in the lane's most recently received training
 * frame. This register should not be written when link training is enabled, i.e. when
 * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this register are indexed by
 * logical PCS lane ID.
 */
union bdk_cgxx_spux_br_pmd_lp_cup
{
    uint64_t u;
    struct bdk_cgxx_spux_br_pmd_lp_cup_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ln3_cup               : 16; /**< [ 63: 48](R/W/H) PCS lane 3 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln2_cup               : 16; /**< [ 47: 32](R/W/H) PCS lane 2 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln1_cup               : 16; /**< [ 31: 16](R/W/H) PCS lane 1 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln0_cup               : 16; /**< [ 15:  0](R/W/H) PCS lane 0 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
#else /* Word 0 - Little Endian */
        uint64_t ln0_cup               : 16; /**< [ 15:  0](R/W/H) PCS lane 0 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln1_cup               : 16; /**< [ 31: 16](R/W/H) PCS lane 1 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln2_cup               : 16; /**< [ 47: 32](R/W/H) PCS lane 2 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
        uint64_t ln3_cup               : 16; /**< [ 63: 48](R/W/H) PCS lane 3 coefficient update: format defined by CGX_SPU_BR_TRAIN_CUP_S. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_pmd_lp_cup_s cn; */
};
typedef union bdk_cgxx_spux_br_pmd_lp_cup bdk_cgxx_spux_br_pmd_lp_cup_t;

static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LP_CUP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LP_CUP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100b8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100b8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100b8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100b8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_PMD_LP_CUP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_PMD_LP_CUP(a,b) bdk_cgxx_spux_br_pmd_lp_cup_t
#define bustype_BDK_CGXX_SPUX_BR_PMD_LP_CUP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_PMD_LP_CUP(a,b) "CGXX_SPUX_BR_PMD_LP_CUP"
#define device_bar_BDK_CGXX_SPUX_BR_PMD_LP_CUP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_PMD_LP_CUP(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_PMD_LP_CUP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_pmd_lp_rep
 *
 * CGX SPU BASE-R PMD Link Partner Status Report Registers
 * This register implements MDIO register 1.153 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
 * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
 *
 * It implements  MDIO registers 1.1200-1.1203 for all other BASE-R modes (40G, 50G, 100G) per
 * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
 *
 * The register is automatically cleared at the start of training. Each field reflects
 * the contents of the coefficient update field in the lane's most recently received training
 * frame. This register should not be written when link training is enabled, i.e. when
 * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this register are indexed by
 * logical PCS lane ID.
 */
union bdk_cgxx_spux_br_pmd_lp_rep
{
    uint64_t u;
    struct bdk_cgxx_spux_br_pmd_lp_rep_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ln3_rep               : 16; /**< [ 63: 48](RO/H) PCS lane 3 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln2_rep               : 16; /**< [ 47: 32](RO/H) PCS lane 2 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln1_rep               : 16; /**< [ 31: 16](RO/H) PCS lane 1 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln0_rep               : 16; /**< [ 15:  0](RO/H) PCS lane 0 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
#else /* Word 0 - Little Endian */
        uint64_t ln0_rep               : 16; /**< [ 15:  0](RO/H) PCS lane 0 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln1_rep               : 16; /**< [ 31: 16](RO/H) PCS lane 1 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln2_rep               : 16; /**< [ 47: 32](RO/H) PCS lane 2 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
        uint64_t ln3_rep               : 16; /**< [ 63: 48](RO/H) PCS lane 3 status report: format defined by CGX_SPU_BR_TRAIN_REP_S. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_pmd_lp_rep_s cn; */
};
typedef union bdk_cgxx_spux_br_pmd_lp_rep bdk_cgxx_spux_br_pmd_lp_rep_t;

static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LP_REP(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_PMD_LP_REP(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100c0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_PMD_LP_REP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_PMD_LP_REP(a,b) bdk_cgxx_spux_br_pmd_lp_rep_t
#define bustype_BDK_CGXX_SPUX_BR_PMD_LP_REP(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_PMD_LP_REP(a,b) "CGXX_SPUX_BR_PMD_LP_REP"
#define device_bar_BDK_CGXX_SPUX_BR_PMD_LP_REP(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_PMD_LP_REP(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_PMD_LP_REP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_pmd_status
 *
 * CGX SPU BASE-R PMD Status Registers
 * The lane fields in this register are indexed by logical PCS lane ID. The lane 0 field (LN0_*)
 * is valid for 10GBASE-R, 25GBASE-R, 40GBASE-R, 50GBASE-R and 100GBASE-R. The lane 1 field
 * (LN1_*) is valid for 40GBASE-R, 50GBASE-R and 100GBASE-R. The remaining fields (LN2_*, LN3_*)
 * are only valid for 40GBASE-R and 100GBASE-R.
 */
union bdk_cgxx_spux_br_pmd_status
{
    uint64_t u;
    struct bdk_cgxx_spux_br_pmd_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ln3_train_status      : 4;  /**< [ 15: 12](RO/H) PCS lane 3 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
        uint64_t ln2_train_status      : 4;  /**< [ 11:  8](RO/H) PCS lane 2 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
        uint64_t ln1_train_status      : 4;  /**< [  7:  4](RO/H) PCS lane 1 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
        uint64_t ln0_train_status      : 4;  /**< [  3:  0](RO/H) PCS lane 0 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
#else /* Word 0 - Little Endian */
        uint64_t ln0_train_status      : 4;  /**< [  3:  0](RO/H) PCS lane 0 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
        uint64_t ln1_train_status      : 4;  /**< [  7:  4](RO/H) PCS lane 1 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
        uint64_t ln2_train_status      : 4;  /**< [ 11:  8](RO/H) PCS lane 2 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
        uint64_t ln3_train_status      : 4;  /**< [ 15: 12](RO/H) PCS lane 3 link training status. Format defined by CGX_SPU_BR_LANE_TRAIN_STATUS_S. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_pmd_status_s cn; */
};
typedef union bdk_cgxx_spux_br_pmd_status bdk_cgxx_spux_br_pmd_status_t;

static inline uint64_t BDK_CGXX_SPUX_BR_PMD_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_PMD_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100b0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100b0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_PMD_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_PMD_STATUS(a,b) bdk_cgxx_spux_br_pmd_status_t
#define bustype_BDK_CGXX_SPUX_BR_PMD_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_PMD_STATUS(a,b) "CGXX_SPUX_BR_PMD_STATUS"
#define device_bar_BDK_CGXX_SPUX_BR_PMD_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_PMD_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_PMD_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_status1
 *
 * CGX SPU BASE-R Status 1 Registers
 */
union bdk_cgxx_spux_br_status1
{
    uint64_t u;
    struct bdk_cgxx_spux_br_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t rcv_lnk               : 1;  /**< [ 12: 12](RO/H) BASE-R receive link status.
                                                                 0 = BASE-R PCS receive-link down.
                                                                 1 = BASE-R PCS receive-link up.

                                                                 This bit is a reflection of the PCS_status variable defined in IEEE 802.3 sections
                                                                 49.2.14.1 and 82.3.1, applicable to 10G,25G, and 40G,50G,100G, respectively. This bit
                                                                 also applies in the same manner to RS-FEC and non-RS-FEC USXGMII. */
        uint64_t reserved_4_11         : 8;
        uint64_t prbs9                 : 1;  /**< [  3:  3](RO) 10GBASE-R PRBS9 pattern testing ability. Always 0; PRBS9 pattern testing is not supported. */
        uint64_t prbs31                : 1;  /**< [  2:  2](RO) 10GBASE-R PRBS31 pattern testing ability. Always 0; PRBS31 pattern testing is not supported. */
        uint64_t hi_ber                : 1;  /**< [  1:  1](RO/H) BASE-R PCS high bit-error rate.
                                                                 0 = 64/66 bit receiver is detecting a bit-error rate of \< 10.4.
                                                                 1 = 64/66 bit receiver is detecting a bit-error rate of \>= 10.4.

                                                                 This bit is a direct reflection of the state of the hi_ber variable in the 64 B/66 B state
                                                                 diagram and is defined in IEEE 802.3 sections 49.2.13.2.2 and 82.2.18.2.2, applicable to
                                                                 10G,25G, and 40G,50G,100G, respectively. This bit also applies in the same manner to RS-FEC
                                                                 and non-RS-FEC USXGMII. */
        uint64_t blk_lock              : 1;  /**< [  0:  0](RO/H) BASE-R PCS block lock.
                                                                 0 = No block lock.
                                                                 1 = 64/66 bit receiver for BASE-R has block lock.

                                                                 This bit is a direct reflection of the state of the block_lock variable in the 64 B/66 B
                                                                 state diagram and is defined in IEEE 802.3 sections 49.2.13.2.2 and 82.2.18.2.2.
                                                                 For 10G,25G FEC defined in IEEE 802.3 clause 74, this corresponds to the state of the
                                                                 fec_block_lock variable as defined in section 74.10.2.2.
                                                                 For a multilane logical PCS (40G,50G,100GBASE-R with or without Clause 74 FEC), this bit indicates
                                                                 that the receiver has both block lock and alignment for all lanes and is identical to
                                                                 CGX()_SPU()_BR_ALGN_STATUS[ALIGND] (DESKEW_SM FSM (ALIGN_ACQUIRED_1)).
                                                                 For non-RS-FEC USXGMII this bit indicates 64 B/66 B lock was achieved.
                                                                 For single-lane RS-FEC (USXGMII and 25GBASE-R) this bit indicates that the IEEE 802.3by
                                                                 Figure 108-6 synchronization FSM reached state 2_GOOD, i.e. FEC_align_status = 1.
                                                                 (USX uses PIPE_RF_USX_AM_DET FSM, 25G uses PIPE_AM_LOCK).
                                                                 For multilane RS-FEC (50G, 100G), this bit indicates that the IEEE 802.3bj
                                                                 Figure 91-9 FEC alignment FSM reached ALIGN_ACQUIRED. (50G, 100G both use PIPE_DESKEW_SM). */
#else /* Word 0 - Little Endian */
        uint64_t blk_lock              : 1;  /**< [  0:  0](RO/H) BASE-R PCS block lock.
                                                                 0 = No block lock.
                                                                 1 = 64/66 bit receiver for BASE-R has block lock.

                                                                 This bit is a direct reflection of the state of the block_lock variable in the 64 B/66 B
                                                                 state diagram and is defined in IEEE 802.3 sections 49.2.13.2.2 and 82.2.18.2.2.
                                                                 For 10G,25G FEC defined in IEEE 802.3 clause 74, this corresponds to the state of the
                                                                 fec_block_lock variable as defined in section 74.10.2.2.
                                                                 For a multilane logical PCS (40G,50G,100GBASE-R with or without Clause 74 FEC), this bit indicates
                                                                 that the receiver has both block lock and alignment for all lanes and is identical to
                                                                 CGX()_SPU()_BR_ALGN_STATUS[ALIGND] (DESKEW_SM FSM (ALIGN_ACQUIRED_1)).
                                                                 For non-RS-FEC USXGMII this bit indicates 64 B/66 B lock was achieved.
                                                                 For single-lane RS-FEC (USXGMII and 25GBASE-R) this bit indicates that the IEEE 802.3by
                                                                 Figure 108-6 synchronization FSM reached state 2_GOOD, i.e. FEC_align_status = 1.
                                                                 (USX uses PIPE_RF_USX_AM_DET FSM, 25G uses PIPE_AM_LOCK).
                                                                 For multilane RS-FEC (50G, 100G), this bit indicates that the IEEE 802.3bj
                                                                 Figure 91-9 FEC alignment FSM reached ALIGN_ACQUIRED. (50G, 100G both use PIPE_DESKEW_SM). */
        uint64_t hi_ber                : 1;  /**< [  1:  1](RO/H) BASE-R PCS high bit-error rate.
                                                                 0 = 64/66 bit receiver is detecting a bit-error rate of \< 10.4.
                                                                 1 = 64/66 bit receiver is detecting a bit-error rate of \>= 10.4.

                                                                 This bit is a direct reflection of the state of the hi_ber variable in the 64 B/66 B state
                                                                 diagram and is defined in IEEE 802.3 sections 49.2.13.2.2 and 82.2.18.2.2, applicable to
                                                                 10G,25G, and 40G,50G,100G, respectively. This bit also applies in the same manner to RS-FEC
                                                                 and non-RS-FEC USXGMII. */
        uint64_t prbs31                : 1;  /**< [  2:  2](RO) 10GBASE-R PRBS31 pattern testing ability. Always 0; PRBS31 pattern testing is not supported. */
        uint64_t prbs9                 : 1;  /**< [  3:  3](RO) 10GBASE-R PRBS9 pattern testing ability. Always 0; PRBS9 pattern testing is not supported. */
        uint64_t reserved_4_11         : 8;
        uint64_t rcv_lnk               : 1;  /**< [ 12: 12](RO/H) BASE-R receive link status.
                                                                 0 = BASE-R PCS receive-link down.
                                                                 1 = BASE-R PCS receive-link up.

                                                                 This bit is a reflection of the PCS_status variable defined in IEEE 802.3 sections
                                                                 49.2.14.1 and 82.3.1, applicable to 10G,25G, and 40G,50G,100G, respectively. This bit
                                                                 also applies in the same manner to RS-FEC and non-RS-FEC USXGMII. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_status1_s cn; */
};
typedef union bdk_cgxx_spux_br_status1 bdk_cgxx_spux_br_status1_t;

static inline uint64_t BDK_CGXX_SPUX_BR_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010030ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010030ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_STATUS1(a,b) bdk_cgxx_spux_br_status1_t
#define bustype_BDK_CGXX_SPUX_BR_STATUS1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_STATUS1(a,b) "CGXX_SPUX_BR_STATUS1"
#define device_bar_BDK_CGXX_SPUX_BR_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_STATUS1(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_status2
 *
 * CGX SPU BASE-R Status 2 Registers
 * This register implements a combination of the following IEEE 802.3 registers:
 * * BASE-R PCS status 2 (MDIO address 3.33).
 * * BASE-R BER high-order counter (MDIO address 3.44).
 * * Errored-blocks high-order counter (MDIO address 3.45).
 *
 * Note that the relative locations of some fields have been moved from IEEE 802.3 in order to
 * make the register layout more software friendly: the BER counter high-order and low-order bits
 * from sections 3.44 and 3.33 have been combined into the contiguous, 22-bit [BER_CNT] field;
 * likewise, the errored-blocks counter high-order and low-order bits from section 3.45 have been
 * combined into the contiguous, 22-bit [ERR_BLKS] field.
 */
union bdk_cgxx_spux_br_status2
{
    uint64_t u;
    struct bdk_cgxx_spux_br_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t err_blks              : 22; /**< [ 61: 40](R/W/H) Errored-blocks counter. This is the BASE-R errored-blocks counter as defined by
                                                                 the errored_block_count variable specified in IEEE 802.3 sections 49.2.14.2 and
                                                                 82.2.18.2.4. It increments by one on each block for which the BASE-R receive
                                                                 state machine, specified in IEEE 802.3 diagrams 49-15 and 82-15, enters the RX_E
                                                                 state. Back-to-back blocks in the RX_E state are counted as transitions from
                                                                 RX_E to RX_E and keep incrementing the counter.

                                                                 This field is writable for test purposes, rather than read-only as specified in IEEE
                                                                 802.3. */
        uint64_t reserved_38_39        : 2;
        uint64_t ber_cnt               : 22; /**< [ 37: 16](R/W/H) Bit-error-rate counter. This is the BASE-R BER counter as defined by the ber_count
                                                                 variable in IEEE 802.3 sections 49.2.14.2 and 82.2.18.2.4.

                                                                 This field is writable for test purposes, rather than read-only as specified in IEEE
                                                                 802.3. */
        uint64_t latched_lock          : 1;  /**< [ 15: 15](R/W1S/H) Latched-block lock.
                                                                 0 = No block.
                                                                 1 = 64/66 bit receiver for BASE-R has block lock.

                                                                 This is a latching-low version of CGX()_SPU()_BR_STATUS1[BLK_LOCK]; it stays clear
                                                                 until a write-1-to-set by software. */
        uint64_t latched_ber           : 1;  /**< [ 14: 14](R/W1C/H) Latched-high bit-error rate.
                                                                 0 = Not a high BER.
                                                                 1 = 64/66 bit receiver is detecting a high BER.

                                                                 This is a latching-high version of CGX()_SPU()_BR_STATUS1[HI_BER]; it stays set until
                                                                 a write-1-to-clear by software. */
        uint64_t reserved_0_13         : 14;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_13         : 14;
        uint64_t latched_ber           : 1;  /**< [ 14: 14](R/W1C/H) Latched-high bit-error rate.
                                                                 0 = Not a high BER.
                                                                 1 = 64/66 bit receiver is detecting a high BER.

                                                                 This is a latching-high version of CGX()_SPU()_BR_STATUS1[HI_BER]; it stays set until
                                                                 a write-1-to-clear by software. */
        uint64_t latched_lock          : 1;  /**< [ 15: 15](R/W1S/H) Latched-block lock.
                                                                 0 = No block.
                                                                 1 = 64/66 bit receiver for BASE-R has block lock.

                                                                 This is a latching-low version of CGX()_SPU()_BR_STATUS1[BLK_LOCK]; it stays clear
                                                                 until a write-1-to-set by software. */
        uint64_t ber_cnt               : 22; /**< [ 37: 16](R/W/H) Bit-error-rate counter. This is the BASE-R BER counter as defined by the ber_count
                                                                 variable in IEEE 802.3 sections 49.2.14.2 and 82.2.18.2.4.

                                                                 This field is writable for test purposes, rather than read-only as specified in IEEE
                                                                 802.3. */
        uint64_t reserved_38_39        : 2;
        uint64_t err_blks              : 22; /**< [ 61: 40](R/W/H) Errored-blocks counter. This is the BASE-R errored-blocks counter as defined by
                                                                 the errored_block_count variable specified in IEEE 802.3 sections 49.2.14.2 and
                                                                 82.2.18.2.4. It increments by one on each block for which the BASE-R receive
                                                                 state machine, specified in IEEE 802.3 diagrams 49-15 and 82-15, enters the RX_E
                                                                 state. Back-to-back blocks in the RX_E state are counted as transitions from
                                                                 RX_E to RX_E and keep incrementing the counter.

                                                                 This field is writable for test purposes, rather than read-only as specified in IEEE
                                                                 802.3. */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_status2_s cn9; */
    /* struct bdk_cgxx_spux_br_status2_s cn96xx; */
    struct bdk_cgxx_spux_br_status2_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t err_blks              : 22; /**< [ 61: 40](R/W/H) Errored-blocks counter. This is the BASE-R errored-blocks counter as defined by
                                                                 the errored_block_count variable specified in IEEE 802.3 sections 49.2.14.2 and
                                                                 82.2.18.2.4. It increments by one on each block for which the BASE-R receive
                                                                 state machine, specified in IEEE 802.3 diagrams 49-15 and 82-15, enters the RX_E
                                                                 state. Back-to-back blocks in the RX_E state are counted as transitions from
                                                                 RX_E to RX_E and keep incrementing the counter.

                                                                 This field is writable for test purposes, rather than read-clear as specified in IEEE
                                                                 802.3. */
        uint64_t reserved_38_39        : 2;
        uint64_t ber_cnt               : 22; /**< [ 37: 16](R/W/H) Bit-error-rate counter. This is the BASE-R BER counter as defined by the ber_count
                                                                 variable in IEEE 802.3 sections 49.2.14.2 and 82.2.18.2.4.

                                                                 This field is writable for test purposes, rather than read-clear as specified in IEEE
                                                                 802.3. */
        uint64_t latched_lock          : 1;  /**< [ 15: 15](R/W1S/H) Latched-block lock.
                                                                 0 = No block.
                                                                 1 = 64/66 bit receiver for BASE-R has block lock.

                                                                 This is a latching-low version of CGX()_SPU()_BR_STATUS1[BLK_LOCK]; it stays clear
                                                                 until a write-1-to-set by software. */
        uint64_t latched_ber           : 1;  /**< [ 14: 14](R/W1C/H) Latched-high bit-error rate.
                                                                 0 = Not a high BER.
                                                                 1 = 64/66 bit receiver is detecting a high BER.

                                                                 This is a latching-high version of CGX()_SPU()_BR_STATUS1[HI_BER]; it stays set until
                                                                 a write-1-to-clear by software. */
        uint64_t reserved_0_13         : 14;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_13         : 14;
        uint64_t latched_ber           : 1;  /**< [ 14: 14](R/W1C/H) Latched-high bit-error rate.
                                                                 0 = Not a high BER.
                                                                 1 = 64/66 bit receiver is detecting a high BER.

                                                                 This is a latching-high version of CGX()_SPU()_BR_STATUS1[HI_BER]; it stays set until
                                                                 a write-1-to-clear by software. */
        uint64_t latched_lock          : 1;  /**< [ 15: 15](R/W1S/H) Latched-block lock.
                                                                 0 = No block.
                                                                 1 = 64/66 bit receiver for BASE-R has block lock.

                                                                 This is a latching-low version of CGX()_SPU()_BR_STATUS1[BLK_LOCK]; it stays clear
                                                                 until a write-1-to-set by software. */
        uint64_t ber_cnt               : 22; /**< [ 37: 16](R/W/H) Bit-error-rate counter. This is the BASE-R BER counter as defined by the ber_count
                                                                 variable in IEEE 802.3 sections 49.2.14.2 and 82.2.18.2.4.

                                                                 This field is writable for test purposes, rather than read-clear as specified in IEEE
                                                                 802.3. */
        uint64_t reserved_38_39        : 2;
        uint64_t err_blks              : 22; /**< [ 61: 40](R/W/H) Errored-blocks counter. This is the BASE-R errored-blocks counter as defined by
                                                                 the errored_block_count variable specified in IEEE 802.3 sections 49.2.14.2 and
                                                                 82.2.18.2.4. It increments by one on each block for which the BASE-R receive
                                                                 state machine, specified in IEEE 802.3 diagrams 49-15 and 82-15, enters the RX_E
                                                                 state. Back-to-back blocks in the RX_E state are counted as transitions from
                                                                 RX_E to RX_E and keep incrementing the counter.

                                                                 This field is writable for test purposes, rather than read-clear as specified in IEEE
                                                                 802.3. */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_spux_br_status2_s cnf95xx; */
    /* struct bdk_cgxx_spux_br_status2_cn98xx loki; */
};
typedef union bdk_cgxx_spux_br_status2 bdk_cgxx_spux_br_status2_t;

static inline uint64_t BDK_CGXX_SPUX_BR_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_STATUS2(a,b) bdk_cgxx_spux_br_status2_t
#define bustype_BDK_CGXX_SPUX_BR_STATUS2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_STATUS2(a,b) "CGXX_SPUX_BR_STATUS2"
#define device_bar_BDK_CGXX_SPUX_BR_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_STATUS2(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_tp_control
 *
 * CGX SPU BASE-R Test-Pattern Control Registers
 * Refer to the test pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
 */
union bdk_cgxx_spux_br_tp_control
{
    uint64_t u;
    struct bdk_cgxx_spux_br_tp_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t pr_tp_data_type       : 1;  /**< [  9:  9](R/W) Select pseudo-random test pattern data type. This bit selects the transmit test pattern
                                                                 data type when [TX_TP_EN] is set and [SCRAMBLE_TP] is 10.
                                                                 0 = Enable 64 zeros test pattern data.
                                                                 1 = Enable 64-bit encoding for two local fault ordered sets as pattern data. */
        uint64_t scramble_tp           : 2;  /**< [  8:  7](R/W) Select transmit test pattern. This field selects the transmit test pattern used when
                                                                 [TX_TP_EN] is set:
                                                                 0x0 = Enable square wave test pattern mode.
                                                                 0x1 = Enable scrambled idle test pattern mode.
                                                                 0x2 = Enable pseudo-random test pattern mode. */
        uint64_t prbs9_tx              : 1;  /**< [  6:  6](RO) 10GBASE-R PRBS9 TP transmit enable. Always 0; PRBS9 pattern testing is not supported. */
        uint64_t prbs31_rx             : 1;  /**< [  5:  5](RO) 10GBASE-R PRBS31 TP receive enable. Always 0; PRBS31 pattern testing is not supported. */
        uint64_t prbs31_tx             : 1;  /**< [  4:  4](RO) 10GBASE-R PRBS31 TP transmit enable. Always 0; PRBS31 pattern is not supported. */
        uint64_t tx_tp_en              : 1;  /**< [  3:  3](R/W) Transmit-test-pattern enable. */
        uint64_t rx_tp_en              : 1;  /**< [  2:  2](R/W) Receive-test-pattern enable. The only supported receive test pattern is the scrambled idle
                                                                 test pattern. Setting this bit enables checking of that receive pattern. */
        uint64_t tp_sel                : 1;  /**< [  1:  1](R/W) Square/pseudo-random test pattern select.
                                                                 0 = Select pseudo-random test pattern.
                                                                 1 = Select square wave test pattern. */
        uint64_t dp_sel                : 1;  /**< [  0:  0](R/W) Data pattern select.
                                                                 0 = Select LF (local fault) data pattern.
                                                                 1 = Select zeros data pattern. */
#else /* Word 0 - Little Endian */
        uint64_t dp_sel                : 1;  /**< [  0:  0](R/W) Data pattern select.
                                                                 0 = Select LF (local fault) data pattern.
                                                                 1 = Select zeros data pattern. */
        uint64_t tp_sel                : 1;  /**< [  1:  1](R/W) Square/pseudo-random test pattern select.
                                                                 0 = Select pseudo-random test pattern.
                                                                 1 = Select square wave test pattern. */
        uint64_t rx_tp_en              : 1;  /**< [  2:  2](R/W) Receive-test-pattern enable. The only supported receive test pattern is the scrambled idle
                                                                 test pattern. Setting this bit enables checking of that receive pattern. */
        uint64_t tx_tp_en              : 1;  /**< [  3:  3](R/W) Transmit-test-pattern enable. */
        uint64_t prbs31_tx             : 1;  /**< [  4:  4](RO) 10GBASE-R PRBS31 TP transmit enable. Always 0; PRBS31 pattern is not supported. */
        uint64_t prbs31_rx             : 1;  /**< [  5:  5](RO) 10GBASE-R PRBS31 TP receive enable. Always 0; PRBS31 pattern testing is not supported. */
        uint64_t prbs9_tx              : 1;  /**< [  6:  6](RO) 10GBASE-R PRBS9 TP transmit enable. Always 0; PRBS9 pattern testing is not supported. */
        uint64_t scramble_tp           : 2;  /**< [  8:  7](R/W) Select transmit test pattern. This field selects the transmit test pattern used when
                                                                 [TX_TP_EN] is set:
                                                                 0x0 = Enable square wave test pattern mode.
                                                                 0x1 = Enable scrambled idle test pattern mode.
                                                                 0x2 = Enable pseudo-random test pattern mode. */
        uint64_t pr_tp_data_type       : 1;  /**< [  9:  9](R/W) Select pseudo-random test pattern data type. This bit selects the transmit test pattern
                                                                 data type when [TX_TP_EN] is set and [SCRAMBLE_TP] is 10.
                                                                 0 = Enable 64 zeros test pattern data.
                                                                 1 = Enable 64-bit encoding for two local fault ordered sets as pattern data. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_tp_control_s cn; */
};
typedef union bdk_cgxx_spux_br_tp_control bdk_cgxx_spux_br_tp_control_t;

static inline uint64_t BDK_CGXX_SPUX_BR_TP_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_TP_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010040ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010040ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_TP_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_TP_CONTROL(a,b) bdk_cgxx_spux_br_tp_control_t
#define bustype_BDK_CGXX_SPUX_BR_TP_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_TP_CONTROL(a,b) "CGXX_SPUX_BR_TP_CONTROL"
#define device_bar_BDK_CGXX_SPUX_BR_TP_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_TP_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_TP_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_tp_err_cnt
 *
 * CGX SPU BASE-R Test-Pattern Error-Count Registers
 * This register provides the BASE-R PCS test-pattern error counter.
 */
union bdk_cgxx_spux_br_tp_err_cnt
{
    uint64_t u;
    struct bdk_cgxx_spux_br_tp_err_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t err_cnt               : 16; /**< [ 15:  0](R/W/H) Error counter. This 16-bit counter contains the number of errors received during a pattern
                                                                 test. These bits are held at all ones in the case of overflow.

                                                                 The test pattern methodology is described in IEEE 802.3, Sections 49.2.12 and 82.2.10.
                                                                 This
                                                                 counter counts either block errors or bit errors dependent on the test mode (see Section
                                                                 49.2.12). This field is writable for test purposes, rather than read-only as specified
                                                                 in IEEE 802.3. */
#else /* Word 0 - Little Endian */
        uint64_t err_cnt               : 16; /**< [ 15:  0](R/W/H) Error counter. This 16-bit counter contains the number of errors received during a pattern
                                                                 test. These bits are held at all ones in the case of overflow.

                                                                 The test pattern methodology is described in IEEE 802.3, Sections 49.2.12 and 82.2.10.
                                                                 This
                                                                 counter counts either block errors or bit errors dependent on the test mode (see Section
                                                                 49.2.12). This field is writable for test purposes, rather than read-only as specified
                                                                 in IEEE 802.3. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_tp_err_cnt_s cn; */
};
typedef union bdk_cgxx_spux_br_tp_err_cnt bdk_cgxx_spux_br_tp_err_cnt_t;

static inline uint64_t BDK_CGXX_SPUX_BR_TP_ERR_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_TP_ERR_CNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010048ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010048ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_TP_ERR_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_TP_ERR_CNT(a,b) bdk_cgxx_spux_br_tp_err_cnt_t
#define bustype_BDK_CGXX_SPUX_BR_TP_ERR_CNT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_TP_ERR_CNT(a,b) "CGXX_SPUX_BR_TP_ERR_CNT"
#define device_bar_BDK_CGXX_SPUX_BR_TP_ERR_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_TP_ERR_CNT(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_TP_ERR_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_tp_seed_a
 *
 * CGX SPU BASE-R Test-Pattern Seed A Registers
 * Refer to the test pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
 */
union bdk_cgxx_spux_br_tp_seed_a
{
    uint64_t u;
    struct bdk_cgxx_spux_br_tp_seed_a_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t tp_seed_a             : 58; /**< [ 57:  0](R/W) Test pattern seed A. Used when pseudo-random test pattern transmission is enabled. */
#else /* Word 0 - Little Endian */
        uint64_t tp_seed_a             : 58; /**< [ 57:  0](R/W) Test pattern seed A. Used when pseudo-random test pattern transmission is enabled. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_tp_seed_a_s cn; */
};
typedef union bdk_cgxx_spux_br_tp_seed_a bdk_cgxx_spux_br_tp_seed_a_t;

static inline uint64_t BDK_CGXX_SPUX_BR_TP_SEED_A(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_TP_SEED_A(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010060ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010060ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_TP_SEED_A", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_TP_SEED_A(a,b) bdk_cgxx_spux_br_tp_seed_a_t
#define bustype_BDK_CGXX_SPUX_BR_TP_SEED_A(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_TP_SEED_A(a,b) "CGXX_SPUX_BR_TP_SEED_A"
#define device_bar_BDK_CGXX_SPUX_BR_TP_SEED_A(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_TP_SEED_A(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_TP_SEED_A(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_br_tp_seed_b
 *
 * CGX SPU BASE-R Test-Pattern Seed B Registers
 * Refer to the test pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
 */
union bdk_cgxx_spux_br_tp_seed_b
{
    uint64_t u;
    struct bdk_cgxx_spux_br_tp_seed_b_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t tp_seed_b             : 58; /**< [ 57:  0](R/W) Test pattern seed B. Used when pseudo-random test pattern transmission is enabled. */
#else /* Word 0 - Little Endian */
        uint64_t tp_seed_b             : 58; /**< [ 57:  0](R/W) Test pattern seed B. Used when pseudo-random test pattern transmission is enabled. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_br_tp_seed_b_s cn; */
};
typedef union bdk_cgxx_spux_br_tp_seed_b bdk_cgxx_spux_br_tp_seed_b_t;

static inline uint64_t BDK_CGXX_SPUX_BR_TP_SEED_B(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BR_TP_SEED_B(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010068ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010068ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BR_TP_SEED_B", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BR_TP_SEED_B(a,b) bdk_cgxx_spux_br_tp_seed_b_t
#define bustype_BDK_CGXX_SPUX_BR_TP_SEED_B(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BR_TP_SEED_B(a,b) "CGXX_SPUX_BR_TP_SEED_B"
#define device_bar_BDK_CGXX_SPUX_BR_TP_SEED_B(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BR_TP_SEED_B(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BR_TP_SEED_B(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_bx_status
 *
 * CGX SPU BASE-X Status Registers
 */
union bdk_cgxx_spux_bx_status
{
    uint64_t u;
    struct bdk_cgxx_spux_bx_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t alignd                : 1;  /**< [ 12: 12](RO/H) 10GBASE-X lane-alignment status.
                                                                 0 = receive lanes not aligned.
                                                                 1 = receive lanes aligned. */
        uint64_t pattst                : 1;  /**< [ 11: 11](RO) Pattern-testing ability. Always 0; 10GBASE-X pattern is testing not supported. */
        uint64_t reserved_4_10         : 7;
        uint64_t lsync                 : 4;  /**< [  3:  0](RO/H) Lane synchronization. BASE-X lane synchronization status for PCS lanes 3-0. Each bit is
                                                                 set when the associated lane is code-group synchronized, and clear otherwise. If the PCS
                                                                 type is RXAUI (i.e. the associated CGX()_CMR()_CONFIG[LMAC_TYPE] = RXAUI), then
                                                                 only lanes 1-0 are valid. */
#else /* Word 0 - Little Endian */
        uint64_t lsync                 : 4;  /**< [  3:  0](RO/H) Lane synchronization. BASE-X lane synchronization status for PCS lanes 3-0. Each bit is
                                                                 set when the associated lane is code-group synchronized, and clear otherwise. If the PCS
                                                                 type is RXAUI (i.e. the associated CGX()_CMR()_CONFIG[LMAC_TYPE] = RXAUI), then
                                                                 only lanes 1-0 are valid. */
        uint64_t reserved_4_10         : 7;
        uint64_t pattst                : 1;  /**< [ 11: 11](RO) Pattern-testing ability. Always 0; 10GBASE-X pattern is testing not supported. */
        uint64_t alignd                : 1;  /**< [ 12: 12](RO/H) 10GBASE-X lane-alignment status.
                                                                 0 = receive lanes not aligned.
                                                                 1 = receive lanes aligned. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_bx_status_s cn; */
};
typedef union bdk_cgxx_spux_bx_status bdk_cgxx_spux_bx_status_t;

static inline uint64_t BDK_CGXX_SPUX_BX_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_BX_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_BX_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_BX_STATUS(a,b) bdk_cgxx_spux_bx_status_t
#define bustype_BDK_CGXX_SPUX_BX_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_BX_STATUS(a,b) "CGXX_SPUX_BX_STATUS"
#define device_bar_BDK_CGXX_SPUX_BX_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_BX_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPUX_BX_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_control1
 *
 * CGX SPU Control 1 Registers
 */
union bdk_cgxx_spux_control1
{
    uint64_t u;
    struct bdk_cgxx_spux_control1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t disable_am            : 1;  /**< [ 22: 22](R/W) Disable alignment markers for USXGMII-S 2.5/5/10G. */
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t reserved_12           : 1;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_7_10         : 4;
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE   Speed       SPD Read Value    Comment
                                                                   ------------------------------------------------------
                                                                   XAUI        10G/20G     0x0               20G if DXAUI
                                                                   RXAUI       10G         0x0
                                                                   10G_R       10G         0x0               802.3by Table 45-120 / 45.2.3.1
                                                                   40G_R       40G         0x3               802.3by Table 45-120 / 45.2.3.1
                                                                   100G_R      100G        0x4               802.3by Table 45-120 / 45.2.3.1
                                                                   25G_R       25G         0x5               802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R       50G         0x6               802.3cd Table 45-120 / 45.2.3.1
                                                                   USXGMII     various     0xD               802.3cd Table 45-120 / 45.2.3.1
                                                                                                             (0xB-0xF reserved, assigning 0xD)
                                                                   Other       -           X
                                                                 \</pre\> */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE   Speed       SPD Read Value    Comment
                                                                   ------------------------------------------------------
                                                                   XAUI        10G/20G     0x0               20G if DXAUI
                                                                   RXAUI       10G         0x0
                                                                   10G_R       10G         0x0               802.3by Table 45-120 / 45.2.3.1
                                                                   40G_R       40G         0x3               802.3by Table 45-120 / 45.2.3.1
                                                                   100G_R      100G        0x4               802.3by Table 45-120 / 45.2.3.1
                                                                   25G_R       25G         0x5               802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R       50G         0x6               802.3cd Table 45-120 / 45.2.3.1
                                                                   USXGMII     various     0xD               802.3cd Table 45-120 / 45.2.3.1
                                                                                                             (0xB-0xF reserved, assigning 0xD)
                                                                   Other       -           X
                                                                 \</pre\> */
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t reserved_7_10         : 4;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_12           : 1;
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t disable_am            : 1;  /**< [ 22: 22](R/W) Disable alignment markers for USXGMII-S 2.5/5/10G. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_control1_s cn9; */
    struct bdk_cgxx_spux_control1_cn96xxp1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t reserved_12           : 1;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_7_10         : 4;
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE   Speed       SPD Read Value    Comment
                                                                   ------------------------------------------------------
                                                                   XAUI        10G/20G     0x0               20G if DXAUI
                                                                   RXAUI       10G         0x0
                                                                   10G_R       10G         0x0               802.3by Table 45-120 / 45.2.3.1
                                                                   40G_R       40G         0x3               802.3by Table 45-120 / 45.2.3.1
                                                                   100G_R      100G        0x4               802.3by Table 45-120 / 45.2.3.1
                                                                   25G_R       25G         0x5               802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R       50G         0x6               802.3cd Table 45-120 / 45.2.3.1
                                                                   USXGMII     various     0xD               802.3cd Table 45-120 / 45.2.3.1
                                                                                                             (0xB-0xF reserved, assigning 0xD)
                                                                   Other       -           X
                                                                 \</pre\> */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE   Speed       SPD Read Value    Comment
                                                                   ------------------------------------------------------
                                                                   XAUI        10G/20G     0x0               20G if DXAUI
                                                                   RXAUI       10G         0x0
                                                                   10G_R       10G         0x0               802.3by Table 45-120 / 45.2.3.1
                                                                   40G_R       40G         0x3               802.3by Table 45-120 / 45.2.3.1
                                                                   100G_R      100G        0x4               802.3by Table 45-120 / 45.2.3.1
                                                                   25G_R       25G         0x5               802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R       50G         0x6               802.3cd Table 45-120 / 45.2.3.1
                                                                   USXGMII     various     0xD               802.3cd Table 45-120 / 45.2.3.1
                                                                                                             (0xB-0xF reserved, assigning 0xD)
                                                                   Other       -           X
                                                                 \</pre\> */
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t reserved_7_10         : 4;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_12           : 1;
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn96xxp1;
    struct bdk_cgxx_spux_control1_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t disable_am            : 1;  /**< [ 22: 22](R/W) Disable alignment markers for USXGMII-S 2.5/5/10G. */
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t reserved_12           : 1;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_7_10         : 4;
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Speed    SPD    Comment
                                                                                       Read
                                                                                       Value
                                                                   ---------  -------  -----  ----------------------
                                                                   XAUI       10G/20G  0x0    20G if DXAUI
                                                                   RXAUI      10G      0x0
                                                                   10G_R      10G      0x0    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   40G_R      40G      0x3    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   100G_R     100G     0x4    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   25G_R      25G      0x5    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   50G_R      50G      0x6    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                   USXGMII    various  0xD    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                                              (0xB-0xF reserved,
                                                                                              assigning 0xD)
                                                                   Other      -        X
                                                                 \</pre\> */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Speed    SPD    Comment
                                                                                       Read
                                                                                       Value
                                                                   ---------  -------  -----  ----------------------
                                                                   XAUI       10G/20G  0x0    20G if DXAUI
                                                                   RXAUI      10G      0x0
                                                                   10G_R      10G      0x0    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   40G_R      40G      0x3    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   100G_R     100G     0x4    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   25G_R      25G      0x5    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   50G_R      50G      0x6    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                   USXGMII    various  0xD    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                                              (0xB-0xF reserved,
                                                                                              assigning 0xD)
                                                                   Other      -        X
                                                                 \</pre\> */
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t reserved_7_10         : 4;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_12           : 1;
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t disable_am            : 1;  /**< [ 22: 22](R/W) Disable alignment markers for USXGMII-S 2.5/5/10G. */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } cn96xxp3;
    struct bdk_cgxx_spux_control1_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t reserved_12           : 1;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_7_10         : 4;
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Speed    SPD    Comment
                                                                                       Read
                                                                                       Value
                                                                   ---------  -------  -----  ----------------------
                                                                   XAUI       10G/20G  0x0    20G if DXAUI
                                                                   RXAUI      10G      0x0
                                                                   10G_R      10G      0x0    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   40G_R      40G      0x3    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   100G_R     100G     0x4    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   25G_R      25G      0x5    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   50G_R      50G      0x6    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                   USXGMII    various  0xD    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                                              (0xB-0xF reserved,
                                                                                              assigning 0xD)
                                                                   Other      -        X
                                                                 \</pre\> */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t spd                   : 4;  /**< [  5:  2](RO/H) Speed selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                   LMAC_TYPE  Speed    SPD    Comment
                                                                                       Read
                                                                                       Value
                                                                   ---------  -------  -----  ----------------------
                                                                   XAUI       10G/20G  0x0    20G if DXAUI
                                                                   RXAUI      10G      0x0
                                                                   10G_R      10G      0x0    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   40G_R      40G      0x3    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   100G_R     100G     0x4    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   25G_R      25G      0x5    802.3by Table 45-120 /
                                                                                              45.2.3.1
                                                                   50G_R      50G      0x6    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                   USXGMII    various  0xD    802.3cd Table 45-120 /
                                                                                              45.2.3.1
                                                                                              (0xB-0xF reserved,
                                                                                              assigning 0xD)
                                                                   Other      -        X
                                                                 \</pre\> */
        uint64_t spdsel0               : 1;  /**< [  6:  6](RO/H) Speed select 0: always 1. */
        uint64_t reserved_7_10         : 4;
        uint64_t lo_pwr                : 1;  /**< [ 11: 11](R/W) Low power enable. When set, the LPCS is disabled (overriding the associated
                                                                 CGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                                 reset. */
        uint64_t reserved_12           : 1;
        uint64_t spdsel1               : 1;  /**< [ 13: 13](RO/H) Speed select 1: always 1. */
        uint64_t loopbck               : 1;  /**< [ 14: 14](R/W) TX-to-RX loopback enable. When set, transmit data for each SerDes lane is looped back as
                                                                 receive data. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W1S/H) Reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_USX_AN_CONTROL[AN_RESET] to 1 causes the following events to occur:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t usxgmii_type          : 3;  /**< [ 18: 16](RO/H) USXGMII port sub-type. Read-only field from
                                                                 CGX()_SPU_USXGMII_CONTROL[USXGMII_TYPE]. Ignored if
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is not USXGMII. Enumerated by CGX_USXGMII_TYPE_E. */
        uint64_t usxgmii_rate          : 3;  /**< [ 21: 19](R/W/H) USXGMII port rate. Ignored if CGX()_CMR()_CONFIG[LMAC_TYPE] is not
                                                                 USXGMII. Enumerated by CGX_USXGMII_RATE_E. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_spux_control1_cn98xx cnf95xx; */
    /* struct bdk_cgxx_spux_control1_cn98xx loki; */
};
typedef union bdk_cgxx_spux_control1 bdk_cgxx_spux_control1_t;

static inline uint64_t BDK_CGXX_SPUX_CONTROL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_CONTROL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010000ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010000ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_CONTROL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_CONTROL1(a,b) bdk_cgxx_spux_control1_t
#define bustype_BDK_CGXX_SPUX_CONTROL1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_CONTROL1(a,b) "CGXX_SPUX_CONTROL1"
#define device_bar_BDK_CGXX_SPUX_CONTROL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_CONTROL1(a,b) (a)
#define arguments_BDK_CGXX_SPUX_CONTROL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_control2
 *
 * CGX SPU Control 2 Registers
 */
union bdk_cgxx_spux_control2
{
    uint64_t u;
    struct bdk_cgxx_spux_control2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) PCS type selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                               [PCS_TYPE]
                                                                   LMAC_TYPE   Read Value      Comment
                                                                   -----------------------------------------------------------------------
                                                                   XAUI        0x1             10GBASE-X PCS type
                                                                   RXAUI       0x1             10GBASE-X PCS type
                                                                   10G_R       0x0             10GBASE-R PCS type
                                                                   40G_R       0x4             40GBASE-R PCS type
                                                                   100G_R      0x5             802.3by Table 45-123 / 45.2.3.6
                                                                   25G_R       0x7             802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R       0x8             802.3cd Table 45-120 / 45.2.3.6
                                                                   USXGMII     0xE             802.3cd Table 45-120 / 45.2.3.6
                                                                                               (0xE, 0xF reserved)
                                                                   Other       Undefined       Reserved
                                                                 \</pre\> */
#else /* Word 0 - Little Endian */
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) PCS type selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                               [PCS_TYPE]
                                                                   LMAC_TYPE   Read Value      Comment
                                                                   -----------------------------------------------------------------------
                                                                   XAUI        0x1             10GBASE-X PCS type
                                                                   RXAUI       0x1             10GBASE-X PCS type
                                                                   10G_R       0x0             10GBASE-R PCS type
                                                                   40G_R       0x4             40GBASE-R PCS type
                                                                   100G_R      0x5             802.3by Table 45-123 / 45.2.3.6
                                                                   25G_R       0x7             802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R       0x8             802.3cd Table 45-120 / 45.2.3.6
                                                                   USXGMII     0xE             802.3cd Table 45-120 / 45.2.3.6
                                                                                               (0xE, 0xF reserved)
                                                                   Other       Undefined       Reserved
                                                                 \</pre\> */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_control2_s cn9; */
    /* struct bdk_cgxx_spux_control2_s cn96xxp1; */
    struct bdk_cgxx_spux_control2_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) PCS type selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                              [PCS_TYPE]
                                                                   LMAC_TYPE  Read Value  Comment
                                                                   ---------  ----------  -------------------------------
                                                                   XAUI       0x1         10GBASE-X PCS type
                                                                   RXAUI      0x1         10GBASE-X PCS type
                                                                   10G_R      0x0         10GBASE-R PCS type
                                                                   40G_R      0x4         40GBASE-R PCS type
                                                                   100G_R     0x5         802.3by Table 45-123 / 45.2.3.6
                                                                   25G_R      0x7         802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R      0x8         802.3cd Table 45-120 / 45.2.3.6
                                                                   USXGMII    0xE         802.3cd Table 45-120 / 45.2.3.6
                                                                                          (0xE, 0xF reserved)
                                                                   Other      Undefined   Reserved
                                                                 \</pre\> */
#else /* Word 0 - Little Endian */
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) PCS type selection.
                                                                 Note that this is a read-only field rather than read/write as
                                                                 specified in 802.3.
                                                                 The LPCS speed is instead configured by the associated
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                                 follows:

                                                                 \<pre\>
                                                                              [PCS_TYPE]
                                                                   LMAC_TYPE  Read Value  Comment
                                                                   ---------  ----------  -------------------------------
                                                                   XAUI       0x1         10GBASE-X PCS type
                                                                   RXAUI      0x1         10GBASE-X PCS type
                                                                   10G_R      0x0         10GBASE-R PCS type
                                                                   40G_R      0x4         40GBASE-R PCS type
                                                                   100G_R     0x5         802.3by Table 45-123 / 45.2.3.6
                                                                   25G_R      0x7         802.3by Table 45-120 / 45.2.3.1
                                                                   50G_R      0x8         802.3cd Table 45-120 / 45.2.3.6
                                                                   USXGMII    0xE         802.3cd Table 45-120 / 45.2.3.6
                                                                                          (0xE, 0xF reserved)
                                                                   Other      Undefined   Reserved
                                                                 \</pre\> */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_cgxx_spux_control2_cn96xxp3 cn98xx; */
    /* struct bdk_cgxx_spux_control2_cn96xxp3 cnf95xx; */
    /* struct bdk_cgxx_spux_control2_cn96xxp3 loki; */
};
typedef union bdk_cgxx_spux_control2 bdk_cgxx_spux_control2_t;

static inline uint64_t BDK_CGXX_SPUX_CONTROL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_CONTROL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_CONTROL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_CONTROL2(a,b) bdk_cgxx_spux_control2_t
#define bustype_BDK_CGXX_SPUX_CONTROL2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_CONTROL2(a,b) "CGXX_SPUX_CONTROL2"
#define device_bar_BDK_CGXX_SPUX_CONTROL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_CONTROL2(a,b) (a)
#define arguments_BDK_CGXX_SPUX_CONTROL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_fec_abil
 *
 * CGX SPU Forward Error Correction Ability Registers
 */
union bdk_cgxx_spux_fec_abil
{
    uint64_t u;
    struct bdk_cgxx_spux_fec_abil_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t err_abil              : 1;  /**< [  1:  1](RO/H) BASE-R FEC error-indication ability. Always 1 when the LPCS type is BASE-R,
                                                                 i.e. CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::TENG_R, FORTYG_R,
                                                                 TWENTYFIVEG_R, FIFTYG_R, HUNDREDG_R, USXGMII.  Reads 0 otherwise. */
        uint64_t fec_abil              : 1;  /**< [  0:  0](RO/H) BASE-R FEC ability. Always 1 when the LPCS type is BASE-R,
                                                                 i.e. CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::TENG_R, FORTYG_R,
                                                                 TWENTYFIVEG_R, FIFTYG_R, HUNDREDG_R, USXGMII.  Reads 0 otherwise. */
#else /* Word 0 - Little Endian */
        uint64_t fec_abil              : 1;  /**< [  0:  0](RO/H) BASE-R FEC ability. Always 1 when the LPCS type is BASE-R,
                                                                 i.e. CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::TENG_R, FORTYG_R,
                                                                 TWENTYFIVEG_R, FIFTYG_R, HUNDREDG_R, USXGMII.  Reads 0 otherwise. */
        uint64_t err_abil              : 1;  /**< [  1:  1](RO/H) BASE-R FEC error-indication ability. Always 1 when the LPCS type is BASE-R,
                                                                 i.e. CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::TENG_R, FORTYG_R,
                                                                 TWENTYFIVEG_R, FIFTYG_R, HUNDREDG_R, USXGMII.  Reads 0 otherwise. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_fec_abil_s cn; */
};
typedef union bdk_cgxx_spux_fec_abil bdk_cgxx_spux_fec_abil_t;

static inline uint64_t BDK_CGXX_SPUX_FEC_ABIL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_FEC_ABIL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100d8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_FEC_ABIL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_FEC_ABIL(a,b) bdk_cgxx_spux_fec_abil_t
#define bustype_BDK_CGXX_SPUX_FEC_ABIL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_FEC_ABIL(a,b) "CGXX_SPUX_FEC_ABIL"
#define device_bar_BDK_CGXX_SPUX_FEC_ABIL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_FEC_ABIL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_FEC_ABIL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_fec_control
 *
 * CGX SPU Forward Error Correction Control Registers
 */
union bdk_cgxx_spux_fec_control
{
    uint64_t u;
    struct bdk_cgxx_spux_fec_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t fec_byp_cor_en        : 1;  /**< [  4:  4](R/W) When this variable is set to one, the Reed-Solomon decoder performs error detection
                                                                 without error correction. When this variable is set to zero, the decoder also performs
                                                                 error correction. For more details see IEEE 802.3 91.5.3.3 and 91.6.1. */
        uint64_t fec_byp_ind_en        : 1;  /**< [  3:  3](R/W) This variable is set to one to bypass the error indication function when this ability is
                                                                 supported. When this variable is set to zero, the decoder indicates errors to the PCS
                                                                 sublayer if RS-FEC is enabled ([FEC_EN]\<1\> is set) for applicable LMAC types. This variable
                                                                 has no effect (the decoder does not bypass error indication) if FEC bypass correction enable
                                                                 is set to one.

                                                                 When this bit is set, if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see IEEE 802.3 91.5.3.3)
                                                                 CGX()_SPU()_RSFEC_STATUS[HI_SER] is set and the Reed-Solomon decoder shall cause
                                                                 synchronization header rx_coded\<1:0\> of each subsequent 66-bit block that is delivered to
                                                                 the PCS to be assigned a value of 00 or 11 for a period of 60 ms to 75 ms.
                                                                 See also 802.3 91.5.3.3, 91.6.2, and 91.6.5. */
        uint64_t err_en                : 1;  /**< [  2:  2](R/W) BASE-R FEC error-indication enable. This bit corresponds to FEC_Enable_Error_to_PCS
                                                                 variable for BASE-R as defined in IEEE 802.3 Clause 74. When FEC is enabled ([FEC_EN]\<0\>
                                                                 is set) and this bit is set, the FEC decoder on the receive side signals an
                                                                 uncorrectable FEC error to the BASE-R decoder by driving a value of 0x3 on the sync bits
                                                                 for some of the 32 64/66 bit blocks belonging to the uncorrectable FEC block. See
                                                                 IEEE 802.3 section 74.7.4.5.1 for more details. */
        uint64_t fec_en                : 2;  /**< [  1:  0](R/W) FEC enable. Bit 0 enables BASE-R FEC. Bit 1 enables RS-FEC (Reed-Solomon FEC).
                                                                 Some LMAC types allow either mode to be selected whereas others allow only one.
                                                                 The two algorithms may not run concurrently. For modes where both are permitted,
                                                                 RS-FEC takes precedence over BASE-R FEC if both are selected.

                                                                 BASE-R FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 forward error correction is enabled. BASE-R FEC is disabled otherwise. BASE-R
                                                                 forward error correction is defined in IEEE 802.3 Clause 74.

                                                                 RS-FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 Reed-Solomon forward error correction is enabled. RS-FEC is disabled otherwise. RS
                                                                 forward error correction is defined in IEEE 802.3 Clause 91 and further
                                                                 specified for 25GBASE-R in 802.3by Clause 108.

                                                                 The following table specifies the behavior for each BASE-R LMAC type for all [FEC_EN]
                                                                 values.

                                                                 \<pre\>
                                                                   Value     LMAC_TYPE         Comment
                                                                   -------   ---------------   ------------
                                                                   0x0       All BASE-R        No FEC
                                                                   0x1       25G_R, 50G_R,     BASE-R FEC enabled
                                                                   0x2       25G_R, 50G_R,     RS-FEC enabled
                                                                   0x3       25G_R, 50G_R,     UNDEFINED
                                                                   0x2,0x3   100G_R, USXGMII   RS-FEC enabled
                                                                   0x2       10G_R, 40G_R      No FEC. 10G_R, 40G_R may only use BASE-R FEC
                                                                   0x1,0x3   10G_R, 40G_R      BASE-R FEC
                                                                   0x1       100G_R            No FEC. 100G_R  may only use RS-FEC
                                                                 \</pre\> */
#else /* Word 0 - Little Endian */
        uint64_t fec_en                : 2;  /**< [  1:  0](R/W) FEC enable. Bit 0 enables BASE-R FEC. Bit 1 enables RS-FEC (Reed-Solomon FEC).
                                                                 Some LMAC types allow either mode to be selected whereas others allow only one.
                                                                 The two algorithms may not run concurrently. For modes where both are permitted,
                                                                 RS-FEC takes precedence over BASE-R FEC if both are selected.

                                                                 BASE-R FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 forward error correction is enabled. BASE-R FEC is disabled otherwise. BASE-R
                                                                 forward error correction is defined in IEEE 802.3 Clause 74.

                                                                 RS-FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 Reed-Solomon forward error correction is enabled. RS-FEC is disabled otherwise. RS
                                                                 forward error correction is defined in IEEE 802.3 Clause 91 and further
                                                                 specified for 25GBASE-R in 802.3by Clause 108.

                                                                 The following table specifies the behavior for each BASE-R LMAC type for all [FEC_EN]
                                                                 values.

                                                                 \<pre\>
                                                                   Value     LMAC_TYPE         Comment
                                                                   -------   ---------------   ------------
                                                                   0x0       All BASE-R        No FEC
                                                                   0x1       25G_R, 50G_R,     BASE-R FEC enabled
                                                                   0x2       25G_R, 50G_R,     RS-FEC enabled
                                                                   0x3       25G_R, 50G_R,     UNDEFINED
                                                                   0x2,0x3   100G_R, USXGMII   RS-FEC enabled
                                                                   0x2       10G_R, 40G_R      No FEC. 10G_R, 40G_R may only use BASE-R FEC
                                                                   0x1,0x3   10G_R, 40G_R      BASE-R FEC
                                                                   0x1       100G_R            No FEC. 100G_R  may only use RS-FEC
                                                                 \</pre\> */
        uint64_t err_en                : 1;  /**< [  2:  2](R/W) BASE-R FEC error-indication enable. This bit corresponds to FEC_Enable_Error_to_PCS
                                                                 variable for BASE-R as defined in IEEE 802.3 Clause 74. When FEC is enabled ([FEC_EN]\<0\>
                                                                 is set) and this bit is set, the FEC decoder on the receive side signals an
                                                                 uncorrectable FEC error to the BASE-R decoder by driving a value of 0x3 on the sync bits
                                                                 for some of the 32 64/66 bit blocks belonging to the uncorrectable FEC block. See
                                                                 IEEE 802.3 section 74.7.4.5.1 for more details. */
        uint64_t fec_byp_ind_en        : 1;  /**< [  3:  3](R/W) This variable is set to one to bypass the error indication function when this ability is
                                                                 supported. When this variable is set to zero, the decoder indicates errors to the PCS
                                                                 sublayer if RS-FEC is enabled ([FEC_EN]\<1\> is set) for applicable LMAC types. This variable
                                                                 has no effect (the decoder does not bypass error indication) if FEC bypass correction enable
                                                                 is set to one.

                                                                 When this bit is set, if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see IEEE 802.3 91.5.3.3)
                                                                 CGX()_SPU()_RSFEC_STATUS[HI_SER] is set and the Reed-Solomon decoder shall cause
                                                                 synchronization header rx_coded\<1:0\> of each subsequent 66-bit block that is delivered to
                                                                 the PCS to be assigned a value of 00 or 11 for a period of 60 ms to 75 ms.
                                                                 See also 802.3 91.5.3.3, 91.6.2, and 91.6.5. */
        uint64_t fec_byp_cor_en        : 1;  /**< [  4:  4](R/W) When this variable is set to one, the Reed-Solomon decoder performs error detection
                                                                 without error correction. When this variable is set to zero, the decoder also performs
                                                                 error correction. For more details see IEEE 802.3 91.5.3.3 and 91.6.1. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_fec_control_s cn9; */
    /* struct bdk_cgxx_spux_fec_control_s cn96xxp1; */
    struct bdk_cgxx_spux_fec_control_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t fec_byp_cor_en        : 1;  /**< [  4:  4](R/W) When this variable is set to one, the Reed-Solomon decoder performs error detection
                                                                 without error correction. When this variable is set to zero, the decoder also performs
                                                                 error correction. For more details see IEEE 802.3 91.5.3.3 and 91.6.1. */
        uint64_t fec_byp_ind_en        : 1;  /**< [  3:  3](R/W) This variable is set to one to bypass the error indication function when this ability is
                                                                 supported. When this variable is set to zero, the decoder indicates errors to the PCS
                                                                 sublayer if RS-FEC is enabled ([FEC_EN]\<1\> is set) for applicable LMAC types. This variable
                                                                 has no effect (the decoder does not bypass error indication) if FEC bypass correction enable
                                                                 is set to one.

                                                                 When this bit is set, if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see IEEE 802.3 91.5.3.3)
                                                                 CGX()_SPU()_RSFEC_STATUS[HI_SER] is set and the Reed-Solomon decoder shall cause
                                                                 synchronization header rx_coded\<1:0\> of each subsequent 66-bit block that is delivered to
                                                                 the PCS to be assigned a value of 00 or 11 for a period of 60 ms to 75 ms.
                                                                 See also 802.3 91.5.3.3, 91.6.2, and 91.6.5. */
        uint64_t err_en                : 1;  /**< [  2:  2](R/W) BASE-R FEC error-indication enable. This bit corresponds to FEC_Enable_Error_to_PCS
                                                                 variable for BASE-R as defined in IEEE 802.3 Clause 74. When FEC is enabled ([FEC_EN]\<0\>
                                                                 is set) and this bit is set, the FEC decoder on the receive side signals an
                                                                 uncorrectable FEC error to the BASE-R decoder by driving a value of 0x3 on the sync bits
                                                                 for some of the 32 64/66 bit blocks belonging to the uncorrectable FEC block. See
                                                                 IEEE 802.3 section 74.7.4.5.1 for more details. */
        uint64_t fec_en                : 2;  /**< [  1:  0](R/W) FEC enable. Bit 0 enables BASE-R FEC. Bit 1 enables RS-FEC (Reed-Solomon FEC).
                                                                 Some LMAC types allow either mode to be selected whereas others allow only one.
                                                                 The two algorithms may not run concurrently. For modes where both are permitted,
                                                                 RS-FEC takes precedence over BASE-R FEC if both are selected.

                                                                 BASE-R FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 forward error correction is enabled. BASE-R FEC is disabled otherwise. BASE-R
                                                                 forward error correction is defined in IEEE 802.3 Clause 74.

                                                                 RS-FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 Reed-Solomon forward error correction is enabled. RS-FEC is disabled otherwise. RS
                                                                 forward error correction is defined in IEEE 802.3 Clause 91 and further
                                                                 specified for 25GBASE-R in 802.3by Clause 108.

                                                                 The following table specifies the behavior for each BASE-R LMAC type for all [FEC_EN]
                                                                 values.

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE        Comment
                                                                   -------  ---------------  -----------------------
                                                                   0x0      All BASE-R       No FEC
                                                                   0x1      25G_R, 50G_R,    BASE-R FEC enabled
                                                                   0x2      25G_R, 50G_R,    RS-FEC enabled
                                                                   0x3      25G_R, 50G_R,    UNDEFINED
                                                                   0x2,0x3  100G_R, USXGMII  RS-FEC enabled
                                                                   0x2      10G_R, 40G_R     No FEC. 10G_R, 40G_R
                                                                                             may only use BASE-R FEC
                                                                   0x1,0x3  10G_R, 40G_R     BASE-R FEC
                                                                   0x1      100G_R           No FEC. 100G_R
                                                                                             may only use RS-FEC
                                                                 \</pre\> */
#else /* Word 0 - Little Endian */
        uint64_t fec_en                : 2;  /**< [  1:  0](R/W) FEC enable. Bit 0 enables BASE-R FEC. Bit 1 enables RS-FEC (Reed-Solomon FEC).
                                                                 Some LMAC types allow either mode to be selected whereas others allow only one.
                                                                 The two algorithms may not run concurrently. For modes where both are permitted,
                                                                 RS-FEC takes precedence over BASE-R FEC if both are selected.

                                                                 BASE-R FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 forward error correction is enabled. BASE-R FEC is disabled otherwise. BASE-R
                                                                 forward error correction is defined in IEEE 802.3 Clause 74.

                                                                 RS-FEC enable. When this bit is set and the LPCS type is BASE-R
                                                                 Reed-Solomon forward error correction is enabled. RS-FEC is disabled otherwise. RS
                                                                 forward error correction is defined in IEEE 802.3 Clause 91 and further
                                                                 specified for 25GBASE-R in 802.3by Clause 108.

                                                                 The following table specifies the behavior for each BASE-R LMAC type for all [FEC_EN]
                                                                 values.

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE        Comment
                                                                   -------  ---------------  -----------------------
                                                                   0x0      All BASE-R       No FEC
                                                                   0x1      25G_R, 50G_R,    BASE-R FEC enabled
                                                                   0x2      25G_R, 50G_R,    RS-FEC enabled
                                                                   0x3      25G_R, 50G_R,    UNDEFINED
                                                                   0x2,0x3  100G_R, USXGMII  RS-FEC enabled
                                                                   0x2      10G_R, 40G_R     No FEC. 10G_R, 40G_R
                                                                                             may only use BASE-R FEC
                                                                   0x1,0x3  10G_R, 40G_R     BASE-R FEC
                                                                   0x1      100G_R           No FEC. 100G_R
                                                                                             may only use RS-FEC
                                                                 \</pre\> */
        uint64_t err_en                : 1;  /**< [  2:  2](R/W) BASE-R FEC error-indication enable. This bit corresponds to FEC_Enable_Error_to_PCS
                                                                 variable for BASE-R as defined in IEEE 802.3 Clause 74. When FEC is enabled ([FEC_EN]\<0\>
                                                                 is set) and this bit is set, the FEC decoder on the receive side signals an
                                                                 uncorrectable FEC error to the BASE-R decoder by driving a value of 0x3 on the sync bits
                                                                 for some of the 32 64/66 bit blocks belonging to the uncorrectable FEC block. See
                                                                 IEEE 802.3 section 74.7.4.5.1 for more details. */
        uint64_t fec_byp_ind_en        : 1;  /**< [  3:  3](R/W) This variable is set to one to bypass the error indication function when this ability is
                                                                 supported. When this variable is set to zero, the decoder indicates errors to the PCS
                                                                 sublayer if RS-FEC is enabled ([FEC_EN]\<1\> is set) for applicable LMAC types. This variable
                                                                 has no effect (the decoder does not bypass error indication) if FEC bypass correction enable
                                                                 is set to one.

                                                                 When this bit is set, if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see IEEE 802.3 91.5.3.3)
                                                                 CGX()_SPU()_RSFEC_STATUS[HI_SER] is set and the Reed-Solomon decoder shall cause
                                                                 synchronization header rx_coded\<1:0\> of each subsequent 66-bit block that is delivered to
                                                                 the PCS to be assigned a value of 00 or 11 for a period of 60 ms to 75 ms.
                                                                 See also 802.3 91.5.3.3, 91.6.2, and 91.6.5. */
        uint64_t fec_byp_cor_en        : 1;  /**< [  4:  4](R/W) When this variable is set to one, the Reed-Solomon decoder performs error detection
                                                                 without error correction. When this variable is set to zero, the decoder also performs
                                                                 error correction. For more details see IEEE 802.3 91.5.3.3 and 91.6.1. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_cgxx_spux_fec_control_cn96xxp3 cn98xx; */
    /* struct bdk_cgxx_spux_fec_control_cn96xxp3 cnf95xx; */
    /* struct bdk_cgxx_spux_fec_control_cn96xxp3 loki; */
};
typedef union bdk_cgxx_spux_fec_control bdk_cgxx_spux_fec_control_t;

static inline uint64_t BDK_CGXX_SPUX_FEC_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_FEC_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00100e0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00100e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00100e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_FEC_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_FEC_CONTROL(a,b) bdk_cgxx_spux_fec_control_t
#define bustype_BDK_CGXX_SPUX_FEC_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_FEC_CONTROL(a,b) "CGXX_SPUX_FEC_CONTROL"
#define device_bar_BDK_CGXX_SPUX_FEC_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_FEC_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_FEC_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_fec_ln#_rsfec_err
 *
 * CGX SPU Reed-Solomon FEC Symbol Error Counter for FEC Lanes 0-3 Registers
 * This register is valid only when Reed-Solomon FEC is enabled.
 * The symbol error counters are defined in 802.3 section 91.6.11 (for 100G
 * and extended to 50G) and 802.3by-2016 section 108.6.9 (for 25G and extended to USXGMII).
 * The counter is reset to all zeros when the register is read, and held at all ones in case
 * of overflow.
 *
 * The reset operation takes precedence over the increment operation; if the register
 * is read on the same clock cycle as an increment operation, the counter is reset to
 * all zeros and the increment operation is lost. The counters are writable for test
 * purposes, rather than read-only as specified in IEEE 802.3.
 */
union bdk_cgxx_spux_fec_lnx_rsfec_err
{
    uint64_t u;
    struct bdk_cgxx_spux_fec_lnx_rsfec_err_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t symb_err_cnt          : 32; /**< [ 31:  0](R/W/H) The counter counts once for each 10-bit symbol corrected on FEC lane i when fec_align_status
                                                                 is true. */
#else /* Word 0 - Little Endian */
        uint64_t symb_err_cnt          : 32; /**< [ 31:  0](R/W/H) The counter counts once for each 10-bit symbol corrected on FEC lane i when fec_align_status
                                                                 is true. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_fec_lnx_rsfec_err_s cn; */
};
typedef union bdk_cgxx_spux_fec_lnx_rsfec_err bdk_cgxx_spux_fec_lnx_rsfec_err_t;

static inline uint64_t BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=3)))
        return 0x87e0e0010900ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=3)))
        return 0x87e0e0010900ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=3)))
        return 0x87e0e0010900ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=3)))
        return 0x87e0e0010900ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_FEC_LNX_RSFEC_ERR", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(a,b,c) bdk_cgxx_spux_fec_lnx_rsfec_err_t
#define bustype_BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(a,b,c) "CGXX_SPUX_FEC_LNX_RSFEC_ERR"
#define device_bar_BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(a,b,c) (a)
#define arguments_BDK_CGXX_SPUX_FEC_LNX_RSFEC_ERR(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_spu#_int
 *
 * CGX SPU Interrupt Registers
 */
union bdk_cgxx_spux_int
{
    uint64_t u;
    struct bdk_cgxx_spux_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) USXGMII autonegotiation complete. Set when CGX()_SPU()_USX_AN_STATUS[AN_CPT] is set,
                                                                 indicating that the autonegotiation process has been completed. This indicates the
                                                                 AN SM is in IDLE_DETECT of Figure 7-6 in 802.3. In order to start link_timer and
                                                                 progress to LINK_OK, software needs to set CGX()_SPU()_AN_CONTROL[USX_AN_ARB_LINK_CHK_EN] */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Autonegotiation link good. Set when CGX()_SPU()_USX_AN_STATUS[LNK_ST] is set,
                                                                 indicating that autonegotiation has completed. This indicates the AN SM reached
                                                                 LINK_OK of Figure 7-6 in 802.3. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) High symbol errror rate.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 See description of CGX()_SPU()_RSFEC_STATUS[HI_SER] for more details. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Uncorrectable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors (when the bypass correction feature is supported
                                                                 and enabled) or contains errors that were not corrected (when the bypass
                                                                 correction feature is not supported or not enabled). */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Correctable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors and was corrected. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED. See also
                                                                 CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) BASE-R PMD training failure. Set when BASE-R PMD link training has failed on the 10G
                                                                 or 25GBASE-R lane or any 40G, 50G, 100GBASE-R lane. Valid if the LPCS type selected
                                                                 by CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) BASE-R PMD training done. Set when the 10G or 25GBASE-R lane or all 40G, 50G,
                                                                 100GBASE-R lanes have successfully completed BASE-R PMD link training. Valid
                                                                 if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Autonegotiation complete. Set when CGX()_SPU()_AN_STATUS[AN_COMPLETE] is set,
                                                                 indicating that the autonegotiation process has been completed and the link is up and
                                                                 running using the negotiated highest common denominator (HCD) technology. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Autonegotiation link good. Set when the an_link_good variable is set as defined in
                                                                 802.3 Figure 73-11, indicating that autonegotiation has completed. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Autonegotiation page received. This bit is set along with
                                                                 CGX()_SPU()_AN_STATUS[PAGE_RX] when a new page has been received and stored in
                                                                 CGX()_SPU()_AN_LP_BASE or CGX()_SPU()_AN_LP_XNP. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Uncorrectable FEC error. Set when an FEC block with an uncorrectable error is received on
                                                                 the 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Correctable FEC error. Set when an FEC block with a correctable error is received on the
                                                                 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Bit interleaved parity error. Set when a BIP error is detected on any lane.
                                                                 Valid if the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE] is 40G, 50G or 100GBASE-R. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Sync failure debug. This interrupt is provided for link problem debugging help. It is set
                                                                 as follows based on the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE], and
                                                                 whether FEC is enabled or disabled by CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions from
                                                                 SYNC_ACQUIRED_1 to SYNC_ACQUIRED_2 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: Set when sh_invalid_cnt
                                                                 increments to 1 while block_lock is 1 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R with BASE-R FEC enabled: Set when parity_invalid_cnt increments to 1
                                                                 while fec_block_lock is 1 (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Loss of lane alignment. Set when lane-to-lane alignment is lost. This is only valid if the
                                                                 logical PCS is a multilane type (i.e. XAUI, RXAUI, 40G, 50G or 100GBASE-R is selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]), and is never set otherwise. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Loss of lane sync. Lane code-group or block synchronization is lost on one or more lanes
                                                                 associated with the LMAC/LPCS. Set as follows based on the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE], and whether FEC is enabled or disabled by
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions to LOSS_OF_SYNC
                                                                 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: set when the block_lock
                                                                 variable is cleared on the 10G, 25G or USXGMII lane or any 40G, 50G or 100G lane
                                                                 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R  with BASE-R FEC enabled: set when the fec_block_lock variable is
                                                                 cleared on the 10G or 25G lane or any 40G or 50G lane (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Bit lock lost on one or more serdes lanes associated with the LMAC/LPCS. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Errored block received. Set when an errored BASE-R block is received as described for
                                                                 CGX()_SPU()_BR_STATUS2[ERR_BLKS]. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII, and never
                                                                 set otherwise. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Set when the receive link goes down, which is the same condition that sets
                                                                 CGX()_SPU()_STATUS2[RCVFLT]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Set when the receive link comes up, which is the same condition that allows the setting of
                                                                 CGX()_SPU()_STATUS1[RCV_LNK]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Set when the receive link comes up, which is the same condition that allows the setting of
                                                                 CGX()_SPU()_STATUS1[RCV_LNK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Set when the receive link goes down, which is the same condition that sets
                                                                 CGX()_SPU()_STATUS2[RCVFLT]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Errored block received. Set when an errored BASE-R block is received as described for
                                                                 CGX()_SPU()_BR_STATUS2[ERR_BLKS]. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII, and never
                                                                 set otherwise. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Bit lock lost on one or more serdes lanes associated with the LMAC/LPCS. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Loss of lane sync. Lane code-group or block synchronization is lost on one or more lanes
                                                                 associated with the LMAC/LPCS. Set as follows based on the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE], and whether FEC is enabled or disabled by
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions to LOSS_OF_SYNC
                                                                 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: set when the block_lock
                                                                 variable is cleared on the 10G, 25G or USXGMII lane or any 40G, 50G or 100G lane
                                                                 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R  with BASE-R FEC enabled: set when the fec_block_lock variable is
                                                                 cleared on the 10G or 25G lane or any 40G or 50G lane (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Loss of lane alignment. Set when lane-to-lane alignment is lost. This is only valid if the
                                                                 logical PCS is a multilane type (i.e. XAUI, RXAUI, 40G, 50G or 100GBASE-R is selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]), and is never set otherwise. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Sync failure debug. This interrupt is provided for link problem debugging help. It is set
                                                                 as follows based on the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE], and
                                                                 whether FEC is enabled or disabled by CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions from
                                                                 SYNC_ACQUIRED_1 to SYNC_ACQUIRED_2 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: Set when sh_invalid_cnt
                                                                 increments to 1 while block_lock is 1 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R with BASE-R FEC enabled: Set when parity_invalid_cnt increments to 1
                                                                 while fec_block_lock is 1 (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Bit interleaved parity error. Set when a BIP error is detected on any lane.
                                                                 Valid if the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE] is 40G, 50G or 100GBASE-R. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Correctable FEC error. Set when an FEC block with a correctable error is received on the
                                                                 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Uncorrectable FEC error. Set when an FEC block with an uncorrectable error is received on
                                                                 the 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Autonegotiation page received. This bit is set along with
                                                                 CGX()_SPU()_AN_STATUS[PAGE_RX] when a new page has been received and stored in
                                                                 CGX()_SPU()_AN_LP_BASE or CGX()_SPU()_AN_LP_XNP. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Autonegotiation link good. Set when the an_link_good variable is set as defined in
                                                                 802.3 Figure 73-11, indicating that autonegotiation has completed. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Autonegotiation complete. Set when CGX()_SPU()_AN_STATUS[AN_COMPLETE] is set,
                                                                 indicating that the autonegotiation process has been completed and the link is up and
                                                                 running using the negotiated highest common denominator (HCD) technology. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) BASE-R PMD training done. Set when the 10G or 25GBASE-R lane or all 40G, 50G,
                                                                 100GBASE-R lanes have successfully completed BASE-R PMD link training. Valid
                                                                 if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) BASE-R PMD training failure. Set when BASE-R PMD link training has failed on the 10G
                                                                 or 25GBASE-R lane or any 40G, 50G, 100GBASE-R lane. Valid if the LPCS type selected
                                                                 by CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED. See also
                                                                 CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Correctable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors and was corrected. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Uncorrectable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors (when the bypass correction feature is supported
                                                                 and enabled) or contains errors that were not corrected (when the bypass
                                                                 correction feature is not supported or not enabled). */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) High symbol errror rate.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 See description of CGX()_SPU()_RSFEC_STATUS[HI_SER] for more details. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Autonegotiation link good. Set when CGX()_SPU()_USX_AN_STATUS[LNK_ST] is set,
                                                                 indicating that autonegotiation has completed. This indicates the AN SM reached
                                                                 LINK_OK of Figure 7-6 in 802.3. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) USXGMII autonegotiation complete. Set when CGX()_SPU()_USX_AN_STATUS[AN_CPT] is set,
                                                                 indicating that the autonegotiation process has been completed. This indicates the
                                                                 AN SM is in IDLE_DETECT of Figure 7-6 in 802.3. In order to start link_timer and
                                                                 progress to LINK_OK, software needs to set CGX()_SPU()_AN_CONTROL[USX_AN_ARB_LINK_CHK_EN] */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_int_s cn9; */
    /* struct bdk_cgxx_spux_int_s cn96xxp1; */
    struct bdk_cgxx_spux_int_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) USXGMII autonegotiation complete. Set when CGX()_SPU()_USX_AN_STATUS[AN_CPT] is set,
                                                                 indicating that the autonegotiation process has been completed. This indicates the
                                                                 AN SM is in IDLE_DETECT of Figure 7-6 in 802.3. In order to start link_timer and
                                                                 progress to LINK_OK, software needs to set CGX()_SPU()_AN_CONTROL[USX_AN_ARB_LINK_CHK_EN] */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Autonegotiation link good. Set when CGX()_SPU()_USX_AN_STATUS[LNK_ST] is set,
                                                                 indicating that autonegotiation has completed. This indicates the AN SM reached
                                                                 LINK_OK of Figure 7-6 in 802.3. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) High symbol error rate.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 See description of CGX()_SPU()_RSFEC_STATUS[HI_SER] for more details. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Uncorrectable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors (when the bypass correction feature is supported
                                                                 and enabled) or contains errors that were not corrected (when the bypass
                                                                 correction feature is not supported or not enabled). */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Correctable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors and was corrected. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED. See also
                                                                 CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) BASE-R PMD training failure. Set when BASE-R PMD link training has failed on the 10G
                                                                 or 25GBASE-R lane or any 40G, 50G, 100GBASE-R lane. Valid if the LPCS type selected
                                                                 by CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) BASE-R PMD training done. Set when the 10G or 25GBASE-R lane or all 40G, 50G,
                                                                 100GBASE-R lanes have successfully completed BASE-R PMD link training. Valid
                                                                 if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Autonegotiation complete. Set when CGX()_SPU()_AN_STATUS[AN_COMPLETE] is set,
                                                                 indicating that the autonegotiation process has been completed and the link is up and
                                                                 running using the negotiated highest common denominator (HCD) technology. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Autonegotiation link good. Set when the an_link_good variable is set as defined in
                                                                 802.3 Figure 73-11, indicating that autonegotiation has completed. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Autonegotiation page received. This bit is set along with
                                                                 CGX()_SPU()_AN_STATUS[PAGE_RX] when a new page has been received and stored in
                                                                 CGX()_SPU()_AN_LP_BASE or CGX()_SPU()_AN_LP_XNP. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Uncorrectable FEC error. Set when an FEC block with an uncorrectable error is received on
                                                                 the 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Correctable FEC error. Set when an FEC block with a correctable error is received on the
                                                                 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Bit interleaved parity error. Set when a BIP error is detected on any lane.
                                                                 Valid if the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE] is 40G, 50G or 100GBASE-R. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Sync failure debug. This interrupt is provided for link problem debugging help. It is set
                                                                 as follows based on the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE], and
                                                                 whether FEC is enabled or disabled by CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions from
                                                                 SYNC_ACQUIRED_1 to SYNC_ACQUIRED_2 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: Set when sh_invalid_cnt
                                                                 increments to 1 while block_lock is 1 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R with BASE-R FEC enabled: Set when parity_invalid_cnt increments to 1
                                                                 while fec_block_lock is 1 (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Loss of lane alignment. Set when lane-to-lane alignment is lost. This is only valid if the
                                                                 logical PCS is a multilane type (i.e. XAUI, RXAUI, 40G, 50G or 100GBASE-R is selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]), and is never set otherwise. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Loss of lane sync. Lane code-group or block synchronization is lost on one or more lanes
                                                                 associated with the LMAC/LPCS. Set as follows based on the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE], and whether FEC is enabled or disabled by
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions to LOSS_OF_SYNC
                                                                 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: set when the block_lock
                                                                 variable is cleared on the 10G, 25G or USXGMII lane or any 40G, 50G or 100G lane
                                                                 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R  with BASE-R FEC enabled: set when the fec_block_lock variable is
                                                                 cleared on the 10G or 25G lane or any 40G or 50G lane (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Bit lock lost on one or more SerDes lanes associated with the LMAC/LPCS. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Errored block received. Set when an errored BASE-R block is received as described for
                                                                 CGX()_SPU()_BR_STATUS2[ERR_BLKS]. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII, and never
                                                                 set otherwise. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Set when the receive link goes down, which is the same condition that sets
                                                                 CGX()_SPU()_STATUS2[RCVFLT]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Set when the receive link comes up, which is the same condition that allows the setting of
                                                                 CGX()_SPU()_STATUS1[RCV_LNK]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Set when the receive link comes up, which is the same condition that allows the setting of
                                                                 CGX()_SPU()_STATUS1[RCV_LNK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Set when the receive link goes down, which is the same condition that sets
                                                                 CGX()_SPU()_STATUS2[RCVFLT]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Errored block received. Set when an errored BASE-R block is received as described for
                                                                 CGX()_SPU()_BR_STATUS2[ERR_BLKS]. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII, and never
                                                                 set otherwise. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Bit lock lost on one or more SerDes lanes associated with the LMAC/LPCS. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Loss of lane sync. Lane code-group or block synchronization is lost on one or more lanes
                                                                 associated with the LMAC/LPCS. Set as follows based on the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE], and whether FEC is enabled or disabled by
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions to LOSS_OF_SYNC
                                                                 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: set when the block_lock
                                                                 variable is cleared on the 10G, 25G or USXGMII lane or any 40G, 50G or 100G lane
                                                                 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R  with BASE-R FEC enabled: set when the fec_block_lock variable is
                                                                 cleared on the 10G or 25G lane or any 40G or 50G lane (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Loss of lane alignment. Set when lane-to-lane alignment is lost. This is only valid if the
                                                                 logical PCS is a multilane type (i.e. XAUI, RXAUI, 40G, 50G or 100GBASE-R is selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE]), and is never set otherwise. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Sync failure debug. This interrupt is provided for link problem debugging help. It is set
                                                                 as follows based on the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE], and
                                                                 whether FEC is enabled or disabled by CGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                                 * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions from
                                                                 SYNC_ACQUIRED_1 to SYNC_ACQUIRED_2 (see 802.3-2008 Figure 48-7).
                                                                 * 10G, 25G, 40G, 50G, 100GBASE-R, USXGMII with FEC disabled: Set when sh_invalid_cnt
                                                                 increments to 1 while block_lock is 1 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                                 * 10G, 25G, 40G, 50GBASE-R with BASE-R FEC enabled: Set when parity_invalid_cnt increments to 1
                                                                 while fec_block_lock is 1 (see 802.3-2008 Figure 74-8).
                                                                 * 25G, 50G, 100GBASE-R, USXGMII with RS-FEC: Set when 3 consecutive uncorrected codewords
                                                                 are received and lock restarts (see 802.3bj-2014 Figure 91-9, 802.3by-2016 Figure 108-7). */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Bit interleaved parity error. Set when a BIP error is detected on any lane.
                                                                 Valid if the LPCS type selected by CGX()_CMR()_CONFIG[LMAC_TYPE] is 40G, 50G or 100GBASE-R. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Correctable FEC error. Set when an FEC block with a correctable error is received on the
                                                                 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Uncorrectable FEC error. Set when an FEC block with an uncorrectable error is received on
                                                                 the 10G or 25GBASE-R lane or any 40G or 50GBASE-R lane. Valid if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G or 50GBASE-R and never set otherwise. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Autonegotiation page received. This bit is set along with
                                                                 CGX()_SPU()_AN_STATUS[PAGE_RX] when a new page has been received and stored in
                                                                 CGX()_SPU()_AN_LP_BASE or CGX()_SPU()_AN_LP_XNP. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Autonegotiation link good. Set when the an_link_good variable is set as defined in
                                                                 802.3 Figure 73-11, indicating that autonegotiation has completed. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Autonegotiation complete. Set when CGX()_SPU()_AN_STATUS[AN_COMPLETE] is set,
                                                                 indicating that the autonegotiation process has been completed and the link is up and
                                                                 running using the negotiated highest common denominator (HCD) technology. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) BASE-R PMD training done. Set when the 10G or 25GBASE-R lane or all 40G, 50G,
                                                                 100GBASE-R lanes have successfully completed BASE-R PMD link training. Valid
                                                                 if the LPCS type selected by
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) BASE-R PMD training failure. Set when BASE-R PMD link training has failed on the 10G
                                                                 or 25GBASE-R lane or any 40G, 50G, 100GBASE-R lane. Valid if the LPCS type selected
                                                                 by CGX()_CMR()_CONFIG[LMAC_TYPE] is 10G, 25G, 40G, 50G or 100GBASE-R and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED. See also
                                                                 CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Correctable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors and was corrected. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Uncorrectable RS-FEC error.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 Set when CGX()_SPU()_RSFEC_STATUS[FEC_ALIGN_STATUS] is true,
                                                                 for each code-word that contains errors (when the bypass correction feature is supported
                                                                 and enabled) or contains errors that were not corrected (when the bypass
                                                                 correction feature is not supported or not enabled). */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) High symbol error rate.
                                                                 Applicable only to modes implementing RS-FEC, USXGMII, 25G, 50G, 100G.
                                                                 See description of CGX()_SPU()_RSFEC_STATUS[HI_SER] for more details. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Autonegotiation link good. Set when CGX()_SPU()_USX_AN_STATUS[LNK_ST] is set,
                                                                 indicating that autonegotiation has completed. This indicates the AN SM reached
                                                                 LINK_OK of Figure 7-6 in 802.3. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) USXGMII autonegotiation complete. Set when CGX()_SPU()_USX_AN_STATUS[AN_CPT] is set,
                                                                 indicating that the autonegotiation process has been completed. This indicates the
                                                                 AN SM is in IDLE_DETECT of Figure 7-6 in 802.3. In order to start link_timer and
                                                                 progress to LINK_OK, software needs to set CGX()_SPU()_AN_CONTROL[USX_AN_ARB_LINK_CHK_EN] */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_cgxx_spux_int_cn96xxp3 cn98xx; */
    /* struct bdk_cgxx_spux_int_s cnf95xxp1; */
    /* struct bdk_cgxx_spux_int_cn96xxp3 cnf95xxp2; */
    /* struct bdk_cgxx_spux_int_cn96xxp3 loki; */
};
typedef union bdk_cgxx_spux_int bdk_cgxx_spux_int_t;

static inline uint64_t BDK_CGXX_SPUX_INT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_INT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010220ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010220ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_INT(a,b) bdk_cgxx_spux_int_t
#define bustype_BDK_CGXX_SPUX_INT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_INT(a,b) "CGXX_SPUX_INT"
#define device_bar_BDK_CGXX_SPUX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_INT(a,b) (a)
#define arguments_BDK_CGXX_SPUX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_int_ena_w1c
 *
 * CGX SPU Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union bdk_cgxx_spux_int_ena_w1c
{
    uint64_t u;
    struct bdk_cgxx_spux_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_int_ena_w1c_s cn9; */
    /* struct bdk_cgxx_spux_int_ena_w1c_s cn96xx; */
    struct bdk_cgxx_spux_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_spux_int_ena_w1c_s cnf95xx; */
    struct bdk_cgxx_spux_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_spux_int_ena_w1c bdk_cgxx_spux_int_ena_w1c_t;

static inline uint64_t BDK_CGXX_SPUX_INT_ENA_W1C(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_INT_ENA_W1C(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010230ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010230ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_INT_ENA_W1C(a,b) bdk_cgxx_spux_int_ena_w1c_t
#define bustype_BDK_CGXX_SPUX_INT_ENA_W1C(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_INT_ENA_W1C(a,b) "CGXX_SPUX_INT_ENA_W1C"
#define device_bar_BDK_CGXX_SPUX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_INT_ENA_W1C(a,b) (a)
#define arguments_BDK_CGXX_SPUX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_int_ena_w1s
 *
 * CGX SPU Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union bdk_cgxx_spux_int_ena_w1s
{
    uint64_t u;
    struct bdk_cgxx_spux_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..2)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_int_ena_w1s_s cn9; */
    /* struct bdk_cgxx_spux_int_ena_w1s_s cn96xx; */
    struct bdk_cgxx_spux_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..4)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_spux_int_ena_w1s_s cnf95xx; */
    struct bdk_cgxx_spux_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for CGX(0..3)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_spux_int_ena_w1s bdk_cgxx_spux_int_ena_w1s_t;

static inline uint64_t BDK_CGXX_SPUX_INT_ENA_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_INT_ENA_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010238ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010238ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010238ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010238ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_INT_ENA_W1S(a,b) bdk_cgxx_spux_int_ena_w1s_t
#define bustype_BDK_CGXX_SPUX_INT_ENA_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_INT_ENA_W1S(a,b) "CGXX_SPUX_INT_ENA_W1S"
#define device_bar_BDK_CGXX_SPUX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_INT_ENA_W1S(a,b) (a)
#define arguments_BDK_CGXX_SPUX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_int_w1s
 *
 * CGX SPU Interrupt Set Registers
 * This register sets interrupt bits.
 */
union bdk_cgxx_spux_int_w1s
{
    uint64_t u;
    struct bdk_cgxx_spux_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..2)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_int_w1s_s cn9; */
    /* struct bdk_cgxx_spux_int_w1s_s cn96xx; */
    struct bdk_cgxx_spux_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..4)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } cn98xx;
    /* struct bdk_cgxx_spux_int_w1s_s cnf95xx; */
    struct bdk_cgxx_spux_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[HI_SER]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RX_LINK_UP]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_link_up            : 1;  /**< [  0:  0](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RX_LINK_UP]. */
        uint64_t rx_link_down          : 1;  /**< [  1:  1](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RX_LINK_DOWN]. */
        uint64_t err_blk               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[ERR_BLK]. */
        uint64_t bitlckls              : 1;  /**< [  3:  3](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[BITLCKLS]. */
        uint64_t synlos                : 1;  /**< [  4:  4](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[SYNLOS]. */
        uint64_t algnlos               : 1;  /**< [  5:  5](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[ALGNLOS]. */
        uint64_t dbg_sync              : 1;  /**< [  6:  6](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[DBG_SYNC]. */
        uint64_t bip_err               : 1;  /**< [  7:  7](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[BIP_ERR]. */
        uint64_t fec_corr              : 1;  /**< [  8:  8](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[FEC_CORR]. */
        uint64_t fec_uncorr            : 1;  /**< [  9:  9](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[FEC_UNCORR]. */
        uint64_t an_page_rx            : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[AN_PAGE_RX]. */
        uint64_t an_link_good          : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[AN_LINK_GOOD]. */
        uint64_t an_complete           : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[AN_COMPLETE]. */
        uint64_t training_done         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[TRAINING_DONE]. */
        uint64_t training_failure      : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[TRAINING_FAILURE]. */
        uint64_t fec_align_status      : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[FEC_ALIGN_STATUS]. */
        uint64_t rsfec_corr            : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RSFEC_CORR]. */
        uint64_t rsfec_uncorr          : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[RSFEC_UNCORR]. */
        uint64_t hi_ser                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[HI_SER]. */
        uint64_t usx_an_lnk_st         : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[USX_AN_LNK_ST]. */
        uint64_t usx_an_cpt            : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets CGX(0..3)_SPU(0..3)_INT[USX_AN_CPT]. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_cgxx_spux_int_w1s bdk_cgxx_spux_int_w1s_t;

static inline uint64_t BDK_CGXX_SPUX_INT_W1S(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_INT_W1S(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010228ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010228ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010228ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010228ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_INT_W1S(a,b) bdk_cgxx_spux_int_w1s_t
#define bustype_BDK_CGXX_SPUX_INT_W1S(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_INT_W1S(a,b) "CGXX_SPUX_INT_W1S"
#define device_bar_BDK_CGXX_SPUX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_INT_W1S(a,b) (a)
#define arguments_BDK_CGXX_SPUX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_ln#_br_bip_err_cnt
 *
 * CGX SPU 40,50,100GBASE-R BIP Error-Counter Registers
 * This register implements the IEEE 802.3 BIP error-counter registers for PCS lanes
 * 0-19 (3.200-3.203). It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R,
 * 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always returns 0x0
 * for all other LPCS types. The counters are indexed by the RX PCS lane number based
 * on the alignment marker detected on each lane and captured in
 * CGX()_SPU()_BR_LANE_MAP(). Each counter counts the BIP errors for its PCS lane, and is
 * held at all ones in case of overflow. The counters are reset to all zeros when this
 * register is read by software.
 *
 * The reset operation takes precedence over the increment operation; if the register
 * is read on the same clock cycle as an increment operation, the counter is reset to
 * all zeros and the increment operation is lost. The counters are writable for test
 * purposes, rather than read-only as specified in IEEE 802.3.
 */
union bdk_cgxx_spux_lnx_br_bip_err_cnt
{
    uint64_t u;
    struct bdk_cgxx_spux_lnx_br_bip_err_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t bip_err_cnt           : 16; /**< [ 15:  0](R/W/H) BIP error counter for lane on which PCS lane N markers are received where N
                                                                 is the (0..19) offset used to access this register. */
#else /* Word 0 - Little Endian */
        uint64_t bip_err_cnt           : 16; /**< [ 15:  0](R/W/H) BIP error counter for lane on which PCS lane N markers are received where N
                                                                 is the (0..19) offset used to access this register. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_lnx_br_bip_err_cnt_s cn; */
};
typedef union bdk_cgxx_spux_lnx_br_bip_err_cnt bdk_cgxx_spux_lnx_br_bip_err_cnt_t;

static inline uint64_t BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010500ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=19)))
        return 0x87e0e0010500ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010500ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=19)))
        return 0x87e0e0010500ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    __bdk_csr_fatal("CGXX_SPUX_LNX_BR_BIP_ERR_CNT", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(a,b,c) bdk_cgxx_spux_lnx_br_bip_err_cnt_t
#define bustype_BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(a,b,c) "CGXX_SPUX_LNX_BR_BIP_ERR_CNT"
#define device_bar_BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(a,b,c) (a)
#define arguments_BDK_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_spu#_ln#_fec_corr_blks
 *
 * CGX SPU FEC Corrected-Blocks Counters 0-19 Registers
 * This register is valid only when the LPCS type is BASE-R
 * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies
 * to BASE-R FEC and Reed-Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC
 * corrected-block counters are defined in IEEE 802.3 section 74.8.4.1. Each
 * corrected-blocks counter increments by one for a corrected FEC block, i.e. an FEC
 * block that has been received with invalid parity on the associated PCS lane and has
 * been corrected by the FEC decoder. The counter is reset to all zeros when the register
 * is read, and held at all ones in case of overflow.
 *
 * The reset operation takes precedence over the increment operation; if the register
 * is read on the same clock cycle as an increment operation, the counter is reset to
 * all zeros and the increment operation is lost. The counters are writable for test
 * purposes, rather than read-only as specified in IEEE 802.3.
 */
union bdk_cgxx_spux_lnx_fec_corr_blks
{
    uint64_t u;
    struct bdk_cgxx_spux_lnx_fec_corr_blks_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ln_corr_blks          : 32; /**< [ 31:  0](R/W/H) PCS Lane 0-19 FEC corrected blocks for BASE-R FEC.
                                                                 FEC Lane 0-1 or 0-3 corrected blocks for RS FEC.
                                                                 * For 10GBASE-R, corresponds to the IEEE 802.3 FEC_corrected_blocks_counter variable
                                                                 (registers 1.172-1.173 from 45.2.1.91).
                                                                 * For 40,100GBASE-R, correspond to the IEEE 802.3 FEC_corrected_blocks_counter_0-19
                                                                 variable (registers 1.300-1.339 from 45.2.1.93). */
#else /* Word 0 - Little Endian */
        uint64_t ln_corr_blks          : 32; /**< [ 31:  0](R/W/H) PCS Lane 0-19 FEC corrected blocks for BASE-R FEC.
                                                                 FEC Lane 0-1 or 0-3 corrected blocks for RS FEC.
                                                                 * For 10GBASE-R, corresponds to the IEEE 802.3 FEC_corrected_blocks_counter variable
                                                                 (registers 1.172-1.173 from 45.2.1.91).
                                                                 * For 40,100GBASE-R, correspond to the IEEE 802.3 FEC_corrected_blocks_counter_0-19
                                                                 variable (registers 1.300-1.339 from 45.2.1.93). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_lnx_fec_corr_blks_s cn; */
};
typedef union bdk_cgxx_spux_lnx_fec_corr_blks bdk_cgxx_spux_lnx_fec_corr_blks_t;

static inline uint64_t BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010700ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=19)))
        return 0x87e0e0010700ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010700ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=19)))
        return 0x87e0e0010700ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    __bdk_csr_fatal("CGXX_SPUX_LNX_FEC_CORR_BLKS", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(a,b,c) bdk_cgxx_spux_lnx_fec_corr_blks_t
#define bustype_BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(a,b,c) "CGXX_SPUX_LNX_FEC_CORR_BLKS"
#define device_bar_BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(a,b,c) (a)
#define arguments_BDK_CGXX_SPUX_LNX_FEC_CORR_BLKS(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_spu#_ln#_fec_uncorr_blks
 *
 * CGX SPU FEC Uncorrected-Blocks Counters 0-19 Registers
 * This register is valid only when the LPCS type is BASE-R
 * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies
 * to BASE-R FEC and Reed-Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC
 * corrected-block counters are defined in IEEE 802.3 section 74.8.4.2. Each
 * uncorrected-blocks counter increments by one for an uncorrected FEC block, i.e. an FEC
 * block that has been received with invalid parity on the associated PCS lane and has
 * not been corrected by the FEC decoder. The counter is reset to all zeros when the
 * register is read, and held at all ones in case of overflow.
 *
 * The reset operation takes precedence over the increment operation; if the register
 * is read on the same clock cycle as an increment operation, the counter is reset to
 * all zeros and the increment operation is lost. The counters are writable for test
 * purposes, rather than read-only as specified in IEEE 802.3.
 */
union bdk_cgxx_spux_lnx_fec_uncorr_blks
{
    uint64_t u;
    struct bdk_cgxx_spux_lnx_fec_uncorr_blks_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ln_uncorr_blks        : 32; /**< [ 31:  0](R/W/H) PCS Lane 0-19 FEC uncorrected blocks.
                                                                 FEC Lane 0-1 or 0-3 uncorrected blocks for RS FEC.
                                                                 * For 10GBASE-R, corresponds to the IEEE 802.3 FEC_uncorrected_blocks_counter variable
                                                                 (registers 1.174-1.175 from 45.2.1.91).
                                                                 * For 40GBASE-R, correspond to the IEEE 802.3 FEC_uncorrected_blocks_counter_0-19 variable
                                                                 (registers 1.700-1.739 from 45.2.1.94).
                                                                 * For 50GBASE-R, there is no such variable up to the latest IEEE 802.3cd_D2p0 */
#else /* Word 0 - Little Endian */
        uint64_t ln_uncorr_blks        : 32; /**< [ 31:  0](R/W/H) PCS Lane 0-19 FEC uncorrected blocks.
                                                                 FEC Lane 0-1 or 0-3 uncorrected blocks for RS FEC.
                                                                 * For 10GBASE-R, corresponds to the IEEE 802.3 FEC_uncorrected_blocks_counter variable
                                                                 (registers 1.174-1.175 from 45.2.1.91).
                                                                 * For 40GBASE-R, correspond to the IEEE 802.3 FEC_uncorrected_blocks_counter_0-19 variable
                                                                 (registers 1.700-1.739 from 45.2.1.94).
                                                                 * For 50GBASE-R, there is no such variable up to the latest IEEE 802.3cd_D2p0 */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_lnx_fec_uncorr_blks_s cn; */
};
typedef union bdk_cgxx_spux_lnx_fec_uncorr_blks bdk_cgxx_spux_lnx_fec_uncorr_blks_t;

static inline uint64_t BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(unsigned long a, unsigned long b, unsigned long c)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3) && (c<=19)))
        return 0x87e0e0010800ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3) && (c<=19)))
        return 0x87e0e0010800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3) && (c<=19)))
        return 0x87e0e0010800ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    __bdk_csr_fatal("CGXX_SPUX_LNX_FEC_UNCORR_BLKS", 3, a, b, c, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(a,b,c) bdk_cgxx_spux_lnx_fec_uncorr_blks_t
#define bustype_BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(a,b,c) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(a,b,c) "CGXX_SPUX_LNX_FEC_UNCORR_BLKS"
#define device_bar_BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(a,b,c) (a)
#define arguments_BDK_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) cgx#_spu#_lpcs_states
 *
 * CGX SPU BASE-X Transmit/Receive States Registers
 */
union bdk_cgxx_spux_lpcs_states
{
    uint64_t u;
    struct bdk_cgxx_spux_lpcs_states_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t br_rx_sm              : 3;  /**< [ 30: 28](RO/H) BASE-R receive state machine state */
        uint64_t reserved_26_27        : 2;
        uint64_t bx_rx_sm              : 2;  /**< [ 25: 24](RO/H) BASE-X receive state machine state */
        uint64_t deskew_am_found       : 20; /**< [ 23:  4](RO/H) 40,50,100GBASE-R deskew state machine alignment marker found flag per logical PCS lane ID. */
        uint64_t reserved_3            : 1;
        uint64_t deskew_sm             : 3;  /**< [  2:  0](RO/H) BASE-X and 40GBASE-R deskew state machine state. */
#else /* Word 0 - Little Endian */
        uint64_t deskew_sm             : 3;  /**< [  2:  0](RO/H) BASE-X and 40GBASE-R deskew state machine state. */
        uint64_t reserved_3            : 1;
        uint64_t deskew_am_found       : 20; /**< [ 23:  4](RO/H) 40,50,100GBASE-R deskew state machine alignment marker found flag per logical PCS lane ID. */
        uint64_t bx_rx_sm              : 2;  /**< [ 25: 24](RO/H) BASE-X receive state machine state */
        uint64_t reserved_26_27        : 2;
        uint64_t br_rx_sm              : 3;  /**< [ 30: 28](RO/H) BASE-R receive state machine state */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_lpcs_states_s cn; */
};
typedef union bdk_cgxx_spux_lpcs_states bdk_cgxx_spux_lpcs_states_t;

static inline uint64_t BDK_CGXX_SPUX_LPCS_STATES(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_LPCS_STATES(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010208ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010208ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010208ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010208ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_LPCS_STATES", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_LPCS_STATES(a,b) bdk_cgxx_spux_lpcs_states_t
#define bustype_BDK_CGXX_SPUX_LPCS_STATES(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_LPCS_STATES(a,b) "CGXX_SPUX_LPCS_STATES"
#define device_bar_BDK_CGXX_SPUX_LPCS_STATES(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_LPCS_STATES(a,b) (a)
#define arguments_BDK_CGXX_SPUX_LPCS_STATES(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_misc_control
 *
 * CGX SPU Miscellaneous Control Registers
 * "* RX logical PCS lane polarity vector \<3:0\> = [XOR_RXPLRT]\<3:0\> ^ {4{[RXPLRT]}}.
 * * TX logical PCS lane polarity vector \<3:0\> = [XOR_TXPLRT]\<3:0\> ^ {4{[TXPLRT]}}.
 *
 * In short, keep [RXPLRT] and [TXPLRT] cleared, and use [XOR_RXPLRT] and [XOR_TXPLRT] fields to
 * define the polarity per logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and
 * only bits 1:0 of vector are used for RXAUI."
 */
union bdk_cgxx_spux_misc_control
{
    uint64_t u;
    struct bdk_cgxx_spux_misc_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t rx_edet_signal_ok     : 1;  /**< [ 13: 13](R/W) Use the SDS edet (energy detect) as the "signal_ok" referred to by all 802.3 state diagrams
                                                                 when this bit is set. When this bit is 0, signal_ok will go down (and bring down associated
                                                                 machines) if the corresponding SDS fails to send a valid beat in any 1024 clock window. */
        uint64_t rx_packet_dis         : 1;  /**< [ 12: 12](R/W) Receive packet disable. Software can set or clear this bit at any time to gracefully
                                                                 disable or re-enable packet reception by the LPCS. If this bit is set while a packet is
                                                                 being received, the packet is completed and all subsequent received packets are discarded
                                                                 by the LPCS. Similarly, if this bit is cleared while a received packet is being discarded,
                                                                 packet reception resumes after the current packet is fully discarded. When set for a
                                                                 BASE-R LMAC/LPCS type (selected by CGX()_CMR()_CONFIG[LMAC_TYPE]),
                                                                 received errors and faults will be ignored while receive packets are discarded; idles will
                                                                 be sent to the MAC layer (SMU) and the errored blocks counter
                                                                 (CGX()_SPU()_BR_STATUS2[ERR_BLKS]) will not increment. */
        uint64_t skip_after_term       : 1;  /**< [ 11: 11](R/W) Enable sending of idle skip after terminate. This bit is meaningful when the logical PCS
                                                                 type is XAUI or RXAUI (selected by CGX()_CMR()_CONFIG[LMAC_TYPE]), and has no
                                                                 effect otherwise. When set, the LMAC/LPCS transmits more idle skip columns for clock
                                                                 compensation. Typically set in HiGig/HiGig2 modes; clear otherwise. This field can be set
                                                                 to ensure sufficient density of XAUI idle skip (||R||) columns with a small transmit
                                                                 inter-frame gap (IFG) in order to allow the link partner's receiver to delete ||R||
                                                                 columns as needed for clock rate compensation. It is usually set when the LMAC's transmit
                                                                 IFG is set to eight bytes in HiGig/HiGig2 modes (i.e. CGX()_SMU()_TX_IFG[IFG1] +
                                                                 CGX()_SMU()_TX_IFG[IFG2] = 8), and should be cleared when the transmit IFG is
                                                                 greater than eight bytes. When this bit is set, the SPU will send an ||R|| column after a
                                                                 ||T0|| column (terminate in lane 0) if no ||R|| was sent in the previous IFG. This is a
                                                                 minor deviation from the functionality specified in 802.3-2008 Figure 48-6 (PCS transmit
                                                                 source state diagram), whereby the state will transition directly from SEND_DATA to
                                                                 SEND_RANDOM_R after ||T0|| if no ||R|| was transmitted in the previous IFG. Sending ||R||
                                                                 after ||T0|| only (and not ||T1||, |T2|| or ||T3||) ensures that the check_end function at
                                                                 the receiving end, as defined in 802.3 sub-clause 48.2.6.1.4, does not detect an
                                                                 error due to this functional change. When this bit is clear, the LMAC will fully conform
                                                                 to the functionality specified in Figure 48-6. */
        uint64_t intlv_rdisp           : 1;  /**< [ 10: 10](R/W) RXAUI interleaved running disparity. This bit is meaningful when the logical PCS type is
                                                                 RXAUI (CGX()_CMR()_CONFIG[LMAC_TYPE] = RXAUI), and has no effect otherwise. It
                                                                 selects which disparity calculation to use when combining or splitting the RXAUI lanes, as
                                                                 follows:

                                                                  0 = Common running disparity. Common running disparity is computed for even
                                                                 and odd code- groups of an RXAUI lane, i.e. interleave lanes before PCS layer as
                                                                 described in the Dune Networks/Broadcom RXAUI v2.1 specification. This obeys
                                                                 6.25GHz SerDes disparity.

                                                                  1 = Interleaved running disparity: Running disparity is computed separately for even and
                                                                 odd code-groups of an RXAUI lane, i.e. interleave lanes after PCS layer as described in
                                                                 the Marvell RXAUI Interface specification. This does not obey 6.25GHz SerDes disparity. */
        uint64_t xor_rxplrt            : 4;  /**< [  9:  6](R/W) RX polarity control per physical PCS lane. */
        uint64_t xor_txplrt            : 4;  /**< [  5:  2](R/W) TX polarity control per physical PCS lane. */
        uint64_t rxplrt                : 1;  /**< [  1:  1](R/W) Receive polarity. 1 = inverted polarity. 0 = normal polarity. */
        uint64_t txplrt                : 1;  /**< [  0:  0](R/W) Transmit polarity. 1 = inverted polarity. 0 = normal polarity. */
#else /* Word 0 - Little Endian */
        uint64_t txplrt                : 1;  /**< [  0:  0](R/W) Transmit polarity. 1 = inverted polarity. 0 = normal polarity. */
        uint64_t rxplrt                : 1;  /**< [  1:  1](R/W) Receive polarity. 1 = inverted polarity. 0 = normal polarity. */
        uint64_t xor_txplrt            : 4;  /**< [  5:  2](R/W) TX polarity control per physical PCS lane. */
        uint64_t xor_rxplrt            : 4;  /**< [  9:  6](R/W) RX polarity control per physical PCS lane. */
        uint64_t intlv_rdisp           : 1;  /**< [ 10: 10](R/W) RXAUI interleaved running disparity. This bit is meaningful when the logical PCS type is
                                                                 RXAUI (CGX()_CMR()_CONFIG[LMAC_TYPE] = RXAUI), and has no effect otherwise. It
                                                                 selects which disparity calculation to use when combining or splitting the RXAUI lanes, as
                                                                 follows:

                                                                  0 = Common running disparity. Common running disparity is computed for even
                                                                 and odd code- groups of an RXAUI lane, i.e. interleave lanes before PCS layer as
                                                                 described in the Dune Networks/Broadcom RXAUI v2.1 specification. This obeys
                                                                 6.25GHz SerDes disparity.

                                                                  1 = Interleaved running disparity: Running disparity is computed separately for even and
                                                                 odd code-groups of an RXAUI lane, i.e. interleave lanes after PCS layer as described in
                                                                 the Marvell RXAUI Interface specification. This does not obey 6.25GHz SerDes disparity. */
        uint64_t skip_after_term       : 1;  /**< [ 11: 11](R/W) Enable sending of idle skip after terminate. This bit is meaningful when the logical PCS
                                                                 type is XAUI or RXAUI (selected by CGX()_CMR()_CONFIG[LMAC_TYPE]), and has no
                                                                 effect otherwise. When set, the LMAC/LPCS transmits more idle skip columns for clock
                                                                 compensation. Typically set in HiGig/HiGig2 modes; clear otherwise. This field can be set
                                                                 to ensure sufficient density of XAUI idle skip (||R||) columns with a small transmit
                                                                 inter-frame gap (IFG) in order to allow the link partner's receiver to delete ||R||
                                                                 columns as needed for clock rate compensation. It is usually set when the LMAC's transmit
                                                                 IFG is set to eight bytes in HiGig/HiGig2 modes (i.e. CGX()_SMU()_TX_IFG[IFG1] +
                                                                 CGX()_SMU()_TX_IFG[IFG2] = 8), and should be cleared when the transmit IFG is
                                                                 greater than eight bytes. When this bit is set, the SPU will send an ||R|| column after a
                                                                 ||T0|| column (terminate in lane 0) if no ||R|| was sent in the previous IFG. This is a
                                                                 minor deviation from the functionality specified in 802.3-2008 Figure 48-6 (PCS transmit
                                                                 source state diagram), whereby the state will transition directly from SEND_DATA to
                                                                 SEND_RANDOM_R after ||T0|| if no ||R|| was transmitted in the previous IFG. Sending ||R||
                                                                 after ||T0|| only (and not ||T1||, |T2|| or ||T3||) ensures that the check_end function at
                                                                 the receiving end, as defined in 802.3 sub-clause 48.2.6.1.4, does not detect an
                                                                 error due to this functional change. When this bit is clear, the LMAC will fully conform
                                                                 to the functionality specified in Figure 48-6. */
        uint64_t rx_packet_dis         : 1;  /**< [ 12: 12](R/W) Receive packet disable. Software can set or clear this bit at any time to gracefully
                                                                 disable or re-enable packet reception by the LPCS. If this bit is set while a packet is
                                                                 being received, the packet is completed and all subsequent received packets are discarded
                                                                 by the LPCS. Similarly, if this bit is cleared while a received packet is being discarded,
                                                                 packet reception resumes after the current packet is fully discarded. When set for a
                                                                 BASE-R LMAC/LPCS type (selected by CGX()_CMR()_CONFIG[LMAC_TYPE]),
                                                                 received errors and faults will be ignored while receive packets are discarded; idles will
                                                                 be sent to the MAC layer (SMU) and the errored blocks counter
                                                                 (CGX()_SPU()_BR_STATUS2[ERR_BLKS]) will not increment. */
        uint64_t rx_edet_signal_ok     : 1;  /**< [ 13: 13](R/W) Use the SDS edet (energy detect) as the "signal_ok" referred to by all 802.3 state diagrams
                                                                 when this bit is set. When this bit is 0, signal_ok will go down (and bring down associated
                                                                 machines) if the corresponding SDS fails to send a valid beat in any 1024 clock window. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_misc_control_s cn; */
};
typedef union bdk_cgxx_spux_misc_control bdk_cgxx_spux_misc_control_t;

static inline uint64_t BDK_CGXX_SPUX_MISC_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_MISC_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010218ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010218ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_MISC_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_MISC_CONTROL(a,b) bdk_cgxx_spux_misc_control_t
#define bustype_BDK_CGXX_SPUX_MISC_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_MISC_CONTROL(a,b) "CGXX_SPUX_MISC_CONTROL"
#define device_bar_BDK_CGXX_SPUX_MISC_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_MISC_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_MISC_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_rsfec_corr
 *
 * CGX SPU Reed-Solomon FEC Corrected Codeword Counter Register
 * This register implements the IEEE 802.3 RS-FEC corrected codewords counter
 * described in 802.3 section 91.6.8 (for 100G and extended to 50G) and 802.3by-2016
 * section 108.6.7 (for 25G and extended to USXGMII).
 */
union bdk_cgxx_spux_rsfec_corr
{
    uint64_t u;
    struct bdk_cgxx_spux_rsfec_corr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cw_cnt                : 32; /**< [ 31:  0](R/W/H) The counter increments by 1 when fec_align_status is true for each code-word that
                                                                 contains errors and was corrected. The counter is held at all ones in case of overflow.

                                                                 The counter is writable for test
                                                                 purposes, rather than read- only as specified in IEEE 802.3. */
#else /* Word 0 - Little Endian */
        uint64_t cw_cnt                : 32; /**< [ 31:  0](R/W/H) The counter increments by 1 when fec_align_status is true for each code-word that
                                                                 contains errors and was corrected. The counter is held at all ones in case of overflow.

                                                                 The counter is writable for test
                                                                 purposes, rather than read- only as specified in IEEE 802.3. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_rsfec_corr_s cn; */
};
typedef union bdk_cgxx_spux_rsfec_corr bdk_cgxx_spux_rsfec_corr_t;

static inline uint64_t BDK_CGXX_SPUX_RSFEC_CORR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_RSFEC_CORR(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010088ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010088ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_RSFEC_CORR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_RSFEC_CORR(a,b) bdk_cgxx_spux_rsfec_corr_t
#define bustype_BDK_CGXX_SPUX_RSFEC_CORR(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_RSFEC_CORR(a,b) "CGXX_SPUX_RSFEC_CORR"
#define device_bar_BDK_CGXX_SPUX_RSFEC_CORR(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_RSFEC_CORR(a,b) (a)
#define arguments_BDK_CGXX_SPUX_RSFEC_CORR(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_rsfec_status
 *
 * CGX SPU Reed-Solomon FEC Status Registers
 * This register implements the IEEE 802.3 RS-FEC status and lane mapping registers as
 * described in 802.3 section 91.6 (for 100G and extended to 50G) and 802.3by-2016
 * section 108-6 (for 25G and extended to USXGMII).
 */
union bdk_cgxx_spux_rsfec_status
{
    uint64_t u;
    struct bdk_cgxx_spux_rsfec_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t fec_byp_cor_abil      : 1;  /**< [ 15: 15](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error correction (while possibly performing error detection only). The variable is
                                                                 set to zero if this ability is not supported. For more details see 802.3
                                                                 91.5.3.3 and also also 802.3 91.6.3. */
        uint64_t fec_byp_ind_abil      : 1;  /**< [ 14: 14](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error indication. The variable is set to zero if this ability is not supported.
                                                                 For more details see 802.3 91.5.3.3 and also 802.3 91.6.4. */
        uint64_t hi_ser                : 1;  /**< [ 13: 13](RO/H) Value defined only when [FEC_BYP_IND_ABIL] is set. When
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_BYP_IND_EN] is set to one,
                                                                 this bit is set to one if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see 802.3 91.5.3.3) and is
                                                                 set to zero otherwise. See also 802.3 91.6.5. */
        uint64_t amps_lock             : 4;  /**< [ 12:  9](RO/H) Marker-locked status for FEC lanes 3..0 as achieved by AM-lock FSM (COUNT_2).
                                                                 0 = Not locked.
                                                                 1 = Locked.

                                                                 This information is also available in
                                                                 CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK]\<3:0\>. See also 802.3bj-2014 91.6.6. */
        uint64_t fec_align_status      : 1;  /**< [  8:  8](RO/H) Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED (802.3bj-2014
                                                                 Figure 91-9, 802.3by-2016 Figure 108-6). See also 802.3bj-2014 section 91.6.7. */
        uint64_t fec_lane_mapping      : 8;  /**< [  7:  0](RO/H) FEC lane number received on service interface N where N is the (0..3) offset used to
                                                                 access one of four fields in this register.

                                                                 _ CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING] = {FEC_lane_idx(SVC_lane_3)[1:0],..
                                                                 FEC_lane_idx(SVC_lane_0)[1:0]}.

                                                                 This information is also available in CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. See
                                                                 also 802.3bj-2014 section 91.6.10. */
#else /* Word 0 - Little Endian */
        uint64_t fec_lane_mapping      : 8;  /**< [  7:  0](RO/H) FEC lane number received on service interface N where N is the (0..3) offset used to
                                                                 access one of four fields in this register.

                                                                 _ CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING] = {FEC_lane_idx(SVC_lane_3)[1:0],..
                                                                 FEC_lane_idx(SVC_lane_0)[1:0]}.

                                                                 This information is also available in CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. See
                                                                 also 802.3bj-2014 section 91.6.10. */
        uint64_t fec_align_status      : 1;  /**< [  8:  8](RO/H) Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED (802.3bj-2014
                                                                 Figure 91-9, 802.3by-2016 Figure 108-6). See also 802.3bj-2014 section 91.6.7. */
        uint64_t amps_lock             : 4;  /**< [ 12:  9](RO/H) Marker-locked status for FEC lanes 3..0 as achieved by AM-lock FSM (COUNT_2).
                                                                 0 = Not locked.
                                                                 1 = Locked.

                                                                 This information is also available in
                                                                 CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK]\<3:0\>. See also 802.3bj-2014 91.6.6. */
        uint64_t hi_ser                : 1;  /**< [ 13: 13](RO/H) Value defined only when [FEC_BYP_IND_ABIL] is set. When
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_BYP_IND_EN] is set to one,
                                                                 this bit is set to one if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see 802.3 91.5.3.3) and is
                                                                 set to zero otherwise. See also 802.3 91.6.5. */
        uint64_t fec_byp_ind_abil      : 1;  /**< [ 14: 14](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error indication. The variable is set to zero if this ability is not supported.
                                                                 For more details see 802.3 91.5.3.3 and also 802.3 91.6.4. */
        uint64_t fec_byp_cor_abil      : 1;  /**< [ 15: 15](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error correction (while possibly performing error detection only). The variable is
                                                                 set to zero if this ability is not supported. For more details see 802.3
                                                                 91.5.3.3 and also also 802.3 91.6.3. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_rsfec_status_s cn9; */
    /* struct bdk_cgxx_spux_rsfec_status_s cn96xxp1; */
    struct bdk_cgxx_spux_rsfec_status_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t fec_byp_cor_abil      : 1;  /**< [ 15: 15](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error correction (while possibly performing error detection only). The variable is
                                                                 set to zero if this ability is not supported. For more details see 802.3
                                                                 91.5.3.3 and also 802.3 91.6.3. */
        uint64_t fec_byp_ind_abil      : 1;  /**< [ 14: 14](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error indication. The variable is set to zero if this ability is not supported.
                                                                 For more details see 802.3 91.5.3.3 and also 802.3 91.6.4. */
        uint64_t hi_ser                : 1;  /**< [ 13: 13](RO/H) Value defined only when [FEC_BYP_IND_ABIL] is set. When
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_BYP_IND_EN] is set to one,
                                                                 this bit is set to one if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see 802.3 91.5.3.3) and is
                                                                 set to zero otherwise. See also 802.3 91.6.5. */
        uint64_t amps_lock             : 4;  /**< [ 12:  9](RO/H) Marker-locked status for FEC lanes 3..0 as achieved by AM-lock FSM (COUNT_2).
                                                                 0 = Not locked.
                                                                 1 = Locked.

                                                                 This information is also available in
                                                                 CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK]\<3:0\>. See also 802.3bj-2014 91.6.6. */
        uint64_t fec_align_status      : 1;  /**< [  8:  8](RO/H) Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED (802.3bj-2014
                                                                 Figure 91-9, 802.3by-2016 Figure 108-6). See also 802.3bj-2014 section 91.6.7. */
        uint64_t fec_lane_mapping      : 8;  /**< [  7:  0](RO/H) FEC lane number received on service interface N where N is the (0..3) offset used to
                                                                 access one of four fields in this register.

                                                                 _ CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING] = {FEC_lane_idx(SVC_lane_3)[1:0],..
                                                                 FEC_lane_idx(SVC_lane_0)[1:0]}.

                                                                 This information is also available in CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. See
                                                                 also 802.3bj-2014 section 91.6.10. */
#else /* Word 0 - Little Endian */
        uint64_t fec_lane_mapping      : 8;  /**< [  7:  0](RO/H) FEC lane number received on service interface N where N is the (0..3) offset used to
                                                                 access one of four fields in this register.

                                                                 _ CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING] = {FEC_lane_idx(SVC_lane_3)[1:0],..
                                                                 FEC_lane_idx(SVC_lane_0)[1:0]}.

                                                                 This information is also available in CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. See
                                                                 also 802.3bj-2014 section 91.6.10. */
        uint64_t fec_align_status      : 1;  /**< [  8:  8](RO/H) Indicates the FEC alignment state machine RF_CW_MON reached ALIGN_ACQUIRED (802.3bj-2014
                                                                 Figure 91-9, 802.3by-2016 Figure 108-6). See also 802.3bj-2014 section 91.6.7. */
        uint64_t amps_lock             : 4;  /**< [ 12:  9](RO/H) Marker-locked status for FEC lanes 3..0 as achieved by AM-lock FSM (COUNT_2).
                                                                 0 = Not locked.
                                                                 1 = Locked.

                                                                 This information is also available in
                                                                 CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK]\<3:0\>. See also 802.3bj-2014 91.6.6. */
        uint64_t hi_ser                : 1;  /**< [ 13: 13](RO/H) Value defined only when [FEC_BYP_IND_ABIL] is set. When
                                                                 CGX()_SPU()_FEC_CONTROL[FEC_BYP_IND_EN] is set to one,
                                                                 this bit is set to one if the number of RS-FEC symbol errors in a window of 8192
                                                                 codewords exceeds the threshold (417 for CR4/KR4, see 802.3 91.5.3.3) and is
                                                                 set to zero otherwise. See also 802.3 91.6.5. */
        uint64_t fec_byp_ind_abil      : 1;  /**< [ 14: 14](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error indication. The variable is set to zero if this ability is not supported.
                                                                 For more details see 802.3 91.5.3.3 and also 802.3 91.6.4. */
        uint64_t fec_byp_cor_abil      : 1;  /**< [ 15: 15](RO/H) This variable is set to one to indicate that the decoder has the ability to bypass
                                                                 error correction (while possibly performing error detection only). The variable is
                                                                 set to zero if this ability is not supported. For more details see 802.3
                                                                 91.5.3.3 and also 802.3 91.6.3. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_cgxx_spux_rsfec_status_cn96xxp3 cn98xx; */
    /* struct bdk_cgxx_spux_rsfec_status_s cnf95xxp1; */
    /* struct bdk_cgxx_spux_rsfec_status_cn96xxp3 cnf95xxp2; */
    /* struct bdk_cgxx_spux_rsfec_status_cn96xxp3 loki; */
};
typedef union bdk_cgxx_spux_rsfec_status bdk_cgxx_spux_rsfec_status_t;

static inline uint64_t BDK_CGXX_SPUX_RSFEC_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_RSFEC_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010080ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010080ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_RSFEC_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_RSFEC_STATUS(a,b) bdk_cgxx_spux_rsfec_status_t
#define bustype_BDK_CGXX_SPUX_RSFEC_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_RSFEC_STATUS(a,b) "CGXX_SPUX_RSFEC_STATUS"
#define device_bar_BDK_CGXX_SPUX_RSFEC_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_RSFEC_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPUX_RSFEC_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_rsfec_uncorr
 *
 * CGX SPU Reed-Solomon FEC Uncorrected Codeword Counter Register
 * This register implements the IEEE 802.3 RS-FEC uncorrected codewords counter
 * described in 802.3 section 91.6.9 (for 100G and extended to 50G) and 802.3by-2016
 * section 108.6.8 (for 25G and extended to USXGMII).
 */
union bdk_cgxx_spux_rsfec_uncorr
{
    uint64_t u;
    struct bdk_cgxx_spux_rsfec_uncorr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cw_cnt                : 32; /**< [ 31:  0](R/W/H) The counter increments by 1 when fec_align_status is true for each code-word that
                                                                 contains errors and was uncorrected. The held at all ones in case of overflow.

                                                                 An uncorrected FEC codeword is a codeword that contains errors (when the bypass
                                                                 correction feature is supported and enabled) or contains errors that were not
                                                                 corrected (when the bypass correction feature is not supported or not enabled).

                                                                 The counter is writable for test
                                                                 purposes, rather than read- only as specified in IEEE 802.3. */
#else /* Word 0 - Little Endian */
        uint64_t cw_cnt                : 32; /**< [ 31:  0](R/W/H) The counter increments by 1 when fec_align_status is true for each code-word that
                                                                 contains errors and was uncorrected. The held at all ones in case of overflow.

                                                                 An uncorrected FEC codeword is a codeword that contains errors (when the bypass
                                                                 correction feature is supported and enabled) or contains errors that were not
                                                                 corrected (when the bypass correction feature is not supported or not enabled).

                                                                 The counter is writable for test
                                                                 purposes, rather than read- only as specified in IEEE 802.3. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_rsfec_uncorr_s cn; */
};
typedef union bdk_cgxx_spux_rsfec_uncorr bdk_cgxx_spux_rsfec_uncorr_t;

static inline uint64_t BDK_CGXX_SPUX_RSFEC_UNCORR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_RSFEC_UNCORR(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010090ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010090ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_RSFEC_UNCORR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_RSFEC_UNCORR(a,b) bdk_cgxx_spux_rsfec_uncorr_t
#define bustype_BDK_CGXX_SPUX_RSFEC_UNCORR(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_RSFEC_UNCORR(a,b) "CGXX_SPUX_RSFEC_UNCORR"
#define device_bar_BDK_CGXX_SPUX_RSFEC_UNCORR(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_RSFEC_UNCORR(a,b) (a)
#define arguments_BDK_CGXX_SPUX_RSFEC_UNCORR(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_rx_eee_wake
 *
 * INTERNAL: CGX SPU  RX EEE Wake Error Counter  Registers
 *
 * Reserved.
 * Internal:
 * A counter that is incremented each time that the LPI receive state diagram enters
 * the RX_WTF state indicating that a wake time fault has been detected.
 */
union bdk_cgxx_spux_rx_eee_wake
{
    uint64_t u;
    struct bdk_cgxx_spux_rx_eee_wake_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t wtf_error_counter     : 16; /**< [ 15:  0](RO/H) Reserved.
                                                                 Internal:
                                                                 Accumulation of wake time faults (rolls over). */
#else /* Word 0 - Little Endian */
        uint64_t wtf_error_counter     : 16; /**< [ 15:  0](RO/H) Reserved.
                                                                 Internal:
                                                                 Accumulation of wake time faults (rolls over). */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_rx_eee_wake_s cn; */
};
typedef union bdk_cgxx_spux_rx_eee_wake bdk_cgxx_spux_rx_eee_wake_t;

static inline uint64_t BDK_CGXX_SPUX_RX_EEE_WAKE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_RX_EEE_WAKE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00103e0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00103e0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00103e0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00103e0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_RX_EEE_WAKE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_RX_EEE_WAKE(a,b) bdk_cgxx_spux_rx_eee_wake_t
#define bustype_BDK_CGXX_SPUX_RX_EEE_WAKE(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_RX_EEE_WAKE(a,b) "CGXX_SPUX_RX_EEE_WAKE"
#define device_bar_BDK_CGXX_SPUX_RX_EEE_WAKE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_RX_EEE_WAKE(a,b) (a)
#define arguments_BDK_CGXX_SPUX_RX_EEE_WAKE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_rx_lpi_timing
 *
 * INTERNAL: CGX SPU RX EEE LPI Timing Parameters Registers
 *
 * Reserved.
 * Internal:
 * This register specifies receiver LPI timing parameters Tqr, Twr and Twtf.
 */
union bdk_cgxx_spux_rx_lpi_timing
{
    uint64_t u;
    struct bdk_cgxx_spux_rx_lpi_timing_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_lpi_en             : 1;  /**< [ 63: 63](R/W) Reserved.
                                                                 Internal:
                                                                 Receive EEE enable. When set, EEE is enabled. */
        uint64_t rx_lpi_fw             : 1;  /**< [ 62: 62](R/W) Reserved.
                                                                 Internal:
                                                                 Receive EEE fast wake enable.
                                                                 When set to 1, fast wake is enabled (i.e. deep sleep is disabled).
                                                                 The only modes that support fast wake are 25GBASE-R, 40GBASE-R, 50GBASE-R, and 100GBASE-R. */
        uint64_t reserved_60_61        : 2;
        uint64_t tqr                   : 20; /**< [ 59: 40](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits for signal detect to be set to OK while in the
                                                                 RX_SLEEP and RX_QUIET states before asserting rx_fault
                                                                 802.3-2012 Tables 48-10/49-3, Figures 48-12/49-13.
                                                                 Tables specifies min of 3 ms/2 ms, max of 4 ms/3 ms.
                                                                 Also used as rx_quiet_timer for RS-FEC in 802.3bj-2014 Figure 91-11.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 3 ms. */
        uint64_t twr                   : 20; /**< [ 39: 20](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits in RX_WAKE state before indicating wake time fault (WTF)
                                                                 802.3-2012 Tables 48-10/49-3, Figures 48-12/49-13.
                                                                 Tables specifies max of 9 us/11.5 us/13.7 us.
                                                                 Also used as first_ramps_counter initial value for RS-FEC in 802.3bj-2014 Figure 91-11.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 9 us. */
        uint64_t twtf                  : 20; /**< [ 19:  0](R/W) Reserved.
                                                                 Internal:
                                                                 EEE wake time fault recovery. 802.3-2012 Tables 48-10/49-3, Figures 48-12/49-13.
                                                                 Tables specifies maximum of 1 ms/10 ms.
                                                                 Also used as ramps_counter initial value for RS-FEC in 802.3bj-2014 Figure 91-11.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 1 ms. */
#else /* Word 0 - Little Endian */
        uint64_t twtf                  : 20; /**< [ 19:  0](R/W) Reserved.
                                                                 Internal:
                                                                 EEE wake time fault recovery. 802.3-2012 Tables 48-10/49-3, Figures 48-12/49-13.
                                                                 Tables specifies maximum of 1 ms/10 ms.
                                                                 Also used as ramps_counter initial value for RS-FEC in 802.3bj-2014 Figure 91-11.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 1 ms. */
        uint64_t twr                   : 20; /**< [ 39: 20](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits in RX_WAKE state before indicating wake time fault (WTF)
                                                                 802.3-2012 Tables 48-10/49-3, Figures 48-12/49-13.
                                                                 Tables specifies max of 9 us/11.5 us/13.7 us.
                                                                 Also used as first_ramps_counter initial value for RS-FEC in 802.3bj-2014 Figure 91-11.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 9 us. */
        uint64_t tqr                   : 20; /**< [ 59: 40](R/W) Reserved.
                                                                 Internal:
                                                                 EEE time the receiver waits for signal detect to be set to OK while in the
                                                                 RX_SLEEP and RX_QUIET states before asserting rx_fault
                                                                 802.3-2012 Tables 48-10/49-3, Figures 48-12/49-13.
                                                                 Tables specifies min of 3 ms/2 ms, max of 4 ms/3 ms.
                                                                 Also used as rx_quiet_timer for RS-FEC in 802.3bj-2014 Figure 91-11.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 3 ms. */
        uint64_t reserved_60_61        : 2;
        uint64_t rx_lpi_fw             : 1;  /**< [ 62: 62](R/W) Reserved.
                                                                 Internal:
                                                                 Receive EEE fast wake enable.
                                                                 When set to 1, fast wake is enabled (i.e. deep sleep is disabled).
                                                                 The only modes that support fast wake are 25GBASE-R, 40GBASE-R, 50GBASE-R, and 100GBASE-R. */
        uint64_t rx_lpi_en             : 1;  /**< [ 63: 63](R/W) Reserved.
                                                                 Internal:
                                                                 Receive EEE enable. When set, EEE is enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_rx_lpi_timing_s cn; */
};
typedef union bdk_cgxx_spux_rx_lpi_timing bdk_cgxx_spux_rx_lpi_timing_t;

static inline uint64_t BDK_CGXX_SPUX_RX_LPI_TIMING(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_RX_LPI_TIMING(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00103c0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00103c0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00103c0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00103c0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_RX_LPI_TIMING", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_RX_LPI_TIMING(a,b) bdk_cgxx_spux_rx_lpi_timing_t
#define bustype_BDK_CGXX_SPUX_RX_LPI_TIMING(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_RX_LPI_TIMING(a,b) "CGXX_SPUX_RX_LPI_TIMING"
#define device_bar_BDK_CGXX_SPUX_RX_LPI_TIMING(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_RX_LPI_TIMING(a,b) (a)
#define arguments_BDK_CGXX_SPUX_RX_LPI_TIMING(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_rx_lpi_timing2
 *
 * INTERNAL: CGX SPU RX EEE LPI Timing2 Parameters Registers
 *
 * Reserved.
 * Internal:
 * This register specifies receiver LPI timing parameters hold_off_timer.
 */
union bdk_cgxx_spux_rx_lpi_timing2
{
    uint64_t u;
    struct bdk_cgxx_spux_rx_lpi_timing2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t hold_off_timer        : 20; /**< [ 19:  0](R/W) Reserved.
                                                                 Internal:
                                                                 802.3-2008 Figure 108-6 hold off timer for 25G RS-FEC.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 11.5 us. */
#else /* Word 0 - Little Endian */
        uint64_t hold_off_timer        : 20; /**< [ 19:  0](R/W) Reserved.
                                                                 Internal:
                                                                 802.3-2008 Figure 108-6 hold off timer for 25G RS-FEC.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 11.5 us. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_rx_lpi_timing2_s cn; */
};
typedef union bdk_cgxx_spux_rx_lpi_timing2 bdk_cgxx_spux_rx_lpi_timing2_t;

static inline uint64_t BDK_CGXX_SPUX_RX_LPI_TIMING2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_RX_LPI_TIMING2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010420ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010420ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010420ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010420ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_RX_LPI_TIMING2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_RX_LPI_TIMING2(a,b) bdk_cgxx_spux_rx_lpi_timing2_t
#define bustype_BDK_CGXX_SPUX_RX_LPI_TIMING2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_RX_LPI_TIMING2(a,b) "CGXX_SPUX_RX_LPI_TIMING2"
#define device_bar_BDK_CGXX_SPUX_RX_LPI_TIMING2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_RX_LPI_TIMING2(a,b) (a)
#define arguments_BDK_CGXX_SPUX_RX_LPI_TIMING2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_rx_mrk_cnt
 *
 * CGX SPU Receiver Marker Interval Count Control Registers
 */
union bdk_cgxx_spux_rx_mrk_cnt
{
    uint64_t u;
    struct bdk_cgxx_spux_rx_mrk_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker receive period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the expected rapid alignment marker receive period per
                                                                 lane, i.e. the expected number of received 66b non-marker blocks between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_45_47        : 3;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_20_43        : 24;
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII receive marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the receive logic
                                                                 expects alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 expects 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU RX is initialized to this value, counts
                                                                 down for each BASE-R block received by SPU RX, and wraps back to the initial value from 0.
                                                                 The SPU RX receive logic expects alignment markers for lanes 0, 1, 2 and 3, respectively,
                                                                 in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for 40G. The default
                                                                 value corresponds to an alignment marker period of 16383 blocks (exclusive) per lane, as
                                                                 specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE                            Comment
                                                                   -------  -----------------------------------  ---------------------------------
                                                                   0x3fff   10G_R, 25G_R   w/        BASE-R-FEC  No markers w/o FEC 10G_R, 25G_R
                                                                            40G_R, 50G_R   w/ or w/o BASE-R-FEC
                                                                            100G_R         w/ or w/o RS-FEC      No BASE-R-FEC for 100G_R
                                                                   0x13ffc  25G_R, USXGMII w/        RS-FEC      Ignored by 25G_R if RS-FEC
                                                                                                                 disabled
                                                                                                                 See below for USXGMII w/o RSFEC
                                                                   0x4010   USXGMII        w/o       RS-FEC      USXGMII w/o RSFEC uses \<\> from
                                                                                                                 RSFEC mode
                                                                                                                 No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R          w/        RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
#else /* Word 0 - Little Endian */
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII receive marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the receive logic
                                                                 expects alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 expects 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU RX is initialized to this value, counts
                                                                 down for each BASE-R block received by SPU RX, and wraps back to the initial value from 0.
                                                                 The SPU RX receive logic expects alignment markers for lanes 0, 1, 2 and 3, respectively,
                                                                 in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for 40G. The default
                                                                 value corresponds to an alignment marker period of 16383 blocks (exclusive) per lane, as
                                                                 specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE                            Comment
                                                                   -------  -----------------------------------  ---------------------------------
                                                                   0x3fff   10G_R, 25G_R   w/        BASE-R-FEC  No markers w/o FEC 10G_R, 25G_R
                                                                            40G_R, 50G_R   w/ or w/o BASE-R-FEC
                                                                            100G_R         w/ or w/o RS-FEC      No BASE-R-FEC for 100G_R
                                                                   0x13ffc  25G_R, USXGMII w/        RS-FEC      Ignored by 25G_R if RS-FEC
                                                                                                                 disabled
                                                                                                                 See below for USXGMII w/o RSFEC
                                                                   0x4010   USXGMII        w/o       RS-FEC      USXGMII w/o RSFEC uses \<\> from
                                                                                                                 RSFEC mode
                                                                                                                 No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R          w/        RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
        uint64_t reserved_20_43        : 24;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_45_47        : 3;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker receive period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the expected rapid alignment marker receive period per
                                                                 lane, i.e. the expected number of received 66b non-marker blocks between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_rx_mrk_cnt_s cn9; */
    /* struct bdk_cgxx_spux_rx_mrk_cnt_s cn96xxp1; */
    struct bdk_cgxx_spux_rx_mrk_cnt_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker receive period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the expected rapid alignment marker receive period per
                                                                 lane, i.e. the expected number of received 66b non-marker blocks between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_45_47        : 3;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_20_43        : 24;
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII receive marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the receive logic
                                                                 expects alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 expects 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU RX is initialized to this value, counts
                                                                 down for each BASE-R block received by SPU RX, and wraps back to the initial value from 0.
                                                                 The SPU RX receive logic expects alignment markers for lanes 0, 1, 2 and 3, respectively,
                                                                 in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for 40G. The default
                                                                 value corresponds to an alignment marker period of 16383 blocks (exclusive) per lane, as
                                                                 specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE          Comment
                                                                   -------  -----------------  --------------------------
                                                                   0x3fff   10G_R, 25G_R w/    No markers w/o FEC 10G_R,
                                                                            BASE-R-FEC         25G_R
                                                                            40G_R, 50G_R w/
                                                                            or w/o BASE-R-FEC
                                                                            100G_R w/ or w/o   No BASE-R-FEC for 100G_R
                                                                            RS-FEC
                                                                   0x13ffc  25G_R, USXGMII w/  Ignored by 25G_R if RS-FEC
                                                                            RS-FEC             disabled
                                                                                               See below for USXGMII w/o
                                                                                               RSFEC
                                                                   0x4010   USXGMII w/o        USXGMII w/o RSFEC uses \<\>
                                                                            RS-FEC             from RSFEC mode
                                                                                               No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R w/ RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
#else /* Word 0 - Little Endian */
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII receive marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the receive logic
                                                                 expects alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 expects 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU RX is initialized to this value, counts
                                                                 down for each BASE-R block received by SPU RX, and wraps back to the initial value from 0.
                                                                 The SPU RX receive logic expects alignment markers for lanes 0, 1, 2 and 3, respectively,
                                                                 in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for 40G. The default
                                                                 value corresponds to an alignment marker period of 16383 blocks (exclusive) per lane, as
                                                                 specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE          Comment
                                                                   -------  -----------------  --------------------------
                                                                   0x3fff   10G_R, 25G_R w/    No markers w/o FEC 10G_R,
                                                                            BASE-R-FEC         25G_R
                                                                            40G_R, 50G_R w/
                                                                            or w/o BASE-R-FEC
                                                                            100G_R w/ or w/o   No BASE-R-FEC for 100G_R
                                                                            RS-FEC
                                                                   0x13ffc  25G_R, USXGMII w/  Ignored by 25G_R if RS-FEC
                                                                            RS-FEC             disabled
                                                                                               See below for USXGMII w/o
                                                                                               RSFEC
                                                                   0x4010   USXGMII w/o        USXGMII w/o RSFEC uses \<\>
                                                                            RS-FEC             from RSFEC mode
                                                                                               No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R w/ RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
        uint64_t reserved_20_43        : 24;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_45_47        : 3;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker receive period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the expected rapid alignment marker receive period per
                                                                 lane, i.e. the expected number of received 66b non-marker blocks between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_cgxx_spux_rx_mrk_cnt_cn96xxp3 cn98xx; */
    /* struct bdk_cgxx_spux_rx_mrk_cnt_cn96xxp3 cnf95xx; */
    /* struct bdk_cgxx_spux_rx_mrk_cnt_cn96xxp3 loki; */
};
typedef union bdk_cgxx_spux_rx_mrk_cnt bdk_cgxx_spux_rx_mrk_cnt_t;

static inline uint64_t BDK_CGXX_SPUX_RX_MRK_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_RX_MRK_CNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00103a0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00103a0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00103a0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00103a0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_RX_MRK_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_RX_MRK_CNT(a,b) bdk_cgxx_spux_rx_mrk_cnt_t
#define bustype_BDK_CGXX_SPUX_RX_MRK_CNT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_RX_MRK_CNT(a,b) "CGXX_SPUX_RX_MRK_CNT"
#define device_bar_BDK_CGXX_SPUX_RX_MRK_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_RX_MRK_CNT(a,b) (a)
#define arguments_BDK_CGXX_SPUX_RX_MRK_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_spd_abil
 *
 * CGX SPU PCS Speed Ability Registers
 */
union bdk_cgxx_spux_spd_abil
{
    uint64_t u;
    struct bdk_cgxx_spux_spd_abil_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hundredgb             : 1;  /**< [  6:  6](RO/H) 100G capable. Always 1. */
        uint64_t fiftygb               : 1;  /**< [  5:  5](RO/H) 50G capable. Always 1. */
        uint64_t fortygb               : 1;  /**< [  4:  4](RO/H) 40G capable. Always 1. */
        uint64_t twentyfivegb          : 1;  /**< [  3:  3](RO/H) 25G capable. Always 1. */
        uint64_t usxgmii               : 1;  /**< [  2:  2](RO/H) USXGMII capable. Always 1. */
        uint64_t tenpasst              : 1;  /**< [  1:  1](RO) 10PASS-TS/2BASE-TL capable. Always 0. */
        uint64_t tengb                 : 1;  /**< [  0:  0](RO/H) 10G capable. Always 1. */
#else /* Word 0 - Little Endian */
        uint64_t tengb                 : 1;  /**< [  0:  0](RO/H) 10G capable. Always 1. */
        uint64_t tenpasst              : 1;  /**< [  1:  1](RO) 10PASS-TS/2BASE-TL capable. Always 0. */
        uint64_t usxgmii               : 1;  /**< [  2:  2](RO/H) USXGMII capable. Always 1. */
        uint64_t twentyfivegb          : 1;  /**< [  3:  3](RO/H) 25G capable. Always 1. */
        uint64_t fortygb               : 1;  /**< [  4:  4](RO/H) 40G capable. Always 1. */
        uint64_t fiftygb               : 1;  /**< [  5:  5](RO/H) 50G capable. Always 1. */
        uint64_t hundredgb             : 1;  /**< [  6:  6](RO/H) 100G capable. Always 1. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_spd_abil_s cn; */
};
typedef union bdk_cgxx_spux_spd_abil bdk_cgxx_spux_spd_abil_t;

static inline uint64_t BDK_CGXX_SPUX_SPD_ABIL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_SPD_ABIL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_SPD_ABIL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_SPD_ABIL(a,b) bdk_cgxx_spux_spd_abil_t
#define bustype_BDK_CGXX_SPUX_SPD_ABIL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_SPD_ABIL(a,b) "CGXX_SPUX_SPD_ABIL"
#define device_bar_BDK_CGXX_SPUX_SPD_ABIL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_SPD_ABIL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_SPD_ABIL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_status1
 *
 * CGX SPU Status 1 Registers
 */
union bdk_cgxx_spux_status1
{
    uint64_t u;
    struct bdk_cgxx_spux_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t tx_lpi_received       : 1;  /**< [ 11: 11](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [TX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t rx_lpi_received       : 1;  /**< [ 10: 10](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [RX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t tx_lpi_indication     : 1;  /**< [  9:  9](RO/H) Reserved.
                                                                 Internal:
                                                                 TX sending LPI.  TX LPI State not in TX_ACTIVE.  802.3-2012 Figure 36-10. */
        uint64_t rx_lpi_indication     : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 RX receiving LPI.  rx_lpi_active = TRUE. 802.3-2012, Figure 36-7a-c. */
        uint64_t flt                   : 1;  /**< [  7:  7](RO/H) Fault condition detected.
                                                                 This bit is a logical OR of CGX()_SPU()_STATUS2[XMTFLT, RCVFLT]. */
        uint64_t reserved_3_6          : 4;
        uint64_t rcv_lnk               : 1;  /**< [  2:  2](R/W1S/H) PCS receive link status:
                                                                   0 = receive link down.
                                                                   1 = receive link up.

                                                                 This is a latching-low bit; it stays clear until a write-1-to-set by software.

                                                                 For a BASE-X logical PCS type (in the associated CGX()_CMR()_CONFIG[LMAC_TYPE] =
                                                                 XAUI or RXAUI), this is a latching-low version of CGX()_SPU()_BX_STATUS[ALIGND].

                                                                 For a BASE-R logical PCS type (in the associated CGX()_CMR()_CONFIG[LMAC_TYPE] =
                                                                 10G_R, 25G_R, 40G_R, 50G_R, 100G_R, USXGMII), this is a latching-low version of
                                                                 CGX()_SPU()_BR_STATUS1[RCV_LNK]. */
        uint64_t lpable                : 1;  /**< [  1:  1](RO) Low-power ability. Always returns 1 to indicate that the LPCS supports low-power mode. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t lpable                : 1;  /**< [  1:  1](RO) Low-power ability. Always returns 1 to indicate that the LPCS supports low-power mode. */
        uint64_t rcv_lnk               : 1;  /**< [  2:  2](R/W1S/H) PCS receive link status:
                                                                   0 = receive link down.
                                                                   1 = receive link up.

                                                                 This is a latching-low bit; it stays clear until a write-1-to-set by software.

                                                                 For a BASE-X logical PCS type (in the associated CGX()_CMR()_CONFIG[LMAC_TYPE] =
                                                                 XAUI or RXAUI), this is a latching-low version of CGX()_SPU()_BX_STATUS[ALIGND].

                                                                 For a BASE-R logical PCS type (in the associated CGX()_CMR()_CONFIG[LMAC_TYPE] =
                                                                 10G_R, 25G_R, 40G_R, 50G_R, 100G_R, USXGMII), this is a latching-low version of
                                                                 CGX()_SPU()_BR_STATUS1[RCV_LNK]. */
        uint64_t reserved_3_6          : 4;
        uint64_t flt                   : 1;  /**< [  7:  7](RO/H) Fault condition detected.
                                                                 This bit is a logical OR of CGX()_SPU()_STATUS2[XMTFLT, RCVFLT]. */
        uint64_t rx_lpi_indication     : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 RX receiving LPI.  rx_lpi_active = TRUE. 802.3-2012, Figure 36-7a-c. */
        uint64_t tx_lpi_indication     : 1;  /**< [  9:  9](RO/H) Reserved.
                                                                 Internal:
                                                                 TX sending LPI.  TX LPI State not in TX_ACTIVE.  802.3-2012 Figure 36-10. */
        uint64_t rx_lpi_received       : 1;  /**< [ 10: 10](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [RX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t tx_lpi_received       : 1;  /**< [ 11: 11](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Latched high version of [TX_LPI_INDICATION].
                                                                 LPI events that occur after read and before write will be lost.

                                                                 In order to avoid read side effects, this is implemented as a write-1-to-clear
                                                                 bit, rather than latching high read-only as specified in 802.3. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_status1_s cn; */
};
typedef union bdk_cgxx_spux_status1 bdk_cgxx_spux_status1_t;

static inline uint64_t BDK_CGXX_SPUX_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_STATUS1(a,b) bdk_cgxx_spux_status1_t
#define bustype_BDK_CGXX_SPUX_STATUS1(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_STATUS1(a,b) "CGXX_SPUX_STATUS1"
#define device_bar_BDK_CGXX_SPUX_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_STATUS1(a,b) (a)
#define arguments_BDK_CGXX_SPUX_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_status2
 *
 * CGX SPU Status 2 Registers
 */
union bdk_cgxx_spux_status2
{
    uint64_t u;
    struct bdk_cgxx_spux_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dev                   : 2;  /**< [ 15: 14](RO/H) Device present. Always returns 0x2 to indicate a device is present at this address. */
        uint64_t reserved_12_13        : 2;
        uint64_t xmtflt                : 1;  /**< [ 11: 11](RO/H) Transmit fault. Always returns 0. */
        uint64_t rcvflt                : 1;  /**< [ 10: 10](R/W1C/H) Receive fault: 1 = receive fault. 0 = no receive fault. Latching high bit; stays set until
                                                                 a write-1-to-clear by software. */
        uint64_t reserved_9            : 1;
        uint64_t hundredgb_r           : 1;  /**< [  8:  8](RO/H) 100GBASE-R capable. Always 1. */
        uint64_t fiftygb_r             : 1;  /**< [  7:  7](RO/H) 50GBASE-R capable. Always 1. */
        uint64_t fortygb_r             : 1;  /**< [  6:  6](RO/H) 40GBASE-R capable. Always 1. */
        uint64_t twentyfivegb_r        : 1;  /**< [  5:  5](RO/H) 25GBASE-R capable. Always 1. */
        uint64_t usxgmii_r             : 1;  /**< [  4:  4](RO/H) USXGMII-BASE-R capable. Always 1. */
        uint64_t tengb_t               : 1;  /**< [  3:  3](RO) 10GBASE-T capable. Always 0. */
        uint64_t tengb_w               : 1;  /**< [  2:  2](RO) 10GBASE-W capable. Always 0. */
        uint64_t tengb_x               : 1;  /**< [  1:  1](RO/H) 10GBASE-X capable. Always 1. */
        uint64_t tengb_r               : 1;  /**< [  0:  0](RO/H) 10GBASE-R capable. Always 1. */
#else /* Word 0 - Little Endian */
        uint64_t tengb_r               : 1;  /**< [  0:  0](RO/H) 10GBASE-R capable. Always 1. */
        uint64_t tengb_x               : 1;  /**< [  1:  1](RO/H) 10GBASE-X capable. Always 1. */
        uint64_t tengb_w               : 1;  /**< [  2:  2](RO) 10GBASE-W capable. Always 0. */
        uint64_t tengb_t               : 1;  /**< [  3:  3](RO) 10GBASE-T capable. Always 0. */
        uint64_t usxgmii_r             : 1;  /**< [  4:  4](RO/H) USXGMII-BASE-R capable. Always 1. */
        uint64_t twentyfivegb_r        : 1;  /**< [  5:  5](RO/H) 25GBASE-R capable. Always 1. */
        uint64_t fortygb_r             : 1;  /**< [  6:  6](RO/H) 40GBASE-R capable. Always 1. */
        uint64_t fiftygb_r             : 1;  /**< [  7:  7](RO/H) 50GBASE-R capable. Always 1. */
        uint64_t hundredgb_r           : 1;  /**< [  8:  8](RO/H) 100GBASE-R capable. Always 1. */
        uint64_t reserved_9            : 1;
        uint64_t rcvflt                : 1;  /**< [ 10: 10](R/W1C/H) Receive fault: 1 = receive fault. 0 = no receive fault. Latching high bit; stays set until
                                                                 a write-1-to-clear by software. */
        uint64_t xmtflt                : 1;  /**< [ 11: 11](RO/H) Transmit fault. Always returns 0. */
        uint64_t reserved_12_13        : 2;
        uint64_t dev                   : 2;  /**< [ 15: 14](RO/H) Device present. Always returns 0x2 to indicate a device is present at this address. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_status2_s cn; */
};
typedef union bdk_cgxx_spux_status2 bdk_cgxx_spux_status2_t;

static inline uint64_t BDK_CGXX_SPUX_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_STATUS2(a,b) bdk_cgxx_spux_status2_t
#define bustype_BDK_CGXX_SPUX_STATUS2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_STATUS2(a,b) "CGXX_SPUX_STATUS2"
#define device_bar_BDK_CGXX_SPUX_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_STATUS2(a,b) (a)
#define arguments_BDK_CGXX_SPUX_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_tx_lpi_timing
 *
 * INTERNAL: CGX SPU TX EEE LPI Timing Parameters Registers
 *
 * Reserved.
 * Internal:
 * Transmit LPI timing parameters Tsl, Tql and Tul
 */
union bdk_cgxx_spux_tx_lpi_timing
{
    uint64_t u;
    struct bdk_cgxx_spux_tx_lpi_timing_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_lpi_en             : 1;  /**< [ 63: 63](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit EEE enable. When set, EEE is enabled. */
        uint64_t tx_lpi_fw             : 1;  /**< [ 62: 62](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit EEE fast wake enable.
                                                                 When set to 1, fast wake is enabled (i.e. deep sleep is disabled).
                                                                 The only modes that support fast wake are 25G-BASER, 40G-BASER, 50GBASE-R and 100G-BASER. */
        uint64_t tx_lpi_ignore_twl     : 1;  /**< [ 61: 61](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit EEE ignore TWL and TWL2 parameters, instead using down_count=22 and down_count=0
                                                                 for TX_WAKE to TX_WAKE2, and TX_WAKE2 to TX_ACTIVE transitions.
                                                                 When set to 1, and EEE is enabled and FastWake is disabled for 40G-BASER, 50G-BASER and
                                                                 100G-BASER, the LPI Transmit state transitions occur on the down_count values.
                                                                 The only modes using this setting are 50G-BASER, 40G-BASER and 100G-BASER. */
        uint64_t reserved_60           : 1;
        uint64_t tsl                   : 12; /**< [ 59: 48](R/W) Reserved.
                                                                 Internal:
                                                                 Local sleep time from entering the TX_SLEEP state to when tx_quiet is set to TRUE
                                                                 802.3 Table 36-8, Figure 36-10.  Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 20 us. */
        uint64_t reserved_44_47        : 4;
        uint64_t tul                   : 12; /**< [ 43: 32](R/W) Reserved.
                                                                 Internal:
                                                                 Local refresh time from entry into the TX_REFRESH state to entry into the TX_QUIET
                                                                 state.
                                                                 802.3 Table 36-8, Figure 36-10.  Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Reset value gives 20 us. */
        uint64_t reserved_19_31        : 13;
        uint64_t tql                   : 19; /**< [ 18:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Local quiet time from when tx_quiet is set to TRUE to entry into the TX_REFRESH
                                                                 state
                                                                 802.3 Table 36-8, Figure 36-10.  Table specifies min of 2.5 ms, max of 2.6 ms.
                                                                 Reset value gives 2.55 ms. */
#else /* Word 0 - Little Endian */
        uint64_t tql                   : 19; /**< [ 18:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Local quiet time from when tx_quiet is set to TRUE to entry into the TX_REFRESH
                                                                 state
                                                                 802.3 Table 36-8, Figure 36-10.  Table specifies min of 2.5 ms, max of 2.6 ms.
                                                                 Reset value gives 2.55 ms. */
        uint64_t reserved_19_31        : 13;
        uint64_t tul                   : 12; /**< [ 43: 32](R/W) Reserved.
                                                                 Internal:
                                                                 Local refresh time from entry into the TX_REFRESH state to entry into the TX_QUIET
                                                                 state.
                                                                 802.3 Table 36-8, Figure 36-10.  Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Reset value gives 20 us. */
        uint64_t reserved_44_47        : 4;
        uint64_t tsl                   : 12; /**< [ 59: 48](R/W) Reserved.
                                                                 Internal:
                                                                 Local sleep time from entering the TX_SLEEP state to when tx_quiet is set to TRUE
                                                                 802.3 Table 36-8, Figure 36-10.  Table specifies min of 19.9 us, max of 20.1 us.
                                                                 Units = global 10 ns clock ticks.
                                                                 Reset value gives 20 us. */
        uint64_t reserved_60           : 1;
        uint64_t tx_lpi_ignore_twl     : 1;  /**< [ 61: 61](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit EEE ignore TWL and TWL2 parameters, instead using down_count=22 and down_count=0
                                                                 for TX_WAKE to TX_WAKE2, and TX_WAKE2 to TX_ACTIVE transitions.
                                                                 When set to 1, and EEE is enabled and FastWake is disabled for 40G-BASER, 50G-BASER and
                                                                 100G-BASER, the LPI Transmit state transitions occur on the down_count values.
                                                                 The only modes using this setting are 50G-BASER, 40G-BASER and 100G-BASER. */
        uint64_t tx_lpi_fw             : 1;  /**< [ 62: 62](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit EEE fast wake enable.
                                                                 When set to 1, fast wake is enabled (i.e. deep sleep is disabled).
                                                                 The only modes that support fast wake are 25G-BASER, 40G-BASER, 50GBASE-R and 100G-BASER. */
        uint64_t tx_lpi_en             : 1;  /**< [ 63: 63](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit EEE enable. When set, EEE is enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_tx_lpi_timing_s cn; */
};
typedef union bdk_cgxx_spux_tx_lpi_timing bdk_cgxx_spux_tx_lpi_timing_t;

static inline uint64_t BDK_CGXX_SPUX_TX_LPI_TIMING(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_TX_LPI_TIMING(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010400ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010400ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010400ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010400ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_TX_LPI_TIMING", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_TX_LPI_TIMING(a,b) bdk_cgxx_spux_tx_lpi_timing_t
#define bustype_BDK_CGXX_SPUX_TX_LPI_TIMING(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_TX_LPI_TIMING(a,b) "CGXX_SPUX_TX_LPI_TIMING"
#define device_bar_BDK_CGXX_SPUX_TX_LPI_TIMING(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_TX_LPI_TIMING(a,b) (a)
#define arguments_BDK_CGXX_SPUX_TX_LPI_TIMING(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_tx_lpi_timing2
 *
 * INTERNAL: CGX SPU TX EEE LPI Timing2 Parameters Registers
 *
 * Reserved.
 * Internal:
 * This register specifies transmit LPI timer parameters.
 */
union bdk_cgxx_spux_tx_lpi_timing2
{
    uint64_t u;
    struct bdk_cgxx_spux_tx_lpi_timing2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_60_63        : 4;
        uint64_t tbyp                  : 12; /**< [ 59: 48](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit scrambler bypass timer for timing TX_SCR_BYPASS EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 2.0 us. */
        uint64_t reserved_44_47        : 4;
        uint64_t twl2                  : 12; /**< [ 43: 32](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit Wake2 timer for timing TX_WAKE2 EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 2.45 us. */
        uint64_t reserved_24_31        : 8;
        uint64_t twl                   : 12; /**< [ 23: 12](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit Wake timer for timing TX_WAKE EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 11.0 us. */
        uint64_t reserved_8_11         : 4;
        uint64_t t1u                   : 8;  /**< [  7:  0](R/W) Reserved.
                                                                 Internal:
                                                                 One micro-second timer for timing TX_ALERT EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 1.2 us. */
#else /* Word 0 - Little Endian */
        uint64_t t1u                   : 8;  /**< [  7:  0](R/W) Reserved.
                                                                 Internal:
                                                                 One micro-second timer for timing TX_ALERT EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 1.2 us. */
        uint64_t reserved_8_11         : 4;
        uint64_t twl                   : 12; /**< [ 23: 12](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit Wake timer for timing TX_WAKE EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 11.0 us. */
        uint64_t reserved_24_31        : 8;
        uint64_t twl2                  : 12; /**< [ 43: 32](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit Wake2 timer for timing TX_WAKE2 EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 2.45 us. */
        uint64_t reserved_44_47        : 4;
        uint64_t tbyp                  : 12; /**< [ 59: 48](R/W) Reserved.
                                                                 Internal:
                                                                 Transmit scrambler bypass timer for timing TX_SCR_BYPASS EEE state.
                                                                 Units in global 10 ns period clock ticks.
                                                                 Reset value gives 2.0 us. */
        uint64_t reserved_60_63        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_tx_lpi_timing2_s cn; */
};
typedef union bdk_cgxx_spux_tx_lpi_timing2 bdk_cgxx_spux_tx_lpi_timing2_t;

static inline uint64_t BDK_CGXX_SPUX_TX_LPI_TIMING2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_TX_LPI_TIMING2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010440ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010440ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010440ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010440ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_TX_LPI_TIMING2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_TX_LPI_TIMING2(a,b) bdk_cgxx_spux_tx_lpi_timing2_t
#define bustype_BDK_CGXX_SPUX_TX_LPI_TIMING2(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_TX_LPI_TIMING2(a,b) "CGXX_SPUX_TX_LPI_TIMING2"
#define device_bar_BDK_CGXX_SPUX_TX_LPI_TIMING2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_TX_LPI_TIMING2(a,b) (a)
#define arguments_BDK_CGXX_SPUX_TX_LPI_TIMING2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_tx_mrk_cnt
 *
 * CGX SPU Transmitter Marker Interval Count Control Registers
 */
union bdk_cgxx_spux_tx_mrk_cnt
{
    uint64_t u;
    struct bdk_cgxx_spux_tx_mrk_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker transmit period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the rapid alignment marker period per lane used by the
                                                                 transmitter, i.e. the number of 66b non-marker blocks transmitted between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_45_47        : 3;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3-2012 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3-2012 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_20_43        : 24;
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII transmit marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the transmit logic
                                                                 inserts alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 inserts 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU TX is initialized to this value, counts
                                                                 down for each BASE-R block transmitted by SPU TX, and wraps back to the initial value from
                                                                 0. The SPU TX transmit logic inserts alignment markers for lanes 0, 1, 2 and 3,
                                                                 respectively, in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for
                                                                 40G. The default value corresponds to an alignment marker period of 16383 blocks
                                                                 (exclusive) per lane, as specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE                            Comment
                                                                   -------  -----------------------------------  ----------------------
                                                                   0x3fff   10G_R, 25G_R   w/        BASE-R-FEC  No markers w/o FEC 10G_R, 25G_R
                                                                            40G_R, 50G_R   w/ or w/o BASE-R-FEC
                                                                            100G_R         w/ or w/o RS-FEC      No BASE-R-FEC for 100G_R
                                                                   0x13ffc  25G_R, USXGMII w/        RS-FEC      Ignored by 25G_R and USXGMII if
                                                                                                                 RS-FEC disabled
                                                                                                                 No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R          w/        RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
#else /* Word 0 - Little Endian */
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII transmit marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the transmit logic
                                                                 inserts alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 inserts 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU TX is initialized to this value, counts
                                                                 down for each BASE-R block transmitted by SPU TX, and wraps back to the initial value from
                                                                 0. The SPU TX transmit logic inserts alignment markers for lanes 0, 1, 2 and 3,
                                                                 respectively, in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for
                                                                 40G. The default value corresponds to an alignment marker period of 16383 blocks
                                                                 (exclusive) per lane, as specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE                            Comment
                                                                   -------  -----------------------------------  ----------------------
                                                                   0x3fff   10G_R, 25G_R   w/        BASE-R-FEC  No markers w/o FEC 10G_R, 25G_R
                                                                            40G_R, 50G_R   w/ or w/o BASE-R-FEC
                                                                            100G_R         w/ or w/o RS-FEC      No BASE-R-FEC for 100G_R
                                                                   0x13ffc  25G_R, USXGMII w/        RS-FEC      Ignored by 25G_R and USXGMII if
                                                                                                                 RS-FEC disabled
                                                                                                                 No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R          w/        RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
        uint64_t reserved_20_43        : 24;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3-2012 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3-2012 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_45_47        : 3;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker transmit period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the rapid alignment marker period per lane used by the
                                                                 transmitter, i.e. the number of 66b non-marker blocks transmitted between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_tx_mrk_cnt_s cn9; */
    /* struct bdk_cgxx_spux_tx_mrk_cnt_s cn96xxp1; */
    struct bdk_cgxx_spux_tx_mrk_cnt_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker transmit period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the rapid alignment marker period per lane used by the
                                                                 transmitter, i.e. the number of 66b non-marker blocks transmitted between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_45_47        : 3;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3-2012 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3-2012 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_20_43        : 24;
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII transmit marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the transmit logic
                                                                 inserts alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 inserts 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU TX is initialized to this value, counts
                                                                 down for each BASE-R block transmitted by SPU TX, and wraps back to the initial value from
                                                                 0. The SPU TX transmit logic inserts alignment markers for lanes 0, 1, 2 and 3,
                                                                 respectively, in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for
                                                                 40G. The default value corresponds to an alignment marker period of 16383 blocks
                                                                 (exclusive) per lane, as specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE          Comment
                                                                   -------  -----------------  -------------------------
                                                                   0x3fff   10G_R, 25G_R w/    No markers w/o FEC 10G_R,
                                                                            BASE-R-FEC         25G_R
                                                                            40G_R, 50G_R w/
                                                                            or w/o BASE-R-FEC
                                                                            100G_R w/ or w/o   No BASE-R-FEC for 100G_R
                                                                            RS-FEC
                                                                   0x13ffc  25G_R, USXGMII w/  Ignored by 25G_R and
                                                                            RS-FEC             USXGMII if RS-FEC disabled
                                                                                               No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R w/ RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
#else /* Word 0 - Little Endian */
        uint64_t mrk_cnt               : 20; /**< [ 19:  0](R/W) 10, 25, 40, 50, 100GBASE-R and USXGMII transmit marker interval count, used by all
                                                                 defined FEC modes (non-FEC as well as BASE-R FEC, RS-FEC where available).
                                                                 Specifies the interval (number of 66-bit BASE-R blocks) at which the transmit logic
                                                                 inserts alignment markers. Ignored when not in any of the aforementioned modes.
                                                                 This value applies to each virtual lane (PCSL), and so, for example, the hardware
                                                                 inserts 4 markers after 4*[MRK_CNT] (40GBASE-R) or 20 markers after 20*[MRK_CNT]
                                                                 (100GBASE-R) blocks. An internal counter in SPU TX is initialized to this value, counts
                                                                 down for each BASE-R block transmitted by SPU TX, and wraps back to the initial value from
                                                                 0. The SPU TX transmit logic inserts alignment markers for lanes 0, 1, 2 and 3,
                                                                 respectively, in the last four BASE-R blocks before the counter wraps (3, 2, 1, 0) for
                                                                 40G. The default value corresponds to an alignment marker period of 16383 blocks
                                                                 (exclusive) per lane, as specified in IEEE 802.3 Clause 82.
                                                                 The following values should always be used for normal operation:

                                                                 \<pre\>
                                                                   Value    LMAC_TYPE          Comment
                                                                   -------  -----------------  -------------------------
                                                                   0x3fff   10G_R, 25G_R w/    No markers w/o FEC 10G_R,
                                                                            BASE-R-FEC         25G_R
                                                                            40G_R, 50G_R w/
                                                                            or w/o BASE-R-FEC
                                                                            100G_R w/ or w/o   No BASE-R-FEC for 100G_R
                                                                            RS-FEC
                                                                   0x13ffc  25G_R, USXGMII w/  Ignored by 25G_R and
                                                                            RS-FEC             USXGMII if RS-FEC disabled
                                                                                               No BASE-R-FEC for USXGMII
                                                                   0x4fff   50G_R w/ RS-FEC
                                                                 \</pre\>

                                                                 In USXGMII mode hardware only uses the value specified for LMAC0. */
        uint64_t reserved_20_43        : 24;
        uint64_t by_mrk_100g           : 1;  /**< [ 44: 44](R/W) Use alignment marker from 802.3-2012 Table 82-2 (100G) PCS lane 0 as first (of four)
                                                                 RS-FEC CWMs for 25G, 50G and USXGMII LMAC types if this bit is set and if RS-FEC
                                                                 is enabled. Lane 0 marker from 802.3-2012 Table 82-3 (40G)
                                                                 is used as first marker otherwise. The remaining three markers are always selected
                                                                 from Table 82-3 (PCS lanes 1-3). This bit was introduced to cover both possible
                                                                 interpretations of a confusing statement in 802.3by 108.5.2.4 bullet a) (to be compared
                                                                 to bullets b), c) and d)). Irrelevant for non- 25G, 50G or USXGMII LMAC types,
                                                                 or if RS-FEC is not enabled. */
        uint64_t reserved_45_47        : 3;
        uint64_t ram_mrk_cnt           : 8;  /**< [ 55: 48](R/W) Reserved.
                                                                 Internal:
                                                                 BASE-R rapid alignment marker transmit period for EEE support. For a multilane
                                                                 40,50,100GBASE-R
                                                                 logical PCS, this field specifies the rapid alignment marker period per lane used by the
                                                                 transmitter, i.e. the number of 66b non-marker blocks transmitted between consecutive
                                                                 markers on the same lane. The default value corresponds to a period of 15 blocks
                                                                 (exclusive) as specified in 802.3bj-2014 Figure 82-9a for 40G, 50G. Should be programmed to
                                                                 0x7 for 100G per 802.3bj-2014. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_cgxx_spux_tx_mrk_cnt_cn96xxp3 cn98xx; */
    /* struct bdk_cgxx_spux_tx_mrk_cnt_cn96xxp3 cnf95xx; */
    /* struct bdk_cgxx_spux_tx_mrk_cnt_cn96xxp3 loki; */
};
typedef union bdk_cgxx_spux_tx_mrk_cnt bdk_cgxx_spux_tx_mrk_cnt_t;

static inline uint64_t BDK_CGXX_SPUX_TX_MRK_CNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_TX_MRK_CNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010380ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010380ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010380ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010380ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_TX_MRK_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_TX_MRK_CNT(a,b) bdk_cgxx_spux_tx_mrk_cnt_t
#define bustype_BDK_CGXX_SPUX_TX_MRK_CNT(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_TX_MRK_CNT(a,b) "CGXX_SPUX_TX_MRK_CNT"
#define device_bar_BDK_CGXX_SPUX_TX_MRK_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_TX_MRK_CNT(a,b) (a)
#define arguments_BDK_CGXX_SPUX_TX_MRK_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_usx_an_adv
 *
 * CGX SPU USXGMII Autonegotiation Advertisement Registers
 * Software programs this register with the contents of the AN-link code word base page to be
 * transmitted during autonegotiation. Any write operations to this register prior to completion
 * of autonegotiation should be followed by a renegotiation in order for the new values to take
 * effect. Once autonegotiation has completed, software can examine this register along with
 * CGX()_SPU()_USX_AN_ADV to determine the highest common denominator technology.
 * The format for this register is from USXGMII Multiport specification section 1.1.2 Table 2.
 */
union bdk_cgxx_spux_usx_an_adv
{
    uint64_t u;
    struct bdk_cgxx_spux_usx_an_adv_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lnk_st                : 1;  /**< [ 15: 15](R/W) Link status:
                                                                   0 = link down.
                                                                   1 = link up. */
        uint64_t reserved_13_14        : 2;
        uint64_t dplx                  : 1;  /**< [ 12: 12](RO) Duplex mode. Always 1 full duplex. */
        uint64_t spd                   : 3;  /**< [ 11:  9](R/W) Link speed selection as follows:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = 10 Gb/s.
                                                                 0x4 = 2.5 Gb/s.
                                                                 0x5 = 5 Gb/s.
                                                                 0x6 = Reserved.
                                                                 0x7 = Reserved. */
        uint64_t eee_abil              : 1;  /**< [  8:  8](RO) Reserved.
                                                                 Internal:
                                                                 Indicates EEE capability. Always 0. */
        uint64_t eee_clk_stop_abil     : 1;  /**< [  7:  7](RO) Reserved.
                                                                 Internal:
                                                                 Indicates EEE clock stop capability. Always 0. */
        uint64_t reserved_1_6          : 6;
        uint64_t set                   : 1;  /**< [  0:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t set                   : 1;  /**< [  0:  0](RO) Reserved. */
        uint64_t reserved_1_6          : 6;
        uint64_t eee_clk_stop_abil     : 1;  /**< [  7:  7](RO) Reserved.
                                                                 Internal:
                                                                 Indicates EEE clock stop capability. Always 0. */
        uint64_t eee_abil              : 1;  /**< [  8:  8](RO) Reserved.
                                                                 Internal:
                                                                 Indicates EEE capability. Always 0. */
        uint64_t spd                   : 3;  /**< [ 11:  9](R/W) Link speed selection as follows:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = 10 Gb/s.
                                                                 0x4 = 2.5 Gb/s.
                                                                 0x5 = 5 Gb/s.
                                                                 0x6 = Reserved.
                                                                 0x7 = Reserved. */
        uint64_t dplx                  : 1;  /**< [ 12: 12](RO) Duplex mode. Always 1 full duplex. */
        uint64_t reserved_13_14        : 2;
        uint64_t lnk_st                : 1;  /**< [ 15: 15](R/W) Link status:
                                                                   0 = link down.
                                                                   1 = link up. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_usx_an_adv_s cn; */
};
typedef union bdk_cgxx_spux_usx_an_adv bdk_cgxx_spux_usx_an_adv_t;

static inline uint64_t BDK_CGXX_SPUX_USX_AN_ADV(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_USX_AN_ADV(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101d0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101d0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101d0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101d0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_USX_AN_ADV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_USX_AN_ADV(a,b) bdk_cgxx_spux_usx_an_adv_t
#define bustype_BDK_CGXX_SPUX_USX_AN_ADV(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_USX_AN_ADV(a,b) "CGXX_SPUX_USX_AN_ADV"
#define device_bar_BDK_CGXX_SPUX_USX_AN_ADV(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_USX_AN_ADV(a,b) (a)
#define arguments_BDK_CGXX_SPUX_USX_AN_ADV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_usx_an_control
 *
 * CGX SPU USXGMII Autonegotiation Control Register
 */
union bdk_cgxx_spux_usx_an_control
{
    uint64_t u;
    struct bdk_cgxx_spux_usx_an_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t an_reset              : 1;  /**< [ 15: 15](R/W1S/H) Autonegotiation reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_CONTROL1[RESET] to 1 causes the following to happen:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t reserved_13_14        : 2;
        uint64_t an_en                 : 1;  /**< [ 12: 12](R/W) Autonegotiation enable. This bit should only be set when
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is set to USXGMII. */
        uint64_t reserved_10_11        : 2;
        uint64_t rst_an                : 1;  /**< [  9:  9](R/W1S/H) Autonegotiation restart. Writing a 1 to this bit restarts the autonegotiation process if
                                                                 [AN_EN] is also set. This is a self-clearing bit. */
        uint64_t reserved_0_8          : 9;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_8          : 9;
        uint64_t rst_an                : 1;  /**< [  9:  9](R/W1S/H) Autonegotiation restart. Writing a 1 to this bit restarts the autonegotiation process if
                                                                 [AN_EN] is also set. This is a self-clearing bit. */
        uint64_t reserved_10_11        : 2;
        uint64_t an_en                 : 1;  /**< [ 12: 12](R/W) Autonegotiation enable. This bit should only be set when
                                                                 CGX()_CMR()_CONFIG[LMAC_TYPE] is set to USXGMII. */
        uint64_t reserved_13_14        : 2;
        uint64_t an_reset              : 1;  /**< [ 15: 15](R/W1S/H) Autonegotiation reset. Setting this bit or CGX()_SPU()_AN_CONTROL[AN_RESET] or
                                                                 CGX()_SPU()_CONTROL1[RESET] to 1 causes the following to happen:
                                                                 * Resets the logical PCS (LPCS).
                                                                 * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states.
                                                                 * Resets the associated SerDes lanes.

                                                                 It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                                 automatically cleared. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_usx_an_control_s cn; */
};
typedef union bdk_cgxx_spux_usx_an_control bdk_cgxx_spux_usx_an_control_t;

static inline uint64_t BDK_CGXX_SPUX_USX_AN_CONTROL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_USX_AN_CONTROL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101c0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101c0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_USX_AN_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_USX_AN_CONTROL(a,b) bdk_cgxx_spux_usx_an_control_t
#define bustype_BDK_CGXX_SPUX_USX_AN_CONTROL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_USX_AN_CONTROL(a,b) "CGXX_SPUX_USX_AN_CONTROL"
#define device_bar_BDK_CGXX_SPUX_USX_AN_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_USX_AN_CONTROL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_USX_AN_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_usx_an_expansion
 *
 * CGX SPU USXGMII Autonegotiation Expansion Register
 * This register is only used to signal page reception.
 */
union bdk_cgxx_spux_usx_an_expansion
{
    uint64_t u;
    struct bdk_cgxx_spux_usx_an_expansion_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t next_page_able        : 1;  /**< [  2:  2](RO) Next page able. Always 0. */
        uint64_t an_page_received      : 1;  /**< [  1:  1](R/W1C/H) Page received. This latching-high bit is set when a new page has been received and stored
                                                                 in CGX()_SPU()_USX_AN_LP_ABIL; stays set until a 1 is
                                                                 written by software, autonegotiation is disabled or restarted. Note that in order to avoid
                                                                 read side effects, this is implemented as a write-1-to-clear bit, rather than latching high
                                                                 read-only as specified in 802.3. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t an_page_received      : 1;  /**< [  1:  1](R/W1C/H) Page received. This latching-high bit is set when a new page has been received and stored
                                                                 in CGX()_SPU()_USX_AN_LP_ABIL; stays set until a 1 is
                                                                 written by software, autonegotiation is disabled or restarted. Note that in order to avoid
                                                                 read side effects, this is implemented as a write-1-to-clear bit, rather than latching high
                                                                 read-only as specified in 802.3. */
        uint64_t next_page_able        : 1;  /**< [  2:  2](RO) Next page able. Always 0. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_usx_an_expansion_s cn; */
};
typedef union bdk_cgxx_spux_usx_an_expansion bdk_cgxx_spux_usx_an_expansion_t;

static inline uint64_t BDK_CGXX_SPUX_USX_AN_EXPANSION(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_USX_AN_EXPANSION(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101e0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101e0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_USX_AN_EXPANSION", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_USX_AN_EXPANSION(a,b) bdk_cgxx_spux_usx_an_expansion_t
#define bustype_BDK_CGXX_SPUX_USX_AN_EXPANSION(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_USX_AN_EXPANSION(a,b) "CGXX_SPUX_USX_AN_EXPANSION"
#define device_bar_BDK_CGXX_SPUX_USX_AN_EXPANSION(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_USX_AN_EXPANSION(a,b) (a)
#define arguments_BDK_CGXX_SPUX_USX_AN_EXPANSION(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_usx_an_flow_ctrl
 *
 * CGX SPU USXGMII Flow Control Registers
 * This register is used by software to affect USXGMII AN hardware behavior.
 */
union bdk_cgxx_spux_usx_an_flow_ctrl
{
    uint64_t u;
    struct bdk_cgxx_spux_usx_an_flow_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t start_idle_detect     : 1;  /**< [  0:  0](R/W1S/H) Enable USXGMII IDLE_DETECT state evaluation and transition to LINK_OK. When
                                                                 autonegotiation is enabled (CGX()_SPU()_USX_AN_CONTROL[AN_EN] is set), this bit controls
                                                                 the behavior of the autonegotiation arbitration state machine when it reaches the
                                                                 IDLE_DETECT state after AN page is successfully exchanged, as defined in Figure 37-6 in
                                                                 802.3-2012. Upon entering IDLE_DETECT the SM waits for software to set this bit. Only after
                                                                 this bit is set does it start the link_timer and eventually transition to LINK_OK or
                                                                 AN_ENABLE. This is a self-clearing bit. */
#else /* Word 0 - Little Endian */
        uint64_t start_idle_detect     : 1;  /**< [  0:  0](R/W1S/H) Enable USXGMII IDLE_DETECT state evaluation and transition to LINK_OK. When
                                                                 autonegotiation is enabled (CGX()_SPU()_USX_AN_CONTROL[AN_EN] is set), this bit controls
                                                                 the behavior of the autonegotiation arbitration state machine when it reaches the
                                                                 IDLE_DETECT state after AN page is successfully exchanged, as defined in Figure 37-6 in
                                                                 802.3-2012. Upon entering IDLE_DETECT the SM waits for software to set this bit. Only after
                                                                 this bit is set does it start the link_timer and eventually transition to LINK_OK or
                                                                 AN_ENABLE. This is a self-clearing bit. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_usx_an_flow_ctrl_s cn; */
};
typedef union bdk_cgxx_spux_usx_an_flow_ctrl bdk_cgxx_spux_usx_an_flow_ctrl_t;

static inline uint64_t BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101e8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101e8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101e8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101e8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_USX_AN_FLOW_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(a,b) bdk_cgxx_spux_usx_an_flow_ctrl_t
#define bustype_BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(a,b) "CGXX_SPUX_USX_AN_FLOW_CTRL"
#define device_bar_BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_USX_AN_FLOW_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_usx_an_link_timer
 *
 * CGX SPU USXGMII Link Timer Registers
 * This is the link timer register.
 */
union bdk_cgxx_spux_usx_an_link_timer
{
    uint64_t u;
    struct bdk_cgxx_spux_usx_an_link_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t count                 : 16; /**< [ 15:  0](R/W) Units are hundreds of microseconds.
                                                                 (10000 * number of rst__gbl_100mhz_sclk_edge cycles: 100 MHz or 10 ns).
                                                                 Reset value results in a 1.5 ms link timer. */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 16; /**< [ 15:  0](R/W) Units are hundreds of microseconds.
                                                                 (10000 * number of rst__gbl_100mhz_sclk_edge cycles: 100 MHz or 10 ns).
                                                                 Reset value results in a 1.5 ms link timer. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_usx_an_link_timer_s cn; */
};
typedef union bdk_cgxx_spux_usx_an_link_timer bdk_cgxx_spux_usx_an_link_timer_t;

static inline uint64_t BDK_CGXX_SPUX_USX_AN_LINK_TIMER(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_USX_AN_LINK_TIMER(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101f0ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101f0ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_USX_AN_LINK_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_USX_AN_LINK_TIMER(a,b) bdk_cgxx_spux_usx_an_link_timer_t
#define bustype_BDK_CGXX_SPUX_USX_AN_LINK_TIMER(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_USX_AN_LINK_TIMER(a,b) "CGXX_SPUX_USX_AN_LINK_TIMER"
#define device_bar_BDK_CGXX_SPUX_USX_AN_LINK_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_USX_AN_LINK_TIMER(a,b) (a)
#define arguments_BDK_CGXX_SPUX_USX_AN_LINK_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_usx_an_lp_abil
 *
 * CGX SPU USXGMII Autonegotiation Link-Partner Advertisement Registers
 * This register captures the contents of the latest AN link code word base page received from
 * the link partner during autonegotiation. This is register 5 per IEEE 802.3, Clause 37.
 * CGX()_SPU()_USX_AN_EXPANSION[AN_PAGE_RECEIVED] is set when this register is updated by hardware.
 */
union bdk_cgxx_spux_usx_an_lp_abil
{
    uint64_t u;
    struct bdk_cgxx_spux_usx_an_lp_abil_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lnk_st                : 1;  /**< [ 15: 15](RO/H) Link status:
                                                                   0 = link down.
                                                                   1 = link up. */
        uint64_t reserved_13_14        : 2;
        uint64_t dplx                  : 1;  /**< [ 12: 12](RO/H) Duplex mode. Always 1 full duplex. */
        uint64_t spd                   : 3;  /**< [ 11:  9](RO/H) Link speed selection as follows:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = 10 Gb/s.
                                                                 0x4 = 2.5 Gb/s.
                                                                 0x5 = 5 Gb/s.
                                                                 0x6 = Reserved.
                                                                 0x7 = Reserved. */
        uint64_t eee_abil              : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates EEE capability. Always 0. */
        uint64_t eee_clk_stop_abil     : 1;  /**< [  7:  7](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates EEE clock stop capability. Always 0. */
        uint64_t reserved_1_6          : 6;
        uint64_t set                   : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t set                   : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint64_t reserved_1_6          : 6;
        uint64_t eee_clk_stop_abil     : 1;  /**< [  7:  7](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates EEE clock stop capability. Always 0. */
        uint64_t eee_abil              : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates EEE capability. Always 0. */
        uint64_t spd                   : 3;  /**< [ 11:  9](RO/H) Link speed selection as follows:
                                                                 0x0 = 10 Mb/s.
                                                                 0x1 = 100 Mb/s.
                                                                 0x2 = 1000 Mb/s.
                                                                 0x3 = 10 Gb/s.
                                                                 0x4 = 2.5 Gb/s.
                                                                 0x5 = 5 Gb/s.
                                                                 0x6 = Reserved.
                                                                 0x7 = Reserved. */
        uint64_t dplx                  : 1;  /**< [ 12: 12](RO/H) Duplex mode. Always 1 full duplex. */
        uint64_t reserved_13_14        : 2;
        uint64_t lnk_st                : 1;  /**< [ 15: 15](RO/H) Link status:
                                                                   0 = link down.
                                                                   1 = link up. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_usx_an_lp_abil_s cn; */
};
typedef union bdk_cgxx_spux_usx_an_lp_abil bdk_cgxx_spux_usx_an_lp_abil_t;

static inline uint64_t BDK_CGXX_SPUX_USX_AN_LP_ABIL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_USX_AN_LP_ABIL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101d8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101d8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_USX_AN_LP_ABIL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_USX_AN_LP_ABIL(a,b) bdk_cgxx_spux_usx_an_lp_abil_t
#define bustype_BDK_CGXX_SPUX_USX_AN_LP_ABIL(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_USX_AN_LP_ABIL(a,b) "CGXX_SPUX_USX_AN_LP_ABIL"
#define device_bar_BDK_CGXX_SPUX_USX_AN_LP_ABIL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_USX_AN_LP_ABIL(a,b) (a)
#define arguments_BDK_CGXX_SPUX_USX_AN_LP_ABIL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu#_usx_an_status
 *
 * CGX SPU USXGMII Autonegotiation Status Register
 */
union bdk_cgxx_spux_usx_an_status
{
    uint64_t u;
    struct bdk_cgxx_spux_usx_an_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t an_cpt                : 1;  /**< [  5:  5](RO/H) Indicates autonegotiation is complete; the contents of the
                                                                 CGX()_SPU()_USX_AN_ADV are valid. This bit is always zero when AN is
                                                                 disabled. */
        uint64_t rmt_flt               : 1;  /**< [  4:  4](RO) Remote fault: Always 0. */
        uint64_t an_abil               : 1;  /**< [  3:  3](RO) Autonegotiation ability: Always 1. */
        uint64_t lnk_st                : 1;  /**< [  2:  2](R/W1S/H) Link status:
                                                                   0 = Link down.
                                                                   1 = Link up.

                                                                 When set, indicates that a valid link has been established. When clear,
                                                                 indicates that the link has been invalid after this bit was last set by software. Latching
                                                                 low bit; stays clear until a 1 is written by software. Note that in order to avoid read
                                                                 side effects, this is implemented as a write-1-to-set bit, rather than latching low read-
                                                                 only as specified in 802.3. */
        uint64_t reserved_1            : 1;
        uint64_t extnd                 : 1;  /**< [  0:  0](RO) This field is always 0, extended capability registers not present. */
#else /* Word 0 - Little Endian */
        uint64_t extnd                 : 1;  /**< [  0:  0](RO) This field is always 0, extended capability registers not present. */
        uint64_t reserved_1            : 1;
        uint64_t lnk_st                : 1;  /**< [  2:  2](R/W1S/H) Link status:
                                                                   0 = Link down.
                                                                   1 = Link up.

                                                                 When set, indicates that a valid link has been established. When clear,
                                                                 indicates that the link has been invalid after this bit was last set by software. Latching
                                                                 low bit; stays clear until a 1 is written by software. Note that in order to avoid read
                                                                 side effects, this is implemented as a write-1-to-set bit, rather than latching low read-
                                                                 only as specified in 802.3. */
        uint64_t an_abil               : 1;  /**< [  3:  3](RO) Autonegotiation ability: Always 1. */
        uint64_t rmt_flt               : 1;  /**< [  4:  4](RO) Remote fault: Always 0. */
        uint64_t an_cpt                : 1;  /**< [  5:  5](RO/H) Indicates autonegotiation is complete; the contents of the
                                                                 CGX()_SPU()_USX_AN_ADV are valid. This bit is always zero when AN is
                                                                 disabled. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spux_usx_an_status_s cn; */
};
typedef union bdk_cgxx_spux_usx_an_status bdk_cgxx_spux_usx_an_status_t;

static inline uint64_t BDK_CGXX_SPUX_USX_AN_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPUX_USX_AN_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101c8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e00101c8ll + 0x1000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e00101c8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e00101c8ll + 0x1000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPUX_USX_AN_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPUX_USX_AN_STATUS(a,b) bdk_cgxx_spux_usx_an_status_t
#define bustype_BDK_CGXX_SPUX_USX_AN_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPUX_USX_AN_STATUS(a,b) "CGXX_SPUX_USX_AN_STATUS"
#define device_bar_BDK_CGXX_SPUX_USX_AN_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPUX_USX_AN_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPUX_USX_AN_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu_dbg_control
 *
 * CGX SPU Debug Control Registers
 */
union bdk_cgxx_spu_dbg_control
{
    uint64_t u;
    struct bdk_cgxx_spu_dbg_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t ms_clk_period         : 12; /**< [ 55: 44](R/W) Millisecond clock period. Specifies the number of microsecond clock ticks per millisecond,
                                                                 minus one. The default value of 999 (0x3E7) should be used during normal operation; other
                                                                 values may be used for test/debug purposes. */
        uint64_t us_clk_period         : 12; /**< [ 43: 32](R/W) Microsecond clock period. Specifies the number of 100MHz cycles per microseconds, minus one.
                                                                 Only sensical value is 100 - 1 == 99 == 0x63.
                                                                 This is used by the BASE-R BER monitor timers. */
        uint64_t rf_cw_mon_erly_restart_dis : 1;/**< [ 31: 31](R/W) The pipe-stage where the FEC alignment state machine RF_CW_MON (802.3bj-2014 Figure 91-9,
                                                                 802.3by-2016 Figure 108-6) resides will retain knowledge of uncorrectable errors in the system
                                                                 from the moment the Reed-Solomon decoder is up and running and until the SM leaves
                                                                 ALIGN_ACQUIRED. If any uncorrectable errors occur in that interval, the SM will go to THREE_BAD
                                                                 and cause restart lock to occur. This behavior will be preempted if this bit is set to 1.

                                                                 Internal:
                                                                 This was added to disable part of the fix to bug 36607. */
        uint64_t br_ber_mon_dis        : 1;  /**< [ 30: 30](R/W) BASE-R bit error rate monitor disable. This bit should be clear for normal operation.
                                                                 Setting it disables the BASE-R BER monitor state machine defined in 802.3-2008 Figure
                                                                 49-13 for 10G, 25GBASE-R, also used for USXGMII and 802.3ba-2010 Figure 82-13 for
                                                                 40G, 50G, 100GBASE-R. */
        uint64_t an_nonce_match_dis    : 1;  /**< [ 29: 29](R/W) Autonegotiation nonce match disable. This bit should be clear for normal operation.
                                                                 Setting it disables Nonce Match check by forcing nonce_match variable to 0 in the
                                                                 autonegotiation arbitration state diagram, as defined in 802.3-2008 Figure 73-11. This bit
                                                                 can be set by software for test purposes, e.g. for running autonegotiation in
                                                                 loopback mode. */
        uint64_t timestamp_norm_dis    : 1;  /**< [ 28: 28](R/W) Multi-lane BASE-R RX timestamp normalization disable. This bit controls the generation
                                                                 of the receive SOP timestamp passed to the SMU sub-block for a 40G, 50G or 100GBASE-R
                                                                 LMAC/LPCS. When this bit is clear, SPU normalizes the receive SOP timestamp in order to
                                                                 compensate for lane-to-lane skew on a multi-lane BASE-R link, as described below. When
                                                                 this bit is set, timestamp normalization is disabled and SPU directly passes the
                                                                 captured SOP timestamp values to SMU.

                                                                 In multi-lane mode, a packet's SOP block can be transferred on any of the LMAC's lanes.
                                                                 In the presence of lane-to-lane skew, the SOP delay from transmit (by the link partner)
                                                                 to receive by SPU varies depending on which lane is used by the SOP block. This variation
                                                                 reduces the accuracy of the received SOP timestamp relative to when it was transmitted by
                                                                 the link partner.

                                                                 SPU captures the timestamp of the alignment marker received on each SerDes lane during
                                                                 align/skew detection; the captured value can be read from the SerDes lane's
                                                                 CGX()_SPU_SDS()_SKEW_STATUS[SKEW_STATUS] field (CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP]
                                                                 sub-field). If
                                                                 alignment markers are transmitted at about the same time on all lanes by the link partner,
                                                                 then the difference between the CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values for a pair
                                                                 of lanes represents the
                                                                 approximate skew between those lanes.

                                                                 SPU uses the multi-lane LMAC's programmed PCS lane 0 as a reference and computes the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta of every other lane relative to PCS lane 0.
                                                                 When normalization is
                                                                 enabled, SPU adjusts the timestamp of a received SOP by subtracting the receiving lane's
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta from the captured timestamp value. The
                                                                 adjusted/normalized timestamp
                                                                 value is then passed to SMU along with the SOP.

                                                                 Software can determine the actual maximum skew of a multi-lane link by examining the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values in the CGX()_SPU_SDS()_SKEW_STATUS
                                                                 registers, and decide if
                                                                 timestamp normalization should be enabled or disabled to improve PTP accuracy.
                                                                 Normalization improves accuracy for larger skew values but reduces the accuracy (due to
                                                                 timestamp measurement errors) for small skew values. */
        uint64_t reserved_20_27        : 8;
        uint64_t br_pmd_train_soft_en  : 1;  /**< [ 19: 19](R/W) Enable BASE-R PMD software controlled link training. This bit configures the operation
                                                                 mode for BASE-R link training for all LMACs and lanes. When this bit is set along with
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] for a given LMAC, the BASE-R link training
                                                                 protocol for that LMAC is executed under software control, whereby the contents the
                                                                 CGX()_SPU()_BR_PMD_LD_CUP and CGX()_SPU()_BR_PMD_LD_REP registers are
                                                                 updated by software. When this bit is clear and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set, the link training protocol is fully
                                                                 automated in hardware, whereby the contents CGX()_SPU()_BR_PMD_LD_CUP and
                                                                 CGX()_SPU()_BR_PMD_LD_REP registers are automatically updated by hardware. */
        uint64_t reserved_17_18        : 2;
        uint64_t scramble_dis          : 1;  /**< [ 16: 16](R/W) BASE-R scrambler/descrambler disable. Setting this bit to 1 disables the BASE-R scrambler
                                                                 & descrambler functions and FEC PN-2112 scrambler & descrambler functions for debug
                                                                 purposes. */
        uint64_t reserved_15           : 1;
        uint64_t marker_rxp            : 15; /**< [ 14:  0](R/W) BASE-R alignment marker receive period. For a multilane BASE-R logical PCS (i.e.
                                                                 40,50,100GBASE-R), this field specifies the expected alignment marker receive period per
                                                                 lane,
                                                                 i.e. the expected number of received 66b non-marker blocks between consecutive markers on
                                                                 the same lane. The default value corresponds to a period of 16383 blocks (exclusive) as
                                                                 specified in 802.3ba-2010. Must be greater than 64. */
#else /* Word 0 - Little Endian */
        uint64_t marker_rxp            : 15; /**< [ 14:  0](R/W) BASE-R alignment marker receive period. For a multilane BASE-R logical PCS (i.e.
                                                                 40,50,100GBASE-R), this field specifies the expected alignment marker receive period per
                                                                 lane,
                                                                 i.e. the expected number of received 66b non-marker blocks between consecutive markers on
                                                                 the same lane. The default value corresponds to a period of 16383 blocks (exclusive) as
                                                                 specified in 802.3ba-2010. Must be greater than 64. */
        uint64_t reserved_15           : 1;
        uint64_t scramble_dis          : 1;  /**< [ 16: 16](R/W) BASE-R scrambler/descrambler disable. Setting this bit to 1 disables the BASE-R scrambler
                                                                 & descrambler functions and FEC PN-2112 scrambler & descrambler functions for debug
                                                                 purposes. */
        uint64_t reserved_17_18        : 2;
        uint64_t br_pmd_train_soft_en  : 1;  /**< [ 19: 19](R/W) Enable BASE-R PMD software controlled link training. This bit configures the operation
                                                                 mode for BASE-R link training for all LMACs and lanes. When this bit is set along with
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] for a given LMAC, the BASE-R link training
                                                                 protocol for that LMAC is executed under software control, whereby the contents the
                                                                 CGX()_SPU()_BR_PMD_LD_CUP and CGX()_SPU()_BR_PMD_LD_REP registers are
                                                                 updated by software. When this bit is clear and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set, the link training protocol is fully
                                                                 automated in hardware, whereby the contents CGX()_SPU()_BR_PMD_LD_CUP and
                                                                 CGX()_SPU()_BR_PMD_LD_REP registers are automatically updated by hardware. */
        uint64_t reserved_20_27        : 8;
        uint64_t timestamp_norm_dis    : 1;  /**< [ 28: 28](R/W) Multi-lane BASE-R RX timestamp normalization disable. This bit controls the generation
                                                                 of the receive SOP timestamp passed to the SMU sub-block for a 40G, 50G or 100GBASE-R
                                                                 LMAC/LPCS. When this bit is clear, SPU normalizes the receive SOP timestamp in order to
                                                                 compensate for lane-to-lane skew on a multi-lane BASE-R link, as described below. When
                                                                 this bit is set, timestamp normalization is disabled and SPU directly passes the
                                                                 captured SOP timestamp values to SMU.

                                                                 In multi-lane mode, a packet's SOP block can be transferred on any of the LMAC's lanes.
                                                                 In the presence of lane-to-lane skew, the SOP delay from transmit (by the link partner)
                                                                 to receive by SPU varies depending on which lane is used by the SOP block. This variation
                                                                 reduces the accuracy of the received SOP timestamp relative to when it was transmitted by
                                                                 the link partner.

                                                                 SPU captures the timestamp of the alignment marker received on each SerDes lane during
                                                                 align/skew detection; the captured value can be read from the SerDes lane's
                                                                 CGX()_SPU_SDS()_SKEW_STATUS[SKEW_STATUS] field (CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP]
                                                                 sub-field). If
                                                                 alignment markers are transmitted at about the same time on all lanes by the link partner,
                                                                 then the difference between the CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values for a pair
                                                                 of lanes represents the
                                                                 approximate skew between those lanes.

                                                                 SPU uses the multi-lane LMAC's programmed PCS lane 0 as a reference and computes the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta of every other lane relative to PCS lane 0.
                                                                 When normalization is
                                                                 enabled, SPU adjusts the timestamp of a received SOP by subtracting the receiving lane's
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta from the captured timestamp value. The
                                                                 adjusted/normalized timestamp
                                                                 value is then passed to SMU along with the SOP.

                                                                 Software can determine the actual maximum skew of a multi-lane link by examining the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values in the CGX()_SPU_SDS()_SKEW_STATUS
                                                                 registers, and decide if
                                                                 timestamp normalization should be enabled or disabled to improve PTP accuracy.
                                                                 Normalization improves accuracy for larger skew values but reduces the accuracy (due to
                                                                 timestamp measurement errors) for small skew values. */
        uint64_t an_nonce_match_dis    : 1;  /**< [ 29: 29](R/W) Autonegotiation nonce match disable. This bit should be clear for normal operation.
                                                                 Setting it disables Nonce Match check by forcing nonce_match variable to 0 in the
                                                                 autonegotiation arbitration state diagram, as defined in 802.3-2008 Figure 73-11. This bit
                                                                 can be set by software for test purposes, e.g. for running autonegotiation in
                                                                 loopback mode. */
        uint64_t br_ber_mon_dis        : 1;  /**< [ 30: 30](R/W) BASE-R bit error rate monitor disable. This bit should be clear for normal operation.
                                                                 Setting it disables the BASE-R BER monitor state machine defined in 802.3-2008 Figure
                                                                 49-13 for 10G, 25GBASE-R, also used for USXGMII and 802.3ba-2010 Figure 82-13 for
                                                                 40G, 50G, 100GBASE-R. */
        uint64_t rf_cw_mon_erly_restart_dis : 1;/**< [ 31: 31](R/W) The pipe-stage where the FEC alignment state machine RF_CW_MON (802.3bj-2014 Figure 91-9,
                                                                 802.3by-2016 Figure 108-6) resides will retain knowledge of uncorrectable errors in the system
                                                                 from the moment the Reed-Solomon decoder is up and running and until the SM leaves
                                                                 ALIGN_ACQUIRED. If any uncorrectable errors occur in that interval, the SM will go to THREE_BAD
                                                                 and cause restart lock to occur. This behavior will be preempted if this bit is set to 1.

                                                                 Internal:
                                                                 This was added to disable part of the fix to bug 36607. */
        uint64_t us_clk_period         : 12; /**< [ 43: 32](R/W) Microsecond clock period. Specifies the number of 100MHz cycles per microseconds, minus one.
                                                                 Only sensical value is 100 - 1 == 99 == 0x63.
                                                                 This is used by the BASE-R BER monitor timers. */
        uint64_t ms_clk_period         : 12; /**< [ 55: 44](R/W) Millisecond clock period. Specifies the number of microsecond clock ticks per millisecond,
                                                                 minus one. The default value of 999 (0x3E7) should be used during normal operation; other
                                                                 values may be used for test/debug purposes. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spu_dbg_control_s cn9; */
    struct bdk_cgxx_spu_dbg_control_cn96xxp1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t ms_clk_period         : 12; /**< [ 55: 44](R/W) Millisecond clock period. Specifies the number of microsecond clock ticks per millisecond,
                                                                 minus one. The default value of 999 (0x3E7) should be used during normal operation; other
                                                                 values may be used for test/debug purposes. */
        uint64_t us_clk_period         : 12; /**< [ 43: 32](R/W) Microsecond clock period. Specifies the number of 100MHz cycles per microseconds, minus one.
                                                                 Only sensical value is 100 - 1 == 99 == 0x63.
                                                                 This is used by the BASE-R BER monitor timers. */
        uint64_t reserved_31           : 1;
        uint64_t br_ber_mon_dis        : 1;  /**< [ 30: 30](R/W) BASE-R bit error rate monitor disable. This bit should be clear for normal operation.
                                                                 Setting it disables the BASE-R BER monitor state machine defined in 802.3-2008 Figure
                                                                 49-13 for 10G, 25GBASE-R, also used for USXGMII and 802.3ba-2010 Figure 82-13 for
                                                                 40G, 50G, 100GBASE-R. */
        uint64_t an_nonce_match_dis    : 1;  /**< [ 29: 29](R/W) Autonegotiation nonce match disable. This bit should be clear for normal operation.
                                                                 Setting it disables Nonce Match check by forcing nonce_match variable to 0 in the
                                                                 autonegotiation arbitration state diagram, as defined in 802.3-2008 Figure 73-11. This bit
                                                                 can be set by software for test purposes, e.g. for running autonegotiation in
                                                                 loopback mode. */
        uint64_t timestamp_norm_dis    : 1;  /**< [ 28: 28](R/W) Multi-lane BASE-R RX timestamp normalization disable. This bit controls the generation
                                                                 of the receive SOP timestamp passed to the SMU sub-block for a 40G, 50G or 100GBASE-R
                                                                 LMAC/LPCS. When this bit is clear, SPU normalizes the receive SOP timestamp in order to
                                                                 compensate for lane-to-lane skew on a multi-lane BASE-R link, as described below. When
                                                                 this bit is set, timestamp normalization is disabled and SPU directly passes the
                                                                 captured SOP timestamp values to SMU.

                                                                 In multi-lane mode, a packet's SOP block can be transferred on any of the LMAC's lanes.
                                                                 In the presence of lane-to-lane skew, the SOP delay from transmit (by the link partner)
                                                                 to receive by SPU varies depending on which lane is used by the SOP block. This variation
                                                                 reduces the accuracy of the received SOP timestamp relative to when it was transmitted by
                                                                 the link partner.

                                                                 SPU captures the timestamp of the alignment marker received on each SerDes lane during
                                                                 align/skew detection; the captured value can be read from the SerDes lane's
                                                                 CGX()_SPU_SDS()_SKEW_STATUS[SKEW_STATUS] field (CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP]
                                                                 sub-field). If
                                                                 alignment markers are transmitted at about the same time on all lanes by the link partner,
                                                                 then the difference between the CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values for a pair
                                                                 of lanes represents the
                                                                 approximate skew between those lanes.

                                                                 SPU uses the multi-lane LMAC's programmed PCS lane 0 as a reference and computes the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta of every other lane relative to PCS lane 0.
                                                                 When normalization is
                                                                 enabled, SPU adjusts the timestamp of a received SOP by subtracting the receiving lane's
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta from the captured timestamp value. The
                                                                 adjusted/normalized timestamp
                                                                 value is then passed to SMU along with the SOP.

                                                                 Software can determine the actual maximum skew of a multi-lane link by examining the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values in the CGX()_SPU_SDS()_SKEW_STATUS
                                                                 registers, and decide if
                                                                 timestamp normalization should be enabled or disabled to improve PTP accuracy.
                                                                 Normalization improves accuracy for larger skew values but reduces the accuracy (due to
                                                                 timestamp measurement errors) for small skew values. */
        uint64_t reserved_20_27        : 8;
        uint64_t br_pmd_train_soft_en  : 1;  /**< [ 19: 19](R/W) Enable BASE-R PMD software controlled link training. This bit configures the operation
                                                                 mode for BASE-R link training for all LMACs and lanes. When this bit is set along with
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] for a given LMAC, the BASE-R link training
                                                                 protocol for that LMAC is executed under software control, whereby the contents the
                                                                 CGX()_SPU()_BR_PMD_LD_CUP and CGX()_SPU()_BR_PMD_LD_REP registers are
                                                                 updated by software. When this bit is clear and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set, the link training protocol is fully
                                                                 automated in hardware, whereby the contents CGX()_SPU()_BR_PMD_LD_CUP and
                                                                 CGX()_SPU()_BR_PMD_LD_REP registers are automatically updated by hardware. */
        uint64_t reserved_17_18        : 2;
        uint64_t scramble_dis          : 1;  /**< [ 16: 16](R/W) BASE-R scrambler/descrambler disable. Setting this bit to 1 disables the BASE-R scrambler
                                                                 & descrambler functions and FEC PN-2112 scrambler & descrambler functions for debug
                                                                 purposes. */
        uint64_t reserved_15           : 1;
        uint64_t marker_rxp            : 15; /**< [ 14:  0](R/W) BASE-R alignment marker receive period. For a multilane BASE-R logical PCS (i.e.
                                                                 40,50,100GBASE-R), this field specifies the expected alignment marker receive period per
                                                                 lane,
                                                                 i.e. the expected number of received 66b non-marker blocks between consecutive markers on
                                                                 the same lane. The default value corresponds to a period of 16383 blocks (exclusive) as
                                                                 specified in 802.3ba-2010. Must be greater than 64. */
#else /* Word 0 - Little Endian */
        uint64_t marker_rxp            : 15; /**< [ 14:  0](R/W) BASE-R alignment marker receive period. For a multilane BASE-R logical PCS (i.e.
                                                                 40,50,100GBASE-R), this field specifies the expected alignment marker receive period per
                                                                 lane,
                                                                 i.e. the expected number of received 66b non-marker blocks between consecutive markers on
                                                                 the same lane. The default value corresponds to a period of 16383 blocks (exclusive) as
                                                                 specified in 802.3ba-2010. Must be greater than 64. */
        uint64_t reserved_15           : 1;
        uint64_t scramble_dis          : 1;  /**< [ 16: 16](R/W) BASE-R scrambler/descrambler disable. Setting this bit to 1 disables the BASE-R scrambler
                                                                 & descrambler functions and FEC PN-2112 scrambler & descrambler functions for debug
                                                                 purposes. */
        uint64_t reserved_17_18        : 2;
        uint64_t br_pmd_train_soft_en  : 1;  /**< [ 19: 19](R/W) Enable BASE-R PMD software controlled link training. This bit configures the operation
                                                                 mode for BASE-R link training for all LMACs and lanes. When this bit is set along with
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] for a given LMAC, the BASE-R link training
                                                                 protocol for that LMAC is executed under software control, whereby the contents the
                                                                 CGX()_SPU()_BR_PMD_LD_CUP and CGX()_SPU()_BR_PMD_LD_REP registers are
                                                                 updated by software. When this bit is clear and
                                                                 CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set, the link training protocol is fully
                                                                 automated in hardware, whereby the contents CGX()_SPU()_BR_PMD_LD_CUP and
                                                                 CGX()_SPU()_BR_PMD_LD_REP registers are automatically updated by hardware. */
        uint64_t reserved_20_27        : 8;
        uint64_t timestamp_norm_dis    : 1;  /**< [ 28: 28](R/W) Multi-lane BASE-R RX timestamp normalization disable. This bit controls the generation
                                                                 of the receive SOP timestamp passed to the SMU sub-block for a 40G, 50G or 100GBASE-R
                                                                 LMAC/LPCS. When this bit is clear, SPU normalizes the receive SOP timestamp in order to
                                                                 compensate for lane-to-lane skew on a multi-lane BASE-R link, as described below. When
                                                                 this bit is set, timestamp normalization is disabled and SPU directly passes the
                                                                 captured SOP timestamp values to SMU.

                                                                 In multi-lane mode, a packet's SOP block can be transferred on any of the LMAC's lanes.
                                                                 In the presence of lane-to-lane skew, the SOP delay from transmit (by the link partner)
                                                                 to receive by SPU varies depending on which lane is used by the SOP block. This variation
                                                                 reduces the accuracy of the received SOP timestamp relative to when it was transmitted by
                                                                 the link partner.

                                                                 SPU captures the timestamp of the alignment marker received on each SerDes lane during
                                                                 align/skew detection; the captured value can be read from the SerDes lane's
                                                                 CGX()_SPU_SDS()_SKEW_STATUS[SKEW_STATUS] field (CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP]
                                                                 sub-field). If
                                                                 alignment markers are transmitted at about the same time on all lanes by the link partner,
                                                                 then the difference between the CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values for a pair
                                                                 of lanes represents the
                                                                 approximate skew between those lanes.

                                                                 SPU uses the multi-lane LMAC's programmed PCS lane 0 as a reference and computes the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta of every other lane relative to PCS lane 0.
                                                                 When normalization is
                                                                 enabled, SPU adjusts the timestamp of a received SOP by subtracting the receiving lane's
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta from the captured timestamp value. The
                                                                 adjusted/normalized timestamp
                                                                 value is then passed to SMU along with the SOP.

                                                                 Software can determine the actual maximum skew of a multi-lane link by examining the
                                                                 CGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values in the CGX()_SPU_SDS()_SKEW_STATUS
                                                                 registers, and decide if
                                                                 timestamp normalization should be enabled or disabled to improve PTP accuracy.
                                                                 Normalization improves accuracy for larger skew values but reduces the accuracy (due to
                                                                 timestamp measurement errors) for small skew values. */
        uint64_t an_nonce_match_dis    : 1;  /**< [ 29: 29](R/W) Autonegotiation nonce match disable. This bit should be clear for normal operation.
                                                                 Setting it disables Nonce Match check by forcing nonce_match variable to 0 in the
                                                                 autonegotiation arbitration state diagram, as defined in 802.3-2008 Figure 73-11. This bit
                                                                 can be set by software for test purposes, e.g. for running autonegotiation in
                                                                 loopback mode. */
        uint64_t br_ber_mon_dis        : 1;  /**< [ 30: 30](R/W) BASE-R bit error rate monitor disable. This bit should be clear for normal operation.
                                                                 Setting it disables the BASE-R BER monitor state machine defined in 802.3-2008 Figure
                                                                 49-13 for 10G, 25GBASE-R, also used for USXGMII and 802.3ba-2010 Figure 82-13 for
                                                                 40G, 50G, 100GBASE-R. */
        uint64_t reserved_31           : 1;
        uint64_t us_clk_period         : 12; /**< [ 43: 32](R/W) Microsecond clock period. Specifies the number of 100MHz cycles per microseconds, minus one.
                                                                 Only sensical value is 100 - 1 == 99 == 0x63.
                                                                 This is used by the BASE-R BER monitor timers. */
        uint64_t ms_clk_period         : 12; /**< [ 55: 44](R/W) Millisecond clock period. Specifies the number of microsecond clock ticks per millisecond,
                                                                 minus one. The default value of 999 (0x3E7) should be used during normal operation; other
                                                                 values may be used for test/debug purposes. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } cn96xxp1;
    /* struct bdk_cgxx_spu_dbg_control_s cn96xxp3; */
    /* struct bdk_cgxx_spu_dbg_control_s cn98xx; */
    /* struct bdk_cgxx_spu_dbg_control_cn96xxp1 cnf95xxp1; */
    /* struct bdk_cgxx_spu_dbg_control_s cnf95xxp2; */
    /* struct bdk_cgxx_spu_dbg_control_s loki; */
};
typedef union bdk_cgxx_spu_dbg_control bdk_cgxx_spu_dbg_control_t;

static inline uint64_t BDK_CGXX_SPU_DBG_CONTROL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPU_DBG_CONTROL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0010300ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0010300ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0010300ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0010300ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_SPU_DBG_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPU_DBG_CONTROL(a) bdk_cgxx_spu_dbg_control_t
#define bustype_BDK_CGXX_SPU_DBG_CONTROL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPU_DBG_CONTROL(a) "CGXX_SPU_DBG_CONTROL"
#define device_bar_BDK_CGXX_SPU_DBG_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPU_DBG_CONTROL(a) (a)
#define arguments_BDK_CGXX_SPU_DBG_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) cgx#_spu_sds#_skew_status
 *
 * CGX SPU SerDes Lane Skew Status Registers
 * This register provides SerDes lane skew status. One register per physical SerDes lane.
 */
union bdk_cgxx_spu_sdsx_skew_status
{
    uint64_t u;
    struct bdk_cgxx_spu_sdsx_skew_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t skew_status           : 32; /**< [ 31:  0](RO/H) Format defined by CGX_SPU_SDS_SKEW_STATUS_S. */
#else /* Word 0 - Little Endian */
        uint64_t skew_status           : 32; /**< [ 31:  0](RO/H) Format defined by CGX_SPU_SDS_SKEW_STATUS_S. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spu_sdsx_skew_status_s cn; */
};
typedef union bdk_cgxx_spu_sdsx_skew_status bdk_cgxx_spu_sdsx_skew_status_t;

static inline uint64_t BDK_CGXX_SPU_SDSX_SKEW_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPU_SDSX_SKEW_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010340ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010340ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010340ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010340ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPU_SDSX_SKEW_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPU_SDSX_SKEW_STATUS(a,b) bdk_cgxx_spu_sdsx_skew_status_t
#define bustype_BDK_CGXX_SPU_SDSX_SKEW_STATUS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPU_SDSX_SKEW_STATUS(a,b) "CGXX_SPU_SDSX_SKEW_STATUS"
#define device_bar_BDK_CGXX_SPU_SDSX_SKEW_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPU_SDSX_SKEW_STATUS(a,b) (a)
#define arguments_BDK_CGXX_SPU_SDSX_SKEW_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu_sds#_states
 *
 * CGX SPU SerDes States Registers
 * This register provides SerDes lane states. One register per physical SerDes lane.
 */
union bdk_cgxx_spu_sdsx_states
{
    uint64_t u;
    struct bdk_cgxx_spu_sdsx_states_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t am_lock_invld_cnt     : 2;  /**< [ 51: 50](RO/H) Multi-lane BASE-R alignment marker lock state machine invalid AM counter. */
        uint64_t am_lock_sm            : 2;  /**< [ 49: 48](RO/H) Multi-lane BASE-R alignment marker lock state machine state. */
        uint64_t reserved_45_47        : 3;
        uint64_t train_sm              : 3;  /**< [ 44: 42](RO/H) Link training state machine state. */
        uint64_t train_code_viol       : 1;  /**< [ 41: 41](RO/H) Link training code violation in received control channel. */
        uint64_t train_frame_lock      : 1;  /**< [ 40: 40](RO/H) Link training frame lock status. */
        uint64_t train_lock_found_1st_marker : 1;/**< [ 39: 39](RO/H) Link training lock state machine found first marker flag. */
        uint64_t train_lock_bad_markers : 3; /**< [ 38: 36](RO/H) Link training lock state machine bad markers counter. */
        uint64_t reserved_35           : 1;
        uint64_t an_arb_sm             : 3;  /**< [ 34: 32](RO/H) Autonegotiation arbitration state machine state. */
        uint64_t an_rx_sm              : 2;  /**< [ 31: 30](RO/H) Autonegotiation receive state machine state. */
        uint64_t reserved_29           : 1;
        uint64_t fec_block_sync        : 1;  /**< [ 28: 28](RO/H) BASE-R FEC block sync status. */
        uint64_t fec_sync_cnt          : 4;  /**< [ 27: 24](RO/H) BASE-R FEC block sync state machine good/bad parity block counter. */
        uint64_t reserved_23           : 1;
        uint64_t br_sh_invld_cnt       : 7;  /**< [ 22: 16](RO/H) BASE-R lock state machine invalid sync header counter. */
        uint64_t br_block_lock         : 1;  /**< [ 15: 15](RO/H) BASE-R block lock status. */
        uint64_t br_sh_cnt             : 11; /**< [ 14:  4](RO/H) BASE-R lock state machine sync header counter */
        uint64_t bx_sync_sm            : 4;  /**< [  3:  0](RO/H) BASE-X PCS synchronization state machine state */
#else /* Word 0 - Little Endian */
        uint64_t bx_sync_sm            : 4;  /**< [  3:  0](RO/H) BASE-X PCS synchronization state machine state */
        uint64_t br_sh_cnt             : 11; /**< [ 14:  4](RO/H) BASE-R lock state machine sync header counter */
        uint64_t br_block_lock         : 1;  /**< [ 15: 15](RO/H) BASE-R block lock status. */
        uint64_t br_sh_invld_cnt       : 7;  /**< [ 22: 16](RO/H) BASE-R lock state machine invalid sync header counter. */
        uint64_t reserved_23           : 1;
        uint64_t fec_sync_cnt          : 4;  /**< [ 27: 24](RO/H) BASE-R FEC block sync state machine good/bad parity block counter. */
        uint64_t fec_block_sync        : 1;  /**< [ 28: 28](RO/H) BASE-R FEC block sync status. */
        uint64_t reserved_29           : 1;
        uint64_t an_rx_sm              : 2;  /**< [ 31: 30](RO/H) Autonegotiation receive state machine state. */
        uint64_t an_arb_sm             : 3;  /**< [ 34: 32](RO/H) Autonegotiation arbitration state machine state. */
        uint64_t reserved_35           : 1;
        uint64_t train_lock_bad_markers : 3; /**< [ 38: 36](RO/H) Link training lock state machine bad markers counter. */
        uint64_t train_lock_found_1st_marker : 1;/**< [ 39: 39](RO/H) Link training lock state machine found first marker flag. */
        uint64_t train_frame_lock      : 1;  /**< [ 40: 40](RO/H) Link training frame lock status. */
        uint64_t train_code_viol       : 1;  /**< [ 41: 41](RO/H) Link training code violation in received control channel. */
        uint64_t train_sm              : 3;  /**< [ 44: 42](RO/H) Link training state machine state. */
        uint64_t reserved_45_47        : 3;
        uint64_t am_lock_sm            : 2;  /**< [ 49: 48](RO/H) Multi-lane BASE-R alignment marker lock state machine state. */
        uint64_t am_lock_invld_cnt     : 2;  /**< [ 51: 50](RO/H) Multi-lane BASE-R alignment marker lock state machine invalid AM counter. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spu_sdsx_states_s cn; */
};
typedef union bdk_cgxx_spu_sdsx_states bdk_cgxx_spu_sdsx_states_t;

static inline uint64_t BDK_CGXX_SPU_SDSX_STATES(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPU_SDSX_STATES(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010360ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x87e0e0010360ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX) && ((a<=2) && (b<=3)))
        return 0x87e0e0010360ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=3) && (b<=3)))
        return 0x87e0e0010360ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("CGXX_SPU_SDSX_STATES", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPU_SDSX_STATES(a,b) bdk_cgxx_spu_sdsx_states_t
#define bustype_BDK_CGXX_SPU_SDSX_STATES(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPU_SDSX_STATES(a,b) "CGXX_SPU_SDSX_STATES"
#define device_bar_BDK_CGXX_SPU_SDSX_STATES(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPU_SDSX_STATES(a,b) (a)
#define arguments_BDK_CGXX_SPU_SDSX_STATES(a,b) (a),(b),-1,-1

/**
 * Register (RSL) cgx#_spu_usxgmii_control
 *
 * CGX SPU Common USXGMII Control Register
 * This register is the common control register that enables USXGMII Mode. The fields
 * in this register are preserved across any LMAC soft-resets. For an LMAC in soft-
 * reset state in USXGMII mode, the CGX will transmit Remote Fault BASE-R blocks.
 */
union bdk_cgxx_spu_usxgmii_control
{
    uint64_t u;
    struct bdk_cgxx_spu_usxgmii_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sds_id                : 2;  /**< [  5:  4](R/W) Specifies the USXGMII SerDes Lane. Since all LMACs within a CGX share the SerDes
                                                                 lane in USXGMII mode, this field specifies that shared lane. This field is
                                                                 required as during soft-reset of an LMAC, its CGX()_CMR()_CONFIG[LANE_TO_SDS]
                                                                 might not be available or might not be correctly configured. Overrides any
                                                                 setting in CGX()_CMR()_CONFIG[LANE_TO_SDS] when in USXGMII mode. Ignored if
                                                                 CGX()_SPU_USXGMII_CONTROL[ENABLE] is not set. */
        uint64_t usxgmii_type          : 3;  /**< [  3:  1](R/W) Specifies the USXGMII type. Ignored if CGX()_SPU_USXGMII_CONTROL[ENABLE] is not
                                                                 set. Enumerated by CGX_USXGMII_TYPE_E. Also reflected in
                                                                 CGX()_SPU()_CONTROL1[USXGMII_TYPE]. */
        uint64_t enable                : 1;  /**< [  0:  0](R/W) Enables USXGMII mode. Identifies the mode of
                                                                 operation for the CGX even when a sub-set of the associated LMACs are in soft-
                                                                 reset state. During a soft-reset of an LMAC in USXGMII mode, the associated
                                                                 attributes for that LMAC in CGX()_CMR()_CONFIG are not available, but the CGX is
                                                                 still required to operate in USXGMII mode as other LMACs might not be in soft-
                                                                 reset state. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 1;  /**< [  0:  0](R/W) Enables USXGMII mode. Identifies the mode of
                                                                 operation for the CGX even when a sub-set of the associated LMACs are in soft-
                                                                 reset state. During a soft-reset of an LMAC in USXGMII mode, the associated
                                                                 attributes for that LMAC in CGX()_CMR()_CONFIG are not available, but the CGX is
                                                                 still required to operate in USXGMII mode as other LMACs might not be in soft-
                                                                 reset state. */
        uint64_t usxgmii_type          : 3;  /**< [  3:  1](R/W) Specifies the USXGMII type. Ignored if CGX()_SPU_USXGMII_CONTROL[ENABLE] is not
                                                                 set. Enumerated by CGX_USXGMII_TYPE_E. Also reflected in
                                                                 CGX()_SPU()_CONTROL1[USXGMII_TYPE]. */
        uint64_t sds_id                : 2;  /**< [  5:  4](R/W) Specifies the USXGMII SerDes Lane. Since all LMACs within a CGX share the SerDes
                                                                 lane in USXGMII mode, this field specifies that shared lane. This field is
                                                                 required as during soft-reset of an LMAC, its CGX()_CMR()_CONFIG[LANE_TO_SDS]
                                                                 might not be available or might not be correctly configured. Overrides any
                                                                 setting in CGX()_CMR()_CONFIG[LANE_TO_SDS] when in USXGMII mode. Ignored if
                                                                 CGX()_SPU_USXGMII_CONTROL[ENABLE] is not set. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_cgxx_spu_usxgmii_control_s cn; */
};
typedef union bdk_cgxx_spu_usxgmii_control bdk_cgxx_spu_usxgmii_control_t;

static inline uint64_t BDK_CGXX_SPU_USXGMII_CONTROL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_CGXX_SPU_USXGMII_CONTROL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=2))
        return 0x87e0e0010920ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x87e0e0010920ll + 0x1000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX) && (a<=2))
        return 0x87e0e0010920ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0e0010920ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("CGXX_SPU_USXGMII_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_CGXX_SPU_USXGMII_CONTROL(a) bdk_cgxx_spu_usxgmii_control_t
#define bustype_BDK_CGXX_SPU_USXGMII_CONTROL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_CGXX_SPU_USXGMII_CONTROL(a) "CGXX_SPU_USXGMII_CONTROL"
#define device_bar_BDK_CGXX_SPU_USXGMII_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_CGXX_SPU_USXGMII_CONTROL(a) (a)
#define arguments_BDK_CGXX_SPU_USXGMII_CONTROL(a) (a),-1,-1,-1

#endif /* __BDK_CSRS_CGX_H__ */
