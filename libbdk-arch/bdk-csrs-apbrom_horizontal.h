#ifndef __BDK_CSRS_APBROM_HORIZONTAL_H__
#define __BDK_CSRS_APBROM_HORIZONTAL_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX APBROM_HORIZONTAL.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Register (RSL32b) apbrom_horizontal_authstatus
 *
 * APBROM Horizontal Authstatus Register
 * Reports the current status of the authentication control signals.
 */
union bdk_apbrom_horizontal_authstatus
{
    uint32_t u;
    struct bdk_apbrom_horizontal_authstatus_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
#else /* Word 0 - Little Endian */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_authstatus_s cn; */
};
typedef union bdk_apbrom_horizontal_authstatus bdk_apbrom_horizontal_authstatus_t;

#define BDK_APBROM_HORIZONTAL_AUTHSTATUS BDK_APBROM_HORIZONTAL_AUTHSTATUS_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_AUTHSTATUS_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_AUTHSTATUS_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fb8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_AUTHSTATUS", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_AUTHSTATUS bdk_apbrom_horizontal_authstatus_t
#define bustype_BDK_APBROM_HORIZONTAL_AUTHSTATUS BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_AUTHSTATUS "APBROM_HORIZONTAL_AUTHSTATUS"
#define busnum_BDK_APBROM_HORIZONTAL_AUTHSTATUS 0
#define arguments_BDK_APBROM_HORIZONTAL_AUTHSTATUS -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr0
 *
 * APBROM Horizontal Cidr0 Register
 * The CIDR0 register is part of the set of component identification registers.
 */
union bdk_apbrom_horizontal_cidr0
{
    uint32_t u;
    struct bdk_apbrom_horizontal_cidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_cidr0_s cn; */
};
typedef union bdk_apbrom_horizontal_cidr0 bdk_apbrom_horizontal_cidr0_t;

#define BDK_APBROM_HORIZONTAL_CIDR0 BDK_APBROM_HORIZONTAL_CIDR0_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR0_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000ff0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_CIDR0", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_CIDR0 bdk_apbrom_horizontal_cidr0_t
#define bustype_BDK_APBROM_HORIZONTAL_CIDR0 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_CIDR0 "APBROM_HORIZONTAL_CIDR0"
#define busnum_BDK_APBROM_HORIZONTAL_CIDR0 0
#define arguments_BDK_APBROM_HORIZONTAL_CIDR0 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr1
 *
 * APBROM Horizontal Cidr1 Register
 * The CIDR1 register is part of the set of component identification registers.
 */
union bdk_apbrom_horizontal_cidr1
{
    uint32_t u;
    struct bdk_apbrom_horizontal_cidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_cidr1_s cn; */
};
typedef union bdk_apbrom_horizontal_cidr1 bdk_apbrom_horizontal_cidr1_t;

#define BDK_APBROM_HORIZONTAL_CIDR1 BDK_APBROM_HORIZONTAL_CIDR1_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR1_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000ff4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_CIDR1", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_CIDR1 bdk_apbrom_horizontal_cidr1_t
#define bustype_BDK_APBROM_HORIZONTAL_CIDR1 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_CIDR1 "APBROM_HORIZONTAL_CIDR1"
#define busnum_BDK_APBROM_HORIZONTAL_CIDR1 0
#define arguments_BDK_APBROM_HORIZONTAL_CIDR1 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr2
 *
 * APBROM Horizontal Cidr2 Register
 * The CIDR2 register is part of the set of component identification registers.
 */
union bdk_apbrom_horizontal_cidr2
{
    uint32_t u;
    struct bdk_apbrom_horizontal_cidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_cidr2_s cn; */
};
typedef union bdk_apbrom_horizontal_cidr2 bdk_apbrom_horizontal_cidr2_t;

#define BDK_APBROM_HORIZONTAL_CIDR2 BDK_APBROM_HORIZONTAL_CIDR2_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR2_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000ff8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_CIDR2", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_CIDR2 bdk_apbrom_horizontal_cidr2_t
#define bustype_BDK_APBROM_HORIZONTAL_CIDR2 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_CIDR2 "APBROM_HORIZONTAL_CIDR2"
#define busnum_BDK_APBROM_HORIZONTAL_CIDR2 0
#define arguments_BDK_APBROM_HORIZONTAL_CIDR2 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_cidr3
 *
 * APBROM Horizontal Cidr3 Register
 * The CIDR3 register is part of the set of component identification registers.
 */
union bdk_apbrom_horizontal_cidr3
{
    uint32_t u;
    struct bdk_apbrom_horizontal_cidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_cidr3_s cn; */
};
typedef union bdk_apbrom_horizontal_cidr3 bdk_apbrom_horizontal_cidr3_t;

#define BDK_APBROM_HORIZONTAL_CIDR3 BDK_APBROM_HORIZONTAL_CIDR3_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_CIDR3_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000ffcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_CIDR3", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_CIDR3 bdk_apbrom_horizontal_cidr3_t
#define bustype_BDK_APBROM_HORIZONTAL_CIDR3 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_CIDR3 "APBROM_HORIZONTAL_CIDR3"
#define busnum_BDK_APBROM_HORIZONTAL_CIDR3 0
#define arguments_BDK_APBROM_HORIZONTAL_CIDR3 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_devarch
 *
 * APBROM Horizontal Devarch Register
 * Identifies the architect and architecture of a CoreSight component. The architect
 * might differ from the designer of a component, for example Arm defines the
 * architecture but another company designs and implements the component.
 */
union bdk_apbrom_horizontal_devarch
{
    uint32_t u;
    struct bdk_apbrom_horizontal_devarch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
#else /* Word 0 - Little Endian */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_devarch_s cn; */
};
typedef union bdk_apbrom_horizontal_devarch bdk_apbrom_horizontal_devarch_t;

#define BDK_APBROM_HORIZONTAL_DEVARCH BDK_APBROM_HORIZONTAL_DEVARCH_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_DEVARCH_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_DEVARCH_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fbcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_DEVARCH", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_DEVARCH bdk_apbrom_horizontal_devarch_t
#define bustype_BDK_APBROM_HORIZONTAL_DEVARCH BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_DEVARCH "APBROM_HORIZONTAL_DEVARCH"
#define busnum_BDK_APBROM_HORIZONTAL_DEVARCH 0
#define arguments_BDK_APBROM_HORIZONTAL_DEVARCH -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_devid
 *
 * APBROM Horizontal Devid Register
 * This register is IMPLEMENTATION DEFINED for each Part Number and Designer. The
 * register indicates the capabilities of the component.
 */
union bdk_apbrom_horizontal_devid
{
    uint32_t u;
    struct bdk_apbrom_horizontal_devid_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
#else /* Word 0 - Little Endian */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_devid_s cn; */
};
typedef union bdk_apbrom_horizontal_devid bdk_apbrom_horizontal_devid_t;

#define BDK_APBROM_HORIZONTAL_DEVID BDK_APBROM_HORIZONTAL_DEVID_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_DEVID_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_DEVID_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fc8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_DEVID", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_DEVID bdk_apbrom_horizontal_devid_t
#define bustype_BDK_APBROM_HORIZONTAL_DEVID BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_DEVID "APBROM_HORIZONTAL_DEVID"
#define busnum_BDK_APBROM_HORIZONTAL_DEVID 0
#define arguments_BDK_APBROM_HORIZONTAL_DEVID -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr0
 *
 * APBROM Horizontal Pidr0 Register
 * The PIDR0 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr0
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
#else /* Word 0 - Little Endian */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr0_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr0 bdk_apbrom_horizontal_pidr0_t;

#define BDK_APBROM_HORIZONTAL_PIDR0 BDK_APBROM_HORIZONTAL_PIDR0_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR0_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fe0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR0", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR0 bdk_apbrom_horizontal_pidr0_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR0 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR0 "APBROM_HORIZONTAL_PIDR0"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR0 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR0 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr1
 *
 * APBROM Horizontal Pidr1 Register
 * The PIDR1 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr1
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
#else /* Word 0 - Little Endian */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr1_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr1 bdk_apbrom_horizontal_pidr1_t;

#define BDK_APBROM_HORIZONTAL_PIDR1 BDK_APBROM_HORIZONTAL_PIDR1_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR1_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fe4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR1", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR1 bdk_apbrom_horizontal_pidr1_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR1 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR1 "APBROM_HORIZONTAL_PIDR1"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR1 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR1 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr2
 *
 * APBROM Horizontal Pidr2 Register
 * The PIDR2 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr2
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
#else /* Word 0 - Little Endian */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr2_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr2 bdk_apbrom_horizontal_pidr2_t;

#define BDK_APBROM_HORIZONTAL_PIDR2 BDK_APBROM_HORIZONTAL_PIDR2_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR2_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fe8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR2", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR2 bdk_apbrom_horizontal_pidr2_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR2 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR2 "APBROM_HORIZONTAL_PIDR2"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR2 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR2 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr3
 *
 * APBROM Horizontal Pidr3 Register
 * The PIDR3 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr3
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr3_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr3 bdk_apbrom_horizontal_pidr3_t;

#define BDK_APBROM_HORIZONTAL_PIDR3 BDK_APBROM_HORIZONTAL_PIDR3_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR3_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR3", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR3 bdk_apbrom_horizontal_pidr3_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR3 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR3 "APBROM_HORIZONTAL_PIDR3"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR3 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR3 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr4
 *
 * APBROM Horizontal Pidr4 Register
 * The PIDR4 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr4
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
#else /* Word 0 - Little Endian */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr4_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr4 bdk_apbrom_horizontal_pidr4_t;

#define BDK_APBROM_HORIZONTAL_PIDR4 BDK_APBROM_HORIZONTAL_PIDR4_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR4_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fd0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR4", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR4 bdk_apbrom_horizontal_pidr4_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR4 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR4 "APBROM_HORIZONTAL_PIDR4"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR4 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR4 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr5
 *
 * APBROM Horizontal Pidr5 Register
 * The PIDR5 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr5
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr5_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr5 bdk_apbrom_horizontal_pidr5_t;

#define BDK_APBROM_HORIZONTAL_PIDR5 BDK_APBROM_HORIZONTAL_PIDR5_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR5_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fd4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR5", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR5 bdk_apbrom_horizontal_pidr5_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR5 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR5 "APBROM_HORIZONTAL_PIDR5"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR5 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR5 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr6
 *
 * APBROM Horizontal Pidr6 Register
 * The PIDR6 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr6
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr6_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr6 bdk_apbrom_horizontal_pidr6_t;

#define BDK_APBROM_HORIZONTAL_PIDR6 BDK_APBROM_HORIZONTAL_PIDR6_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR6_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fd8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR6", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR6 bdk_apbrom_horizontal_pidr6_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR6 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR6 "APBROM_HORIZONTAL_PIDR6"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR6 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR6 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_pidr7
 *
 * APBROM Horizontal Pidr7 Register
 * The PIDR7 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_horizontal_pidr7
{
    uint32_t u;
    struct bdk_apbrom_horizontal_pidr7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_pidr7_s cn; */
};
typedef union bdk_apbrom_horizontal_pidr7 bdk_apbrom_horizontal_pidr7_t;

#define BDK_APBROM_HORIZONTAL_PIDR7 BDK_APBROM_HORIZONTAL_PIDR7_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_PIDR7_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000fdcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_PIDR7", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_PIDR7 bdk_apbrom_horizontal_pidr7_t
#define bustype_BDK_APBROM_HORIZONTAL_PIDR7 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_PIDR7 "APBROM_HORIZONTAL_PIDR7"
#define busnum_BDK_APBROM_HORIZONTAL_PIDR7 0
#define arguments_BDK_APBROM_HORIZONTAL_PIDR7 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry0
 *
 * APBROM Horizontal Romentry0 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry0
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry0_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry0 bdk_apbrom_horizontal_romentry0_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY0 BDK_APBROM_HORIZONTAL_ROMENTRY0_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY0_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000000ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY0", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY0 bdk_apbrom_horizontal_romentry0_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY0 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY0 "APBROM_HORIZONTAL_ROMENTRY0"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY0 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY0 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry1
 *
 * APBROM Horizontal Romentry1 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry1
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry1_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry1 bdk_apbrom_horizontal_romentry1_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY1 BDK_APBROM_HORIZONTAL_ROMENTRY1_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY1_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000004ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY1", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY1 bdk_apbrom_horizontal_romentry1_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY1 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY1 "APBROM_HORIZONTAL_ROMENTRY1"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY1 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY1 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry10
 *
 * APBROM Horizontal Romentry10 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry10
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry10_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry10 bdk_apbrom_horizontal_romentry10_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY10 BDK_APBROM_HORIZONTAL_ROMENTRY10_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY10_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY10_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000028ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY10", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY10 bdk_apbrom_horizontal_romentry10_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY10 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY10 "APBROM_HORIZONTAL_ROMENTRY10"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY10 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY10 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry100
 *
 * APBROM Horizontal Romentry100 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry100
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry100_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry100_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry100 bdk_apbrom_horizontal_romentry100_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY100 BDK_APBROM_HORIZONTAL_ROMENTRY100_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY100_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY100_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000190ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY100", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY100 bdk_apbrom_horizontal_romentry100_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY100 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY100 "APBROM_HORIZONTAL_ROMENTRY100"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY100 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY100 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry101
 *
 * APBROM Horizontal Romentry101 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry101
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry101_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry101_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry101 bdk_apbrom_horizontal_romentry101_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY101 BDK_APBROM_HORIZONTAL_ROMENTRY101_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY101_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY101_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000194ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY101", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY101 bdk_apbrom_horizontal_romentry101_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY101 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY101 "APBROM_HORIZONTAL_ROMENTRY101"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY101 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY101 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry102
 *
 * APBROM Horizontal Romentry102 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry102
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry102_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry102_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry102 bdk_apbrom_horizontal_romentry102_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY102 BDK_APBROM_HORIZONTAL_ROMENTRY102_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY102_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY102_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000198ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY102", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY102 bdk_apbrom_horizontal_romentry102_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY102 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY102 "APBROM_HORIZONTAL_ROMENTRY102"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY102 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY102 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry103
 *
 * APBROM Horizontal Romentry103 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry103
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry103_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry103_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry103 bdk_apbrom_horizontal_romentry103_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY103 BDK_APBROM_HORIZONTAL_ROMENTRY103_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY103_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY103_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600019cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY103", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY103 bdk_apbrom_horizontal_romentry103_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY103 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY103 "APBROM_HORIZONTAL_ROMENTRY103"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY103 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY103 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry104
 *
 * APBROM Horizontal Romentry104 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry104
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry104_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry104 bdk_apbrom_horizontal_romentry104_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY104 BDK_APBROM_HORIZONTAL_ROMENTRY104_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY104_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY104_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY104", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY104 bdk_apbrom_horizontal_romentry104_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY104 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY104 "APBROM_HORIZONTAL_ROMENTRY104"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY104 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY104 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry105
 *
 * APBROM Horizontal Romentry105 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry105
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry105_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry105_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry105 bdk_apbrom_horizontal_romentry105_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY105 BDK_APBROM_HORIZONTAL_ROMENTRY105_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY105_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY105_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY105", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY105 bdk_apbrom_horizontal_romentry105_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY105 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY105 "APBROM_HORIZONTAL_ROMENTRY105"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY105 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY105 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry106
 *
 * APBROM Horizontal Romentry106 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry106
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry106_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry106_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry106 bdk_apbrom_horizontal_romentry106_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY106 BDK_APBROM_HORIZONTAL_ROMENTRY106_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY106_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY106_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY106", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY106 bdk_apbrom_horizontal_romentry106_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY106 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY106 "APBROM_HORIZONTAL_ROMENTRY106"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY106 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY106 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry107
 *
 * APBROM Horizontal Romentry107 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry107
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry107_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry107_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry107 bdk_apbrom_horizontal_romentry107_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY107 BDK_APBROM_HORIZONTAL_ROMENTRY107_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY107_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY107_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY107", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY107 bdk_apbrom_horizontal_romentry107_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY107 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY107 "APBROM_HORIZONTAL_ROMENTRY107"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY107 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY107 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry108
 *
 * APBROM Horizontal Romentry108 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry108
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry108_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry108_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry108 bdk_apbrom_horizontal_romentry108_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY108 BDK_APBROM_HORIZONTAL_ROMENTRY108_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY108_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY108_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY108", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY108 bdk_apbrom_horizontal_romentry108_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY108 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY108 "APBROM_HORIZONTAL_ROMENTRY108"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY108 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY108 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry109
 *
 * APBROM Horizontal Romentry109 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry109
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry109_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry109_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry109 bdk_apbrom_horizontal_romentry109_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY109 BDK_APBROM_HORIZONTAL_ROMENTRY109_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY109_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY109_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY109", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY109 bdk_apbrom_horizontal_romentry109_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY109 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY109 "APBROM_HORIZONTAL_ROMENTRY109"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY109 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY109 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry11
 *
 * APBROM Horizontal Romentry11 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry11
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry11_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry11 bdk_apbrom_horizontal_romentry11_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY11 BDK_APBROM_HORIZONTAL_ROMENTRY11_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY11_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY11_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600002cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY11", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY11 bdk_apbrom_horizontal_romentry11_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY11 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY11 "APBROM_HORIZONTAL_ROMENTRY11"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY11 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY11 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry110
 *
 * APBROM Horizontal Romentry110 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry110
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry110_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry110_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry110 bdk_apbrom_horizontal_romentry110_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY110 BDK_APBROM_HORIZONTAL_ROMENTRY110_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY110_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY110_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY110", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY110 bdk_apbrom_horizontal_romentry110_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY110 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY110 "APBROM_HORIZONTAL_ROMENTRY110"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY110 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY110 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry111
 *
 * APBROM Horizontal Romentry111 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry111
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry111_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry111_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry111 bdk_apbrom_horizontal_romentry111_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY111 BDK_APBROM_HORIZONTAL_ROMENTRY111_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY111_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY111_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY111", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY111 bdk_apbrom_horizontal_romentry111_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY111 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY111 "APBROM_HORIZONTAL_ROMENTRY111"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY111 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY111 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry112
 *
 * APBROM Horizontal Romentry112 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry112
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry112_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry112 bdk_apbrom_horizontal_romentry112_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY112 BDK_APBROM_HORIZONTAL_ROMENTRY112_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY112_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY112_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY112", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY112 bdk_apbrom_horizontal_romentry112_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY112 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY112 "APBROM_HORIZONTAL_ROMENTRY112"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY112 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY112 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry113
 *
 * APBROM Horizontal Romentry113 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry113
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry113_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry113_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry113 bdk_apbrom_horizontal_romentry113_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY113 BDK_APBROM_HORIZONTAL_ROMENTRY113_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY113_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY113_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY113", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY113 bdk_apbrom_horizontal_romentry113_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY113 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY113 "APBROM_HORIZONTAL_ROMENTRY113"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY113 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY113 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry114
 *
 * APBROM Horizontal Romentry114 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry114
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry114_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry114_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry114 bdk_apbrom_horizontal_romentry114_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY114 BDK_APBROM_HORIZONTAL_ROMENTRY114_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY114_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY114_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY114", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY114 bdk_apbrom_horizontal_romentry114_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY114 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY114 "APBROM_HORIZONTAL_ROMENTRY114"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY114 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY114 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry115
 *
 * APBROM Horizontal Romentry115 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry115
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry115_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry115_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry115 bdk_apbrom_horizontal_romentry115_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY115 BDK_APBROM_HORIZONTAL_ROMENTRY115_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY115_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY115_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY115", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY115 bdk_apbrom_horizontal_romentry115_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY115 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY115 "APBROM_HORIZONTAL_ROMENTRY115"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY115 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY115 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry116
 *
 * APBROM Horizontal Romentry116 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry116
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry116_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry116_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry116 bdk_apbrom_horizontal_romentry116_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY116 BDK_APBROM_HORIZONTAL_ROMENTRY116_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY116_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY116_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY116", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY116 bdk_apbrom_horizontal_romentry116_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY116 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY116 "APBROM_HORIZONTAL_ROMENTRY116"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY116 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY116 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry117
 *
 * APBROM Horizontal Romentry117 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry117
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry117_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry117_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry117 bdk_apbrom_horizontal_romentry117_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY117 BDK_APBROM_HORIZONTAL_ROMENTRY117_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY117_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY117_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY117", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY117 bdk_apbrom_horizontal_romentry117_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY117 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY117 "APBROM_HORIZONTAL_ROMENTRY117"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY117 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY117 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry118
 *
 * APBROM Horizontal Romentry118 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry118
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry118_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry118_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry118 bdk_apbrom_horizontal_romentry118_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY118 BDK_APBROM_HORIZONTAL_ROMENTRY118_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY118_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY118_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY118", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY118 bdk_apbrom_horizontal_romentry118_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY118 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY118 "APBROM_HORIZONTAL_ROMENTRY118"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY118 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY118 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry119
 *
 * APBROM Horizontal Romentry119 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry119
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry119_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry119_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry119 bdk_apbrom_horizontal_romentry119_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY119 BDK_APBROM_HORIZONTAL_ROMENTRY119_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY119_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY119_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY119", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY119 bdk_apbrom_horizontal_romentry119_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY119 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY119 "APBROM_HORIZONTAL_ROMENTRY119"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY119 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY119 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry12
 *
 * APBROM Horizontal Romentry12 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry12
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry12_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry12 bdk_apbrom_horizontal_romentry12_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY12 BDK_APBROM_HORIZONTAL_ROMENTRY12_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY12_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY12_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000030ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY12", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY12 bdk_apbrom_horizontal_romentry12_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY12 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY12 "APBROM_HORIZONTAL_ROMENTRY12"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY12 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY12 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry120
 *
 * APBROM Horizontal Romentry120 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry120
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry120_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry120 bdk_apbrom_horizontal_romentry120_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY120 BDK_APBROM_HORIZONTAL_ROMENTRY120_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY120_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY120_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY120", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY120 bdk_apbrom_horizontal_romentry120_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY120 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY120 "APBROM_HORIZONTAL_ROMENTRY120"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY120 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY120 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry121
 *
 * APBROM Horizontal Romentry121 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry121
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry121_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry121_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry121 bdk_apbrom_horizontal_romentry121_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY121 BDK_APBROM_HORIZONTAL_ROMENTRY121_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY121_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY121_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY121", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY121 bdk_apbrom_horizontal_romentry121_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY121 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY121 "APBROM_HORIZONTAL_ROMENTRY121"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY121 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY121 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry122
 *
 * APBROM Horizontal Romentry122 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry122
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry122_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry122_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry122 bdk_apbrom_horizontal_romentry122_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY122 BDK_APBROM_HORIZONTAL_ROMENTRY122_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY122_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY122_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY122", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY122 bdk_apbrom_horizontal_romentry122_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY122 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY122 "APBROM_HORIZONTAL_ROMENTRY122"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY122 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY122 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry123
 *
 * APBROM Horizontal Romentry123 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry123
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry123_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry123_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry123 bdk_apbrom_horizontal_romentry123_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY123 BDK_APBROM_HORIZONTAL_ROMENTRY123_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY123_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY123_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY123", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY123 bdk_apbrom_horizontal_romentry123_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY123 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY123 "APBROM_HORIZONTAL_ROMENTRY123"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY123 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY123 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry124
 *
 * APBROM Horizontal Romentry124 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry124
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry124_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry124_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry124 bdk_apbrom_horizontal_romentry124_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY124 BDK_APBROM_HORIZONTAL_ROMENTRY124_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY124_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY124_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY124", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY124 bdk_apbrom_horizontal_romentry124_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY124 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY124 "APBROM_HORIZONTAL_ROMENTRY124"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY124 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY124 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry125
 *
 * APBROM Horizontal Romentry125 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry125
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry125_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry125_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry125 bdk_apbrom_horizontal_romentry125_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY125 BDK_APBROM_HORIZONTAL_ROMENTRY125_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY125_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY125_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY125", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY125 bdk_apbrom_horizontal_romentry125_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY125 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY125 "APBROM_HORIZONTAL_ROMENTRY125"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY125 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY125 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry126
 *
 * APBROM Horizontal Romentry126 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry126
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry126_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry126_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry126 bdk_apbrom_horizontal_romentry126_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY126 BDK_APBROM_HORIZONTAL_ROMENTRY126_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY126_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY126_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY126", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY126 bdk_apbrom_horizontal_romentry126_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY126 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY126 "APBROM_HORIZONTAL_ROMENTRY126"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY126 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY126 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry127
 *
 * APBROM Horizontal Romentry127 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry127
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry127_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry127_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry127 bdk_apbrom_horizontal_romentry127_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY127 BDK_APBROM_HORIZONTAL_ROMENTRY127_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY127_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY127_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460001fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY127", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY127 bdk_apbrom_horizontal_romentry127_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY127 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY127 "APBROM_HORIZONTAL_ROMENTRY127"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY127 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY127 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry128
 *
 * APBROM Horizontal Romentry128 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry128
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry128_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry128 bdk_apbrom_horizontal_romentry128_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY128 BDK_APBROM_HORIZONTAL_ROMENTRY128_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY128_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY128_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000200ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY128", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY128 bdk_apbrom_horizontal_romentry128_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY128 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY128 "APBROM_HORIZONTAL_ROMENTRY128"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY128 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY128 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry129
 *
 * APBROM Horizontal Romentry129 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry129
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry129_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry129_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry129 bdk_apbrom_horizontal_romentry129_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY129 BDK_APBROM_HORIZONTAL_ROMENTRY129_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY129_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY129_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000204ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY129", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY129 bdk_apbrom_horizontal_romentry129_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY129 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY129 "APBROM_HORIZONTAL_ROMENTRY129"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY129 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY129 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry13
 *
 * APBROM Horizontal Romentry13 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry13
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry13_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry13 bdk_apbrom_horizontal_romentry13_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY13 BDK_APBROM_HORIZONTAL_ROMENTRY13_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY13_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY13_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000034ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY13", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY13 bdk_apbrom_horizontal_romentry13_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY13 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY13 "APBROM_HORIZONTAL_ROMENTRY13"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY13 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY13 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry130
 *
 * APBROM Horizontal Romentry130 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry130
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry130_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry130_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry130 bdk_apbrom_horizontal_romentry130_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY130 BDK_APBROM_HORIZONTAL_ROMENTRY130_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY130_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY130_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000208ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY130", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY130 bdk_apbrom_horizontal_romentry130_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY130 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY130 "APBROM_HORIZONTAL_ROMENTRY130"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY130 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY130 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry131
 *
 * APBROM Horizontal Romentry131 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry131
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry131_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry131_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry131 bdk_apbrom_horizontal_romentry131_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY131 BDK_APBROM_HORIZONTAL_ROMENTRY131_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY131_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY131_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600020cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY131", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY131 bdk_apbrom_horizontal_romentry131_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY131 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY131 "APBROM_HORIZONTAL_ROMENTRY131"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY131 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY131 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry132
 *
 * APBROM Horizontal Romentry132 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry132
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry132_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry132_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry132 bdk_apbrom_horizontal_romentry132_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY132 BDK_APBROM_HORIZONTAL_ROMENTRY132_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY132_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY132_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000210ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY132", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY132 bdk_apbrom_horizontal_romentry132_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY132 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY132 "APBROM_HORIZONTAL_ROMENTRY132"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY132 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY132 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry133
 *
 * APBROM Horizontal Romentry133 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry133
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry133_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry133_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry133 bdk_apbrom_horizontal_romentry133_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY133 BDK_APBROM_HORIZONTAL_ROMENTRY133_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY133_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY133_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000214ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY133", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY133 bdk_apbrom_horizontal_romentry133_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY133 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY133 "APBROM_HORIZONTAL_ROMENTRY133"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY133 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY133 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry134
 *
 * APBROM Horizontal Romentry134 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry134
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry134_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry134_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry134 bdk_apbrom_horizontal_romentry134_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY134 BDK_APBROM_HORIZONTAL_ROMENTRY134_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY134_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY134_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000218ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY134", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY134 bdk_apbrom_horizontal_romentry134_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY134 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY134 "APBROM_HORIZONTAL_ROMENTRY134"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY134 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY134 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry135
 *
 * APBROM Horizontal Romentry135 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry135
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry135_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry135_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry135 bdk_apbrom_horizontal_romentry135_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY135 BDK_APBROM_HORIZONTAL_ROMENTRY135_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY135_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY135_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600021cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY135", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY135 bdk_apbrom_horizontal_romentry135_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY135 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY135 "APBROM_HORIZONTAL_ROMENTRY135"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY135 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY135 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry136
 *
 * APBROM Horizontal Romentry136 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry136
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry136_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry136 bdk_apbrom_horizontal_romentry136_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY136 BDK_APBROM_HORIZONTAL_ROMENTRY136_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY136_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY136_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000220ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY136", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY136 bdk_apbrom_horizontal_romentry136_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY136 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY136 "APBROM_HORIZONTAL_ROMENTRY136"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY136 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY136 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry137
 *
 * APBROM Horizontal Romentry137 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry137
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry137_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry137_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry137 bdk_apbrom_horizontal_romentry137_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY137 BDK_APBROM_HORIZONTAL_ROMENTRY137_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY137_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY137_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000224ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY137", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY137 bdk_apbrom_horizontal_romentry137_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY137 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY137 "APBROM_HORIZONTAL_ROMENTRY137"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY137 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY137 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry138
 *
 * APBROM Horizontal Romentry138 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry138
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry138_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry138_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry138 bdk_apbrom_horizontal_romentry138_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY138 BDK_APBROM_HORIZONTAL_ROMENTRY138_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY138_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY138_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000228ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY138", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY138 bdk_apbrom_horizontal_romentry138_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY138 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY138 "APBROM_HORIZONTAL_ROMENTRY138"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY138 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY138 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry139
 *
 * APBROM Horizontal Romentry139 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry139
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry139_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry139_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry139 bdk_apbrom_horizontal_romentry139_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY139 BDK_APBROM_HORIZONTAL_ROMENTRY139_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY139_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY139_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600022cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY139", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY139 bdk_apbrom_horizontal_romentry139_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY139 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY139 "APBROM_HORIZONTAL_ROMENTRY139"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY139 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY139 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry14
 *
 * APBROM Horizontal Romentry14 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry14
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry14_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry14 bdk_apbrom_horizontal_romentry14_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY14 BDK_APBROM_HORIZONTAL_ROMENTRY14_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY14_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY14_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000038ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY14", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY14 bdk_apbrom_horizontal_romentry14_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY14 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY14 "APBROM_HORIZONTAL_ROMENTRY14"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY14 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY14 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry140
 *
 * APBROM Horizontal Romentry140 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry140
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry140_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry140_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry140 bdk_apbrom_horizontal_romentry140_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY140 BDK_APBROM_HORIZONTAL_ROMENTRY140_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY140_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY140_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000230ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY140", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY140 bdk_apbrom_horizontal_romentry140_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY140 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY140 "APBROM_HORIZONTAL_ROMENTRY140"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY140 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY140 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry141
 *
 * APBROM Horizontal Romentry141 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry141
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry141_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry141_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry141 bdk_apbrom_horizontal_romentry141_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY141 BDK_APBROM_HORIZONTAL_ROMENTRY141_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY141_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY141_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000234ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY141", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY141 bdk_apbrom_horizontal_romentry141_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY141 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY141 "APBROM_HORIZONTAL_ROMENTRY141"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY141 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY141 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry142
 *
 * APBROM Horizontal Romentry142 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry142
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry142_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry142_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry142 bdk_apbrom_horizontal_romentry142_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY142 BDK_APBROM_HORIZONTAL_ROMENTRY142_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY142_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY142_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000238ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY142", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY142 bdk_apbrom_horizontal_romentry142_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY142 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY142 "APBROM_HORIZONTAL_ROMENTRY142"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY142 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY142 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry143
 *
 * APBROM Horizontal Romentry143 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry143
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry143_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry143_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry143 bdk_apbrom_horizontal_romentry143_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY143 BDK_APBROM_HORIZONTAL_ROMENTRY143_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY143_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY143_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600023cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY143", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY143 bdk_apbrom_horizontal_romentry143_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY143 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY143 "APBROM_HORIZONTAL_ROMENTRY143"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY143 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY143 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry144
 *
 * APBROM Horizontal Romentry144 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry144
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry144_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry144 bdk_apbrom_horizontal_romentry144_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY144 BDK_APBROM_HORIZONTAL_ROMENTRY144_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY144_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY144_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000240ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY144", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY144 bdk_apbrom_horizontal_romentry144_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY144 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY144 "APBROM_HORIZONTAL_ROMENTRY144"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY144 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY144 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry145
 *
 * APBROM Horizontal Romentry145 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry145
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry145_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry145_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry145 bdk_apbrom_horizontal_romentry145_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY145 BDK_APBROM_HORIZONTAL_ROMENTRY145_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY145_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY145_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000244ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY145", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY145 bdk_apbrom_horizontal_romentry145_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY145 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY145 "APBROM_HORIZONTAL_ROMENTRY145"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY145 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY145 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry146
 *
 * APBROM Horizontal Romentry146 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry146
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry146_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry146_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry146 bdk_apbrom_horizontal_romentry146_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY146 BDK_APBROM_HORIZONTAL_ROMENTRY146_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY146_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY146_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000248ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY146", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY146 bdk_apbrom_horizontal_romentry146_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY146 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY146 "APBROM_HORIZONTAL_ROMENTRY146"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY146 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY146 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry147
 *
 * APBROM Horizontal Romentry147 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry147
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry147_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry147_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry147 bdk_apbrom_horizontal_romentry147_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY147 BDK_APBROM_HORIZONTAL_ROMENTRY147_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY147_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY147_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600024cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY147", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY147 bdk_apbrom_horizontal_romentry147_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY147 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY147 "APBROM_HORIZONTAL_ROMENTRY147"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY147 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY147 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry148
 *
 * APBROM Horizontal Romentry148 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry148
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry148_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry148_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry148 bdk_apbrom_horizontal_romentry148_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY148 BDK_APBROM_HORIZONTAL_ROMENTRY148_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY148_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY148_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000250ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY148", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY148 bdk_apbrom_horizontal_romentry148_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY148 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY148 "APBROM_HORIZONTAL_ROMENTRY148"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY148 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY148 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry149
 *
 * APBROM Horizontal Romentry149 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry149
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry149_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry149_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry149 bdk_apbrom_horizontal_romentry149_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY149 BDK_APBROM_HORIZONTAL_ROMENTRY149_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY149_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY149_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000254ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY149", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY149 bdk_apbrom_horizontal_romentry149_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY149 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY149 "APBROM_HORIZONTAL_ROMENTRY149"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY149 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY149 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry15
 *
 * APBROM Horizontal Romentry15 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry15
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry15_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry15 bdk_apbrom_horizontal_romentry15_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY15 BDK_APBROM_HORIZONTAL_ROMENTRY15_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY15_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY15_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600003cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY15", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY15 bdk_apbrom_horizontal_romentry15_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY15 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY15 "APBROM_HORIZONTAL_ROMENTRY15"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY15 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY15 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry150
 *
 * APBROM Horizontal Romentry150 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry150
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry150_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry150_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry150 bdk_apbrom_horizontal_romentry150_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY150 BDK_APBROM_HORIZONTAL_ROMENTRY150_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY150_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY150_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000258ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY150", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY150 bdk_apbrom_horizontal_romentry150_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY150 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY150 "APBROM_HORIZONTAL_ROMENTRY150"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY150 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY150 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry151
 *
 * APBROM Horizontal Romentry151 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry151
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry151_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry151_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry151 bdk_apbrom_horizontal_romentry151_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY151 BDK_APBROM_HORIZONTAL_ROMENTRY151_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY151_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY151_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600025cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY151", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY151 bdk_apbrom_horizontal_romentry151_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY151 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY151 "APBROM_HORIZONTAL_ROMENTRY151"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY151 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY151 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry152
 *
 * APBROM Horizontal Romentry152 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry152
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry152_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry152 bdk_apbrom_horizontal_romentry152_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY152 BDK_APBROM_HORIZONTAL_ROMENTRY152_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY152_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY152_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000260ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY152", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY152 bdk_apbrom_horizontal_romentry152_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY152 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY152 "APBROM_HORIZONTAL_ROMENTRY152"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY152 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY152 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry153
 *
 * APBROM Horizontal Romentry153 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry153
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry153_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry153_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry153 bdk_apbrom_horizontal_romentry153_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY153 BDK_APBROM_HORIZONTAL_ROMENTRY153_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY153_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY153_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000264ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY153", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY153 bdk_apbrom_horizontal_romentry153_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY153 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY153 "APBROM_HORIZONTAL_ROMENTRY153"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY153 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY153 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry154
 *
 * APBROM Horizontal Romentry154 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry154
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry154_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry154_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry154 bdk_apbrom_horizontal_romentry154_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY154 BDK_APBROM_HORIZONTAL_ROMENTRY154_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY154_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY154_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000268ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY154", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY154 bdk_apbrom_horizontal_romentry154_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY154 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY154 "APBROM_HORIZONTAL_ROMENTRY154"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY154 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY154 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry155
 *
 * APBROM Horizontal Romentry155 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry155
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry155_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry155_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry155 bdk_apbrom_horizontal_romentry155_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY155 BDK_APBROM_HORIZONTAL_ROMENTRY155_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY155_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY155_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600026cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY155", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY155 bdk_apbrom_horizontal_romentry155_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY155 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY155 "APBROM_HORIZONTAL_ROMENTRY155"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY155 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY155 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry156
 *
 * APBROM Horizontal Romentry156 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry156
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry156_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry156_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry156 bdk_apbrom_horizontal_romentry156_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY156 BDK_APBROM_HORIZONTAL_ROMENTRY156_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY156_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY156_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000270ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY156", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY156 bdk_apbrom_horizontal_romentry156_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY156 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY156 "APBROM_HORIZONTAL_ROMENTRY156"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY156 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY156 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry157
 *
 * APBROM Horizontal Romentry157 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry157
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry157_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry157_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry157 bdk_apbrom_horizontal_romentry157_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY157 BDK_APBROM_HORIZONTAL_ROMENTRY157_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY157_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY157_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000274ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY157", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY157 bdk_apbrom_horizontal_romentry157_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY157 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY157 "APBROM_HORIZONTAL_ROMENTRY157"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY157 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY157 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry158
 *
 * APBROM Horizontal Romentry158 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry158
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry158_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry158_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry158 bdk_apbrom_horizontal_romentry158_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY158 BDK_APBROM_HORIZONTAL_ROMENTRY158_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY158_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY158_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000278ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY158", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY158 bdk_apbrom_horizontal_romentry158_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY158 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY158 "APBROM_HORIZONTAL_ROMENTRY158"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY158 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY158 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry159
 *
 * APBROM Horizontal Romentry159 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry159
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry159_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry159_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry159 bdk_apbrom_horizontal_romentry159_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY159 BDK_APBROM_HORIZONTAL_ROMENTRY159_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY159_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY159_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600027cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY159", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY159 bdk_apbrom_horizontal_romentry159_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY159 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY159 "APBROM_HORIZONTAL_ROMENTRY159"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY159 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY159 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry16
 *
 * APBROM Horizontal Romentry16 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry16
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry16_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry16 bdk_apbrom_horizontal_romentry16_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY16 BDK_APBROM_HORIZONTAL_ROMENTRY16_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY16_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY16_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000040ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY16", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY16 bdk_apbrom_horizontal_romentry16_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY16 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY16 "APBROM_HORIZONTAL_ROMENTRY16"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY16 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY16 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry160
 *
 * APBROM Horizontal Romentry160 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry160
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry160_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry160 bdk_apbrom_horizontal_romentry160_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY160 BDK_APBROM_HORIZONTAL_ROMENTRY160_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY160_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY160_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000280ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY160", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY160 bdk_apbrom_horizontal_romentry160_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY160 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY160 "APBROM_HORIZONTAL_ROMENTRY160"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY160 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY160 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry161
 *
 * APBROM Horizontal Romentry161 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry161
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry161_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry161_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry161 bdk_apbrom_horizontal_romentry161_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY161 BDK_APBROM_HORIZONTAL_ROMENTRY161_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY161_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY161_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000284ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY161", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY161 bdk_apbrom_horizontal_romentry161_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY161 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY161 "APBROM_HORIZONTAL_ROMENTRY161"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY161 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY161 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry162
 *
 * APBROM Horizontal Romentry162 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry162
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry162_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry162_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry162 bdk_apbrom_horizontal_romentry162_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY162 BDK_APBROM_HORIZONTAL_ROMENTRY162_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY162_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY162_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000288ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY162", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY162 bdk_apbrom_horizontal_romentry162_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY162 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY162 "APBROM_HORIZONTAL_ROMENTRY162"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY162 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY162 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry163
 *
 * APBROM Horizontal Romentry163 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry163
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry163_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry163_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry163 bdk_apbrom_horizontal_romentry163_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY163 BDK_APBROM_HORIZONTAL_ROMENTRY163_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY163_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY163_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600028cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY163", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY163 bdk_apbrom_horizontal_romentry163_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY163 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY163 "APBROM_HORIZONTAL_ROMENTRY163"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY163 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY163 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry164
 *
 * APBROM Horizontal Romentry164 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry164
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry164_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry164_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry164 bdk_apbrom_horizontal_romentry164_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY164 BDK_APBROM_HORIZONTAL_ROMENTRY164_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY164_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY164_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000290ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY164", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY164 bdk_apbrom_horizontal_romentry164_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY164 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY164 "APBROM_HORIZONTAL_ROMENTRY164"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY164 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY164 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry165
 *
 * APBROM Horizontal Romentry165 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry165
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry165_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry165_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry165 bdk_apbrom_horizontal_romentry165_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY165 BDK_APBROM_HORIZONTAL_ROMENTRY165_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY165_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY165_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000294ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY165", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY165 bdk_apbrom_horizontal_romentry165_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY165 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY165 "APBROM_HORIZONTAL_ROMENTRY165"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY165 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY165 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry166
 *
 * APBROM Horizontal Romentry166 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry166
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry166_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry166_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry166 bdk_apbrom_horizontal_romentry166_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY166 BDK_APBROM_HORIZONTAL_ROMENTRY166_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY166_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY166_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000298ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY166", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY166 bdk_apbrom_horizontal_romentry166_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY166 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY166 "APBROM_HORIZONTAL_ROMENTRY166"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY166 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY166 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry167
 *
 * APBROM Horizontal Romentry167 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry167
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry167_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry167_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry167 bdk_apbrom_horizontal_romentry167_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY167 BDK_APBROM_HORIZONTAL_ROMENTRY167_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY167_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY167_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600029cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY167", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY167 bdk_apbrom_horizontal_romentry167_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY167 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY167 "APBROM_HORIZONTAL_ROMENTRY167"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY167 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY167 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry168
 *
 * APBROM Horizontal Romentry168 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry168
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry168_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry168 bdk_apbrom_horizontal_romentry168_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY168 BDK_APBROM_HORIZONTAL_ROMENTRY168_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY168_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY168_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY168", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY168 bdk_apbrom_horizontal_romentry168_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY168 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY168 "APBROM_HORIZONTAL_ROMENTRY168"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY168 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY168 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry169
 *
 * APBROM Horizontal Romentry169 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry169
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry169_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry169_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry169 bdk_apbrom_horizontal_romentry169_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY169 BDK_APBROM_HORIZONTAL_ROMENTRY169_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY169_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY169_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY169", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY169 bdk_apbrom_horizontal_romentry169_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY169 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY169 "APBROM_HORIZONTAL_ROMENTRY169"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY169 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY169 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry17
 *
 * APBROM Horizontal Romentry17 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry17
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry17_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry17_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry17 bdk_apbrom_horizontal_romentry17_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY17 BDK_APBROM_HORIZONTAL_ROMENTRY17_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY17_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY17_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000044ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY17", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY17 bdk_apbrom_horizontal_romentry17_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY17 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY17 "APBROM_HORIZONTAL_ROMENTRY17"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY17 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY17 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry170
 *
 * APBROM Horizontal Romentry170 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry170
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry170_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry170_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry170 bdk_apbrom_horizontal_romentry170_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY170 BDK_APBROM_HORIZONTAL_ROMENTRY170_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY170_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY170_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY170", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY170 bdk_apbrom_horizontal_romentry170_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY170 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY170 "APBROM_HORIZONTAL_ROMENTRY170"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY170 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY170 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry171
 *
 * APBROM Horizontal Romentry171 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry171
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry171_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry171_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry171 bdk_apbrom_horizontal_romentry171_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY171 BDK_APBROM_HORIZONTAL_ROMENTRY171_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY171_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY171_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY171", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY171 bdk_apbrom_horizontal_romentry171_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY171 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY171 "APBROM_HORIZONTAL_ROMENTRY171"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY171 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY171 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry172
 *
 * APBROM Horizontal Romentry172 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry172
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry172_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry172_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry172 bdk_apbrom_horizontal_romentry172_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY172 BDK_APBROM_HORIZONTAL_ROMENTRY172_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY172_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY172_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY172", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY172 bdk_apbrom_horizontal_romentry172_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY172 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY172 "APBROM_HORIZONTAL_ROMENTRY172"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY172 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY172 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry173
 *
 * APBROM Horizontal Romentry173 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry173
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry173_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry173_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry173 bdk_apbrom_horizontal_romentry173_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY173 BDK_APBROM_HORIZONTAL_ROMENTRY173_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY173_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY173_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY173", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY173 bdk_apbrom_horizontal_romentry173_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY173 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY173 "APBROM_HORIZONTAL_ROMENTRY173"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY173 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY173 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry174
 *
 * APBROM Horizontal Romentry174 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry174
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry174_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry174_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry174 bdk_apbrom_horizontal_romentry174_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY174 BDK_APBROM_HORIZONTAL_ROMENTRY174_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY174_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY174_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY174", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY174 bdk_apbrom_horizontal_romentry174_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY174 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY174 "APBROM_HORIZONTAL_ROMENTRY174"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY174 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY174 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry175
 *
 * APBROM Horizontal Romentry175 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry175
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry175_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry175_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry175 bdk_apbrom_horizontal_romentry175_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY175 BDK_APBROM_HORIZONTAL_ROMENTRY175_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY175_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY175_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY175", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY175 bdk_apbrom_horizontal_romentry175_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY175 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY175 "APBROM_HORIZONTAL_ROMENTRY175"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY175 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY175 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry176
 *
 * APBROM Horizontal Romentry176 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry176
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry176_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry176 bdk_apbrom_horizontal_romentry176_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY176 BDK_APBROM_HORIZONTAL_ROMENTRY176_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY176_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY176_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY176", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY176 bdk_apbrom_horizontal_romentry176_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY176 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY176 "APBROM_HORIZONTAL_ROMENTRY176"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY176 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY176 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry177
 *
 * APBROM Horizontal Romentry177 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry177
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry177_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry177_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry177 bdk_apbrom_horizontal_romentry177_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY177 BDK_APBROM_HORIZONTAL_ROMENTRY177_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY177_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY177_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY177", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY177 bdk_apbrom_horizontal_romentry177_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY177 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY177 "APBROM_HORIZONTAL_ROMENTRY177"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY177 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY177 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry178
 *
 * APBROM Horizontal Romentry178 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry178
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry178_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry178_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry178 bdk_apbrom_horizontal_romentry178_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY178 BDK_APBROM_HORIZONTAL_ROMENTRY178_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY178_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY178_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY178", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY178 bdk_apbrom_horizontal_romentry178_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY178 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY178 "APBROM_HORIZONTAL_ROMENTRY178"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY178 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY178 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry179
 *
 * APBROM Horizontal Romentry179 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry179
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry179_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry179_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry179 bdk_apbrom_horizontal_romentry179_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY179 BDK_APBROM_HORIZONTAL_ROMENTRY179_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY179_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY179_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY179", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY179 bdk_apbrom_horizontal_romentry179_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY179 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY179 "APBROM_HORIZONTAL_ROMENTRY179"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY179 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY179 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry18
 *
 * APBROM Horizontal Romentry18 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry18
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry18_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry18_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry18 bdk_apbrom_horizontal_romentry18_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY18 BDK_APBROM_HORIZONTAL_ROMENTRY18_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY18_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY18_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000048ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY18", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY18 bdk_apbrom_horizontal_romentry18_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY18 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY18 "APBROM_HORIZONTAL_ROMENTRY18"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY18 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY18 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry180
 *
 * APBROM Horizontal Romentry180 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry180
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry180_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry180_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry180 bdk_apbrom_horizontal_romentry180_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY180 BDK_APBROM_HORIZONTAL_ROMENTRY180_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY180_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY180_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY180", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY180 bdk_apbrom_horizontal_romentry180_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY180 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY180 "APBROM_HORIZONTAL_ROMENTRY180"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY180 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY180 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry181
 *
 * APBROM Horizontal Romentry181 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry181
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry181_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry181_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry181 bdk_apbrom_horizontal_romentry181_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY181 BDK_APBROM_HORIZONTAL_ROMENTRY181_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY181_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY181_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY181", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY181 bdk_apbrom_horizontal_romentry181_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY181 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY181 "APBROM_HORIZONTAL_ROMENTRY181"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY181 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY181 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry182
 *
 * APBROM Horizontal Romentry182 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry182
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry182_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry182_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry182 bdk_apbrom_horizontal_romentry182_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY182 BDK_APBROM_HORIZONTAL_ROMENTRY182_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY182_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY182_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY182", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY182 bdk_apbrom_horizontal_romentry182_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY182 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY182 "APBROM_HORIZONTAL_ROMENTRY182"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY182 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY182 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry183
 *
 * APBROM Horizontal Romentry183 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry183
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry183_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry183_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry183 bdk_apbrom_horizontal_romentry183_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY183 BDK_APBROM_HORIZONTAL_ROMENTRY183_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY183_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY183_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY183", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY183 bdk_apbrom_horizontal_romentry183_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY183 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY183 "APBROM_HORIZONTAL_ROMENTRY183"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY183 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY183 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry184
 *
 * APBROM Horizontal Romentry184 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry184
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry184_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry184 bdk_apbrom_horizontal_romentry184_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY184 BDK_APBROM_HORIZONTAL_ROMENTRY184_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY184_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY184_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY184", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY184 bdk_apbrom_horizontal_romentry184_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY184 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY184 "APBROM_HORIZONTAL_ROMENTRY184"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY184 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY184 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry185
 *
 * APBROM Horizontal Romentry185 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry185
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry185_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry185_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry185 bdk_apbrom_horizontal_romentry185_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY185 BDK_APBROM_HORIZONTAL_ROMENTRY185_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY185_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY185_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY185", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY185 bdk_apbrom_horizontal_romentry185_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY185 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY185 "APBROM_HORIZONTAL_ROMENTRY185"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY185 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY185 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry186
 *
 * APBROM Horizontal Romentry186 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry186
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry186_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry186_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry186 bdk_apbrom_horizontal_romentry186_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY186 BDK_APBROM_HORIZONTAL_ROMENTRY186_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY186_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY186_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY186", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY186 bdk_apbrom_horizontal_romentry186_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY186 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY186 "APBROM_HORIZONTAL_ROMENTRY186"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY186 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY186 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry187
 *
 * APBROM Horizontal Romentry187 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry187
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry187_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry187_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry187 bdk_apbrom_horizontal_romentry187_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY187 BDK_APBROM_HORIZONTAL_ROMENTRY187_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY187_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY187_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY187", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY187 bdk_apbrom_horizontal_romentry187_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY187 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY187 "APBROM_HORIZONTAL_ROMENTRY187"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY187 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY187 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry188
 *
 * APBROM Horizontal Romentry188 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry188
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry188_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry188_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry188 bdk_apbrom_horizontal_romentry188_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY188 BDK_APBROM_HORIZONTAL_ROMENTRY188_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY188_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY188_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY188", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY188 bdk_apbrom_horizontal_romentry188_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY188 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY188 "APBROM_HORIZONTAL_ROMENTRY188"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY188 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY188 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry189
 *
 * APBROM Horizontal Romentry189 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry189
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry189_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry189_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry189 bdk_apbrom_horizontal_romentry189_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY189 BDK_APBROM_HORIZONTAL_ROMENTRY189_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY189_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY189_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY189", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY189 bdk_apbrom_horizontal_romentry189_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY189 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY189 "APBROM_HORIZONTAL_ROMENTRY189"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY189 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY189 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry19
 *
 * APBROM Horizontal Romentry19 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry19
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry19_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry19 bdk_apbrom_horizontal_romentry19_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY19 BDK_APBROM_HORIZONTAL_ROMENTRY19_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY19_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY19_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600004cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY19", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY19 bdk_apbrom_horizontal_romentry19_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY19 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY19 "APBROM_HORIZONTAL_ROMENTRY19"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY19 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY19 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry190
 *
 * APBROM Horizontal Romentry190 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry190
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry190_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry190_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry190 bdk_apbrom_horizontal_romentry190_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY190 BDK_APBROM_HORIZONTAL_ROMENTRY190_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY190_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY190_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY190", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY190 bdk_apbrom_horizontal_romentry190_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY190 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY190 "APBROM_HORIZONTAL_ROMENTRY190"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY190 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY190 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry191
 *
 * APBROM Horizontal Romentry191 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry191
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry191_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry191_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry191 bdk_apbrom_horizontal_romentry191_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY191 BDK_APBROM_HORIZONTAL_ROMENTRY191_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY191_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY191_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460002fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY191", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY191 bdk_apbrom_horizontal_romentry191_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY191 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY191 "APBROM_HORIZONTAL_ROMENTRY191"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY191 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY191 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry192
 *
 * APBROM Horizontal Romentry192 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry192
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry192_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry192 bdk_apbrom_horizontal_romentry192_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY192 BDK_APBROM_HORIZONTAL_ROMENTRY192_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY192_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY192_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000300ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY192", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY192 bdk_apbrom_horizontal_romentry192_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY192 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY192 "APBROM_HORIZONTAL_ROMENTRY192"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY192 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY192 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry193
 *
 * APBROM Horizontal Romentry193 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry193
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry193_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry193_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry193 bdk_apbrom_horizontal_romentry193_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY193 BDK_APBROM_HORIZONTAL_ROMENTRY193_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY193_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY193_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000304ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY193", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY193 bdk_apbrom_horizontal_romentry193_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY193 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY193 "APBROM_HORIZONTAL_ROMENTRY193"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY193 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY193 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry194
 *
 * APBROM Horizontal Romentry194 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry194
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry194_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry194_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry194 bdk_apbrom_horizontal_romentry194_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY194 BDK_APBROM_HORIZONTAL_ROMENTRY194_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY194_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY194_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000308ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY194", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY194 bdk_apbrom_horizontal_romentry194_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY194 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY194 "APBROM_HORIZONTAL_ROMENTRY194"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY194 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY194 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry195
 *
 * APBROM Horizontal Romentry195 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry195
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry195_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry195_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry195 bdk_apbrom_horizontal_romentry195_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY195 BDK_APBROM_HORIZONTAL_ROMENTRY195_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY195_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY195_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600030cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY195", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY195 bdk_apbrom_horizontal_romentry195_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY195 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY195 "APBROM_HORIZONTAL_ROMENTRY195"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY195 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY195 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry196
 *
 * APBROM Horizontal Romentry196 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry196
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry196_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry196_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry196 bdk_apbrom_horizontal_romentry196_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY196 BDK_APBROM_HORIZONTAL_ROMENTRY196_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY196_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY196_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000310ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY196", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY196 bdk_apbrom_horizontal_romentry196_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY196 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY196 "APBROM_HORIZONTAL_ROMENTRY196"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY196 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY196 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry197
 *
 * APBROM Horizontal Romentry197 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry197
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry197_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry197_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry197 bdk_apbrom_horizontal_romentry197_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY197 BDK_APBROM_HORIZONTAL_ROMENTRY197_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY197_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY197_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000314ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY197", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY197 bdk_apbrom_horizontal_romentry197_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY197 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY197 "APBROM_HORIZONTAL_ROMENTRY197"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY197 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY197 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry198
 *
 * APBROM Horizontal Romentry198 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry198
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry198_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry198_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry198 bdk_apbrom_horizontal_romentry198_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY198 BDK_APBROM_HORIZONTAL_ROMENTRY198_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY198_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY198_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000318ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY198", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY198 bdk_apbrom_horizontal_romentry198_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY198 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY198 "APBROM_HORIZONTAL_ROMENTRY198"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY198 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY198 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry199
 *
 * APBROM Horizontal Romentry199 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry199
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry199_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry199_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry199 bdk_apbrom_horizontal_romentry199_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY199 BDK_APBROM_HORIZONTAL_ROMENTRY199_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY199_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY199_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600031cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY199", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY199 bdk_apbrom_horizontal_romentry199_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY199 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY199 "APBROM_HORIZONTAL_ROMENTRY199"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY199 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY199 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry2
 *
 * APBROM Horizontal Romentry2 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry2
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry2_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry2 bdk_apbrom_horizontal_romentry2_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY2 BDK_APBROM_HORIZONTAL_ROMENTRY2_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY2_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000008ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY2", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY2 bdk_apbrom_horizontal_romentry2_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY2 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY2 "APBROM_HORIZONTAL_ROMENTRY2"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY2 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY2 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry20
 *
 * APBROM Horizontal Romentry20 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry20
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry20_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry20_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry20 bdk_apbrom_horizontal_romentry20_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY20 BDK_APBROM_HORIZONTAL_ROMENTRY20_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY20_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY20_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000050ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY20", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY20 bdk_apbrom_horizontal_romentry20_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY20 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY20 "APBROM_HORIZONTAL_ROMENTRY20"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY20 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY20 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry200
 *
 * APBROM Horizontal Romentry200 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry200
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry200_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry200_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry200 bdk_apbrom_horizontal_romentry200_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY200 BDK_APBROM_HORIZONTAL_ROMENTRY200_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY200_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY200_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000320ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY200", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY200 bdk_apbrom_horizontal_romentry200_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY200 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY200 "APBROM_HORIZONTAL_ROMENTRY200"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY200 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY200 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry201
 *
 * APBROM Horizontal Romentry201 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry201
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry201_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry201_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry201 bdk_apbrom_horizontal_romentry201_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY201 BDK_APBROM_HORIZONTAL_ROMENTRY201_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY201_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY201_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000324ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY201", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY201 bdk_apbrom_horizontal_romentry201_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY201 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY201 "APBROM_HORIZONTAL_ROMENTRY201"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY201 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY201 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry202
 *
 * APBROM Horizontal Romentry202 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry202
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry202_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry202_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry202 bdk_apbrom_horizontal_romentry202_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY202 BDK_APBROM_HORIZONTAL_ROMENTRY202_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY202_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY202_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000328ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY202", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY202 bdk_apbrom_horizontal_romentry202_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY202 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY202 "APBROM_HORIZONTAL_ROMENTRY202"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY202 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY202 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry203
 *
 * APBROM Horizontal Romentry203 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry203
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry203_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry203_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry203 bdk_apbrom_horizontal_romentry203_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY203 BDK_APBROM_HORIZONTAL_ROMENTRY203_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY203_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY203_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600032cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY203", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY203 bdk_apbrom_horizontal_romentry203_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY203 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY203 "APBROM_HORIZONTAL_ROMENTRY203"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY203 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY203 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry204
 *
 * APBROM Horizontal Romentry204 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry204
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry204_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry204_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry204 bdk_apbrom_horizontal_romentry204_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY204 BDK_APBROM_HORIZONTAL_ROMENTRY204_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY204_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY204_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000330ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY204", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY204 bdk_apbrom_horizontal_romentry204_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY204 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY204 "APBROM_HORIZONTAL_ROMENTRY204"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY204 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY204 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry205
 *
 * APBROM Horizontal Romentry205 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry205
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry205_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry205_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry205 bdk_apbrom_horizontal_romentry205_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY205 BDK_APBROM_HORIZONTAL_ROMENTRY205_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY205_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY205_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000334ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY205", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY205 bdk_apbrom_horizontal_romentry205_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY205 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY205 "APBROM_HORIZONTAL_ROMENTRY205"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY205 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY205 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry206
 *
 * APBROM Horizontal Romentry206 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry206
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry206_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry206_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry206 bdk_apbrom_horizontal_romentry206_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY206 BDK_APBROM_HORIZONTAL_ROMENTRY206_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY206_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY206_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000338ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY206", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY206 bdk_apbrom_horizontal_romentry206_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY206 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY206 "APBROM_HORIZONTAL_ROMENTRY206"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY206 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY206 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry207
 *
 * APBROM Horizontal Romentry207 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry207
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry207_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry207_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry207 bdk_apbrom_horizontal_romentry207_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY207 BDK_APBROM_HORIZONTAL_ROMENTRY207_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY207_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY207_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600033cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY207", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY207 bdk_apbrom_horizontal_romentry207_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY207 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY207 "APBROM_HORIZONTAL_ROMENTRY207"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY207 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY207 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry208
 *
 * APBROM Horizontal Romentry208 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry208
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry208_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry208_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry208 bdk_apbrom_horizontal_romentry208_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY208 BDK_APBROM_HORIZONTAL_ROMENTRY208_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY208_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY208_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000340ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY208", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY208 bdk_apbrom_horizontal_romentry208_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY208 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY208 "APBROM_HORIZONTAL_ROMENTRY208"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY208 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY208 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry209
 *
 * APBROM Horizontal Romentry209 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry209
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry209_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry209_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry209 bdk_apbrom_horizontal_romentry209_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY209 BDK_APBROM_HORIZONTAL_ROMENTRY209_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY209_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY209_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000344ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY209", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY209 bdk_apbrom_horizontal_romentry209_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY209 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY209 "APBROM_HORIZONTAL_ROMENTRY209"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY209 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY209 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry21
 *
 * APBROM Horizontal Romentry21 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry21
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry21_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry21_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry21 bdk_apbrom_horizontal_romentry21_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY21 BDK_APBROM_HORIZONTAL_ROMENTRY21_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY21_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY21_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000054ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY21", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY21 bdk_apbrom_horizontal_romentry21_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY21 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY21 "APBROM_HORIZONTAL_ROMENTRY21"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY21 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY21 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry210
 *
 * APBROM Horizontal Romentry210 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry210
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry210_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry210_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry210 bdk_apbrom_horizontal_romentry210_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY210 BDK_APBROM_HORIZONTAL_ROMENTRY210_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY210_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY210_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000348ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY210", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY210 bdk_apbrom_horizontal_romentry210_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY210 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY210 "APBROM_HORIZONTAL_ROMENTRY210"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY210 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY210 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry211
 *
 * APBROM Horizontal Romentry211 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry211
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry211_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry211_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry211 bdk_apbrom_horizontal_romentry211_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY211 BDK_APBROM_HORIZONTAL_ROMENTRY211_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY211_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY211_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600034cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY211", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY211 bdk_apbrom_horizontal_romentry211_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY211 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY211 "APBROM_HORIZONTAL_ROMENTRY211"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY211 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY211 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry212
 *
 * APBROM Horizontal Romentry212 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry212
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry212_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry212_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry212 bdk_apbrom_horizontal_romentry212_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY212 BDK_APBROM_HORIZONTAL_ROMENTRY212_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY212_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY212_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000350ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY212", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY212 bdk_apbrom_horizontal_romentry212_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY212 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY212 "APBROM_HORIZONTAL_ROMENTRY212"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY212 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY212 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry213
 *
 * APBROM Horizontal Romentry213 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry213
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry213_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry213_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry213 bdk_apbrom_horizontal_romentry213_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY213 BDK_APBROM_HORIZONTAL_ROMENTRY213_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY213_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY213_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000354ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY213", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY213 bdk_apbrom_horizontal_romentry213_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY213 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY213 "APBROM_HORIZONTAL_ROMENTRY213"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY213 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY213 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry214
 *
 * APBROM Horizontal Romentry214 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry214
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry214_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry214_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry214 bdk_apbrom_horizontal_romentry214_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY214 BDK_APBROM_HORIZONTAL_ROMENTRY214_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY214_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY214_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000358ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY214", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY214 bdk_apbrom_horizontal_romentry214_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY214 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY214 "APBROM_HORIZONTAL_ROMENTRY214"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY214 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY214 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry215
 *
 * APBROM Horizontal Romentry215 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry215
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry215_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry215_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry215 bdk_apbrom_horizontal_romentry215_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY215 BDK_APBROM_HORIZONTAL_ROMENTRY215_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY215_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY215_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600035cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY215", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY215 bdk_apbrom_horizontal_romentry215_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY215 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY215 "APBROM_HORIZONTAL_ROMENTRY215"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY215 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY215 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry216
 *
 * APBROM Horizontal Romentry216 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry216
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry216_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry216_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry216 bdk_apbrom_horizontal_romentry216_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY216 BDK_APBROM_HORIZONTAL_ROMENTRY216_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY216_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY216_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000360ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY216", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY216 bdk_apbrom_horizontal_romentry216_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY216 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY216 "APBROM_HORIZONTAL_ROMENTRY216"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY216 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY216 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry217
 *
 * APBROM Horizontal Romentry217 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry217
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry217_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry217_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry217 bdk_apbrom_horizontal_romentry217_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY217 BDK_APBROM_HORIZONTAL_ROMENTRY217_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY217_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY217_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000364ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY217", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY217 bdk_apbrom_horizontal_romentry217_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY217 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY217 "APBROM_HORIZONTAL_ROMENTRY217"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY217 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY217 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry218
 *
 * APBROM Horizontal Romentry218 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry218
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry218_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry218_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry218 bdk_apbrom_horizontal_romentry218_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY218 BDK_APBROM_HORIZONTAL_ROMENTRY218_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY218_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY218_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000368ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY218", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY218 bdk_apbrom_horizontal_romentry218_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY218 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY218 "APBROM_HORIZONTAL_ROMENTRY218"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY218 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY218 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry219
 *
 * APBROM Horizontal Romentry219 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry219
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry219_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry219_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry219 bdk_apbrom_horizontal_romentry219_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY219 BDK_APBROM_HORIZONTAL_ROMENTRY219_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY219_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY219_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600036cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY219", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY219 bdk_apbrom_horizontal_romentry219_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY219 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY219 "APBROM_HORIZONTAL_ROMENTRY219"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY219 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY219 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry22
 *
 * APBROM Horizontal Romentry22 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry22
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry22_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry22_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry22 bdk_apbrom_horizontal_romentry22_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY22 BDK_APBROM_HORIZONTAL_ROMENTRY22_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY22_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY22_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000058ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY22", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY22 bdk_apbrom_horizontal_romentry22_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY22 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY22 "APBROM_HORIZONTAL_ROMENTRY22"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY22 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY22 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry220
 *
 * APBROM Horizontal Romentry220 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry220
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry220_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry220_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry220 bdk_apbrom_horizontal_romentry220_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY220 BDK_APBROM_HORIZONTAL_ROMENTRY220_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY220_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY220_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000370ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY220", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY220 bdk_apbrom_horizontal_romentry220_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY220 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY220 "APBROM_HORIZONTAL_ROMENTRY220"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY220 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY220 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry221
 *
 * APBROM Horizontal Romentry221 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry221
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry221_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry221_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry221 bdk_apbrom_horizontal_romentry221_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY221 BDK_APBROM_HORIZONTAL_ROMENTRY221_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY221_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY221_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000374ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY221", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY221 bdk_apbrom_horizontal_romentry221_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY221 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY221 "APBROM_HORIZONTAL_ROMENTRY221"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY221 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY221 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry222
 *
 * APBROM Horizontal Romentry222 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry222
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry222_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry222_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry222 bdk_apbrom_horizontal_romentry222_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY222 BDK_APBROM_HORIZONTAL_ROMENTRY222_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY222_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY222_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000378ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY222", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY222 bdk_apbrom_horizontal_romentry222_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY222 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY222 "APBROM_HORIZONTAL_ROMENTRY222"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY222 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY222 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry223
 *
 * APBROM Horizontal Romentry223 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry223
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry223_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry223_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry223 bdk_apbrom_horizontal_romentry223_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY223 BDK_APBROM_HORIZONTAL_ROMENTRY223_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY223_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY223_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600037cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY223", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY223 bdk_apbrom_horizontal_romentry223_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY223 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY223 "APBROM_HORIZONTAL_ROMENTRY223"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY223 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY223 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry224
 *
 * APBROM Horizontal Romentry224 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry224
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry224_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry224_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry224 bdk_apbrom_horizontal_romentry224_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY224 BDK_APBROM_HORIZONTAL_ROMENTRY224_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY224_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY224_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000380ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY224", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY224 bdk_apbrom_horizontal_romentry224_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY224 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY224 "APBROM_HORIZONTAL_ROMENTRY224"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY224 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY224 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry225
 *
 * APBROM Horizontal Romentry225 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry225
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry225_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry225_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry225 bdk_apbrom_horizontal_romentry225_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY225 BDK_APBROM_HORIZONTAL_ROMENTRY225_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY225_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY225_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000384ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY225", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY225 bdk_apbrom_horizontal_romentry225_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY225 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY225 "APBROM_HORIZONTAL_ROMENTRY225"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY225 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY225 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry226
 *
 * APBROM Horizontal Romentry226 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry226
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry226_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry226_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry226 bdk_apbrom_horizontal_romentry226_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY226 BDK_APBROM_HORIZONTAL_ROMENTRY226_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY226_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY226_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000388ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY226", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY226 bdk_apbrom_horizontal_romentry226_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY226 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY226 "APBROM_HORIZONTAL_ROMENTRY226"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY226 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY226 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry227
 *
 * APBROM Horizontal Romentry227 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry227
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry227_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry227_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry227 bdk_apbrom_horizontal_romentry227_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY227 BDK_APBROM_HORIZONTAL_ROMENTRY227_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY227_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY227_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600038cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY227", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY227 bdk_apbrom_horizontal_romentry227_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY227 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY227 "APBROM_HORIZONTAL_ROMENTRY227"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY227 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY227 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry228
 *
 * APBROM Horizontal Romentry228 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry228
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry228_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry228_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry228 bdk_apbrom_horizontal_romentry228_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY228 BDK_APBROM_HORIZONTAL_ROMENTRY228_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY228_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY228_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000390ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY228", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY228 bdk_apbrom_horizontal_romentry228_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY228 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY228 "APBROM_HORIZONTAL_ROMENTRY228"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY228 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY228 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry229
 *
 * APBROM Horizontal Romentry229 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry229
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry229_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry229_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry229 bdk_apbrom_horizontal_romentry229_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY229 BDK_APBROM_HORIZONTAL_ROMENTRY229_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY229_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY229_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000394ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY229", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY229 bdk_apbrom_horizontal_romentry229_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY229 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY229 "APBROM_HORIZONTAL_ROMENTRY229"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY229 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY229 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry23
 *
 * APBROM Horizontal Romentry23 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry23
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry23_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry23_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry23 bdk_apbrom_horizontal_romentry23_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY23 BDK_APBROM_HORIZONTAL_ROMENTRY23_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY23_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY23_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600005cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY23", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY23 bdk_apbrom_horizontal_romentry23_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY23 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY23 "APBROM_HORIZONTAL_ROMENTRY23"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY23 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY23 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry230
 *
 * APBROM Horizontal Romentry230 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry230
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry230_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry230_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry230 bdk_apbrom_horizontal_romentry230_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY230 BDK_APBROM_HORIZONTAL_ROMENTRY230_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY230_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY230_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000398ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY230", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY230 bdk_apbrom_horizontal_romentry230_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY230 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY230 "APBROM_HORIZONTAL_ROMENTRY230"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY230 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY230 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry231
 *
 * APBROM Horizontal Romentry231 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry231
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry231_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry231_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry231 bdk_apbrom_horizontal_romentry231_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY231 BDK_APBROM_HORIZONTAL_ROMENTRY231_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY231_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY231_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600039cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY231", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY231 bdk_apbrom_horizontal_romentry231_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY231 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY231 "APBROM_HORIZONTAL_ROMENTRY231"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY231 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY231 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry232
 *
 * APBROM Horizontal Romentry232 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry232
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry232_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry232_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry232 bdk_apbrom_horizontal_romentry232_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY232 BDK_APBROM_HORIZONTAL_ROMENTRY232_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY232_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY232_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY232", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY232 bdk_apbrom_horizontal_romentry232_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY232 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY232 "APBROM_HORIZONTAL_ROMENTRY232"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY232 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY232 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry233
 *
 * APBROM Horizontal Romentry233 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry233
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry233_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry233_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry233 bdk_apbrom_horizontal_romentry233_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY233 BDK_APBROM_HORIZONTAL_ROMENTRY233_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY233_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY233_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY233", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY233 bdk_apbrom_horizontal_romentry233_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY233 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY233 "APBROM_HORIZONTAL_ROMENTRY233"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY233 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY233 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry234
 *
 * APBROM Horizontal Romentry234 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry234
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry234_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry234_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry234 bdk_apbrom_horizontal_romentry234_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY234 BDK_APBROM_HORIZONTAL_ROMENTRY234_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY234_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY234_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY234", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY234 bdk_apbrom_horizontal_romentry234_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY234 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY234 "APBROM_HORIZONTAL_ROMENTRY234"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY234 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY234 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry235
 *
 * APBROM Horizontal Romentry235 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry235
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry235_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry235_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry235 bdk_apbrom_horizontal_romentry235_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY235 BDK_APBROM_HORIZONTAL_ROMENTRY235_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY235_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY235_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY235", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY235 bdk_apbrom_horizontal_romentry235_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY235 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY235 "APBROM_HORIZONTAL_ROMENTRY235"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY235 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY235 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry236
 *
 * APBROM Horizontal Romentry236 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry236
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry236_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry236_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry236 bdk_apbrom_horizontal_romentry236_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY236 BDK_APBROM_HORIZONTAL_ROMENTRY236_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY236_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY236_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY236", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY236 bdk_apbrom_horizontal_romentry236_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY236 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY236 "APBROM_HORIZONTAL_ROMENTRY236"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY236 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY236 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry237
 *
 * APBROM Horizontal Romentry237 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry237
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry237_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry237_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry237 bdk_apbrom_horizontal_romentry237_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY237 BDK_APBROM_HORIZONTAL_ROMENTRY237_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY237_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY237_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY237", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY237 bdk_apbrom_horizontal_romentry237_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY237 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY237 "APBROM_HORIZONTAL_ROMENTRY237"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY237 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY237 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry238
 *
 * APBROM Horizontal Romentry238 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry238
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry238_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry238_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry238 bdk_apbrom_horizontal_romentry238_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY238 BDK_APBROM_HORIZONTAL_ROMENTRY238_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY238_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY238_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY238", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY238 bdk_apbrom_horizontal_romentry238_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY238 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY238 "APBROM_HORIZONTAL_ROMENTRY238"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY238 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY238 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry239
 *
 * APBROM Horizontal Romentry239 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry239
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry239_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry239_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry239 bdk_apbrom_horizontal_romentry239_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY239 BDK_APBROM_HORIZONTAL_ROMENTRY239_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY239_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY239_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY239", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY239 bdk_apbrom_horizontal_romentry239_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY239 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY239 "APBROM_HORIZONTAL_ROMENTRY239"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY239 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY239 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry24
 *
 * APBROM Horizontal Romentry24 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry24
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry24_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry24 bdk_apbrom_horizontal_romentry24_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY24 BDK_APBROM_HORIZONTAL_ROMENTRY24_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY24_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY24_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000060ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY24", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY24 bdk_apbrom_horizontal_romentry24_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY24 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY24 "APBROM_HORIZONTAL_ROMENTRY24"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY24 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY24 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry240
 *
 * APBROM Horizontal Romentry240 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry240
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry240_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry240_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry240 bdk_apbrom_horizontal_romentry240_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY240 BDK_APBROM_HORIZONTAL_ROMENTRY240_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY240_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY240_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY240", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY240 bdk_apbrom_horizontal_romentry240_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY240 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY240 "APBROM_HORIZONTAL_ROMENTRY240"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY240 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY240 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry241
 *
 * APBROM Horizontal Romentry241 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry241
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry241_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry241_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry241 bdk_apbrom_horizontal_romentry241_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY241 BDK_APBROM_HORIZONTAL_ROMENTRY241_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY241_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY241_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY241", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY241 bdk_apbrom_horizontal_romentry241_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY241 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY241 "APBROM_HORIZONTAL_ROMENTRY241"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY241 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY241 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry242
 *
 * APBROM Horizontal Romentry242 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry242
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry242_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry242_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry242 bdk_apbrom_horizontal_romentry242_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY242 BDK_APBROM_HORIZONTAL_ROMENTRY242_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY242_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY242_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY242", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY242 bdk_apbrom_horizontal_romentry242_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY242 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY242 "APBROM_HORIZONTAL_ROMENTRY242"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY242 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY242 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry243
 *
 * APBROM Horizontal Romentry243 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry243
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry243_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry243_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry243 bdk_apbrom_horizontal_romentry243_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY243 BDK_APBROM_HORIZONTAL_ROMENTRY243_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY243_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY243_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY243", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY243 bdk_apbrom_horizontal_romentry243_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY243 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY243 "APBROM_HORIZONTAL_ROMENTRY243"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY243 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY243 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry244
 *
 * APBROM Horizontal Romentry244 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry244
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry244_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry244_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry244 bdk_apbrom_horizontal_romentry244_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY244 BDK_APBROM_HORIZONTAL_ROMENTRY244_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY244_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY244_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY244", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY244 bdk_apbrom_horizontal_romentry244_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY244 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY244 "APBROM_HORIZONTAL_ROMENTRY244"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY244 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY244 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry245
 *
 * APBROM Horizontal Romentry245 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry245
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry245_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry245_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry245 bdk_apbrom_horizontal_romentry245_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY245 BDK_APBROM_HORIZONTAL_ROMENTRY245_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY245_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY245_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY245", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY245 bdk_apbrom_horizontal_romentry245_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY245 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY245 "APBROM_HORIZONTAL_ROMENTRY245"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY245 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY245 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry246
 *
 * APBROM Horizontal Romentry246 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry246
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry246_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry246_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry246 bdk_apbrom_horizontal_romentry246_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY246 BDK_APBROM_HORIZONTAL_ROMENTRY246_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY246_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY246_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY246", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY246 bdk_apbrom_horizontal_romentry246_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY246 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY246 "APBROM_HORIZONTAL_ROMENTRY246"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY246 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY246 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry247
 *
 * APBROM Horizontal Romentry247 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry247
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry247_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry247_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry247 bdk_apbrom_horizontal_romentry247_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY247 BDK_APBROM_HORIZONTAL_ROMENTRY247_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY247_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY247_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY247", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY247 bdk_apbrom_horizontal_romentry247_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY247 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY247 "APBROM_HORIZONTAL_ROMENTRY247"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY247 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY247 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry248
 *
 * APBROM Horizontal Romentry248 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry248
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry248_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry248_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry248 bdk_apbrom_horizontal_romentry248_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY248 BDK_APBROM_HORIZONTAL_ROMENTRY248_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY248_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY248_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY248", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY248 bdk_apbrom_horizontal_romentry248_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY248 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY248 "APBROM_HORIZONTAL_ROMENTRY248"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY248 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY248 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry249
 *
 * APBROM Horizontal Romentry249 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry249
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry249_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry249_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry249 bdk_apbrom_horizontal_romentry249_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY249 BDK_APBROM_HORIZONTAL_ROMENTRY249_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY249_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY249_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY249", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY249 bdk_apbrom_horizontal_romentry249_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY249 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY249 "APBROM_HORIZONTAL_ROMENTRY249"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY249 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY249 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry25
 *
 * APBROM Horizontal Romentry25 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry25
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry25_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry25_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry25 bdk_apbrom_horizontal_romentry25_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY25 BDK_APBROM_HORIZONTAL_ROMENTRY25_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY25_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY25_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000064ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY25", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY25 bdk_apbrom_horizontal_romentry25_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY25 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY25 "APBROM_HORIZONTAL_ROMENTRY25"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY25 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY25 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry250
 *
 * APBROM Horizontal Romentry250 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry250
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry250_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry250_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry250 bdk_apbrom_horizontal_romentry250_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY250 BDK_APBROM_HORIZONTAL_ROMENTRY250_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY250_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY250_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY250", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY250 bdk_apbrom_horizontal_romentry250_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY250 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY250 "APBROM_HORIZONTAL_ROMENTRY250"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY250 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY250 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry251
 *
 * APBROM Horizontal Romentry251 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry251
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry251_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry251_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry251 bdk_apbrom_horizontal_romentry251_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY251 BDK_APBROM_HORIZONTAL_ROMENTRY251_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY251_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY251_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY251", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY251 bdk_apbrom_horizontal_romentry251_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY251 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY251 "APBROM_HORIZONTAL_ROMENTRY251"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY251 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY251 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry252
 *
 * APBROM Horizontal Romentry252 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry252
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry252_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry252_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry252 bdk_apbrom_horizontal_romentry252_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY252 BDK_APBROM_HORIZONTAL_ROMENTRY252_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY252_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY252_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY252", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY252 bdk_apbrom_horizontal_romentry252_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY252 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY252 "APBROM_HORIZONTAL_ROMENTRY252"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY252 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY252 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry253
 *
 * APBROM Horizontal Romentry253 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry253
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry253_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry253_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry253 bdk_apbrom_horizontal_romentry253_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY253 BDK_APBROM_HORIZONTAL_ROMENTRY253_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY253_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY253_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY253", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY253 bdk_apbrom_horizontal_romentry253_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY253 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY253 "APBROM_HORIZONTAL_ROMENTRY253"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY253 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY253 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry254
 *
 * APBROM Horizontal Romentry254 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry254
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry254_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry254_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry254 bdk_apbrom_horizontal_romentry254_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY254 BDK_APBROM_HORIZONTAL_ROMENTRY254_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY254_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY254_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY254", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY254 bdk_apbrom_horizontal_romentry254_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY254 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY254 "APBROM_HORIZONTAL_ROMENTRY254"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY254 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY254 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry255
 *
 * APBROM Horizontal Romentry255 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry255
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry255_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry255_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry255 bdk_apbrom_horizontal_romentry255_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY255 BDK_APBROM_HORIZONTAL_ROMENTRY255_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY255_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY255_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460003fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY255", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY255 bdk_apbrom_horizontal_romentry255_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY255 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY255 "APBROM_HORIZONTAL_ROMENTRY255"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY255 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY255 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry256
 *
 * APBROM Horizontal Romentry256 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry256
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry256_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry256_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry256 bdk_apbrom_horizontal_romentry256_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY256 BDK_APBROM_HORIZONTAL_ROMENTRY256_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY256_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY256_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000400ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY256", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY256 bdk_apbrom_horizontal_romentry256_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY256 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY256 "APBROM_HORIZONTAL_ROMENTRY256"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY256 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY256 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry257
 *
 * APBROM Horizontal Romentry257 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry257
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry257_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry257_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry257 bdk_apbrom_horizontal_romentry257_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY257 BDK_APBROM_HORIZONTAL_ROMENTRY257_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY257_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY257_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000404ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY257", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY257 bdk_apbrom_horizontal_romentry257_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY257 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY257 "APBROM_HORIZONTAL_ROMENTRY257"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY257 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY257 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry258
 *
 * APBROM Horizontal Romentry258 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry258
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry258_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry258_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry258 bdk_apbrom_horizontal_romentry258_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY258 BDK_APBROM_HORIZONTAL_ROMENTRY258_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY258_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY258_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000408ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY258", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY258 bdk_apbrom_horizontal_romentry258_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY258 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY258 "APBROM_HORIZONTAL_ROMENTRY258"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY258 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY258 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry259
 *
 * APBROM Horizontal Romentry259 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry259
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry259_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry259_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry259 bdk_apbrom_horizontal_romentry259_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY259 BDK_APBROM_HORIZONTAL_ROMENTRY259_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY259_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY259_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600040cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY259", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY259 bdk_apbrom_horizontal_romentry259_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY259 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY259 "APBROM_HORIZONTAL_ROMENTRY259"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY259 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY259 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry26
 *
 * APBROM Horizontal Romentry26 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry26
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry26_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry26_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry26 bdk_apbrom_horizontal_romentry26_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY26 BDK_APBROM_HORIZONTAL_ROMENTRY26_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY26_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY26_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000068ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY26", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY26 bdk_apbrom_horizontal_romentry26_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY26 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY26 "APBROM_HORIZONTAL_ROMENTRY26"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY26 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY26 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry260
 *
 * APBROM Horizontal Romentry260 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry260
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry260_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry260_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry260 bdk_apbrom_horizontal_romentry260_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY260 BDK_APBROM_HORIZONTAL_ROMENTRY260_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY260_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY260_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000410ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY260", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY260 bdk_apbrom_horizontal_romentry260_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY260 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY260 "APBROM_HORIZONTAL_ROMENTRY260"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY260 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY260 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry261
 *
 * APBROM Horizontal Romentry261 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry261
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry261_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry261_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry261 bdk_apbrom_horizontal_romentry261_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY261 BDK_APBROM_HORIZONTAL_ROMENTRY261_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY261_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY261_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000414ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY261", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY261 bdk_apbrom_horizontal_romentry261_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY261 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY261 "APBROM_HORIZONTAL_ROMENTRY261"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY261 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY261 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry262
 *
 * APBROM Horizontal Romentry262 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry262
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry262_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry262_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry262 bdk_apbrom_horizontal_romentry262_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY262 BDK_APBROM_HORIZONTAL_ROMENTRY262_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY262_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY262_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000418ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY262", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY262 bdk_apbrom_horizontal_romentry262_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY262 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY262 "APBROM_HORIZONTAL_ROMENTRY262"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY262 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY262 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry263
 *
 * APBROM Horizontal Romentry263 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry263
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry263_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry263_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry263 bdk_apbrom_horizontal_romentry263_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY263 BDK_APBROM_HORIZONTAL_ROMENTRY263_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY263_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY263_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600041cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY263", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY263 bdk_apbrom_horizontal_romentry263_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY263 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY263 "APBROM_HORIZONTAL_ROMENTRY263"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY263 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY263 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry264
 *
 * APBROM Horizontal Romentry264 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry264
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry264_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry264_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry264 bdk_apbrom_horizontal_romentry264_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY264 BDK_APBROM_HORIZONTAL_ROMENTRY264_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY264_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY264_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000420ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY264", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY264 bdk_apbrom_horizontal_romentry264_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY264 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY264 "APBROM_HORIZONTAL_ROMENTRY264"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY264 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY264 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry265
 *
 * APBROM Horizontal Romentry265 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry265
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry265_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry265_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry265 bdk_apbrom_horizontal_romentry265_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY265 BDK_APBROM_HORIZONTAL_ROMENTRY265_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY265_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY265_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000424ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY265", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY265 bdk_apbrom_horizontal_romentry265_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY265 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY265 "APBROM_HORIZONTAL_ROMENTRY265"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY265 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY265 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry266
 *
 * APBROM Horizontal Romentry266 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry266
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry266_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry266_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry266 bdk_apbrom_horizontal_romentry266_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY266 BDK_APBROM_HORIZONTAL_ROMENTRY266_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY266_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY266_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000428ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY266", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY266 bdk_apbrom_horizontal_romentry266_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY266 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY266 "APBROM_HORIZONTAL_ROMENTRY266"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY266 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY266 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry267
 *
 * APBROM Horizontal Romentry267 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry267
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry267_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry267_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry267 bdk_apbrom_horizontal_romentry267_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY267 BDK_APBROM_HORIZONTAL_ROMENTRY267_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY267_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY267_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600042cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY267", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY267 bdk_apbrom_horizontal_romentry267_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY267 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY267 "APBROM_HORIZONTAL_ROMENTRY267"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY267 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY267 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry268
 *
 * APBROM Horizontal Romentry268 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry268
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry268_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry268_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry268 bdk_apbrom_horizontal_romentry268_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY268 BDK_APBROM_HORIZONTAL_ROMENTRY268_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY268_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY268_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000430ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY268", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY268 bdk_apbrom_horizontal_romentry268_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY268 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY268 "APBROM_HORIZONTAL_ROMENTRY268"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY268 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY268 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry269
 *
 * APBROM Horizontal Romentry269 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry269
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry269_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry269_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry269 bdk_apbrom_horizontal_romentry269_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY269 BDK_APBROM_HORIZONTAL_ROMENTRY269_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY269_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY269_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000434ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY269", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY269 bdk_apbrom_horizontal_romentry269_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY269 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY269 "APBROM_HORIZONTAL_ROMENTRY269"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY269 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY269 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry27
 *
 * APBROM Horizontal Romentry27 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry27
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry27_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry27_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry27 bdk_apbrom_horizontal_romentry27_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY27 BDK_APBROM_HORIZONTAL_ROMENTRY27_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY27_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY27_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600006cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY27", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY27 bdk_apbrom_horizontal_romentry27_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY27 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY27 "APBROM_HORIZONTAL_ROMENTRY27"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY27 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY27 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry270
 *
 * APBROM Horizontal Romentry270 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry270
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry270_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry270_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry270 bdk_apbrom_horizontal_romentry270_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY270 BDK_APBROM_HORIZONTAL_ROMENTRY270_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY270_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY270_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000438ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY270", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY270 bdk_apbrom_horizontal_romentry270_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY270 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY270 "APBROM_HORIZONTAL_ROMENTRY270"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY270 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY270 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry271
 *
 * APBROM Horizontal Romentry271 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry271
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry271_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry271_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry271 bdk_apbrom_horizontal_romentry271_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY271 BDK_APBROM_HORIZONTAL_ROMENTRY271_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY271_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY271_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600043cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY271", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY271 bdk_apbrom_horizontal_romentry271_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY271 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY271 "APBROM_HORIZONTAL_ROMENTRY271"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY271 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY271 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry272
 *
 * APBROM Horizontal Romentry272 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry272
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry272_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry272_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry272 bdk_apbrom_horizontal_romentry272_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY272 BDK_APBROM_HORIZONTAL_ROMENTRY272_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY272_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY272_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000440ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY272", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY272 bdk_apbrom_horizontal_romentry272_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY272 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY272 "APBROM_HORIZONTAL_ROMENTRY272"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY272 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY272 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry273
 *
 * APBROM Horizontal Romentry273 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry273
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry273_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry273_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry273 bdk_apbrom_horizontal_romentry273_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY273 BDK_APBROM_HORIZONTAL_ROMENTRY273_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY273_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY273_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000444ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY273", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY273 bdk_apbrom_horizontal_romentry273_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY273 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY273 "APBROM_HORIZONTAL_ROMENTRY273"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY273 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY273 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry274
 *
 * APBROM Horizontal Romentry274 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry274
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry274_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry274_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry274 bdk_apbrom_horizontal_romentry274_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY274 BDK_APBROM_HORIZONTAL_ROMENTRY274_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY274_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY274_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000448ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY274", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY274 bdk_apbrom_horizontal_romentry274_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY274 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY274 "APBROM_HORIZONTAL_ROMENTRY274"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY274 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY274 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry275
 *
 * APBROM Horizontal Romentry275 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry275
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry275_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry275_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry275 bdk_apbrom_horizontal_romentry275_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY275 BDK_APBROM_HORIZONTAL_ROMENTRY275_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY275_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY275_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600044cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY275", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY275 bdk_apbrom_horizontal_romentry275_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY275 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY275 "APBROM_HORIZONTAL_ROMENTRY275"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY275 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY275 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry276
 *
 * APBROM Horizontal Romentry276 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry276
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry276_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry276_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry276 bdk_apbrom_horizontal_romentry276_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY276 BDK_APBROM_HORIZONTAL_ROMENTRY276_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY276_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY276_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000450ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY276", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY276 bdk_apbrom_horizontal_romentry276_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY276 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY276 "APBROM_HORIZONTAL_ROMENTRY276"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY276 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY276 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry277
 *
 * APBROM Horizontal Romentry277 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry277
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry277_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry277_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry277 bdk_apbrom_horizontal_romentry277_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY277 BDK_APBROM_HORIZONTAL_ROMENTRY277_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY277_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY277_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000454ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY277", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY277 bdk_apbrom_horizontal_romentry277_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY277 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY277 "APBROM_HORIZONTAL_ROMENTRY277"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY277 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY277 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry278
 *
 * APBROM Horizontal Romentry278 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry278
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry278_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry278_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry278 bdk_apbrom_horizontal_romentry278_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY278 BDK_APBROM_HORIZONTAL_ROMENTRY278_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY278_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY278_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000458ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY278", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY278 bdk_apbrom_horizontal_romentry278_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY278 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY278 "APBROM_HORIZONTAL_ROMENTRY278"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY278 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY278 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry279
 *
 * APBROM Horizontal Romentry279 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry279
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry279_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry279_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry279 bdk_apbrom_horizontal_romentry279_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY279 BDK_APBROM_HORIZONTAL_ROMENTRY279_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY279_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY279_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600045cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY279", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY279 bdk_apbrom_horizontal_romentry279_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY279 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY279 "APBROM_HORIZONTAL_ROMENTRY279"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY279 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY279 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry28
 *
 * APBROM Horizontal Romentry28 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry28
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry28_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry28_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry28 bdk_apbrom_horizontal_romentry28_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY28 BDK_APBROM_HORIZONTAL_ROMENTRY28_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY28_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY28_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000070ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY28", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY28 bdk_apbrom_horizontal_romentry28_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY28 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY28 "APBROM_HORIZONTAL_ROMENTRY28"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY28 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY28 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry280
 *
 * APBROM Horizontal Romentry280 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry280
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry280_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry280_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry280 bdk_apbrom_horizontal_romentry280_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY280 BDK_APBROM_HORIZONTAL_ROMENTRY280_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY280_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY280_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000460ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY280", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY280 bdk_apbrom_horizontal_romentry280_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY280 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY280 "APBROM_HORIZONTAL_ROMENTRY280"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY280 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY280 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry281
 *
 * APBROM Horizontal Romentry281 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry281
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry281_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry281_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry281 bdk_apbrom_horizontal_romentry281_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY281 BDK_APBROM_HORIZONTAL_ROMENTRY281_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY281_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY281_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000464ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY281", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY281 bdk_apbrom_horizontal_romentry281_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY281 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY281 "APBROM_HORIZONTAL_ROMENTRY281"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY281 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY281 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry282
 *
 * APBROM Horizontal Romentry282 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry282
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry282_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry282_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry282 bdk_apbrom_horizontal_romentry282_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY282 BDK_APBROM_HORIZONTAL_ROMENTRY282_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY282_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY282_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000468ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY282", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY282 bdk_apbrom_horizontal_romentry282_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY282 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY282 "APBROM_HORIZONTAL_ROMENTRY282"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY282 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY282 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry283
 *
 * APBROM Horizontal Romentry283 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry283
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry283_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry283_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry283 bdk_apbrom_horizontal_romentry283_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY283 BDK_APBROM_HORIZONTAL_ROMENTRY283_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY283_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY283_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600046cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY283", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY283 bdk_apbrom_horizontal_romentry283_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY283 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY283 "APBROM_HORIZONTAL_ROMENTRY283"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY283 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY283 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry284
 *
 * APBROM Horizontal Romentry284 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry284
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry284_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry284_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry284 bdk_apbrom_horizontal_romentry284_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY284 BDK_APBROM_HORIZONTAL_ROMENTRY284_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY284_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY284_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000470ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY284", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY284 bdk_apbrom_horizontal_romentry284_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY284 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY284 "APBROM_HORIZONTAL_ROMENTRY284"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY284 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY284 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry285
 *
 * APBROM Horizontal Romentry285 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry285
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry285_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry285_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry285 bdk_apbrom_horizontal_romentry285_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY285 BDK_APBROM_HORIZONTAL_ROMENTRY285_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY285_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY285_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000474ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY285", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY285 bdk_apbrom_horizontal_romentry285_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY285 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY285 "APBROM_HORIZONTAL_ROMENTRY285"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY285 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY285 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry286
 *
 * APBROM Horizontal Romentry286 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry286
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry286_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry286_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry286 bdk_apbrom_horizontal_romentry286_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY286 BDK_APBROM_HORIZONTAL_ROMENTRY286_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY286_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY286_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000478ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY286", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY286 bdk_apbrom_horizontal_romentry286_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY286 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY286 "APBROM_HORIZONTAL_ROMENTRY286"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY286 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY286 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry287
 *
 * APBROM Horizontal Romentry287 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry287
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry287_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry287_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry287 bdk_apbrom_horizontal_romentry287_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY287 BDK_APBROM_HORIZONTAL_ROMENTRY287_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY287_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY287_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600047cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY287", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY287 bdk_apbrom_horizontal_romentry287_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY287 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY287 "APBROM_HORIZONTAL_ROMENTRY287"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY287 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY287 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry288
 *
 * APBROM Horizontal Romentry288 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry288
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry288_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry288_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry288 bdk_apbrom_horizontal_romentry288_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY288 BDK_APBROM_HORIZONTAL_ROMENTRY288_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY288_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY288_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000480ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY288", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY288 bdk_apbrom_horizontal_romentry288_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY288 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY288 "APBROM_HORIZONTAL_ROMENTRY288"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY288 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY288 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry289
 *
 * APBROM Horizontal Romentry289 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry289
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry289_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry289_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry289 bdk_apbrom_horizontal_romentry289_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY289 BDK_APBROM_HORIZONTAL_ROMENTRY289_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY289_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY289_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000484ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY289", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY289 bdk_apbrom_horizontal_romentry289_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY289 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY289 "APBROM_HORIZONTAL_ROMENTRY289"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY289 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY289 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry29
 *
 * APBROM Horizontal Romentry29 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry29
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry29_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry29_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry29 bdk_apbrom_horizontal_romentry29_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY29 BDK_APBROM_HORIZONTAL_ROMENTRY29_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY29_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY29_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000074ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY29", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY29 bdk_apbrom_horizontal_romentry29_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY29 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY29 "APBROM_HORIZONTAL_ROMENTRY29"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY29 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY29 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry290
 *
 * APBROM Horizontal Romentry290 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry290
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry290_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry290_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry290 bdk_apbrom_horizontal_romentry290_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY290 BDK_APBROM_HORIZONTAL_ROMENTRY290_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY290_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY290_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000488ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY290", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY290 bdk_apbrom_horizontal_romentry290_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY290 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY290 "APBROM_HORIZONTAL_ROMENTRY290"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY290 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY290 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry291
 *
 * APBROM Horizontal Romentry291 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry291
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry291_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry291_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry291 bdk_apbrom_horizontal_romentry291_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY291 BDK_APBROM_HORIZONTAL_ROMENTRY291_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY291_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY291_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600048cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY291", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY291 bdk_apbrom_horizontal_romentry291_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY291 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY291 "APBROM_HORIZONTAL_ROMENTRY291"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY291 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY291 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry292
 *
 * APBROM Horizontal Romentry292 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry292
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry292_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry292_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry292 bdk_apbrom_horizontal_romentry292_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY292 BDK_APBROM_HORIZONTAL_ROMENTRY292_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY292_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY292_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000490ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY292", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY292 bdk_apbrom_horizontal_romentry292_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY292 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY292 "APBROM_HORIZONTAL_ROMENTRY292"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY292 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY292 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry293
 *
 * APBROM Horizontal Romentry293 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry293
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry293_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry293_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry293 bdk_apbrom_horizontal_romentry293_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY293 BDK_APBROM_HORIZONTAL_ROMENTRY293_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY293_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY293_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000494ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY293", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY293 bdk_apbrom_horizontal_romentry293_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY293 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY293 "APBROM_HORIZONTAL_ROMENTRY293"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY293 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY293 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry294
 *
 * APBROM Horizontal Romentry294 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry294
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry294_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry294_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry294 bdk_apbrom_horizontal_romentry294_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY294 BDK_APBROM_HORIZONTAL_ROMENTRY294_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY294_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY294_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000498ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY294", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY294 bdk_apbrom_horizontal_romentry294_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY294 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY294 "APBROM_HORIZONTAL_ROMENTRY294"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY294 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY294 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry295
 *
 * APBROM Horizontal Romentry295 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry295
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry295_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry295_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry295 bdk_apbrom_horizontal_romentry295_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY295 BDK_APBROM_HORIZONTAL_ROMENTRY295_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY295_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY295_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600049cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY295", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY295 bdk_apbrom_horizontal_romentry295_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY295 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY295 "APBROM_HORIZONTAL_ROMENTRY295"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY295 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY295 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry296
 *
 * APBROM Horizontal Romentry296 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry296
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry296_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry296_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry296 bdk_apbrom_horizontal_romentry296_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY296 BDK_APBROM_HORIZONTAL_ROMENTRY296_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY296_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY296_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY296", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY296 bdk_apbrom_horizontal_romentry296_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY296 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY296 "APBROM_HORIZONTAL_ROMENTRY296"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY296 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY296 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry297
 *
 * APBROM Horizontal Romentry297 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry297
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry297_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry297_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry297 bdk_apbrom_horizontal_romentry297_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY297 BDK_APBROM_HORIZONTAL_ROMENTRY297_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY297_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY297_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY297", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY297 bdk_apbrom_horizontal_romentry297_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY297 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY297 "APBROM_HORIZONTAL_ROMENTRY297"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY297 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY297 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry298
 *
 * APBROM Horizontal Romentry298 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry298
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry298_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry298_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry298 bdk_apbrom_horizontal_romentry298_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY298 BDK_APBROM_HORIZONTAL_ROMENTRY298_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY298_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY298_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY298", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY298 bdk_apbrom_horizontal_romentry298_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY298 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY298 "APBROM_HORIZONTAL_ROMENTRY298"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY298 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY298 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry299
 *
 * APBROM Horizontal Romentry299 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry299
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry299_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry299_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry299 bdk_apbrom_horizontal_romentry299_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY299 BDK_APBROM_HORIZONTAL_ROMENTRY299_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY299_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY299_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY299", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY299 bdk_apbrom_horizontal_romentry299_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY299 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY299 "APBROM_HORIZONTAL_ROMENTRY299"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY299 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY299 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry3
 *
 * APBROM Horizontal Romentry3 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry3
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry3_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry3 bdk_apbrom_horizontal_romentry3_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY3 BDK_APBROM_HORIZONTAL_ROMENTRY3_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY3_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600000cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY3", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY3 bdk_apbrom_horizontal_romentry3_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY3 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY3 "APBROM_HORIZONTAL_ROMENTRY3"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY3 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY3 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry30
 *
 * APBROM Horizontal Romentry30 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry30
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry30_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry30_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry30 bdk_apbrom_horizontal_romentry30_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY30 BDK_APBROM_HORIZONTAL_ROMENTRY30_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY30_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY30_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000078ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY30", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY30 bdk_apbrom_horizontal_romentry30_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY30 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY30 "APBROM_HORIZONTAL_ROMENTRY30"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY30 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY30 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry300
 *
 * APBROM Horizontal Romentry300 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry300
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry300_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry300_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry300 bdk_apbrom_horizontal_romentry300_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY300 BDK_APBROM_HORIZONTAL_ROMENTRY300_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY300_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY300_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY300", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY300 bdk_apbrom_horizontal_romentry300_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY300 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY300 "APBROM_HORIZONTAL_ROMENTRY300"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY300 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY300 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry301
 *
 * APBROM Horizontal Romentry301 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry301
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry301_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry301_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry301 bdk_apbrom_horizontal_romentry301_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY301 BDK_APBROM_HORIZONTAL_ROMENTRY301_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY301_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY301_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY301", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY301 bdk_apbrom_horizontal_romentry301_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY301 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY301 "APBROM_HORIZONTAL_ROMENTRY301"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY301 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY301 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry302
 *
 * APBROM Horizontal Romentry302 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry302
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry302_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry302_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry302 bdk_apbrom_horizontal_romentry302_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY302 BDK_APBROM_HORIZONTAL_ROMENTRY302_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY302_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY302_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY302", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY302 bdk_apbrom_horizontal_romentry302_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY302 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY302 "APBROM_HORIZONTAL_ROMENTRY302"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY302 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY302 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry303
 *
 * APBROM Horizontal Romentry303 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry303
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry303_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry303_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry303 bdk_apbrom_horizontal_romentry303_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY303 BDK_APBROM_HORIZONTAL_ROMENTRY303_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY303_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY303_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY303", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY303 bdk_apbrom_horizontal_romentry303_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY303 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY303 "APBROM_HORIZONTAL_ROMENTRY303"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY303 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY303 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry304
 *
 * APBROM Horizontal Romentry304 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry304
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry304_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry304_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry304 bdk_apbrom_horizontal_romentry304_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY304 BDK_APBROM_HORIZONTAL_ROMENTRY304_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY304_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY304_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY304", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY304 bdk_apbrom_horizontal_romentry304_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY304 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY304 "APBROM_HORIZONTAL_ROMENTRY304"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY304 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY304 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry305
 *
 * APBROM Horizontal Romentry305 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry305
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry305_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry305_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry305 bdk_apbrom_horizontal_romentry305_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY305 BDK_APBROM_HORIZONTAL_ROMENTRY305_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY305_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY305_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY305", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY305 bdk_apbrom_horizontal_romentry305_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY305 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY305 "APBROM_HORIZONTAL_ROMENTRY305"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY305 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY305 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry306
 *
 * APBROM Horizontal Romentry306 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry306
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry306_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry306_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry306 bdk_apbrom_horizontal_romentry306_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY306 BDK_APBROM_HORIZONTAL_ROMENTRY306_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY306_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY306_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY306", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY306 bdk_apbrom_horizontal_romentry306_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY306 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY306 "APBROM_HORIZONTAL_ROMENTRY306"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY306 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY306 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry307
 *
 * APBROM Horizontal Romentry307 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry307
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry307_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry307_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry307 bdk_apbrom_horizontal_romentry307_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY307 BDK_APBROM_HORIZONTAL_ROMENTRY307_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY307_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY307_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY307", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY307 bdk_apbrom_horizontal_romentry307_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY307 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY307 "APBROM_HORIZONTAL_ROMENTRY307"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY307 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY307 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry308
 *
 * APBROM Horizontal Romentry308 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry308
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry308_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry308_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry308 bdk_apbrom_horizontal_romentry308_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY308 BDK_APBROM_HORIZONTAL_ROMENTRY308_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY308_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY308_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY308", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY308 bdk_apbrom_horizontal_romentry308_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY308 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY308 "APBROM_HORIZONTAL_ROMENTRY308"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY308 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY308 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry309
 *
 * APBROM Horizontal Romentry309 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry309
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry309_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry309_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry309 bdk_apbrom_horizontal_romentry309_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY309 BDK_APBROM_HORIZONTAL_ROMENTRY309_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY309_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY309_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY309", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY309 bdk_apbrom_horizontal_romentry309_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY309 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY309 "APBROM_HORIZONTAL_ROMENTRY309"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY309 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY309 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry31
 *
 * APBROM Horizontal Romentry31 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry31
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry31_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry31_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry31 bdk_apbrom_horizontal_romentry31_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY31 BDK_APBROM_HORIZONTAL_ROMENTRY31_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY31_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY31_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600007cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY31", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY31 bdk_apbrom_horizontal_romentry31_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY31 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY31 "APBROM_HORIZONTAL_ROMENTRY31"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY31 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY31 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry310
 *
 * APBROM Horizontal Romentry310 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry310
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry310_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry310_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry310 bdk_apbrom_horizontal_romentry310_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY310 BDK_APBROM_HORIZONTAL_ROMENTRY310_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY310_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY310_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY310", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY310 bdk_apbrom_horizontal_romentry310_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY310 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY310 "APBROM_HORIZONTAL_ROMENTRY310"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY310 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY310 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry311
 *
 * APBROM Horizontal Romentry311 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry311
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry311_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry311_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry311 bdk_apbrom_horizontal_romentry311_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY311 BDK_APBROM_HORIZONTAL_ROMENTRY311_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY311_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY311_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY311", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY311 bdk_apbrom_horizontal_romentry311_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY311 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY311 "APBROM_HORIZONTAL_ROMENTRY311"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY311 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY311 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry312
 *
 * APBROM Horizontal Romentry312 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry312
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry312_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry312_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry312 bdk_apbrom_horizontal_romentry312_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY312 BDK_APBROM_HORIZONTAL_ROMENTRY312_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY312_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY312_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY312", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY312 bdk_apbrom_horizontal_romentry312_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY312 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY312 "APBROM_HORIZONTAL_ROMENTRY312"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY312 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY312 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry313
 *
 * APBROM Horizontal Romentry313 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry313
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry313_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry313_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry313 bdk_apbrom_horizontal_romentry313_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY313 BDK_APBROM_HORIZONTAL_ROMENTRY313_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY313_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY313_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY313", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY313 bdk_apbrom_horizontal_romentry313_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY313 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY313 "APBROM_HORIZONTAL_ROMENTRY313"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY313 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY313 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry314
 *
 * APBROM Horizontal Romentry314 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry314
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry314_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry314_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry314 bdk_apbrom_horizontal_romentry314_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY314 BDK_APBROM_HORIZONTAL_ROMENTRY314_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY314_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY314_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY314", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY314 bdk_apbrom_horizontal_romentry314_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY314 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY314 "APBROM_HORIZONTAL_ROMENTRY314"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY314 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY314 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry315
 *
 * APBROM Horizontal Romentry315 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry315
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry315_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry315_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry315 bdk_apbrom_horizontal_romentry315_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY315 BDK_APBROM_HORIZONTAL_ROMENTRY315_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY315_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY315_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY315", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY315 bdk_apbrom_horizontal_romentry315_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY315 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY315 "APBROM_HORIZONTAL_ROMENTRY315"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY315 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY315 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry316
 *
 * APBROM Horizontal Romentry316 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry316
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry316_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry316_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry316 bdk_apbrom_horizontal_romentry316_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY316 BDK_APBROM_HORIZONTAL_ROMENTRY316_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY316_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY316_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY316", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY316 bdk_apbrom_horizontal_romentry316_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY316 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY316 "APBROM_HORIZONTAL_ROMENTRY316"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY316 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY316 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry317
 *
 * APBROM Horizontal Romentry317 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry317
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry317_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry317_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry317 bdk_apbrom_horizontal_romentry317_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY317 BDK_APBROM_HORIZONTAL_ROMENTRY317_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY317_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY317_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY317", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY317 bdk_apbrom_horizontal_romentry317_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY317 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY317 "APBROM_HORIZONTAL_ROMENTRY317"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY317 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY317 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry318
 *
 * APBROM Horizontal Romentry318 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry318
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry318_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry318_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry318 bdk_apbrom_horizontal_romentry318_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY318 BDK_APBROM_HORIZONTAL_ROMENTRY318_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY318_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY318_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY318", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY318 bdk_apbrom_horizontal_romentry318_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY318 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY318 "APBROM_HORIZONTAL_ROMENTRY318"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY318 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY318 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry319
 *
 * APBROM Horizontal Romentry319 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry319
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry319_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry319_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry319 bdk_apbrom_horizontal_romentry319_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY319 BDK_APBROM_HORIZONTAL_ROMENTRY319_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY319_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY319_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460004fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY319", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY319 bdk_apbrom_horizontal_romentry319_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY319 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY319 "APBROM_HORIZONTAL_ROMENTRY319"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY319 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY319 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry32
 *
 * APBROM Horizontal Romentry32 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry32
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry32_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry32 bdk_apbrom_horizontal_romentry32_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY32 BDK_APBROM_HORIZONTAL_ROMENTRY32_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY32_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY32_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000080ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY32", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY32 bdk_apbrom_horizontal_romentry32_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY32 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY32 "APBROM_HORIZONTAL_ROMENTRY32"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY32 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY32 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry320
 *
 * APBROM Horizontal Romentry320 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry320
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry320_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry320_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry320 bdk_apbrom_horizontal_romentry320_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY320 BDK_APBROM_HORIZONTAL_ROMENTRY320_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY320_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY320_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000500ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY320", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY320 bdk_apbrom_horizontal_romentry320_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY320 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY320 "APBROM_HORIZONTAL_ROMENTRY320"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY320 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY320 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry321
 *
 * APBROM Horizontal Romentry321 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry321
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry321_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry321_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry321 bdk_apbrom_horizontal_romentry321_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY321 BDK_APBROM_HORIZONTAL_ROMENTRY321_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY321_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY321_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000504ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY321", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY321 bdk_apbrom_horizontal_romentry321_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY321 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY321 "APBROM_HORIZONTAL_ROMENTRY321"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY321 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY321 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry322
 *
 * APBROM Horizontal Romentry322 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry322
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry322_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry322_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry322 bdk_apbrom_horizontal_romentry322_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY322 BDK_APBROM_HORIZONTAL_ROMENTRY322_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY322_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY322_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000508ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY322", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY322 bdk_apbrom_horizontal_romentry322_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY322 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY322 "APBROM_HORIZONTAL_ROMENTRY322"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY322 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY322 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry323
 *
 * APBROM Horizontal Romentry323 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry323
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry323_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry323_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry323 bdk_apbrom_horizontal_romentry323_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY323 BDK_APBROM_HORIZONTAL_ROMENTRY323_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY323_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY323_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600050cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY323", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY323 bdk_apbrom_horizontal_romentry323_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY323 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY323 "APBROM_HORIZONTAL_ROMENTRY323"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY323 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY323 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry324
 *
 * APBROM Horizontal Romentry324 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry324
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry324_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry324_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry324 bdk_apbrom_horizontal_romentry324_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY324 BDK_APBROM_HORIZONTAL_ROMENTRY324_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY324_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY324_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000510ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY324", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY324 bdk_apbrom_horizontal_romentry324_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY324 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY324 "APBROM_HORIZONTAL_ROMENTRY324"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY324 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY324 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry325
 *
 * APBROM Horizontal Romentry325 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry325
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry325_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry325_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry325 bdk_apbrom_horizontal_romentry325_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY325 BDK_APBROM_HORIZONTAL_ROMENTRY325_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY325_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY325_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000514ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY325", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY325 bdk_apbrom_horizontal_romentry325_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY325 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY325 "APBROM_HORIZONTAL_ROMENTRY325"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY325 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY325 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry326
 *
 * APBROM Horizontal Romentry326 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry326
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry326_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry326_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry326 bdk_apbrom_horizontal_romentry326_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY326 BDK_APBROM_HORIZONTAL_ROMENTRY326_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY326_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY326_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000518ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY326", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY326 bdk_apbrom_horizontal_romentry326_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY326 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY326 "APBROM_HORIZONTAL_ROMENTRY326"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY326 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY326 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry327
 *
 * APBROM Horizontal Romentry327 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry327
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry327_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry327_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry327 bdk_apbrom_horizontal_romentry327_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY327 BDK_APBROM_HORIZONTAL_ROMENTRY327_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY327_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY327_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600051cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY327", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY327 bdk_apbrom_horizontal_romentry327_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY327 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY327 "APBROM_HORIZONTAL_ROMENTRY327"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY327 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY327 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry328
 *
 * APBROM Horizontal Romentry328 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry328
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry328_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry328_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry328 bdk_apbrom_horizontal_romentry328_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY328 BDK_APBROM_HORIZONTAL_ROMENTRY328_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY328_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY328_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000520ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY328", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY328 bdk_apbrom_horizontal_romentry328_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY328 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY328 "APBROM_HORIZONTAL_ROMENTRY328"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY328 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY328 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry329
 *
 * APBROM Horizontal Romentry329 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry329
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry329_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry329_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry329 bdk_apbrom_horizontal_romentry329_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY329 BDK_APBROM_HORIZONTAL_ROMENTRY329_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY329_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY329_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000524ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY329", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY329 bdk_apbrom_horizontal_romentry329_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY329 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY329 "APBROM_HORIZONTAL_ROMENTRY329"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY329 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY329 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry33
 *
 * APBROM Horizontal Romentry33 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry33
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry33_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry33_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry33 bdk_apbrom_horizontal_romentry33_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY33 BDK_APBROM_HORIZONTAL_ROMENTRY33_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY33_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY33_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000084ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY33", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY33 bdk_apbrom_horizontal_romentry33_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY33 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY33 "APBROM_HORIZONTAL_ROMENTRY33"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY33 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY33 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry330
 *
 * APBROM Horizontal Romentry330 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry330
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry330_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry330_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry330 bdk_apbrom_horizontal_romentry330_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY330 BDK_APBROM_HORIZONTAL_ROMENTRY330_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY330_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY330_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000528ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY330", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY330 bdk_apbrom_horizontal_romentry330_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY330 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY330 "APBROM_HORIZONTAL_ROMENTRY330"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY330 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY330 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry331
 *
 * APBROM Horizontal Romentry331 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry331
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry331_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry331_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry331 bdk_apbrom_horizontal_romentry331_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY331 BDK_APBROM_HORIZONTAL_ROMENTRY331_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY331_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY331_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600052cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY331", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY331 bdk_apbrom_horizontal_romentry331_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY331 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY331 "APBROM_HORIZONTAL_ROMENTRY331"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY331 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY331 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry332
 *
 * APBROM Horizontal Romentry332 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry332
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry332_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry332_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry332 bdk_apbrom_horizontal_romentry332_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY332 BDK_APBROM_HORIZONTAL_ROMENTRY332_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY332_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY332_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000530ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY332", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY332 bdk_apbrom_horizontal_romentry332_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY332 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY332 "APBROM_HORIZONTAL_ROMENTRY332"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY332 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY332 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry333
 *
 * APBROM Horizontal Romentry333 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry333
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry333_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry333_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry333 bdk_apbrom_horizontal_romentry333_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY333 BDK_APBROM_HORIZONTAL_ROMENTRY333_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY333_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY333_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000534ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY333", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY333 bdk_apbrom_horizontal_romentry333_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY333 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY333 "APBROM_HORIZONTAL_ROMENTRY333"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY333 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY333 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry334
 *
 * APBROM Horizontal Romentry334 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry334
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry334_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry334_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry334 bdk_apbrom_horizontal_romentry334_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY334 BDK_APBROM_HORIZONTAL_ROMENTRY334_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY334_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY334_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000538ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY334", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY334 bdk_apbrom_horizontal_romentry334_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY334 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY334 "APBROM_HORIZONTAL_ROMENTRY334"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY334 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY334 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry335
 *
 * APBROM Horizontal Romentry335 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry335
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry335_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry335_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry335 bdk_apbrom_horizontal_romentry335_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY335 BDK_APBROM_HORIZONTAL_ROMENTRY335_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY335_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY335_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600053cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY335", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY335 bdk_apbrom_horizontal_romentry335_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY335 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY335 "APBROM_HORIZONTAL_ROMENTRY335"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY335 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY335 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry336
 *
 * APBROM Horizontal Romentry336 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry336
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry336_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry336_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry336 bdk_apbrom_horizontal_romentry336_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY336 BDK_APBROM_HORIZONTAL_ROMENTRY336_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY336_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY336_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000540ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY336", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY336 bdk_apbrom_horizontal_romentry336_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY336 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY336 "APBROM_HORIZONTAL_ROMENTRY336"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY336 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY336 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry337
 *
 * APBROM Horizontal Romentry337 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry337
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry337_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry337_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry337 bdk_apbrom_horizontal_romentry337_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY337 BDK_APBROM_HORIZONTAL_ROMENTRY337_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY337_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY337_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000544ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY337", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY337 bdk_apbrom_horizontal_romentry337_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY337 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY337 "APBROM_HORIZONTAL_ROMENTRY337"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY337 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY337 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry338
 *
 * APBROM Horizontal Romentry338 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry338
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry338_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry338_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry338 bdk_apbrom_horizontal_romentry338_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY338 BDK_APBROM_HORIZONTAL_ROMENTRY338_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY338_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY338_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000548ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY338", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY338 bdk_apbrom_horizontal_romentry338_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY338 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY338 "APBROM_HORIZONTAL_ROMENTRY338"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY338 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY338 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry339
 *
 * APBROM Horizontal Romentry339 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry339
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry339_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry339_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry339 bdk_apbrom_horizontal_romentry339_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY339 BDK_APBROM_HORIZONTAL_ROMENTRY339_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY339_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY339_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600054cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY339", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY339 bdk_apbrom_horizontal_romentry339_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY339 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY339 "APBROM_HORIZONTAL_ROMENTRY339"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY339 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY339 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry34
 *
 * APBROM Horizontal Romentry34 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry34
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry34_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry34_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry34 bdk_apbrom_horizontal_romentry34_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY34 BDK_APBROM_HORIZONTAL_ROMENTRY34_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY34_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY34_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000088ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY34", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY34 bdk_apbrom_horizontal_romentry34_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY34 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY34 "APBROM_HORIZONTAL_ROMENTRY34"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY34 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY34 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry340
 *
 * APBROM Horizontal Romentry340 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry340
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry340_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry340_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry340 bdk_apbrom_horizontal_romentry340_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY340 BDK_APBROM_HORIZONTAL_ROMENTRY340_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY340_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY340_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000550ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY340", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY340 bdk_apbrom_horizontal_romentry340_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY340 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY340 "APBROM_HORIZONTAL_ROMENTRY340"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY340 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY340 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry341
 *
 * APBROM Horizontal Romentry341 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry341
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry341_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry341_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry341 bdk_apbrom_horizontal_romentry341_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY341 BDK_APBROM_HORIZONTAL_ROMENTRY341_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY341_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY341_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000554ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY341", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY341 bdk_apbrom_horizontal_romentry341_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY341 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY341 "APBROM_HORIZONTAL_ROMENTRY341"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY341 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY341 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry342
 *
 * APBROM Horizontal Romentry342 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry342
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry342_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry342_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry342 bdk_apbrom_horizontal_romentry342_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY342 BDK_APBROM_HORIZONTAL_ROMENTRY342_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY342_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY342_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000558ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY342", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY342 bdk_apbrom_horizontal_romentry342_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY342 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY342 "APBROM_HORIZONTAL_ROMENTRY342"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY342 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY342 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry343
 *
 * APBROM Horizontal Romentry343 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry343
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry343_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry343_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry343 bdk_apbrom_horizontal_romentry343_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY343 BDK_APBROM_HORIZONTAL_ROMENTRY343_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY343_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY343_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600055cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY343", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY343 bdk_apbrom_horizontal_romentry343_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY343 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY343 "APBROM_HORIZONTAL_ROMENTRY343"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY343 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY343 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry344
 *
 * APBROM Horizontal Romentry344 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry344
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry344_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry344_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry344 bdk_apbrom_horizontal_romentry344_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY344 BDK_APBROM_HORIZONTAL_ROMENTRY344_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY344_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY344_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000560ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY344", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY344 bdk_apbrom_horizontal_romentry344_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY344 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY344 "APBROM_HORIZONTAL_ROMENTRY344"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY344 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY344 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry345
 *
 * APBROM Horizontal Romentry345 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry345
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry345_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry345_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry345 bdk_apbrom_horizontal_romentry345_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY345 BDK_APBROM_HORIZONTAL_ROMENTRY345_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY345_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY345_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000564ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY345", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY345 bdk_apbrom_horizontal_romentry345_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY345 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY345 "APBROM_HORIZONTAL_ROMENTRY345"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY345 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY345 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry346
 *
 * APBROM Horizontal Romentry346 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry346
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry346_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry346_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry346 bdk_apbrom_horizontal_romentry346_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY346 BDK_APBROM_HORIZONTAL_ROMENTRY346_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY346_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY346_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000568ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY346", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY346 bdk_apbrom_horizontal_romentry346_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY346 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY346 "APBROM_HORIZONTAL_ROMENTRY346"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY346 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY346 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry347
 *
 * APBROM Horizontal Romentry347 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry347
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry347_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry347_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry347 bdk_apbrom_horizontal_romentry347_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY347 BDK_APBROM_HORIZONTAL_ROMENTRY347_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY347_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY347_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600056cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY347", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY347 bdk_apbrom_horizontal_romentry347_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY347 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY347 "APBROM_HORIZONTAL_ROMENTRY347"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY347 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY347 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry348
 *
 * APBROM Horizontal Romentry348 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry348
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry348_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry348_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry348 bdk_apbrom_horizontal_romentry348_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY348 BDK_APBROM_HORIZONTAL_ROMENTRY348_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY348_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY348_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000570ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY348", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY348 bdk_apbrom_horizontal_romentry348_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY348 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY348 "APBROM_HORIZONTAL_ROMENTRY348"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY348 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY348 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry349
 *
 * APBROM Horizontal Romentry349 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry349
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry349_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry349_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry349 bdk_apbrom_horizontal_romentry349_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY349 BDK_APBROM_HORIZONTAL_ROMENTRY349_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY349_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY349_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000574ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY349", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY349 bdk_apbrom_horizontal_romentry349_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY349 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY349 "APBROM_HORIZONTAL_ROMENTRY349"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY349 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY349 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry35
 *
 * APBROM Horizontal Romentry35 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry35
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry35_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry35_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry35 bdk_apbrom_horizontal_romentry35_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY35 BDK_APBROM_HORIZONTAL_ROMENTRY35_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY35_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY35_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600008cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY35", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY35 bdk_apbrom_horizontal_romentry35_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY35 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY35 "APBROM_HORIZONTAL_ROMENTRY35"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY35 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY35 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry350
 *
 * APBROM Horizontal Romentry350 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry350
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry350_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry350_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry350 bdk_apbrom_horizontal_romentry350_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY350 BDK_APBROM_HORIZONTAL_ROMENTRY350_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY350_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY350_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000578ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY350", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY350 bdk_apbrom_horizontal_romentry350_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY350 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY350 "APBROM_HORIZONTAL_ROMENTRY350"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY350 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY350 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry351
 *
 * APBROM Horizontal Romentry351 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry351
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry351_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry351_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry351 bdk_apbrom_horizontal_romentry351_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY351 BDK_APBROM_HORIZONTAL_ROMENTRY351_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY351_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY351_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600057cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY351", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY351 bdk_apbrom_horizontal_romentry351_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY351 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY351 "APBROM_HORIZONTAL_ROMENTRY351"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY351 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY351 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry352
 *
 * APBROM Horizontal Romentry352 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry352
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry352_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry352_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry352 bdk_apbrom_horizontal_romentry352_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY352 BDK_APBROM_HORIZONTAL_ROMENTRY352_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY352_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY352_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000580ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY352", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY352 bdk_apbrom_horizontal_romentry352_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY352 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY352 "APBROM_HORIZONTAL_ROMENTRY352"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY352 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY352 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry353
 *
 * APBROM Horizontal Romentry353 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry353
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry353_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry353_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry353 bdk_apbrom_horizontal_romentry353_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY353 BDK_APBROM_HORIZONTAL_ROMENTRY353_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY353_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY353_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000584ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY353", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY353 bdk_apbrom_horizontal_romentry353_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY353 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY353 "APBROM_HORIZONTAL_ROMENTRY353"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY353 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY353 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry354
 *
 * APBROM Horizontal Romentry354 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry354
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry354_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry354_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry354 bdk_apbrom_horizontal_romentry354_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY354 BDK_APBROM_HORIZONTAL_ROMENTRY354_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY354_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY354_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000588ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY354", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY354 bdk_apbrom_horizontal_romentry354_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY354 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY354 "APBROM_HORIZONTAL_ROMENTRY354"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY354 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY354 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry355
 *
 * APBROM Horizontal Romentry355 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry355
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry355_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry355_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry355 bdk_apbrom_horizontal_romentry355_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY355 BDK_APBROM_HORIZONTAL_ROMENTRY355_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY355_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY355_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600058cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY355", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY355 bdk_apbrom_horizontal_romentry355_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY355 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY355 "APBROM_HORIZONTAL_ROMENTRY355"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY355 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY355 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry356
 *
 * APBROM Horizontal Romentry356 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry356
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry356_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry356_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry356 bdk_apbrom_horizontal_romentry356_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY356 BDK_APBROM_HORIZONTAL_ROMENTRY356_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY356_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY356_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000590ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY356", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY356 bdk_apbrom_horizontal_romentry356_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY356 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY356 "APBROM_HORIZONTAL_ROMENTRY356"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY356 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY356 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry357
 *
 * APBROM Horizontal Romentry357 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry357
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry357_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry357_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry357 bdk_apbrom_horizontal_romentry357_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY357 BDK_APBROM_HORIZONTAL_ROMENTRY357_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY357_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY357_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000594ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY357", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY357 bdk_apbrom_horizontal_romentry357_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY357 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY357 "APBROM_HORIZONTAL_ROMENTRY357"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY357 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY357 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry358
 *
 * APBROM Horizontal Romentry358 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry358
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry358_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry358_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry358 bdk_apbrom_horizontal_romentry358_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY358 BDK_APBROM_HORIZONTAL_ROMENTRY358_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY358_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY358_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000598ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY358", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY358 bdk_apbrom_horizontal_romentry358_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY358 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY358 "APBROM_HORIZONTAL_ROMENTRY358"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY358 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY358 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry359
 *
 * APBROM Horizontal Romentry359 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry359
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry359_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry359_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry359 bdk_apbrom_horizontal_romentry359_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY359 BDK_APBROM_HORIZONTAL_ROMENTRY359_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY359_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY359_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600059cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY359", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY359 bdk_apbrom_horizontal_romentry359_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY359 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY359 "APBROM_HORIZONTAL_ROMENTRY359"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY359 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY359 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry36
 *
 * APBROM Horizontal Romentry36 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry36
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry36_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry36_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry36 bdk_apbrom_horizontal_romentry36_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY36 BDK_APBROM_HORIZONTAL_ROMENTRY36_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY36_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY36_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000090ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY36", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY36 bdk_apbrom_horizontal_romentry36_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY36 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY36 "APBROM_HORIZONTAL_ROMENTRY36"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY36 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY36 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry360
 *
 * APBROM Horizontal Romentry360 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry360
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry360_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry360_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry360 bdk_apbrom_horizontal_romentry360_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY360 BDK_APBROM_HORIZONTAL_ROMENTRY360_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY360_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY360_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY360", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY360 bdk_apbrom_horizontal_romentry360_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY360 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY360 "APBROM_HORIZONTAL_ROMENTRY360"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY360 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY360 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry361
 *
 * APBROM Horizontal Romentry361 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry361
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry361_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry361_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry361 bdk_apbrom_horizontal_romentry361_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY361 BDK_APBROM_HORIZONTAL_ROMENTRY361_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY361_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY361_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY361", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY361 bdk_apbrom_horizontal_romentry361_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY361 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY361 "APBROM_HORIZONTAL_ROMENTRY361"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY361 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY361 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry362
 *
 * APBROM Horizontal Romentry362 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry362
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry362_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry362_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry362 bdk_apbrom_horizontal_romentry362_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY362 BDK_APBROM_HORIZONTAL_ROMENTRY362_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY362_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY362_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY362", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY362 bdk_apbrom_horizontal_romentry362_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY362 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY362 "APBROM_HORIZONTAL_ROMENTRY362"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY362 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY362 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry363
 *
 * APBROM Horizontal Romentry363 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry363
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry363_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry363_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry363 bdk_apbrom_horizontal_romentry363_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY363 BDK_APBROM_HORIZONTAL_ROMENTRY363_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY363_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY363_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY363", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY363 bdk_apbrom_horizontal_romentry363_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY363 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY363 "APBROM_HORIZONTAL_ROMENTRY363"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY363 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY363 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry364
 *
 * APBROM Horizontal Romentry364 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry364
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry364_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry364_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry364 bdk_apbrom_horizontal_romentry364_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY364 BDK_APBROM_HORIZONTAL_ROMENTRY364_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY364_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY364_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY364", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY364 bdk_apbrom_horizontal_romentry364_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY364 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY364 "APBROM_HORIZONTAL_ROMENTRY364"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY364 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY364 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry365
 *
 * APBROM Horizontal Romentry365 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry365
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry365_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry365_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry365 bdk_apbrom_horizontal_romentry365_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY365 BDK_APBROM_HORIZONTAL_ROMENTRY365_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY365_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY365_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY365", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY365 bdk_apbrom_horizontal_romentry365_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY365 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY365 "APBROM_HORIZONTAL_ROMENTRY365"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY365 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY365 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry366
 *
 * APBROM Horizontal Romentry366 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry366
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry366_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry366_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry366 bdk_apbrom_horizontal_romentry366_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY366 BDK_APBROM_HORIZONTAL_ROMENTRY366_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY366_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY366_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY366", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY366 bdk_apbrom_horizontal_romentry366_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY366 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY366 "APBROM_HORIZONTAL_ROMENTRY366"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY366 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY366 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry367
 *
 * APBROM Horizontal Romentry367 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry367
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry367_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry367_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry367 bdk_apbrom_horizontal_romentry367_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY367 BDK_APBROM_HORIZONTAL_ROMENTRY367_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY367_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY367_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY367", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY367 bdk_apbrom_horizontal_romentry367_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY367 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY367 "APBROM_HORIZONTAL_ROMENTRY367"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY367 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY367 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry368
 *
 * APBROM Horizontal Romentry368 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry368
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry368_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry368_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry368 bdk_apbrom_horizontal_romentry368_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY368 BDK_APBROM_HORIZONTAL_ROMENTRY368_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY368_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY368_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY368", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY368 bdk_apbrom_horizontal_romentry368_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY368 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY368 "APBROM_HORIZONTAL_ROMENTRY368"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY368 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY368 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry369
 *
 * APBROM Horizontal Romentry369 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry369
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry369_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry369_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry369 bdk_apbrom_horizontal_romentry369_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY369 BDK_APBROM_HORIZONTAL_ROMENTRY369_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY369_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY369_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY369", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY369 bdk_apbrom_horizontal_romentry369_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY369 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY369 "APBROM_HORIZONTAL_ROMENTRY369"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY369 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY369 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry37
 *
 * APBROM Horizontal Romentry37 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry37
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry37_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry37_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry37 bdk_apbrom_horizontal_romentry37_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY37 BDK_APBROM_HORIZONTAL_ROMENTRY37_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY37_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY37_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000094ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY37", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY37 bdk_apbrom_horizontal_romentry37_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY37 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY37 "APBROM_HORIZONTAL_ROMENTRY37"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY37 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY37 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry370
 *
 * APBROM Horizontal Romentry370 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry370
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry370_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry370_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry370 bdk_apbrom_horizontal_romentry370_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY370 BDK_APBROM_HORIZONTAL_ROMENTRY370_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY370_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY370_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY370", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY370 bdk_apbrom_horizontal_romentry370_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY370 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY370 "APBROM_HORIZONTAL_ROMENTRY370"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY370 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY370 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry371
 *
 * APBROM Horizontal Romentry371 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry371
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry371_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry371_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry371 bdk_apbrom_horizontal_romentry371_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY371 BDK_APBROM_HORIZONTAL_ROMENTRY371_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY371_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY371_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY371", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY371 bdk_apbrom_horizontal_romentry371_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY371 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY371 "APBROM_HORIZONTAL_ROMENTRY371"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY371 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY371 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry372
 *
 * APBROM Horizontal Romentry372 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry372
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry372_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry372_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry372 bdk_apbrom_horizontal_romentry372_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY372 BDK_APBROM_HORIZONTAL_ROMENTRY372_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY372_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY372_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY372", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY372 bdk_apbrom_horizontal_romentry372_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY372 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY372 "APBROM_HORIZONTAL_ROMENTRY372"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY372 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY372 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry373
 *
 * APBROM Horizontal Romentry373 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry373
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry373_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry373_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry373 bdk_apbrom_horizontal_romentry373_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY373 BDK_APBROM_HORIZONTAL_ROMENTRY373_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY373_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY373_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY373", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY373 bdk_apbrom_horizontal_romentry373_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY373 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY373 "APBROM_HORIZONTAL_ROMENTRY373"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY373 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY373 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry374
 *
 * APBROM Horizontal Romentry374 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry374
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry374_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry374_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry374 bdk_apbrom_horizontal_romentry374_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY374 BDK_APBROM_HORIZONTAL_ROMENTRY374_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY374_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY374_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY374", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY374 bdk_apbrom_horizontal_romentry374_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY374 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY374 "APBROM_HORIZONTAL_ROMENTRY374"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY374 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY374 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry375
 *
 * APBROM Horizontal Romentry375 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry375
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry375_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry375_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry375 bdk_apbrom_horizontal_romentry375_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY375 BDK_APBROM_HORIZONTAL_ROMENTRY375_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY375_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY375_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY375", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY375 bdk_apbrom_horizontal_romentry375_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY375 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY375 "APBROM_HORIZONTAL_ROMENTRY375"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY375 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY375 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry376
 *
 * APBROM Horizontal Romentry376 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry376
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry376_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry376_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry376 bdk_apbrom_horizontal_romentry376_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY376 BDK_APBROM_HORIZONTAL_ROMENTRY376_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY376_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY376_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY376", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY376 bdk_apbrom_horizontal_romentry376_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY376 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY376 "APBROM_HORIZONTAL_ROMENTRY376"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY376 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY376 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry377
 *
 * APBROM Horizontal Romentry377 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry377
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry377_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry377_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry377 bdk_apbrom_horizontal_romentry377_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY377 BDK_APBROM_HORIZONTAL_ROMENTRY377_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY377_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY377_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY377", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY377 bdk_apbrom_horizontal_romentry377_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY377 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY377 "APBROM_HORIZONTAL_ROMENTRY377"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY377 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY377 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry378
 *
 * APBROM Horizontal Romentry378 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry378
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry378_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry378_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry378 bdk_apbrom_horizontal_romentry378_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY378 BDK_APBROM_HORIZONTAL_ROMENTRY378_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY378_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY378_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY378", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY378 bdk_apbrom_horizontal_romentry378_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY378 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY378 "APBROM_HORIZONTAL_ROMENTRY378"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY378 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY378 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry379
 *
 * APBROM Horizontal Romentry379 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry379
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry379_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry379_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry379 bdk_apbrom_horizontal_romentry379_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY379 BDK_APBROM_HORIZONTAL_ROMENTRY379_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY379_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY379_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY379", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY379 bdk_apbrom_horizontal_romentry379_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY379 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY379 "APBROM_HORIZONTAL_ROMENTRY379"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY379 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY379 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry38
 *
 * APBROM Horizontal Romentry38 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry38
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry38_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry38_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry38 bdk_apbrom_horizontal_romentry38_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY38 BDK_APBROM_HORIZONTAL_ROMENTRY38_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY38_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY38_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000098ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY38", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY38 bdk_apbrom_horizontal_romentry38_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY38 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY38 "APBROM_HORIZONTAL_ROMENTRY38"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY38 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY38 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry380
 *
 * APBROM Horizontal Romentry380 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry380
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry380_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry380_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry380 bdk_apbrom_horizontal_romentry380_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY380 BDK_APBROM_HORIZONTAL_ROMENTRY380_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY380_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY380_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY380", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY380 bdk_apbrom_horizontal_romentry380_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY380 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY380 "APBROM_HORIZONTAL_ROMENTRY380"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY380 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY380 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry381
 *
 * APBROM Horizontal Romentry381 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry381
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry381_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry381_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry381 bdk_apbrom_horizontal_romentry381_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY381 BDK_APBROM_HORIZONTAL_ROMENTRY381_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY381_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY381_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY381", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY381 bdk_apbrom_horizontal_romentry381_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY381 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY381 "APBROM_HORIZONTAL_ROMENTRY381"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY381 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY381 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry382
 *
 * APBROM Horizontal Romentry382 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry382
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry382_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry382_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry382 bdk_apbrom_horizontal_romentry382_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY382 BDK_APBROM_HORIZONTAL_ROMENTRY382_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY382_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY382_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY382", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY382 bdk_apbrom_horizontal_romentry382_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY382 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY382 "APBROM_HORIZONTAL_ROMENTRY382"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY382 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY382 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry383
 *
 * APBROM Horizontal Romentry383 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry383
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry383_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry383_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry383 bdk_apbrom_horizontal_romentry383_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY383 BDK_APBROM_HORIZONTAL_ROMENTRY383_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY383_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY383_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460005fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY383", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY383 bdk_apbrom_horizontal_romentry383_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY383 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY383 "APBROM_HORIZONTAL_ROMENTRY383"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY383 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY383 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry384
 *
 * APBROM Horizontal Romentry384 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry384
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry384_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry384_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry384 bdk_apbrom_horizontal_romentry384_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY384 BDK_APBROM_HORIZONTAL_ROMENTRY384_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY384_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY384_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000600ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY384", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY384 bdk_apbrom_horizontal_romentry384_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY384 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY384 "APBROM_HORIZONTAL_ROMENTRY384"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY384 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY384 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry385
 *
 * APBROM Horizontal Romentry385 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry385
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry385_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry385_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry385 bdk_apbrom_horizontal_romentry385_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY385 BDK_APBROM_HORIZONTAL_ROMENTRY385_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY385_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY385_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000604ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY385", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY385 bdk_apbrom_horizontal_romentry385_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY385 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY385 "APBROM_HORIZONTAL_ROMENTRY385"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY385 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY385 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry386
 *
 * APBROM Horizontal Romentry386 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry386
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry386_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry386_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry386 bdk_apbrom_horizontal_romentry386_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY386 BDK_APBROM_HORIZONTAL_ROMENTRY386_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY386_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY386_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000608ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY386", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY386 bdk_apbrom_horizontal_romentry386_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY386 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY386 "APBROM_HORIZONTAL_ROMENTRY386"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY386 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY386 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry387
 *
 * APBROM Horizontal Romentry387 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry387
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry387_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry387_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry387 bdk_apbrom_horizontal_romentry387_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY387 BDK_APBROM_HORIZONTAL_ROMENTRY387_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY387_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY387_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600060cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY387", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY387 bdk_apbrom_horizontal_romentry387_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY387 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY387 "APBROM_HORIZONTAL_ROMENTRY387"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY387 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY387 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry388
 *
 * APBROM Horizontal Romentry388 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry388
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry388_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry388_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry388 bdk_apbrom_horizontal_romentry388_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY388 BDK_APBROM_HORIZONTAL_ROMENTRY388_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY388_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY388_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000610ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY388", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY388 bdk_apbrom_horizontal_romentry388_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY388 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY388 "APBROM_HORIZONTAL_ROMENTRY388"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY388 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY388 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry389
 *
 * APBROM Horizontal Romentry389 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry389
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry389_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry389_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry389 bdk_apbrom_horizontal_romentry389_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY389 BDK_APBROM_HORIZONTAL_ROMENTRY389_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY389_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY389_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000614ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY389", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY389 bdk_apbrom_horizontal_romentry389_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY389 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY389 "APBROM_HORIZONTAL_ROMENTRY389"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY389 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY389 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry39
 *
 * APBROM Horizontal Romentry39 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry39
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry39_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry39_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry39 bdk_apbrom_horizontal_romentry39_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY39 BDK_APBROM_HORIZONTAL_ROMENTRY39_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY39_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY39_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600009cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY39", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY39 bdk_apbrom_horizontal_romentry39_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY39 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY39 "APBROM_HORIZONTAL_ROMENTRY39"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY39 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY39 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry390
 *
 * APBROM Horizontal Romentry390 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry390
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry390_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry390_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry390 bdk_apbrom_horizontal_romentry390_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY390 BDK_APBROM_HORIZONTAL_ROMENTRY390_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY390_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY390_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000618ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY390", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY390 bdk_apbrom_horizontal_romentry390_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY390 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY390 "APBROM_HORIZONTAL_ROMENTRY390"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY390 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY390 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry391
 *
 * APBROM Horizontal Romentry391 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry391
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry391_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry391_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry391 bdk_apbrom_horizontal_romentry391_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY391 BDK_APBROM_HORIZONTAL_ROMENTRY391_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY391_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY391_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600061cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY391", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY391 bdk_apbrom_horizontal_romentry391_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY391 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY391 "APBROM_HORIZONTAL_ROMENTRY391"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY391 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY391 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry392
 *
 * APBROM Horizontal Romentry392 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry392
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry392_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry392_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry392 bdk_apbrom_horizontal_romentry392_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY392 BDK_APBROM_HORIZONTAL_ROMENTRY392_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY392_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY392_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000620ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY392", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY392 bdk_apbrom_horizontal_romentry392_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY392 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY392 "APBROM_HORIZONTAL_ROMENTRY392"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY392 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY392 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry393
 *
 * APBROM Horizontal Romentry393 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry393
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry393_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry393_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry393 bdk_apbrom_horizontal_romentry393_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY393 BDK_APBROM_HORIZONTAL_ROMENTRY393_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY393_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY393_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000624ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY393", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY393 bdk_apbrom_horizontal_romentry393_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY393 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY393 "APBROM_HORIZONTAL_ROMENTRY393"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY393 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY393 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry394
 *
 * APBROM Horizontal Romentry394 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry394
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry394_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry394_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry394 bdk_apbrom_horizontal_romentry394_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY394 BDK_APBROM_HORIZONTAL_ROMENTRY394_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY394_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY394_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000628ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY394", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY394 bdk_apbrom_horizontal_romentry394_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY394 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY394 "APBROM_HORIZONTAL_ROMENTRY394"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY394 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY394 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry395
 *
 * APBROM Horizontal Romentry395 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry395
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry395_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry395_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry395 bdk_apbrom_horizontal_romentry395_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY395 BDK_APBROM_HORIZONTAL_ROMENTRY395_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY395_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY395_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600062cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY395", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY395 bdk_apbrom_horizontal_romentry395_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY395 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY395 "APBROM_HORIZONTAL_ROMENTRY395"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY395 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY395 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry396
 *
 * APBROM Horizontal Romentry396 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry396
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry396_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry396_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry396 bdk_apbrom_horizontal_romentry396_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY396 BDK_APBROM_HORIZONTAL_ROMENTRY396_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY396_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY396_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000630ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY396", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY396 bdk_apbrom_horizontal_romentry396_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY396 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY396 "APBROM_HORIZONTAL_ROMENTRY396"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY396 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY396 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry397
 *
 * APBROM Horizontal Romentry397 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry397
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry397_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry397_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry397 bdk_apbrom_horizontal_romentry397_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY397 BDK_APBROM_HORIZONTAL_ROMENTRY397_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY397_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY397_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000634ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY397", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY397 bdk_apbrom_horizontal_romentry397_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY397 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY397 "APBROM_HORIZONTAL_ROMENTRY397"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY397 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY397 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry398
 *
 * APBROM Horizontal Romentry398 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry398
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry398_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry398_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry398 bdk_apbrom_horizontal_romentry398_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY398 BDK_APBROM_HORIZONTAL_ROMENTRY398_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY398_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY398_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000638ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY398", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY398 bdk_apbrom_horizontal_romentry398_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY398 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY398 "APBROM_HORIZONTAL_ROMENTRY398"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY398 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY398 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry399
 *
 * APBROM Horizontal Romentry399 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry399
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry399_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry399_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry399 bdk_apbrom_horizontal_romentry399_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY399 BDK_APBROM_HORIZONTAL_ROMENTRY399_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY399_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY399_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600063cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY399", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY399 bdk_apbrom_horizontal_romentry399_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY399 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY399 "APBROM_HORIZONTAL_ROMENTRY399"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY399 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY399 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry4
 *
 * APBROM Horizontal Romentry4 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry4
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry4_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry4 bdk_apbrom_horizontal_romentry4_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY4 BDK_APBROM_HORIZONTAL_ROMENTRY4_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY4_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000010ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY4", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY4 bdk_apbrom_horizontal_romentry4_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY4 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY4 "APBROM_HORIZONTAL_ROMENTRY4"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY4 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY4 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry40
 *
 * APBROM Horizontal Romentry40 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry40
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry40_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry40 bdk_apbrom_horizontal_romentry40_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY40 BDK_APBROM_HORIZONTAL_ROMENTRY40_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY40_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY40_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY40", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY40 bdk_apbrom_horizontal_romentry40_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY40 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY40 "APBROM_HORIZONTAL_ROMENTRY40"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY40 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY40 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry400
 *
 * APBROM Horizontal Romentry400 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry400
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry400_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry400_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry400 bdk_apbrom_horizontal_romentry400_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY400 BDK_APBROM_HORIZONTAL_ROMENTRY400_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY400_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY400_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000640ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY400", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY400 bdk_apbrom_horizontal_romentry400_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY400 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY400 "APBROM_HORIZONTAL_ROMENTRY400"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY400 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY400 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry401
 *
 * APBROM Horizontal Romentry401 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry401
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry401_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry401_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry401 bdk_apbrom_horizontal_romentry401_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY401 BDK_APBROM_HORIZONTAL_ROMENTRY401_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY401_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY401_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000644ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY401", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY401 bdk_apbrom_horizontal_romentry401_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY401 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY401 "APBROM_HORIZONTAL_ROMENTRY401"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY401 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY401 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry402
 *
 * APBROM Horizontal Romentry402 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry402
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry402_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry402_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry402 bdk_apbrom_horizontal_romentry402_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY402 BDK_APBROM_HORIZONTAL_ROMENTRY402_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY402_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY402_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000648ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY402", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY402 bdk_apbrom_horizontal_romentry402_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY402 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY402 "APBROM_HORIZONTAL_ROMENTRY402"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY402 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY402 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry403
 *
 * APBROM Horizontal Romentry403 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry403
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry403_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry403_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry403 bdk_apbrom_horizontal_romentry403_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY403 BDK_APBROM_HORIZONTAL_ROMENTRY403_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY403_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY403_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600064cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY403", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY403 bdk_apbrom_horizontal_romentry403_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY403 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY403 "APBROM_HORIZONTAL_ROMENTRY403"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY403 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY403 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry404
 *
 * APBROM Horizontal Romentry404 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry404
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry404_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry404_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry404 bdk_apbrom_horizontal_romentry404_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY404 BDK_APBROM_HORIZONTAL_ROMENTRY404_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY404_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY404_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000650ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY404", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY404 bdk_apbrom_horizontal_romentry404_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY404 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY404 "APBROM_HORIZONTAL_ROMENTRY404"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY404 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY404 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry405
 *
 * APBROM Horizontal Romentry405 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry405
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry405_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry405_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry405 bdk_apbrom_horizontal_romentry405_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY405 BDK_APBROM_HORIZONTAL_ROMENTRY405_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY405_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY405_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000654ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY405", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY405 bdk_apbrom_horizontal_romentry405_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY405 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY405 "APBROM_HORIZONTAL_ROMENTRY405"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY405 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY405 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry406
 *
 * APBROM Horizontal Romentry406 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry406
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry406_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry406_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry406 bdk_apbrom_horizontal_romentry406_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY406 BDK_APBROM_HORIZONTAL_ROMENTRY406_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY406_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY406_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000658ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY406", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY406 bdk_apbrom_horizontal_romentry406_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY406 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY406 "APBROM_HORIZONTAL_ROMENTRY406"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY406 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY406 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry407
 *
 * APBROM Horizontal Romentry407 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry407
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry407_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry407_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry407 bdk_apbrom_horizontal_romentry407_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY407 BDK_APBROM_HORIZONTAL_ROMENTRY407_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY407_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY407_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600065cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY407", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY407 bdk_apbrom_horizontal_romentry407_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY407 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY407 "APBROM_HORIZONTAL_ROMENTRY407"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY407 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY407 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry408
 *
 * APBROM Horizontal Romentry408 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry408
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry408_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry408_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry408 bdk_apbrom_horizontal_romentry408_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY408 BDK_APBROM_HORIZONTAL_ROMENTRY408_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY408_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY408_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000660ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY408", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY408 bdk_apbrom_horizontal_romentry408_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY408 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY408 "APBROM_HORIZONTAL_ROMENTRY408"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY408 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY408 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry409
 *
 * APBROM Horizontal Romentry409 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry409
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry409_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry409_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry409 bdk_apbrom_horizontal_romentry409_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY409 BDK_APBROM_HORIZONTAL_ROMENTRY409_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY409_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY409_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000664ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY409", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY409 bdk_apbrom_horizontal_romentry409_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY409 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY409 "APBROM_HORIZONTAL_ROMENTRY409"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY409 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY409 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry41
 *
 * APBROM Horizontal Romentry41 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry41
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry41_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry41_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry41 bdk_apbrom_horizontal_romentry41_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY41 BDK_APBROM_HORIZONTAL_ROMENTRY41_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY41_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY41_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY41", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY41 bdk_apbrom_horizontal_romentry41_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY41 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY41 "APBROM_HORIZONTAL_ROMENTRY41"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY41 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY41 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry410
 *
 * APBROM Horizontal Romentry410 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry410
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry410_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry410_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry410 bdk_apbrom_horizontal_romentry410_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY410 BDK_APBROM_HORIZONTAL_ROMENTRY410_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY410_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY410_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000668ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY410", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY410 bdk_apbrom_horizontal_romentry410_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY410 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY410 "APBROM_HORIZONTAL_ROMENTRY410"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY410 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY410 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry411
 *
 * APBROM Horizontal Romentry411 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry411
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry411_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry411_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry411 bdk_apbrom_horizontal_romentry411_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY411 BDK_APBROM_HORIZONTAL_ROMENTRY411_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY411_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY411_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600066cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY411", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY411 bdk_apbrom_horizontal_romentry411_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY411 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY411 "APBROM_HORIZONTAL_ROMENTRY411"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY411 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY411 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry412
 *
 * APBROM Horizontal Romentry412 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry412
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry412_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry412_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry412 bdk_apbrom_horizontal_romentry412_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY412 BDK_APBROM_HORIZONTAL_ROMENTRY412_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY412_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY412_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000670ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY412", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY412 bdk_apbrom_horizontal_romentry412_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY412 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY412 "APBROM_HORIZONTAL_ROMENTRY412"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY412 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY412 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry413
 *
 * APBROM Horizontal Romentry413 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry413
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry413_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry413_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry413 bdk_apbrom_horizontal_romentry413_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY413 BDK_APBROM_HORIZONTAL_ROMENTRY413_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY413_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY413_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000674ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY413", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY413 bdk_apbrom_horizontal_romentry413_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY413 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY413 "APBROM_HORIZONTAL_ROMENTRY413"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY413 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY413 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry414
 *
 * APBROM Horizontal Romentry414 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry414
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry414_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry414_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry414 bdk_apbrom_horizontal_romentry414_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY414 BDK_APBROM_HORIZONTAL_ROMENTRY414_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY414_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY414_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000678ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY414", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY414 bdk_apbrom_horizontal_romentry414_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY414 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY414 "APBROM_HORIZONTAL_ROMENTRY414"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY414 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY414 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry415
 *
 * APBROM Horizontal Romentry415 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry415
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry415_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry415_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry415 bdk_apbrom_horizontal_romentry415_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY415 BDK_APBROM_HORIZONTAL_ROMENTRY415_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY415_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY415_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600067cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY415", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY415 bdk_apbrom_horizontal_romentry415_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY415 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY415 "APBROM_HORIZONTAL_ROMENTRY415"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY415 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY415 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry416
 *
 * APBROM Horizontal Romentry416 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry416
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry416_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry416_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry416 bdk_apbrom_horizontal_romentry416_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY416 BDK_APBROM_HORIZONTAL_ROMENTRY416_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY416_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY416_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000680ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY416", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY416 bdk_apbrom_horizontal_romentry416_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY416 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY416 "APBROM_HORIZONTAL_ROMENTRY416"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY416 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY416 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry417
 *
 * APBROM Horizontal Romentry417 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry417
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry417_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry417_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry417 bdk_apbrom_horizontal_romentry417_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY417 BDK_APBROM_HORIZONTAL_ROMENTRY417_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY417_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY417_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000684ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY417", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY417 bdk_apbrom_horizontal_romentry417_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY417 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY417 "APBROM_HORIZONTAL_ROMENTRY417"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY417 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY417 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry418
 *
 * APBROM Horizontal Romentry418 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry418
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry418_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry418_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry418 bdk_apbrom_horizontal_romentry418_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY418 BDK_APBROM_HORIZONTAL_ROMENTRY418_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY418_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY418_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000688ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY418", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY418 bdk_apbrom_horizontal_romentry418_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY418 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY418 "APBROM_HORIZONTAL_ROMENTRY418"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY418 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY418 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry419
 *
 * APBROM Horizontal Romentry419 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry419
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry419_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry419_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry419 bdk_apbrom_horizontal_romentry419_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY419 BDK_APBROM_HORIZONTAL_ROMENTRY419_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY419_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY419_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600068cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY419", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY419 bdk_apbrom_horizontal_romentry419_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY419 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY419 "APBROM_HORIZONTAL_ROMENTRY419"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY419 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY419 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry42
 *
 * APBROM Horizontal Romentry42 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry42
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry42_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry42_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry42 bdk_apbrom_horizontal_romentry42_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY42 BDK_APBROM_HORIZONTAL_ROMENTRY42_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY42_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY42_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY42", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY42 bdk_apbrom_horizontal_romentry42_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY42 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY42 "APBROM_HORIZONTAL_ROMENTRY42"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY42 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY42 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry420
 *
 * APBROM Horizontal Romentry420 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry420
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry420_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry420_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry420 bdk_apbrom_horizontal_romentry420_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY420 BDK_APBROM_HORIZONTAL_ROMENTRY420_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY420_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY420_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000690ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY420", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY420 bdk_apbrom_horizontal_romentry420_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY420 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY420 "APBROM_HORIZONTAL_ROMENTRY420"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY420 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY420 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry421
 *
 * APBROM Horizontal Romentry421 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry421
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry421_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry421_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry421 bdk_apbrom_horizontal_romentry421_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY421 BDK_APBROM_HORIZONTAL_ROMENTRY421_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY421_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY421_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000694ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY421", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY421 bdk_apbrom_horizontal_romentry421_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY421 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY421 "APBROM_HORIZONTAL_ROMENTRY421"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY421 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY421 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry422
 *
 * APBROM Horizontal Romentry422 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry422
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry422_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry422_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry422 bdk_apbrom_horizontal_romentry422_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY422 BDK_APBROM_HORIZONTAL_ROMENTRY422_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY422_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY422_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000698ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY422", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY422 bdk_apbrom_horizontal_romentry422_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY422 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY422 "APBROM_HORIZONTAL_ROMENTRY422"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY422 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY422 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry423
 *
 * APBROM Horizontal Romentry423 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry423
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry423_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry423_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry423 bdk_apbrom_horizontal_romentry423_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY423 BDK_APBROM_HORIZONTAL_ROMENTRY423_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY423_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY423_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600069cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY423", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY423 bdk_apbrom_horizontal_romentry423_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY423 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY423 "APBROM_HORIZONTAL_ROMENTRY423"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY423 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY423 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry424
 *
 * APBROM Horizontal Romentry424 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry424
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry424_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry424_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry424 bdk_apbrom_horizontal_romentry424_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY424 BDK_APBROM_HORIZONTAL_ROMENTRY424_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY424_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY424_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY424", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY424 bdk_apbrom_horizontal_romentry424_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY424 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY424 "APBROM_HORIZONTAL_ROMENTRY424"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY424 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY424 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry425
 *
 * APBROM Horizontal Romentry425 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry425
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry425_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry425_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry425 bdk_apbrom_horizontal_romentry425_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY425 BDK_APBROM_HORIZONTAL_ROMENTRY425_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY425_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY425_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY425", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY425 bdk_apbrom_horizontal_romentry425_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY425 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY425 "APBROM_HORIZONTAL_ROMENTRY425"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY425 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY425 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry426
 *
 * APBROM Horizontal Romentry426 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry426
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry426_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry426_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry426 bdk_apbrom_horizontal_romentry426_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY426 BDK_APBROM_HORIZONTAL_ROMENTRY426_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY426_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY426_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY426", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY426 bdk_apbrom_horizontal_romentry426_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY426 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY426 "APBROM_HORIZONTAL_ROMENTRY426"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY426 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY426 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry427
 *
 * APBROM Horizontal Romentry427 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry427
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry427_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry427_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry427 bdk_apbrom_horizontal_romentry427_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY427 BDK_APBROM_HORIZONTAL_ROMENTRY427_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY427_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY427_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY427", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY427 bdk_apbrom_horizontal_romentry427_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY427 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY427 "APBROM_HORIZONTAL_ROMENTRY427"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY427 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY427 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry428
 *
 * APBROM Horizontal Romentry428 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry428
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry428_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry428_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry428 bdk_apbrom_horizontal_romentry428_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY428 BDK_APBROM_HORIZONTAL_ROMENTRY428_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY428_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY428_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY428", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY428 bdk_apbrom_horizontal_romentry428_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY428 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY428 "APBROM_HORIZONTAL_ROMENTRY428"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY428 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY428 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry429
 *
 * APBROM Horizontal Romentry429 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry429
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry429_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry429_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry429 bdk_apbrom_horizontal_romentry429_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY429 BDK_APBROM_HORIZONTAL_ROMENTRY429_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY429_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY429_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY429", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY429 bdk_apbrom_horizontal_romentry429_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY429 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY429 "APBROM_HORIZONTAL_ROMENTRY429"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY429 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY429 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry43
 *
 * APBROM Horizontal Romentry43 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry43
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry43_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry43_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry43 bdk_apbrom_horizontal_romentry43_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY43 BDK_APBROM_HORIZONTAL_ROMENTRY43_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY43_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY43_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY43", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY43 bdk_apbrom_horizontal_romentry43_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY43 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY43 "APBROM_HORIZONTAL_ROMENTRY43"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY43 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY43 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry430
 *
 * APBROM Horizontal Romentry430 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry430
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry430_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry430_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry430 bdk_apbrom_horizontal_romentry430_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY430 BDK_APBROM_HORIZONTAL_ROMENTRY430_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY430_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY430_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY430", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY430 bdk_apbrom_horizontal_romentry430_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY430 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY430 "APBROM_HORIZONTAL_ROMENTRY430"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY430 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY430 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry431
 *
 * APBROM Horizontal Romentry431 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry431
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry431_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry431_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry431 bdk_apbrom_horizontal_romentry431_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY431 BDK_APBROM_HORIZONTAL_ROMENTRY431_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY431_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY431_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY431", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY431 bdk_apbrom_horizontal_romentry431_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY431 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY431 "APBROM_HORIZONTAL_ROMENTRY431"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY431 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY431 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry432
 *
 * APBROM Horizontal Romentry432 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry432
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry432_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry432_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry432 bdk_apbrom_horizontal_romentry432_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY432 BDK_APBROM_HORIZONTAL_ROMENTRY432_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY432_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY432_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY432", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY432 bdk_apbrom_horizontal_romentry432_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY432 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY432 "APBROM_HORIZONTAL_ROMENTRY432"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY432 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY432 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry433
 *
 * APBROM Horizontal Romentry433 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry433
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry433_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry433_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry433 bdk_apbrom_horizontal_romentry433_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY433 BDK_APBROM_HORIZONTAL_ROMENTRY433_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY433_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY433_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY433", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY433 bdk_apbrom_horizontal_romentry433_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY433 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY433 "APBROM_HORIZONTAL_ROMENTRY433"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY433 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY433 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry434
 *
 * APBROM Horizontal Romentry434 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry434
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry434_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry434_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry434 bdk_apbrom_horizontal_romentry434_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY434 BDK_APBROM_HORIZONTAL_ROMENTRY434_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY434_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY434_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY434", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY434 bdk_apbrom_horizontal_romentry434_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY434 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY434 "APBROM_HORIZONTAL_ROMENTRY434"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY434 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY434 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry435
 *
 * APBROM Horizontal Romentry435 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry435
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry435_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry435_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry435 bdk_apbrom_horizontal_romentry435_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY435 BDK_APBROM_HORIZONTAL_ROMENTRY435_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY435_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY435_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY435", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY435 bdk_apbrom_horizontal_romentry435_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY435 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY435 "APBROM_HORIZONTAL_ROMENTRY435"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY435 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY435 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry436
 *
 * APBROM Horizontal Romentry436 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry436
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry436_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry436_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry436 bdk_apbrom_horizontal_romentry436_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY436 BDK_APBROM_HORIZONTAL_ROMENTRY436_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY436_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY436_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY436", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY436 bdk_apbrom_horizontal_romentry436_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY436 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY436 "APBROM_HORIZONTAL_ROMENTRY436"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY436 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY436 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry437
 *
 * APBROM Horizontal Romentry437 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry437
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry437_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry437_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry437 bdk_apbrom_horizontal_romentry437_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY437 BDK_APBROM_HORIZONTAL_ROMENTRY437_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY437_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY437_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY437", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY437 bdk_apbrom_horizontal_romentry437_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY437 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY437 "APBROM_HORIZONTAL_ROMENTRY437"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY437 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY437 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry438
 *
 * APBROM Horizontal Romentry438 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry438
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry438_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry438_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry438 bdk_apbrom_horizontal_romentry438_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY438 BDK_APBROM_HORIZONTAL_ROMENTRY438_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY438_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY438_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY438", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY438 bdk_apbrom_horizontal_romentry438_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY438 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY438 "APBROM_HORIZONTAL_ROMENTRY438"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY438 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY438 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry439
 *
 * APBROM Horizontal Romentry439 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry439
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry439_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry439_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry439 bdk_apbrom_horizontal_romentry439_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY439 BDK_APBROM_HORIZONTAL_ROMENTRY439_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY439_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY439_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY439", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY439 bdk_apbrom_horizontal_romentry439_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY439 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY439 "APBROM_HORIZONTAL_ROMENTRY439"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY439 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY439 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry44
 *
 * APBROM Horizontal Romentry44 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry44
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry44_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry44_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry44 bdk_apbrom_horizontal_romentry44_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY44 BDK_APBROM_HORIZONTAL_ROMENTRY44_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY44_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY44_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY44", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY44 bdk_apbrom_horizontal_romentry44_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY44 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY44 "APBROM_HORIZONTAL_ROMENTRY44"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY44 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY44 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry440
 *
 * APBROM Horizontal Romentry440 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry440
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry440_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry440_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry440 bdk_apbrom_horizontal_romentry440_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY440 BDK_APBROM_HORIZONTAL_ROMENTRY440_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY440_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY440_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY440", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY440 bdk_apbrom_horizontal_romentry440_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY440 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY440 "APBROM_HORIZONTAL_ROMENTRY440"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY440 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY440 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry441
 *
 * APBROM Horizontal Romentry441 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry441
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry441_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry441_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry441 bdk_apbrom_horizontal_romentry441_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY441 BDK_APBROM_HORIZONTAL_ROMENTRY441_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY441_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY441_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY441", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY441 bdk_apbrom_horizontal_romentry441_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY441 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY441 "APBROM_HORIZONTAL_ROMENTRY441"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY441 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY441 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry442
 *
 * APBROM Horizontal Romentry442 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry442
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry442_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry442_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry442 bdk_apbrom_horizontal_romentry442_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY442 BDK_APBROM_HORIZONTAL_ROMENTRY442_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY442_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY442_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY442", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY442 bdk_apbrom_horizontal_romentry442_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY442 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY442 "APBROM_HORIZONTAL_ROMENTRY442"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY442 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY442 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry443
 *
 * APBROM Horizontal Romentry443 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry443
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry443_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry443_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry443 bdk_apbrom_horizontal_romentry443_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY443 BDK_APBROM_HORIZONTAL_ROMENTRY443_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY443_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY443_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY443", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY443 bdk_apbrom_horizontal_romentry443_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY443 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY443 "APBROM_HORIZONTAL_ROMENTRY443"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY443 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY443 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry444
 *
 * APBROM Horizontal Romentry444 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry444
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry444_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry444_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry444 bdk_apbrom_horizontal_romentry444_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY444 BDK_APBROM_HORIZONTAL_ROMENTRY444_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY444_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY444_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY444", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY444 bdk_apbrom_horizontal_romentry444_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY444 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY444 "APBROM_HORIZONTAL_ROMENTRY444"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY444 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY444 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry445
 *
 * APBROM Horizontal Romentry445 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry445
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry445_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry445_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry445 bdk_apbrom_horizontal_romentry445_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY445 BDK_APBROM_HORIZONTAL_ROMENTRY445_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY445_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY445_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY445", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY445 bdk_apbrom_horizontal_romentry445_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY445 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY445 "APBROM_HORIZONTAL_ROMENTRY445"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY445 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY445 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry446
 *
 * APBROM Horizontal Romentry446 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry446
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry446_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry446_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry446 bdk_apbrom_horizontal_romentry446_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY446 BDK_APBROM_HORIZONTAL_ROMENTRY446_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY446_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY446_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY446", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY446 bdk_apbrom_horizontal_romentry446_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY446 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY446 "APBROM_HORIZONTAL_ROMENTRY446"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY446 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY446 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry447
 *
 * APBROM Horizontal Romentry447 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry447
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry447_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry447_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry447 bdk_apbrom_horizontal_romentry447_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY447 BDK_APBROM_HORIZONTAL_ROMENTRY447_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY447_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY447_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460006fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY447", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY447 bdk_apbrom_horizontal_romentry447_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY447 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY447 "APBROM_HORIZONTAL_ROMENTRY447"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY447 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY447 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry448
 *
 * APBROM Horizontal Romentry448 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry448
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry448_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry448_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry448 bdk_apbrom_horizontal_romentry448_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY448 BDK_APBROM_HORIZONTAL_ROMENTRY448_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY448_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY448_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000700ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY448", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY448 bdk_apbrom_horizontal_romentry448_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY448 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY448 "APBROM_HORIZONTAL_ROMENTRY448"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY448 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY448 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry449
 *
 * APBROM Horizontal Romentry449 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry449
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry449_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry449_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry449 bdk_apbrom_horizontal_romentry449_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY449 BDK_APBROM_HORIZONTAL_ROMENTRY449_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY449_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY449_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000704ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY449", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY449 bdk_apbrom_horizontal_romentry449_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY449 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY449 "APBROM_HORIZONTAL_ROMENTRY449"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY449 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY449 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry45
 *
 * APBROM Horizontal Romentry45 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry45
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry45_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry45_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry45 bdk_apbrom_horizontal_romentry45_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY45 BDK_APBROM_HORIZONTAL_ROMENTRY45_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY45_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY45_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY45", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY45 bdk_apbrom_horizontal_romentry45_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY45 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY45 "APBROM_HORIZONTAL_ROMENTRY45"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY45 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY45 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry450
 *
 * APBROM Horizontal Romentry450 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry450
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry450_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry450_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry450 bdk_apbrom_horizontal_romentry450_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY450 BDK_APBROM_HORIZONTAL_ROMENTRY450_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY450_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY450_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000708ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY450", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY450 bdk_apbrom_horizontal_romentry450_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY450 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY450 "APBROM_HORIZONTAL_ROMENTRY450"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY450 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY450 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry451
 *
 * APBROM Horizontal Romentry451 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry451
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry451_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry451_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry451 bdk_apbrom_horizontal_romentry451_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY451 BDK_APBROM_HORIZONTAL_ROMENTRY451_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY451_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY451_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600070cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY451", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY451 bdk_apbrom_horizontal_romentry451_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY451 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY451 "APBROM_HORIZONTAL_ROMENTRY451"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY451 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY451 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry452
 *
 * APBROM Horizontal Romentry452 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry452
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry452_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry452_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry452 bdk_apbrom_horizontal_romentry452_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY452 BDK_APBROM_HORIZONTAL_ROMENTRY452_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY452_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY452_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000710ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY452", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY452 bdk_apbrom_horizontal_romentry452_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY452 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY452 "APBROM_HORIZONTAL_ROMENTRY452"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY452 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY452 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry453
 *
 * APBROM Horizontal Romentry453 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry453
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry453_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry453_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry453 bdk_apbrom_horizontal_romentry453_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY453 BDK_APBROM_HORIZONTAL_ROMENTRY453_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY453_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY453_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000714ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY453", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY453 bdk_apbrom_horizontal_romentry453_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY453 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY453 "APBROM_HORIZONTAL_ROMENTRY453"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY453 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY453 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry454
 *
 * APBROM Horizontal Romentry454 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry454
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry454_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry454_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry454 bdk_apbrom_horizontal_romentry454_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY454 BDK_APBROM_HORIZONTAL_ROMENTRY454_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY454_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY454_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000718ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY454", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY454 bdk_apbrom_horizontal_romentry454_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY454 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY454 "APBROM_HORIZONTAL_ROMENTRY454"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY454 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY454 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry455
 *
 * APBROM Horizontal Romentry455 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry455
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry455_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry455_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry455 bdk_apbrom_horizontal_romentry455_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY455 BDK_APBROM_HORIZONTAL_ROMENTRY455_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY455_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY455_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600071cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY455", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY455 bdk_apbrom_horizontal_romentry455_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY455 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY455 "APBROM_HORIZONTAL_ROMENTRY455"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY455 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY455 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry456
 *
 * APBROM Horizontal Romentry456 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry456
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry456_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry456_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry456 bdk_apbrom_horizontal_romentry456_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY456 BDK_APBROM_HORIZONTAL_ROMENTRY456_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY456_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY456_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000720ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY456", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY456 bdk_apbrom_horizontal_romentry456_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY456 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY456 "APBROM_HORIZONTAL_ROMENTRY456"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY456 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY456 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry457
 *
 * APBROM Horizontal Romentry457 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry457
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry457_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry457_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry457 bdk_apbrom_horizontal_romentry457_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY457 BDK_APBROM_HORIZONTAL_ROMENTRY457_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY457_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY457_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000724ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY457", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY457 bdk_apbrom_horizontal_romentry457_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY457 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY457 "APBROM_HORIZONTAL_ROMENTRY457"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY457 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY457 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry458
 *
 * APBROM Horizontal Romentry458 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry458
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry458_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry458_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry458 bdk_apbrom_horizontal_romentry458_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY458 BDK_APBROM_HORIZONTAL_ROMENTRY458_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY458_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY458_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000728ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY458", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY458 bdk_apbrom_horizontal_romentry458_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY458 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY458 "APBROM_HORIZONTAL_ROMENTRY458"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY458 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY458 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry459
 *
 * APBROM Horizontal Romentry459 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry459
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry459_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry459_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry459 bdk_apbrom_horizontal_romentry459_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY459 BDK_APBROM_HORIZONTAL_ROMENTRY459_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY459_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY459_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600072cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY459", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY459 bdk_apbrom_horizontal_romentry459_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY459 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY459 "APBROM_HORIZONTAL_ROMENTRY459"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY459 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY459 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry46
 *
 * APBROM Horizontal Romentry46 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry46
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry46_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry46_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry46 bdk_apbrom_horizontal_romentry46_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY46 BDK_APBROM_HORIZONTAL_ROMENTRY46_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY46_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY46_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY46", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY46 bdk_apbrom_horizontal_romentry46_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY46 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY46 "APBROM_HORIZONTAL_ROMENTRY46"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY46 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY46 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry460
 *
 * APBROM Horizontal Romentry460 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry460
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry460_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry460_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry460 bdk_apbrom_horizontal_romentry460_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY460 BDK_APBROM_HORIZONTAL_ROMENTRY460_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY460_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY460_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000730ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY460", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY460 bdk_apbrom_horizontal_romentry460_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY460 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY460 "APBROM_HORIZONTAL_ROMENTRY460"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY460 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY460 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry461
 *
 * APBROM Horizontal Romentry461 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry461
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry461_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry461_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry461 bdk_apbrom_horizontal_romentry461_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY461 BDK_APBROM_HORIZONTAL_ROMENTRY461_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY461_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY461_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000734ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY461", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY461 bdk_apbrom_horizontal_romentry461_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY461 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY461 "APBROM_HORIZONTAL_ROMENTRY461"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY461 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY461 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry462
 *
 * APBROM Horizontal Romentry462 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry462
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry462_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry462_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry462 bdk_apbrom_horizontal_romentry462_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY462 BDK_APBROM_HORIZONTAL_ROMENTRY462_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY462_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY462_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000738ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY462", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY462 bdk_apbrom_horizontal_romentry462_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY462 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY462 "APBROM_HORIZONTAL_ROMENTRY462"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY462 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY462 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry463
 *
 * APBROM Horizontal Romentry463 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry463
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry463_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry463_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry463 bdk_apbrom_horizontal_romentry463_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY463 BDK_APBROM_HORIZONTAL_ROMENTRY463_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY463_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY463_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600073cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY463", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY463 bdk_apbrom_horizontal_romentry463_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY463 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY463 "APBROM_HORIZONTAL_ROMENTRY463"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY463 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY463 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry464
 *
 * APBROM Horizontal Romentry464 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry464
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry464_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry464_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry464 bdk_apbrom_horizontal_romentry464_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY464 BDK_APBROM_HORIZONTAL_ROMENTRY464_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY464_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY464_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000740ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY464", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY464 bdk_apbrom_horizontal_romentry464_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY464 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY464 "APBROM_HORIZONTAL_ROMENTRY464"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY464 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY464 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry465
 *
 * APBROM Horizontal Romentry465 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry465
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry465_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry465_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry465 bdk_apbrom_horizontal_romentry465_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY465 BDK_APBROM_HORIZONTAL_ROMENTRY465_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY465_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY465_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000744ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY465", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY465 bdk_apbrom_horizontal_romentry465_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY465 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY465 "APBROM_HORIZONTAL_ROMENTRY465"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY465 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY465 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry466
 *
 * APBROM Horizontal Romentry466 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry466
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry466_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry466_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry466 bdk_apbrom_horizontal_romentry466_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY466 BDK_APBROM_HORIZONTAL_ROMENTRY466_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY466_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY466_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000748ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY466", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY466 bdk_apbrom_horizontal_romentry466_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY466 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY466 "APBROM_HORIZONTAL_ROMENTRY466"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY466 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY466 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry467
 *
 * APBROM Horizontal Romentry467 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry467
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry467_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry467_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry467 bdk_apbrom_horizontal_romentry467_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY467 BDK_APBROM_HORIZONTAL_ROMENTRY467_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY467_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY467_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600074cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY467", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY467 bdk_apbrom_horizontal_romentry467_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY467 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY467 "APBROM_HORIZONTAL_ROMENTRY467"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY467 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY467 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry468
 *
 * APBROM Horizontal Romentry468 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry468
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry468_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry468_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry468 bdk_apbrom_horizontal_romentry468_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY468 BDK_APBROM_HORIZONTAL_ROMENTRY468_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY468_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY468_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000750ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY468", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY468 bdk_apbrom_horizontal_romentry468_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY468 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY468 "APBROM_HORIZONTAL_ROMENTRY468"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY468 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY468 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry469
 *
 * APBROM Horizontal Romentry469 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry469
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry469_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry469_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry469 bdk_apbrom_horizontal_romentry469_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY469 BDK_APBROM_HORIZONTAL_ROMENTRY469_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY469_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY469_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000754ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY469", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY469 bdk_apbrom_horizontal_romentry469_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY469 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY469 "APBROM_HORIZONTAL_ROMENTRY469"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY469 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY469 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry47
 *
 * APBROM Horizontal Romentry47 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry47
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry47_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry47_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry47 bdk_apbrom_horizontal_romentry47_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY47 BDK_APBROM_HORIZONTAL_ROMENTRY47_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY47_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY47_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY47", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY47 bdk_apbrom_horizontal_romentry47_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY47 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY47 "APBROM_HORIZONTAL_ROMENTRY47"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY47 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY47 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry470
 *
 * APBROM Horizontal Romentry470 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry470
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry470_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry470_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry470 bdk_apbrom_horizontal_romentry470_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY470 BDK_APBROM_HORIZONTAL_ROMENTRY470_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY470_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY470_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000758ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY470", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY470 bdk_apbrom_horizontal_romentry470_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY470 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY470 "APBROM_HORIZONTAL_ROMENTRY470"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY470 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY470 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry471
 *
 * APBROM Horizontal Romentry471 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry471
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry471_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry471_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry471 bdk_apbrom_horizontal_romentry471_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY471 BDK_APBROM_HORIZONTAL_ROMENTRY471_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY471_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY471_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600075cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY471", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY471 bdk_apbrom_horizontal_romentry471_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY471 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY471 "APBROM_HORIZONTAL_ROMENTRY471"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY471 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY471 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry472
 *
 * APBROM Horizontal Romentry472 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry472
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry472_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry472_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry472 bdk_apbrom_horizontal_romentry472_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY472 BDK_APBROM_HORIZONTAL_ROMENTRY472_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY472_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY472_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000760ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY472", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY472 bdk_apbrom_horizontal_romentry472_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY472 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY472 "APBROM_HORIZONTAL_ROMENTRY472"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY472 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY472 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry473
 *
 * APBROM Horizontal Romentry473 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry473
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry473_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry473_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry473 bdk_apbrom_horizontal_romentry473_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY473 BDK_APBROM_HORIZONTAL_ROMENTRY473_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY473_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY473_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000764ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY473", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY473 bdk_apbrom_horizontal_romentry473_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY473 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY473 "APBROM_HORIZONTAL_ROMENTRY473"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY473 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY473 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry474
 *
 * APBROM Horizontal Romentry474 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry474
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry474_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry474_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry474 bdk_apbrom_horizontal_romentry474_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY474 BDK_APBROM_HORIZONTAL_ROMENTRY474_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY474_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY474_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000768ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY474", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY474 bdk_apbrom_horizontal_romentry474_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY474 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY474 "APBROM_HORIZONTAL_ROMENTRY474"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY474 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY474 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry475
 *
 * APBROM Horizontal Romentry475 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry475
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry475_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry475_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry475 bdk_apbrom_horizontal_romentry475_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY475 BDK_APBROM_HORIZONTAL_ROMENTRY475_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY475_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY475_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600076cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY475", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY475 bdk_apbrom_horizontal_romentry475_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY475 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY475 "APBROM_HORIZONTAL_ROMENTRY475"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY475 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY475 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry476
 *
 * APBROM Horizontal Romentry476 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry476
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry476_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry476_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry476 bdk_apbrom_horizontal_romentry476_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY476 BDK_APBROM_HORIZONTAL_ROMENTRY476_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY476_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY476_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000770ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY476", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY476 bdk_apbrom_horizontal_romentry476_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY476 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY476 "APBROM_HORIZONTAL_ROMENTRY476"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY476 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY476 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry477
 *
 * APBROM Horizontal Romentry477 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry477
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry477_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry477_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry477 bdk_apbrom_horizontal_romentry477_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY477 BDK_APBROM_HORIZONTAL_ROMENTRY477_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY477_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY477_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000774ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY477", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY477 bdk_apbrom_horizontal_romentry477_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY477 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY477 "APBROM_HORIZONTAL_ROMENTRY477"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY477 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY477 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry478
 *
 * APBROM Horizontal Romentry478 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry478
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry478_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry478_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry478 bdk_apbrom_horizontal_romentry478_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY478 BDK_APBROM_HORIZONTAL_ROMENTRY478_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY478_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY478_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000778ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY478", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY478 bdk_apbrom_horizontal_romentry478_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY478 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY478 "APBROM_HORIZONTAL_ROMENTRY478"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY478 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY478 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry479
 *
 * APBROM Horizontal Romentry479 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry479
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry479_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry479_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry479 bdk_apbrom_horizontal_romentry479_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY479 BDK_APBROM_HORIZONTAL_ROMENTRY479_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY479_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY479_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600077cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY479", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY479 bdk_apbrom_horizontal_romentry479_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY479 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY479 "APBROM_HORIZONTAL_ROMENTRY479"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY479 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY479 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry48
 *
 * APBROM Horizontal Romentry48 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry48
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry48_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry48 bdk_apbrom_horizontal_romentry48_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY48 BDK_APBROM_HORIZONTAL_ROMENTRY48_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY48_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY48_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY48", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY48 bdk_apbrom_horizontal_romentry48_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY48 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY48 "APBROM_HORIZONTAL_ROMENTRY48"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY48 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY48 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry480
 *
 * APBROM Horizontal Romentry480 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry480
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry480_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry480_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry480 bdk_apbrom_horizontal_romentry480_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY480 BDK_APBROM_HORIZONTAL_ROMENTRY480_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY480_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY480_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000780ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY480", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY480 bdk_apbrom_horizontal_romentry480_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY480 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY480 "APBROM_HORIZONTAL_ROMENTRY480"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY480 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY480 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry481
 *
 * APBROM Horizontal Romentry481 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry481
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry481_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry481_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry481 bdk_apbrom_horizontal_romentry481_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY481 BDK_APBROM_HORIZONTAL_ROMENTRY481_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY481_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY481_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000784ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY481", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY481 bdk_apbrom_horizontal_romentry481_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY481 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY481 "APBROM_HORIZONTAL_ROMENTRY481"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY481 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY481 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry482
 *
 * APBROM Horizontal Romentry482 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry482
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry482_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry482_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry482 bdk_apbrom_horizontal_romentry482_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY482 BDK_APBROM_HORIZONTAL_ROMENTRY482_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY482_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY482_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000788ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY482", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY482 bdk_apbrom_horizontal_romentry482_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY482 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY482 "APBROM_HORIZONTAL_ROMENTRY482"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY482 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY482 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry483
 *
 * APBROM Horizontal Romentry483 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry483
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry483_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry483_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry483 bdk_apbrom_horizontal_romentry483_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY483 BDK_APBROM_HORIZONTAL_ROMENTRY483_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY483_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY483_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600078cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY483", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY483 bdk_apbrom_horizontal_romentry483_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY483 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY483 "APBROM_HORIZONTAL_ROMENTRY483"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY483 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY483 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry484
 *
 * APBROM Horizontal Romentry484 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry484
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry484_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry484_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry484 bdk_apbrom_horizontal_romentry484_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY484 BDK_APBROM_HORIZONTAL_ROMENTRY484_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY484_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY484_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000790ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY484", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY484 bdk_apbrom_horizontal_romentry484_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY484 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY484 "APBROM_HORIZONTAL_ROMENTRY484"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY484 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY484 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry485
 *
 * APBROM Horizontal Romentry485 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry485
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry485_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry485_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry485 bdk_apbrom_horizontal_romentry485_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY485 BDK_APBROM_HORIZONTAL_ROMENTRY485_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY485_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY485_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000794ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY485", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY485 bdk_apbrom_horizontal_romentry485_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY485 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY485 "APBROM_HORIZONTAL_ROMENTRY485"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY485 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY485 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry486
 *
 * APBROM Horizontal Romentry486 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry486
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry486_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry486_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry486 bdk_apbrom_horizontal_romentry486_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY486 BDK_APBROM_HORIZONTAL_ROMENTRY486_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY486_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY486_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000798ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY486", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY486 bdk_apbrom_horizontal_romentry486_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY486 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY486 "APBROM_HORIZONTAL_ROMENTRY486"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY486 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY486 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry487
 *
 * APBROM Horizontal Romentry487 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry487
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry487_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry487_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry487 bdk_apbrom_horizontal_romentry487_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY487 BDK_APBROM_HORIZONTAL_ROMENTRY487_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY487_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY487_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600079cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY487", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY487 bdk_apbrom_horizontal_romentry487_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY487 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY487 "APBROM_HORIZONTAL_ROMENTRY487"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY487 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY487 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry488
 *
 * APBROM Horizontal Romentry488 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry488
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry488_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry488_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry488 bdk_apbrom_horizontal_romentry488_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY488 BDK_APBROM_HORIZONTAL_ROMENTRY488_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY488_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY488_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007a0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY488", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY488 bdk_apbrom_horizontal_romentry488_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY488 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY488 "APBROM_HORIZONTAL_ROMENTRY488"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY488 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY488 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry489
 *
 * APBROM Horizontal Romentry489 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry489
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry489_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry489_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry489 bdk_apbrom_horizontal_romentry489_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY489 BDK_APBROM_HORIZONTAL_ROMENTRY489_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY489_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY489_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007a4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY489", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY489 bdk_apbrom_horizontal_romentry489_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY489 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY489 "APBROM_HORIZONTAL_ROMENTRY489"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY489 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY489 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry49
 *
 * APBROM Horizontal Romentry49 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry49
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry49_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry49_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry49 bdk_apbrom_horizontal_romentry49_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY49 BDK_APBROM_HORIZONTAL_ROMENTRY49_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY49_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY49_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY49", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY49 bdk_apbrom_horizontal_romentry49_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY49 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY49 "APBROM_HORIZONTAL_ROMENTRY49"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY49 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY49 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry490
 *
 * APBROM Horizontal Romentry490 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry490
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry490_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry490_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry490 bdk_apbrom_horizontal_romentry490_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY490 BDK_APBROM_HORIZONTAL_ROMENTRY490_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY490_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY490_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007a8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY490", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY490 bdk_apbrom_horizontal_romentry490_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY490 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY490 "APBROM_HORIZONTAL_ROMENTRY490"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY490 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY490 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry491
 *
 * APBROM Horizontal Romentry491 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry491
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry491_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry491_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry491 bdk_apbrom_horizontal_romentry491_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY491 BDK_APBROM_HORIZONTAL_ROMENTRY491_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY491_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY491_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007acll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY491", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY491 bdk_apbrom_horizontal_romentry491_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY491 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY491 "APBROM_HORIZONTAL_ROMENTRY491"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY491 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY491 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry492
 *
 * APBROM Horizontal Romentry492 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry492
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry492_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry492_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry492 bdk_apbrom_horizontal_romentry492_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY492 BDK_APBROM_HORIZONTAL_ROMENTRY492_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY492_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY492_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007b0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY492", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY492 bdk_apbrom_horizontal_romentry492_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY492 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY492 "APBROM_HORIZONTAL_ROMENTRY492"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY492 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY492 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry493
 *
 * APBROM Horizontal Romentry493 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry493
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry493_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry493_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry493 bdk_apbrom_horizontal_romentry493_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY493 BDK_APBROM_HORIZONTAL_ROMENTRY493_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY493_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY493_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007b4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY493", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY493 bdk_apbrom_horizontal_romentry493_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY493 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY493 "APBROM_HORIZONTAL_ROMENTRY493"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY493 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY493 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry494
 *
 * APBROM Horizontal Romentry494 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry494
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry494_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry494_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry494 bdk_apbrom_horizontal_romentry494_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY494 BDK_APBROM_HORIZONTAL_ROMENTRY494_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY494_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY494_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007b8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY494", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY494 bdk_apbrom_horizontal_romentry494_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY494 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY494 "APBROM_HORIZONTAL_ROMENTRY494"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY494 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY494 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry495
 *
 * APBROM Horizontal Romentry495 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry495
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry495_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry495_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry495 bdk_apbrom_horizontal_romentry495_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY495 BDK_APBROM_HORIZONTAL_ROMENTRY495_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY495_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY495_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007bcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY495", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY495 bdk_apbrom_horizontal_romentry495_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY495 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY495 "APBROM_HORIZONTAL_ROMENTRY495"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY495 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY495 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry496
 *
 * APBROM Horizontal Romentry496 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry496
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry496_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry496_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry496 bdk_apbrom_horizontal_romentry496_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY496 BDK_APBROM_HORIZONTAL_ROMENTRY496_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY496_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY496_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007c0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY496", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY496 bdk_apbrom_horizontal_romentry496_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY496 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY496 "APBROM_HORIZONTAL_ROMENTRY496"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY496 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY496 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry497
 *
 * APBROM Horizontal Romentry497 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry497
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry497_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry497_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry497 bdk_apbrom_horizontal_romentry497_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY497 BDK_APBROM_HORIZONTAL_ROMENTRY497_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY497_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY497_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007c4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY497", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY497 bdk_apbrom_horizontal_romentry497_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY497 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY497 "APBROM_HORIZONTAL_ROMENTRY497"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY497 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY497 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry498
 *
 * APBROM Horizontal Romentry498 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry498
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry498_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry498_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry498 bdk_apbrom_horizontal_romentry498_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY498 BDK_APBROM_HORIZONTAL_ROMENTRY498_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY498_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY498_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY498", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY498 bdk_apbrom_horizontal_romentry498_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY498 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY498 "APBROM_HORIZONTAL_ROMENTRY498"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY498 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY498 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry499
 *
 * APBROM Horizontal Romentry499 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry499
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry499_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry499_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry499 bdk_apbrom_horizontal_romentry499_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY499 BDK_APBROM_HORIZONTAL_ROMENTRY499_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY499_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY499_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY499", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY499 bdk_apbrom_horizontal_romentry499_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY499 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY499 "APBROM_HORIZONTAL_ROMENTRY499"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY499 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY499 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry5
 *
 * APBROM Horizontal Romentry5 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry5
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry5_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry5 bdk_apbrom_horizontal_romentry5_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY5 BDK_APBROM_HORIZONTAL_ROMENTRY5_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY5_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000014ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY5", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY5 bdk_apbrom_horizontal_romentry5_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY5 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY5 "APBROM_HORIZONTAL_ROMENTRY5"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY5 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY5 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry50
 *
 * APBROM Horizontal Romentry50 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry50
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry50_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry50_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry50 bdk_apbrom_horizontal_romentry50_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY50 BDK_APBROM_HORIZONTAL_ROMENTRY50_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY50_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY50_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000c8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY50", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY50 bdk_apbrom_horizontal_romentry50_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY50 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY50 "APBROM_HORIZONTAL_ROMENTRY50"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY50 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY50 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry500
 *
 * APBROM Horizontal Romentry500 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry500
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry500_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry500_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry500 bdk_apbrom_horizontal_romentry500_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY500 BDK_APBROM_HORIZONTAL_ROMENTRY500_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY500_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY500_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY500", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY500 bdk_apbrom_horizontal_romentry500_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY500 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY500 "APBROM_HORIZONTAL_ROMENTRY500"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY500 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY500 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry501
 *
 * APBROM Horizontal Romentry501 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry501
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry501_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry501_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry501 bdk_apbrom_horizontal_romentry501_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY501 BDK_APBROM_HORIZONTAL_ROMENTRY501_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY501_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY501_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY501", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY501 bdk_apbrom_horizontal_romentry501_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY501 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY501 "APBROM_HORIZONTAL_ROMENTRY501"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY501 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY501 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry502
 *
 * APBROM Horizontal Romentry502 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry502
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry502_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry502_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry502 bdk_apbrom_horizontal_romentry502_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY502 BDK_APBROM_HORIZONTAL_ROMENTRY502_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY502_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY502_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY502", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY502 bdk_apbrom_horizontal_romentry502_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY502 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY502 "APBROM_HORIZONTAL_ROMENTRY502"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY502 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY502 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry503
 *
 * APBROM Horizontal Romentry503 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry503
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry503_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry503_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry503 bdk_apbrom_horizontal_romentry503_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY503 BDK_APBROM_HORIZONTAL_ROMENTRY503_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY503_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY503_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY503", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY503 bdk_apbrom_horizontal_romentry503_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY503 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY503 "APBROM_HORIZONTAL_ROMENTRY503"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY503 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY503 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry504
 *
 * APBROM Horizontal Romentry504 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry504
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry504_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry504_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry504 bdk_apbrom_horizontal_romentry504_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY504 BDK_APBROM_HORIZONTAL_ROMENTRY504_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY504_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY504_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY504", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY504 bdk_apbrom_horizontal_romentry504_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY504 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY504 "APBROM_HORIZONTAL_ROMENTRY504"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY504 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY504 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry505
 *
 * APBROM Horizontal Romentry505 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry505
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry505_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry505_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry505 bdk_apbrom_horizontal_romentry505_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY505 BDK_APBROM_HORIZONTAL_ROMENTRY505_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY505_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY505_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY505", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY505 bdk_apbrom_horizontal_romentry505_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY505 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY505 "APBROM_HORIZONTAL_ROMENTRY505"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY505 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY505 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry506
 *
 * APBROM Horizontal Romentry506 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry506
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry506_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry506_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry506 bdk_apbrom_horizontal_romentry506_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY506 BDK_APBROM_HORIZONTAL_ROMENTRY506_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY506_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY506_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY506", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY506 bdk_apbrom_horizontal_romentry506_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY506 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY506 "APBROM_HORIZONTAL_ROMENTRY506"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY506 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY506 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry507
 *
 * APBROM Horizontal Romentry507 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry507
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry507_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry507_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry507 bdk_apbrom_horizontal_romentry507_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY507 BDK_APBROM_HORIZONTAL_ROMENTRY507_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY507_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY507_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY507", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY507 bdk_apbrom_horizontal_romentry507_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY507 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY507 "APBROM_HORIZONTAL_ROMENTRY507"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY507 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY507 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry508
 *
 * APBROM Horizontal Romentry508 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry508
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry508_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry508_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry508 bdk_apbrom_horizontal_romentry508_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY508 BDK_APBROM_HORIZONTAL_ROMENTRY508_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY508_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY508_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY508", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY508 bdk_apbrom_horizontal_romentry508_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY508 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY508 "APBROM_HORIZONTAL_ROMENTRY508"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY508 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY508 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry509
 *
 * APBROM Horizontal Romentry509 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry509
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry509_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry509_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry509 bdk_apbrom_horizontal_romentry509_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY509 BDK_APBROM_HORIZONTAL_ROMENTRY509_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY509_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY509_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY509", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY509 bdk_apbrom_horizontal_romentry509_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY509 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY509 "APBROM_HORIZONTAL_ROMENTRY509"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY509 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY509 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry51
 *
 * APBROM Horizontal Romentry51 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry51
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry51_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry51_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry51 bdk_apbrom_horizontal_romentry51_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY51 BDK_APBROM_HORIZONTAL_ROMENTRY51_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY51_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY51_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000ccll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY51", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY51 bdk_apbrom_horizontal_romentry51_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY51 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY51 "APBROM_HORIZONTAL_ROMENTRY51"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY51 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY51 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry510
 *
 * APBROM Horizontal Romentry510 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry510
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry510_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry510_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry510 bdk_apbrom_horizontal_romentry510_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY510 BDK_APBROM_HORIZONTAL_ROMENTRY510_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY510_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY510_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY510", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY510 bdk_apbrom_horizontal_romentry510_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY510 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY510 "APBROM_HORIZONTAL_ROMENTRY510"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY510 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY510 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry511
 *
 * APBROM Horizontal Romentry511 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry511
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry511_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry511_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry511 bdk_apbrom_horizontal_romentry511_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY511 BDK_APBROM_HORIZONTAL_ROMENTRY511_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY511_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY511_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460007fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY511", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY511 bdk_apbrom_horizontal_romentry511_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY511 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY511 "APBROM_HORIZONTAL_ROMENTRY511"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY511 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY511 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry52
 *
 * APBROM Horizontal Romentry52 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry52
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry52_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry52_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry52 bdk_apbrom_horizontal_romentry52_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY52 BDK_APBROM_HORIZONTAL_ROMENTRY52_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY52_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY52_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000d0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY52", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY52 bdk_apbrom_horizontal_romentry52_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY52 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY52 "APBROM_HORIZONTAL_ROMENTRY52"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY52 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY52 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry53
 *
 * APBROM Horizontal Romentry53 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry53
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry53_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry53_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry53 bdk_apbrom_horizontal_romentry53_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY53 BDK_APBROM_HORIZONTAL_ROMENTRY53_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY53_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY53_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000d4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY53", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY53 bdk_apbrom_horizontal_romentry53_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY53 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY53 "APBROM_HORIZONTAL_ROMENTRY53"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY53 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY53 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry54
 *
 * APBROM Horizontal Romentry54 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry54
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry54_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry54_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry54 bdk_apbrom_horizontal_romentry54_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY54 BDK_APBROM_HORIZONTAL_ROMENTRY54_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY54_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY54_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000d8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY54", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY54 bdk_apbrom_horizontal_romentry54_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY54 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY54 "APBROM_HORIZONTAL_ROMENTRY54"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY54 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY54 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry55
 *
 * APBROM Horizontal Romentry55 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry55
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry55_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry55_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry55 bdk_apbrom_horizontal_romentry55_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY55 BDK_APBROM_HORIZONTAL_ROMENTRY55_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY55_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY55_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000dcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY55", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY55 bdk_apbrom_horizontal_romentry55_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY55 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY55 "APBROM_HORIZONTAL_ROMENTRY55"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY55 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY55 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry56
 *
 * APBROM Horizontal Romentry56 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry56
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry56_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry56 bdk_apbrom_horizontal_romentry56_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY56 BDK_APBROM_HORIZONTAL_ROMENTRY56_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY56_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY56_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000e0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY56", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY56 bdk_apbrom_horizontal_romentry56_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY56 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY56 "APBROM_HORIZONTAL_ROMENTRY56"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY56 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY56 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry57
 *
 * APBROM Horizontal Romentry57 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry57
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry57_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry57_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry57 bdk_apbrom_horizontal_romentry57_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY57 BDK_APBROM_HORIZONTAL_ROMENTRY57_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY57_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY57_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000e4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY57", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY57 bdk_apbrom_horizontal_romentry57_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY57 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY57 "APBROM_HORIZONTAL_ROMENTRY57"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY57 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY57 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry58
 *
 * APBROM Horizontal Romentry58 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry58
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry58_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry58_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry58 bdk_apbrom_horizontal_romentry58_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY58 BDK_APBROM_HORIZONTAL_ROMENTRY58_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY58_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY58_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000e8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY58", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY58 bdk_apbrom_horizontal_romentry58_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY58 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY58 "APBROM_HORIZONTAL_ROMENTRY58"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY58 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY58 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry59
 *
 * APBROM Horizontal Romentry59 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry59
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry59_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry59_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry59 bdk_apbrom_horizontal_romentry59_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY59 BDK_APBROM_HORIZONTAL_ROMENTRY59_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY59_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY59_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000ecll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY59", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY59 bdk_apbrom_horizontal_romentry59_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY59 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY59 "APBROM_HORIZONTAL_ROMENTRY59"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY59 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY59 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry6
 *
 * APBROM Horizontal Romentry6 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry6
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry6_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry6 bdk_apbrom_horizontal_romentry6_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY6 BDK_APBROM_HORIZONTAL_ROMENTRY6_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY6_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000018ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY6", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY6 bdk_apbrom_horizontal_romentry6_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY6 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY6 "APBROM_HORIZONTAL_ROMENTRY6"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY6 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY6 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry60
 *
 * APBROM Horizontal Romentry60 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry60
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry60_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry60_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry60 bdk_apbrom_horizontal_romentry60_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY60 BDK_APBROM_HORIZONTAL_ROMENTRY60_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY60_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY60_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000f0ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY60", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY60 bdk_apbrom_horizontal_romentry60_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY60 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY60 "APBROM_HORIZONTAL_ROMENTRY60"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY60 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY60 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry61
 *
 * APBROM Horizontal Romentry61 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry61
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry61_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry61_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry61 bdk_apbrom_horizontal_romentry61_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY61 BDK_APBROM_HORIZONTAL_ROMENTRY61_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY61_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY61_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000f4ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY61", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY61 bdk_apbrom_horizontal_romentry61_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY61 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY61 "APBROM_HORIZONTAL_ROMENTRY61"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY61 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY61 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry62
 *
 * APBROM Horizontal Romentry62 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry62
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry62_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry62_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry62 bdk_apbrom_horizontal_romentry62_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY62 BDK_APBROM_HORIZONTAL_ROMENTRY62_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY62_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY62_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000f8ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY62", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY62 bdk_apbrom_horizontal_romentry62_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY62 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY62 "APBROM_HORIZONTAL_ROMENTRY62"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY62 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY62 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry63
 *
 * APBROM Horizontal Romentry63 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry63
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry63_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry63_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry63 bdk_apbrom_horizontal_romentry63_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY63 BDK_APBROM_HORIZONTAL_ROMENTRY63_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY63_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY63_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e0460000fcll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY63", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY63 bdk_apbrom_horizontal_romentry63_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY63 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY63 "APBROM_HORIZONTAL_ROMENTRY63"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY63 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY63 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry64
 *
 * APBROM Horizontal Romentry64 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry64
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry64_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry64 bdk_apbrom_horizontal_romentry64_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY64 BDK_APBROM_HORIZONTAL_ROMENTRY64_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY64_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY64_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000100ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY64", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY64 bdk_apbrom_horizontal_romentry64_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY64 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY64 "APBROM_HORIZONTAL_ROMENTRY64"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY64 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY64 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry65
 *
 * APBROM Horizontal Romentry65 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry65
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry65_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry65_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry65 bdk_apbrom_horizontal_romentry65_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY65 BDK_APBROM_HORIZONTAL_ROMENTRY65_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY65_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY65_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000104ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY65", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY65 bdk_apbrom_horizontal_romentry65_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY65 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY65 "APBROM_HORIZONTAL_ROMENTRY65"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY65 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY65 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry66
 *
 * APBROM Horizontal Romentry66 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry66
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry66_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry66_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry66 bdk_apbrom_horizontal_romentry66_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY66 BDK_APBROM_HORIZONTAL_ROMENTRY66_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY66_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY66_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000108ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY66", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY66 bdk_apbrom_horizontal_romentry66_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY66 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY66 "APBROM_HORIZONTAL_ROMENTRY66"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY66 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY66 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry67
 *
 * APBROM Horizontal Romentry67 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry67
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry67_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry67_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry67 bdk_apbrom_horizontal_romentry67_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY67 BDK_APBROM_HORIZONTAL_ROMENTRY67_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY67_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY67_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600010cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY67", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY67 bdk_apbrom_horizontal_romentry67_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY67 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY67 "APBROM_HORIZONTAL_ROMENTRY67"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY67 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY67 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry68
 *
 * APBROM Horizontal Romentry68 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry68
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry68_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry68_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry68 bdk_apbrom_horizontal_romentry68_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY68 BDK_APBROM_HORIZONTAL_ROMENTRY68_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY68_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY68_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000110ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY68", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY68 bdk_apbrom_horizontal_romentry68_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY68 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY68 "APBROM_HORIZONTAL_ROMENTRY68"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY68 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY68 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry69
 *
 * APBROM Horizontal Romentry69 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry69
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry69_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry69_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry69 bdk_apbrom_horizontal_romentry69_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY69 BDK_APBROM_HORIZONTAL_ROMENTRY69_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY69_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY69_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000114ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY69", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY69 bdk_apbrom_horizontal_romentry69_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY69 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY69 "APBROM_HORIZONTAL_ROMENTRY69"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY69 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY69 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry7
 *
 * APBROM Horizontal Romentry7 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry7
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry7_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry7 bdk_apbrom_horizontal_romentry7_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY7 BDK_APBROM_HORIZONTAL_ROMENTRY7_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY7_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600001cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY7", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY7 bdk_apbrom_horizontal_romentry7_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY7 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY7 "APBROM_HORIZONTAL_ROMENTRY7"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY7 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY7 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry70
 *
 * APBROM Horizontal Romentry70 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry70
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry70_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry70_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry70 bdk_apbrom_horizontal_romentry70_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY70 BDK_APBROM_HORIZONTAL_ROMENTRY70_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY70_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY70_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000118ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY70", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY70 bdk_apbrom_horizontal_romentry70_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY70 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY70 "APBROM_HORIZONTAL_ROMENTRY70"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY70 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY70 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry71
 *
 * APBROM Horizontal Romentry71 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry71
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry71_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry71_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry71 bdk_apbrom_horizontal_romentry71_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY71 BDK_APBROM_HORIZONTAL_ROMENTRY71_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY71_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY71_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600011cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY71", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY71 bdk_apbrom_horizontal_romentry71_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY71 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY71 "APBROM_HORIZONTAL_ROMENTRY71"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY71 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY71 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry72
 *
 * APBROM Horizontal Romentry72 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry72
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry72_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry72 bdk_apbrom_horizontal_romentry72_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY72 BDK_APBROM_HORIZONTAL_ROMENTRY72_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY72_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY72_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000120ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY72", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY72 bdk_apbrom_horizontal_romentry72_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY72 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY72 "APBROM_HORIZONTAL_ROMENTRY72"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY72 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY72 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry73
 *
 * APBROM Horizontal Romentry73 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry73
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry73_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry73_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry73 bdk_apbrom_horizontal_romentry73_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY73 BDK_APBROM_HORIZONTAL_ROMENTRY73_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY73_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY73_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000124ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY73", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY73 bdk_apbrom_horizontal_romentry73_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY73 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY73 "APBROM_HORIZONTAL_ROMENTRY73"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY73 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY73 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry74
 *
 * APBROM Horizontal Romentry74 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry74
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry74_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry74_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry74 bdk_apbrom_horizontal_romentry74_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY74 BDK_APBROM_HORIZONTAL_ROMENTRY74_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY74_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY74_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000128ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY74", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY74 bdk_apbrom_horizontal_romentry74_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY74 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY74 "APBROM_HORIZONTAL_ROMENTRY74"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY74 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY74 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry75
 *
 * APBROM Horizontal Romentry75 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry75
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry75_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry75_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry75 bdk_apbrom_horizontal_romentry75_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY75 BDK_APBROM_HORIZONTAL_ROMENTRY75_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY75_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY75_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600012cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY75", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY75 bdk_apbrom_horizontal_romentry75_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY75 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY75 "APBROM_HORIZONTAL_ROMENTRY75"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY75 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY75 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry76
 *
 * APBROM Horizontal Romentry76 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry76
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry76_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry76_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry76 bdk_apbrom_horizontal_romentry76_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY76 BDK_APBROM_HORIZONTAL_ROMENTRY76_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY76_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY76_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000130ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY76", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY76 bdk_apbrom_horizontal_romentry76_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY76 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY76 "APBROM_HORIZONTAL_ROMENTRY76"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY76 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY76 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry77
 *
 * APBROM Horizontal Romentry77 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry77
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry77_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry77_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry77 bdk_apbrom_horizontal_romentry77_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY77 BDK_APBROM_HORIZONTAL_ROMENTRY77_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY77_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY77_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000134ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY77", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY77 bdk_apbrom_horizontal_romentry77_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY77 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY77 "APBROM_HORIZONTAL_ROMENTRY77"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY77 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY77 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry78
 *
 * APBROM Horizontal Romentry78 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry78
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry78_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry78_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry78 bdk_apbrom_horizontal_romentry78_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY78 BDK_APBROM_HORIZONTAL_ROMENTRY78_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY78_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY78_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000138ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY78", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY78 bdk_apbrom_horizontal_romentry78_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY78 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY78 "APBROM_HORIZONTAL_ROMENTRY78"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY78 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY78 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry79
 *
 * APBROM Horizontal Romentry79 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry79
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry79_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry79_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry79 bdk_apbrom_horizontal_romentry79_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY79 BDK_APBROM_HORIZONTAL_ROMENTRY79_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY79_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY79_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600013cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY79", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY79 bdk_apbrom_horizontal_romentry79_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY79 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY79 "APBROM_HORIZONTAL_ROMENTRY79"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY79 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY79 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry8
 *
 * APBROM Horizontal Romentry8 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry8
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry8_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry8 bdk_apbrom_horizontal_romentry8_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY8 BDK_APBROM_HORIZONTAL_ROMENTRY8_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY8_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY8_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000020ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY8", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY8 bdk_apbrom_horizontal_romentry8_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY8 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY8 "APBROM_HORIZONTAL_ROMENTRY8"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY8 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY8 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry80
 *
 * APBROM Horizontal Romentry80 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry80
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry80_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry80 bdk_apbrom_horizontal_romentry80_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY80 BDK_APBROM_HORIZONTAL_ROMENTRY80_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY80_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY80_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000140ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY80", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY80 bdk_apbrom_horizontal_romentry80_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY80 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY80 "APBROM_HORIZONTAL_ROMENTRY80"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY80 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY80 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry81
 *
 * APBROM Horizontal Romentry81 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry81
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry81_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry81_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry81 bdk_apbrom_horizontal_romentry81_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY81 BDK_APBROM_HORIZONTAL_ROMENTRY81_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY81_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY81_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000144ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY81", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY81 bdk_apbrom_horizontal_romentry81_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY81 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY81 "APBROM_HORIZONTAL_ROMENTRY81"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY81 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY81 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry82
 *
 * APBROM Horizontal Romentry82 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry82
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry82_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry82_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry82 bdk_apbrom_horizontal_romentry82_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY82 BDK_APBROM_HORIZONTAL_ROMENTRY82_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY82_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY82_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000148ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY82", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY82 bdk_apbrom_horizontal_romentry82_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY82 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY82 "APBROM_HORIZONTAL_ROMENTRY82"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY82 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY82 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry83
 *
 * APBROM Horizontal Romentry83 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry83
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry83_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry83_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry83 bdk_apbrom_horizontal_romentry83_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY83 BDK_APBROM_HORIZONTAL_ROMENTRY83_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY83_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY83_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600014cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY83", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY83 bdk_apbrom_horizontal_romentry83_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY83 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY83 "APBROM_HORIZONTAL_ROMENTRY83"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY83 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY83 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry84
 *
 * APBROM Horizontal Romentry84 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry84
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry84_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry84_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry84 bdk_apbrom_horizontal_romentry84_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY84 BDK_APBROM_HORIZONTAL_ROMENTRY84_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY84_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY84_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000150ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY84", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY84 bdk_apbrom_horizontal_romentry84_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY84 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY84 "APBROM_HORIZONTAL_ROMENTRY84"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY84 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY84 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry85
 *
 * APBROM Horizontal Romentry85 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry85
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry85_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry85_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry85 bdk_apbrom_horizontal_romentry85_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY85 BDK_APBROM_HORIZONTAL_ROMENTRY85_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY85_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY85_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000154ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY85", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY85 bdk_apbrom_horizontal_romentry85_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY85 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY85 "APBROM_HORIZONTAL_ROMENTRY85"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY85 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY85 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry86
 *
 * APBROM Horizontal Romentry86 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry86
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry86_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry86_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry86 bdk_apbrom_horizontal_romentry86_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY86 BDK_APBROM_HORIZONTAL_ROMENTRY86_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY86_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY86_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000158ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY86", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY86 bdk_apbrom_horizontal_romentry86_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY86 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY86 "APBROM_HORIZONTAL_ROMENTRY86"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY86 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY86 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry87
 *
 * APBROM Horizontal Romentry87 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry87
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry87_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry87_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry87 bdk_apbrom_horizontal_romentry87_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY87 BDK_APBROM_HORIZONTAL_ROMENTRY87_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY87_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY87_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600015cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY87", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY87 bdk_apbrom_horizontal_romentry87_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY87 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY87 "APBROM_HORIZONTAL_ROMENTRY87"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY87 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY87 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry88
 *
 * APBROM Horizontal Romentry88 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry88
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry88_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry88 bdk_apbrom_horizontal_romentry88_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY88 BDK_APBROM_HORIZONTAL_ROMENTRY88_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY88_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY88_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000160ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY88", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY88 bdk_apbrom_horizontal_romentry88_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY88 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY88 "APBROM_HORIZONTAL_ROMENTRY88"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY88 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY88 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry89
 *
 * APBROM Horizontal Romentry89 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry89
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry89_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry89_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry89 bdk_apbrom_horizontal_romentry89_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY89 BDK_APBROM_HORIZONTAL_ROMENTRY89_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY89_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY89_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000164ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY89", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY89 bdk_apbrom_horizontal_romentry89_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY89 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY89 "APBROM_HORIZONTAL_ROMENTRY89"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY89 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY89 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry9
 *
 * APBROM Horizontal Romentry9 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry9
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry9_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry9 bdk_apbrom_horizontal_romentry9_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY9 BDK_APBROM_HORIZONTAL_ROMENTRY9_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY9_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY9_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000024ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY9", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY9 bdk_apbrom_horizontal_romentry9_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY9 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY9 "APBROM_HORIZONTAL_ROMENTRY9"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY9 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY9 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry90
 *
 * APBROM Horizontal Romentry90 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry90
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry90_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry90_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry90 bdk_apbrom_horizontal_romentry90_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY90 BDK_APBROM_HORIZONTAL_ROMENTRY90_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY90_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY90_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000168ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY90", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY90 bdk_apbrom_horizontal_romentry90_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY90 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY90 "APBROM_HORIZONTAL_ROMENTRY90"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY90 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY90 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry91
 *
 * APBROM Horizontal Romentry91 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry91
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry91_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry91_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry91 bdk_apbrom_horizontal_romentry91_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY91 BDK_APBROM_HORIZONTAL_ROMENTRY91_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY91_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY91_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600016cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY91", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY91 bdk_apbrom_horizontal_romentry91_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY91 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY91 "APBROM_HORIZONTAL_ROMENTRY91"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY91 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY91 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry92
 *
 * APBROM Horizontal Romentry92 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry92
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry92_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry92_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry92 bdk_apbrom_horizontal_romentry92_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY92 BDK_APBROM_HORIZONTAL_ROMENTRY92_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY92_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY92_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000170ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY92", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY92 bdk_apbrom_horizontal_romentry92_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY92 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY92 "APBROM_HORIZONTAL_ROMENTRY92"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY92 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY92 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry93
 *
 * APBROM Horizontal Romentry93 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry93
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry93_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry93_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry93 bdk_apbrom_horizontal_romentry93_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY93 BDK_APBROM_HORIZONTAL_ROMENTRY93_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY93_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY93_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000174ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY93", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY93 bdk_apbrom_horizontal_romentry93_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY93 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY93 "APBROM_HORIZONTAL_ROMENTRY93"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY93 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY93 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry94
 *
 * APBROM Horizontal Romentry94 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry94
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry94_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry94_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry94 bdk_apbrom_horizontal_romentry94_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY94 BDK_APBROM_HORIZONTAL_ROMENTRY94_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY94_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY94_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000178ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY94", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY94 bdk_apbrom_horizontal_romentry94_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY94 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY94 "APBROM_HORIZONTAL_ROMENTRY94"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY94 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY94 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry95
 *
 * APBROM Horizontal Romentry95 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry95
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry95_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry95_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry95 bdk_apbrom_horizontal_romentry95_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY95 BDK_APBROM_HORIZONTAL_ROMENTRY95_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY95_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY95_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600017cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY95", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY95 bdk_apbrom_horizontal_romentry95_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY95 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY95 "APBROM_HORIZONTAL_ROMENTRY95"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY95 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY95 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry96
 *
 * APBROM Horizontal Romentry96 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry96
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry96_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry96 bdk_apbrom_horizontal_romentry96_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY96 BDK_APBROM_HORIZONTAL_ROMENTRY96_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY96_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY96_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000180ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY96", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY96 bdk_apbrom_horizontal_romentry96_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY96 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY96 "APBROM_HORIZONTAL_ROMENTRY96"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY96 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY96 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry97
 *
 * APBROM Horizontal Romentry97 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry97
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry97_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry97_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry97 bdk_apbrom_horizontal_romentry97_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY97 BDK_APBROM_HORIZONTAL_ROMENTRY97_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY97_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY97_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000184ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY97", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY97 bdk_apbrom_horizontal_romentry97_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY97 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY97 "APBROM_HORIZONTAL_ROMENTRY97"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY97 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY97 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry98
 *
 * APBROM Horizontal Romentry98 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry98
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry98_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry98_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry98 bdk_apbrom_horizontal_romentry98_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY98 BDK_APBROM_HORIZONTAL_ROMENTRY98_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY98_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY98_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e046000188ll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY98", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY98 bdk_apbrom_horizontal_romentry98_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY98 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY98 "APBROM_HORIZONTAL_ROMENTRY98"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY98 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY98 -1,-1,-1,-1

/**
 * Register (RSL32b) apbrom_horizontal_romentry99
 *
 * APBROM Horizontal Romentry99 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_horizontal_romentry99
{
    uint32_t u;
    struct bdk_apbrom_horizontal_romentry99_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_horizontal_romentry99_s cn; */
};
typedef union bdk_apbrom_horizontal_romentry99 bdk_apbrom_horizontal_romentry99_t;

#define BDK_APBROM_HORIZONTAL_ROMENTRY99 BDK_APBROM_HORIZONTAL_ROMENTRY99_FUNC()
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY99_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_HORIZONTAL_ROMENTRY99_FUNC(void)
{
    if (bdk_is_model(OCTEONTX_LOKI))
        return 0x87e04600018cll;
    __bdk_csr_fatal("APBROM_HORIZONTAL_ROMENTRY99", 0, 0, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_HORIZONTAL_ROMENTRY99 bdk_apbrom_horizontal_romentry99_t
#define bustype_BDK_APBROM_HORIZONTAL_ROMENTRY99 BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_HORIZONTAL_ROMENTRY99 "APBROM_HORIZONTAL_ROMENTRY99"
#define busnum_BDK_APBROM_HORIZONTAL_ROMENTRY99 0
#define arguments_BDK_APBROM_HORIZONTAL_ROMENTRY99 -1,-1,-1,-1

#endif /* __BDK_CSRS_APBROM_HORIZONTAL_H__ */
