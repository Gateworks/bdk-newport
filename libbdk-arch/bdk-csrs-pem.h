#ifndef __BDK_CSRS_PEM_H__
#define __BDK_CSRS_PEM_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX PEM.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration pem_bar_e
 *
 * PEM Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define BDK_PEM_BAR_E_PEMX_PF_BAR0_CN8(a) (0x87e0c0000000ll + 0x1000000ll * (a))
#define BDK_PEM_BAR_E_PEMX_PF_BAR0_CN8_SIZE 0x800000ull
#define BDK_PEM_BAR_E_PEMX_PF_BAR0_CN9(a) (0x8e0000000000ll + 0x1000000000ll * (a))
#define BDK_PEM_BAR_E_PEMX_PF_BAR0_CN9_SIZE 0x40000000ull
#define BDK_PEM_BAR_E_PEMX_PF_BAR4_CN8(a) (0x87e0c0f00000ll + 0x1000000ll * (a))
#define BDK_PEM_BAR_E_PEMX_PF_BAR4_CN8_SIZE 0x100000ull
#define BDK_PEM_BAR_E_PEMX_PF_BAR4_CN9(a) (0x8e0f00000000ll + 0x1000000000ll * (a))
#define BDK_PEM_BAR_E_PEMX_PF_BAR4_CN9_SIZE 0x100000ull

/**
 * Enumeration pem_ep_functions_e
 *
 * PEM EP Mode Function Number Enumeration
 * Enumerates the function numbers that an EP PEM masters.
 */
#define BDK_PEM_EP_FUNCTIONS_E_PF0 (0)
#define BDK_PEM_EP_FUNCTIONS_E_PF0_VFX(a) (0 + (a))

/**
 * Enumeration pem_int_vec_e
 *
 * PEM MSI-X Vector Enumeration
 * Enumerates the MSI-X interrupt vectors.
 */
#define BDK_PEM_INT_VEC_E_DBG_INFO (0xb)
#define BDK_PEM_INT_VEC_E_ERROR_AERI (0)
#define BDK_PEM_INT_VEC_E_HP_PMEI (1)
#define BDK_PEM_INT_VEC_E_INTA_CN8 (2)
#define BDK_PEM_INT_VEC_E_INTA_CN9 (0)
#define BDK_PEM_INT_VEC_E_INTA_CLEAR_CN8 (3)
#define BDK_PEM_INT_VEC_E_INTA_CLEAR_CN9 (1)
#define BDK_PEM_INT_VEC_E_INTB_CN8 (4)
#define BDK_PEM_INT_VEC_E_INTB_CN9 (2)
#define BDK_PEM_INT_VEC_E_INTB_CLEAR_CN8 (5)
#define BDK_PEM_INT_VEC_E_INTB_CLEAR_CN9 (3)
#define BDK_PEM_INT_VEC_E_INTC_CN8 (6)
#define BDK_PEM_INT_VEC_E_INTC_CN9 (4)
#define BDK_PEM_INT_VEC_E_INTC_CLEAR_CN8 (7)
#define BDK_PEM_INT_VEC_E_INTC_CLEAR_CN9 (5)
#define BDK_PEM_INT_VEC_E_INTD_CN8 (8)
#define BDK_PEM_INT_VEC_E_INTD_CN9 (6)
#define BDK_PEM_INT_VEC_E_INTD_CLEAR_CN8 (9)
#define BDK_PEM_INT_VEC_E_INTD_CLEAR_CN9 (7)
#define BDK_PEM_INT_VEC_E_INT_SUM_CN8 (0xa)
#define BDK_PEM_INT_VEC_E_INT_SUM_CN9 (8)
#define BDK_PEM_INT_VEC_E_RST_INT (9)

/**
 * Enumeration pem_rst_source_e
 *
 * PEM Reset Cause Enumeration
 * Enumerates the reset sources for both reset domain mapping and cause of last reset,
 * corresponding to the bit numbers of PEM()_RST_LBOOT.
 */
#define BDK_PEM_RST_SOURCE_E_L2 (2)
#define BDK_PEM_RST_SOURCE_E_LINKDOWN (1)
#define BDK_PEM_RST_SOURCE_E_PEM_PFFLR (3)
#define BDK_PEM_RST_SOURCE_E_PEM_RSVD (4)
#define BDK_PEM_RST_SOURCE_E_PERST_PIN (0)

/**
 * Structure pem_ncbo_huge_memio_s
 *
 * NCB to MAC Operation Structure
 * Core initiated load and store operations that are initiating MAC transactions form an address
 * with this structure through the PEM()_REG_HUGE()_ACC table. 8-bit, 16-bit, 32-bit and 64-bit
 * reads and writes, in addition to atomics are supported to this region.
 */
union bdk_pem_ncbo_huge_memio_s
{
    uint64_t u;
    struct bdk_pem_ncbo_huge_memio_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t pem_hi                : 2;  /**< [ 51: 50] Special decode for upper = (PEM_Number[3:2]+1). 0x1 for PEM0-3, 0x2 for PEM4. */
        uint64_t node                  : 2;  /**< [ 49: 48] Reserved.
                                                                 Internal:
                                                                 CCPI node number. */
        uint64_t pem_lo                : 2;  /**< [ 47: 46] PEM number \<1:0\>. */
        uint64_t region                : 8;  /**< [ 45: 38] ACC region.  Indexes into PEM()_REG_HUGE()_ACC. */
        uint64_t addr                  : 38; /**< [ 37:  0] Register address within the device. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 38; /**< [ 37:  0] Register address within the device. */
        uint64_t region                : 8;  /**< [ 45: 38] ACC region.  Indexes into PEM()_REG_HUGE()_ACC. */
        uint64_t pem_lo                : 2;  /**< [ 47: 46] PEM number \<1:0\>. */
        uint64_t node                  : 2;  /**< [ 49: 48] Reserved.
                                                                 Internal:
                                                                 CCPI node number. */
        uint64_t pem_hi                : 2;  /**< [ 51: 50] Special decode for upper = (PEM_Number[3:2]+1). 0x1 for PEM0-3, 0x2 for PEM4. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pem_ncbo_huge_memio_s_s cn; */
};

/**
 * Structure pem_ncbo_norm_memio_s
 *
 * NCB to MAC Operation Structure
 * Core initiated load and store operations that are initiating MAC transactions form an address
 * with this structure through the PEM()_REG_NORM()_ACC table. 8-bit, 16-bit, 32-bit and 64-bit
 * reads and writes, in addition to atomics are supported to this region.
 */
union bdk_pem_ncbo_norm_memio_s
{
    uint64_t u;
    struct bdk_pem_ncbo_norm_memio_s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t io                    : 5;  /**< [ 51: 47] Indicates IO space. */
        uint64_t reserved_46           : 1;
        uint64_t node                  : 2;  /**< [ 45: 44] Reserved.
                                                                 Internal:
                                                                 CCPI node number. */
        uint64_t did_hi                : 5;  /**< [ 43: 39] PEM high device ID bits \<7:3\>. */
        uint64_t region                : 8;  /**< [ 38: 31] ACC region.  Indexes into PEM()_REG_NORM()_ACC. */
        uint64_t addr                  : 31; /**< [ 30:  0] Register address within the device. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 31; /**< [ 30:  0] Register address within the device. */
        uint64_t region                : 8;  /**< [ 38: 31] ACC region.  Indexes into PEM()_REG_NORM()_ACC. */
        uint64_t did_hi                : 5;  /**< [ 43: 39] PEM high device ID bits \<7:3\>. */
        uint64_t node                  : 2;  /**< [ 45: 44] Reserved.
                                                                 Internal:
                                                                 CCPI node number. */
        uint64_t reserved_46           : 1;
        uint64_t io                    : 5;  /**< [ 51: 47] Indicates IO space. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pem_ncbo_norm_memio_s_s cn; */
};

/**
 * Register (RSL) pem#_bar1_index#
 *
 * PEM BAR1 Index 0-15 Register
 * This register contains the address index and control bits for access to memory ranges of BAR1.
 * The index is built from supplied address [25:22].
 */
union bdk_pemx_bar1_indexx
{
    uint64_t u;
    struct bdk_pemx_bar1_indexx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t addr_idx              : 27; /**< [ 30:  4](R/W) Address index. Address bits [48:22] sent to L2C. */
        uint64_t ca                    : 1;  /**< [  3:  3](R/W) Cached. Set to 1 when access is not to be cached in L2. */
        uint64_t end_swp               : 2;  /**< [  2:  1](R/W) Endian-swap mode. */
        uint64_t addr_v                : 1;  /**< [  0:  0](R/W) Address valid. Set to 1 when the selected address range is valid. */
#else /* Word 0 - Little Endian */
        uint64_t addr_v                : 1;  /**< [  0:  0](R/W) Address valid. Set to 1 when the selected address range is valid. */
        uint64_t end_swp               : 2;  /**< [  2:  1](R/W) Endian-swap mode. */
        uint64_t ca                    : 1;  /**< [  3:  3](R/W) Cached. Set to 1 when access is not to be cached in L2. */
        uint64_t addr_idx              : 27; /**< [ 30:  4](R/W) Address index. Address bits [48:22] sent to L2C. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bar1_indexx_s cn8; */
    struct bdk_pemx_bar1_indexx_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t addr_idx              : 27; /**< [ 30:  4](R/W) Address index. Address bits [48:22] sent to L2C. */
        uint64_t ca                    : 1;  /**< [  3:  3](R/W) Cached. Set to 1 when access is not to be cached in L2. */
        uint64_t reserved_1_2          : 2;
        uint64_t addr_v                : 1;  /**< [  0:  0](R/W) Address valid. Set to 1 when the selected address range is valid. */
#else /* Word 0 - Little Endian */
        uint64_t addr_v                : 1;  /**< [  0:  0](R/W) Address valid. Set to 1 when the selected address range is valid. */
        uint64_t reserved_1_2          : 2;
        uint64_t ca                    : 1;  /**< [  3:  3](R/W) Cached. Set to 1 when access is not to be cached in L2. */
        uint64_t addr_idx              : 27; /**< [ 30:  4](R/W) Address index. Address bits [48:22] sent to L2C. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } cn81xx;
    /* struct bdk_pemx_bar1_indexx_s cn83xx; */
};
typedef union bdk_pemx_bar1_indexx bdk_pemx_bar1_indexx_t;

static inline uint64_t BDK_PEMX_BAR1_INDEXX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BAR1_INDEXX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && ((a<=2) && (b<=15)))
        return 0x87e0c0000100ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b<=15)))
        return 0x87e0c0000100ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_BAR1_INDEXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BAR1_INDEXX(a,b) bdk_pemx_bar1_indexx_t
#define bustype_BDK_PEMX_BAR1_INDEXX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_BAR1_INDEXX(a,b) "PEMX_BAR1_INDEXX"
#define device_bar_BDK_PEMX_BAR1_INDEXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BAR1_INDEXX(a,b) (a)
#define arguments_BDK_PEMX_BAR1_INDEXX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_bar2_mask
 *
 * PEM BAR2 Mask Register
 * This register contains the mask pattern that is ANDed with the address from the PCIe core for
 * inbound PF BAR2 hits in either RC or EP mode. This mask is only applied if
 * PEM()_EBUS_CTL[PF_BAR2_SEL] is clear and the address hits in the PCIEEP_BAR2L / PCIEEP_BAR2U
 * registers (EP mode) or PEM()_P2N_BAR2_START / PEM()_BAR_CTL[BAR2_SIZ] registers (RC mode).
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bar2_mask
{
    uint64_t u;
    struct bdk_pemx_bar2_mask_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t mask                  : 49; /**< [ 52:  4](R/W) The value to be ANDED with the address sent to memory. */
        uint64_t reserved_0_3          : 4;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_3          : 4;
        uint64_t mask                  : 49; /**< [ 52:  4](R/W) The value to be ANDED with the address sent to memory. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_bar2_mask_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t mask                  : 45; /**< [ 48:  4](R/W) The value to be ANDED with the address sent to memory. */
        uint64_t reserved_0_3          : 4;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_3          : 4;
        uint64_t mask                  : 45; /**< [ 48:  4](R/W) The value to be ANDED with the address sent to memory. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } cn8;
    /* struct bdk_pemx_bar2_mask_cn8 cn81xx; */
    struct bdk_pemx_bar2_mask_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t mask                  : 45; /**< [ 48:  4](R/W) The value to be ANDed with the address sent to memory (to IOB). */
        uint64_t reserved_0_3          : 4;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_3          : 4;
        uint64_t mask                  : 45; /**< [ 48:  4](R/W) The value to be ANDed with the address sent to memory (to IOB). */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_bar2_mask_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t mask                  : 49; /**< [ 52:  4](R/W) The value to be ANDed with the address sent to memory (to IOB). */
        uint64_t reserved_0_3          : 4;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_3          : 4;
        uint64_t mask                  : 49; /**< [ 52:  4](R/W) The value to be ANDed with the address sent to memory (to IOB). */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_bar2_mask bdk_pemx_bar2_mask_t;

static inline uint64_t BDK_PEMX_BAR2_MASK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BAR2_MASK(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c00000b0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c00000b0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000048ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000048ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000048ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000048ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BAR2_MASK", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BAR2_MASK(a) bdk_pemx_bar2_mask_t
#define bustype_BDK_PEMX_BAR2_MASK(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BAR2_MASK(a) "PEMX_BAR2_MASK"
#define device_bar_BDK_PEMX_BAR2_MASK(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BAR2_MASK(a) (a)
#define arguments_BDK_PEMX_BAR2_MASK(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bar4_index#
 *
 * PEM BAR4 Index 0-15 Register
 * This register contains the address index and control bits for access to memory ranges of BAR4.
 * The index is built from the PCI inbound address \<25:22\>. The bits in this register only apply to
 * inbound accesses targeting the NCB bus in both RC and EP modes, this register is ignored
 * when PEM()_EBUS_CTL[PF_BAR4_SEL] is set.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bar4_indexx
{
    uint64_t u;
    struct bdk_pemx_bar4_indexx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t addr_idx              : 31; /**< [ 34:  4](R/W) Address index. IOVA \<52:22\> sent to NCB. */
        uint64_t ca                    : 1;  /**< [  3:  3](R/W) Cached. Set to 1 when access is not to be cached in LLC. */
        uint64_t reserved_1_2          : 2;
        uint64_t addr_v                : 1;  /**< [  0:  0](R/W) Address valid. Set to 1 when the selected address range is valid. */
#else /* Word 0 - Little Endian */
        uint64_t addr_v                : 1;  /**< [  0:  0](R/W) Address valid. Set to 1 when the selected address range is valid. */
        uint64_t reserved_1_2          : 2;
        uint64_t ca                    : 1;  /**< [  3:  3](R/W) Cached. Set to 1 when access is not to be cached in LLC. */
        uint64_t addr_idx              : 31; /**< [ 34:  4](R/W) Address index. IOVA \<52:22\> sent to NCB. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bar4_indexx_s cn; */
};
typedef union bdk_pemx_bar4_indexx bdk_pemx_bar4_indexx_t;

static inline uint64_t BDK_PEMX_BAR4_INDEXX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BAR4_INDEXX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=15)))
        return 0x8e0000000700ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=15)))
        return 0x8e0000000700ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=15)))
        return 0x8e0000000700ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=15)))
        return 0x8e0000000700ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_BAR4_INDEXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BAR4_INDEXX(a,b) bdk_pemx_bar4_indexx_t
#define bustype_BDK_PEMX_BAR4_INDEXX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BAR4_INDEXX(a,b) "PEMX_BAR4_INDEXX"
#define device_bar_BDK_PEMX_BAR4_INDEXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BAR4_INDEXX(a,b) (a)
#define arguments_BDK_PEMX_BAR4_INDEXX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_bar_ctl
 *
 * PEM BAR Control Register
 * This register contains control for BAR accesses. This control always
 * applies to memory accesses targeting the NCBI bus. Some of the fields also
 * apply to accesses targeting EBUS in RC mode only, see the individual field
 * descriptions for more detail.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bar_ctl
{
    uint64_t u;
    struct bdk_pemx_bar_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_38_63        : 26;
        uint64_t vf_bar4_enb           : 1;  /**< [ 37: 37](R/W) This bit controls whether BAR4 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR4 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR4 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR4U, PCIEEP_SRIOV_BAR4L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR4 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR4U / PCIEEP_SRIOV_BAR4L. */
        uint64_t vf_bar2_enb           : 1;  /**< [ 36: 36](R/W) This bit controls whether BAR2 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR2 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR2 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR2U, PCIEEP_SRIOV_BAR2L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR2 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR2U / PCIEEP_SRIOV_BAR2L. */
        uint64_t vf_bar0_enb           : 1;  /**< [ 35: 35](R/W) This bit controls whether BAR0 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR0 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR0U, PCIEEP_SRIOV_BAR0L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR0 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR0U / PCIEEP_SRIOV_BAR0L. */
        uint64_t reserved_32_34        : 3;
        uint64_t bar4_enb              : 1;  /**< [ 31: 31](R/W) In RC mode:
                                                                  0 = BAR4 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR4_SEL].
                                                                  1 = BAR4 is enabled and will respond if the corresponding
                                                                  bits in PEM()_BAR4_INDEX() are set and the address matches
                                                                  an enabled indexed address range.

                                                                 In EP mode:

                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is set, BAR4 hits are based on
                                                                  a combination of this bit and config registers PCIEEP_BAR4U / PCIEEP_BAR4L.
                                                                  Both enable bits must be set to enable a BAR4 hit.
                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is clear, BAR4 hits are based
                                                                  on a combination of this bit, the config registers PCIEEP_BAR4U /
                                                                  PCIEEP_BAR4L, and the PEM()_BAR4_INDEX() registers.
                                                                  Both enable bits must be set along with the appropriate bits in
                                                                  PEM()_BAR4_INDEX() in order for a BAR4 access to respond. */
        uint64_t bar0_siz              : 5;  /**< [ 30: 26](R/W) PCIe BAR0 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 KB; 2^16.
                                                                 0x2 = 128 KB; 2^17.
                                                                 0x3 = 256 KB; 2^18.
                                                                 0x4 = 512 KB; 2^19.
                                                                 0x5 = 1 MB; 2^20.
                                                                 0x6 = 2 MB; 2^21.
                                                                 0x7 = 4 MB; 2^22.
                                                                 0x8 = 8 MB; 2^23.
                                                                 0x9 = 16 MB; 2^24.
                                                                 0xA = 32 MB; 2^25.
                                                                 0xB = 64 MB; 2^26.
                                                                 0xC - 0x1F = Reserved.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t bar0_enb              : 1;  /**< [ 25: 25](R/W) In RC mode:
                                                                  0 = BAR0 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR0_SEL].
                                                                  1 = BAR0 is enabled and will respond.

                                                                 In EP mode:

                                                                  * BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_BAR0U / PCIEEP_BAR0L. Both enable
                                                                  bits must be set to enable a BAR0 hit. */
        uint64_t bar2_ebit             : 6;  /**< [ 24: 19](R/W) Address bits for ESX\<1:0\> in a PCIe BAR2 address.

                                                                 When [BAR2_EBIT] is zero, a PCIe BAR2 address does not contain an ESX\<1:0\> field,
                                                                 and [BAR2_ESX] is the endian-swap used for all BAR2 requests.

                                                                 When [BAR2_EBIT] is non-zero, it places ESX\<1:0\> (ESX\<0\> is at PCIe BAR2 address bit
                                                                 [BAR2_EBIT], and ESX\<1\> is at PCIe BAR2 address bit [BAR2_EBIT]+1). [BAR2_EBIT] must
                                                                 be in the range 16 .. [BAR2_SIZ]+18 and must not conflict with a non-zero
                                                                 [BAR2_CBIT] in this case. [BAR2_ESX] XOR ESX\<1:0\> is the endian-swap
                                                                 used for BAR2 requests in this case. If [BAR2_EBIT] \<= 48 in this case, then
                                                                 one or two PCIe BAR2 address ESX field bit(s) are in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit for CAX in a PCIe BAR2 address.

                                                                 When [BAR2_CBIT] is zero, a PCIe BAR2 address does not contain a CAX bit,
                                                                 and [BAR2_CAX] is the cache allocation for all BAR2 requests.

                                                                 When [BAR2_CBIT] is non-zero, the CAX bit is at bit [BAR2_CBIT] in the PCIe
                                                                 BAR2 address. [BAR2_CBIT] must be in the range 16 .. [BAR2_SIZ]+19 and must
                                                                 not conflict with a non-zero [BAR2_EBIT] in this case. [BAR2_CBIT] XOR CAX is
                                                                 the cache allocation for BAR2 requests. If [BAR2_CBIT] \<= 48 in this
                                                                 case, then the PCIe BAR2 address CAX bit is in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded identically to PCIEEP()_CFG190[RBARS]. Resets to 0x1D (512 TB).

                                                                 In EP mode, [BAR2_SIZ] must equal the corresponding PCIEEP()_CFG190[RBARS].

                                                                 In RC mode, [BAR2_SIZ] determines the PEM()_P2N_BAR2_START[ADDR] bits used/compared
                                                                 to an incoming PCIe address.

                                                                 On a BAR2 match, PEM zeroes the PCIe address bits outside [BAR2_SIZ], applies
                                                                 [BAR2_EBIT,BAR2_CBIT], and forwards the request to SLI and the SMMU. */
        uint64_t reserved_4_6          : 3;
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t bar2_esx              : 2;  /**< [  2:  1](R/W) Value is XORed with PCIe addresses as defined by [BAR2_EBIT] to determine the
                                                                 endian swap mode. */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address \<49\> to determine the L2 cache attribute. Not cached in
                                                                 L2 if XOR result is 1. */
#else /* Word 0 - Little Endian */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address \<49\> to determine the L2 cache attribute. Not cached in
                                                                 L2 if XOR result is 1. */
        uint64_t bar2_esx              : 2;  /**< [  2:  1](R/W) Value is XORed with PCIe addresses as defined by [BAR2_EBIT] to determine the
                                                                 endian swap mode. */
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t reserved_4_6          : 3;
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded identically to PCIEEP()_CFG190[RBARS]. Resets to 0x1D (512 TB).

                                                                 In EP mode, [BAR2_SIZ] must equal the corresponding PCIEEP()_CFG190[RBARS].

                                                                 In RC mode, [BAR2_SIZ] determines the PEM()_P2N_BAR2_START[ADDR] bits used/compared
                                                                 to an incoming PCIe address.

                                                                 On a BAR2 match, PEM zeroes the PCIe address bits outside [BAR2_SIZ], applies
                                                                 [BAR2_EBIT,BAR2_CBIT], and forwards the request to SLI and the SMMU. */
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit for CAX in a PCIe BAR2 address.

                                                                 When [BAR2_CBIT] is zero, a PCIe BAR2 address does not contain a CAX bit,
                                                                 and [BAR2_CAX] is the cache allocation for all BAR2 requests.

                                                                 When [BAR2_CBIT] is non-zero, the CAX bit is at bit [BAR2_CBIT] in the PCIe
                                                                 BAR2 address. [BAR2_CBIT] must be in the range 16 .. [BAR2_SIZ]+19 and must
                                                                 not conflict with a non-zero [BAR2_EBIT] in this case. [BAR2_CBIT] XOR CAX is
                                                                 the cache allocation for BAR2 requests. If [BAR2_CBIT] \<= 48 in this
                                                                 case, then the PCIe BAR2 address CAX bit is in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_ebit             : 6;  /**< [ 24: 19](R/W) Address bits for ESX\<1:0\> in a PCIe BAR2 address.

                                                                 When [BAR2_EBIT] is zero, a PCIe BAR2 address does not contain an ESX\<1:0\> field,
                                                                 and [BAR2_ESX] is the endian-swap used for all BAR2 requests.

                                                                 When [BAR2_EBIT] is non-zero, it places ESX\<1:0\> (ESX\<0\> is at PCIe BAR2 address bit
                                                                 [BAR2_EBIT], and ESX\<1\> is at PCIe BAR2 address bit [BAR2_EBIT]+1). [BAR2_EBIT] must
                                                                 be in the range 16 .. [BAR2_SIZ]+18 and must not conflict with a non-zero
                                                                 [BAR2_CBIT] in this case. [BAR2_ESX] XOR ESX\<1:0\> is the endian-swap
                                                                 used for BAR2 requests in this case. If [BAR2_EBIT] \<= 48 in this case, then
                                                                 one or two PCIe BAR2 address ESX field bit(s) are in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar0_enb              : 1;  /**< [ 25: 25](R/W) In RC mode:
                                                                  0 = BAR0 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR0_SEL].
                                                                  1 = BAR0 is enabled and will respond.

                                                                 In EP mode:

                                                                  * BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_BAR0U / PCIEEP_BAR0L. Both enable
                                                                  bits must be set to enable a BAR0 hit. */
        uint64_t bar0_siz              : 5;  /**< [ 30: 26](R/W) PCIe BAR0 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 KB; 2^16.
                                                                 0x2 = 128 KB; 2^17.
                                                                 0x3 = 256 KB; 2^18.
                                                                 0x4 = 512 KB; 2^19.
                                                                 0x5 = 1 MB; 2^20.
                                                                 0x6 = 2 MB; 2^21.
                                                                 0x7 = 4 MB; 2^22.
                                                                 0x8 = 8 MB; 2^23.
                                                                 0x9 = 16 MB; 2^24.
                                                                 0xA = 32 MB; 2^25.
                                                                 0xB = 64 MB; 2^26.
                                                                 0xC - 0x1F = Reserved.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t bar4_enb              : 1;  /**< [ 31: 31](R/W) In RC mode:
                                                                  0 = BAR4 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR4_SEL].
                                                                  1 = BAR4 is enabled and will respond if the corresponding
                                                                  bits in PEM()_BAR4_INDEX() are set and the address matches
                                                                  an enabled indexed address range.

                                                                 In EP mode:

                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is set, BAR4 hits are based on
                                                                  a combination of this bit and config registers PCIEEP_BAR4U / PCIEEP_BAR4L.
                                                                  Both enable bits must be set to enable a BAR4 hit.
                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is clear, BAR4 hits are based
                                                                  on a combination of this bit, the config registers PCIEEP_BAR4U /
                                                                  PCIEEP_BAR4L, and the PEM()_BAR4_INDEX() registers.
                                                                  Both enable bits must be set along with the appropriate bits in
                                                                  PEM()_BAR4_INDEX() in order for a BAR4 access to respond. */
        uint64_t reserved_32_34        : 3;
        uint64_t vf_bar0_enb           : 1;  /**< [ 35: 35](R/W) This bit controls whether BAR0 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR0 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR0U, PCIEEP_SRIOV_BAR0L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR0 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR0U / PCIEEP_SRIOV_BAR0L. */
        uint64_t vf_bar2_enb           : 1;  /**< [ 36: 36](R/W) This bit controls whether BAR2 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR2 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR2 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR2U, PCIEEP_SRIOV_BAR2L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR2 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR2U / PCIEEP_SRIOV_BAR2L. */
        uint64_t vf_bar4_enb           : 1;  /**< [ 37: 37](R/W) This bit controls whether BAR4 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR4 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR4 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR4U, PCIEEP_SRIOV_BAR4L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR4 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR4U / PCIEEP_SRIOV_BAR4L. */
        uint64_t reserved_38_63        : 26;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_bar_ctl_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t bar2_ebit             : 6;  /**< [ 24: 19](R/W) Address bits for ESX\<1:0\> in a PCIe BAR2 address.

                                                                 When [BAR2_EBIT] is zero, a PCIe BAR2 address does not contain an ESX\<1:0\> field,
                                                                 and [BAR2_ESX] is the endian-swap used for all BAR2 requests.

                                                                 When [BAR2_EBIT] is non-zero, it places ESX\<1:0\> (ESX\<0\> is at PCIe BAR2 address bit
                                                                 [BAR2_EBIT], and ESX\<1\> is at PCIe BAR2 address bit [BAR2_EBIT]+1). [BAR2_EBIT] must
                                                                 be in the range 16 .. [BAR2_SIZ]+18 and must not conflict with a non-zero
                                                                 [BAR2_CBIT] in this case. [BAR2_ESX] XOR ESX\<1:0\> is the endian-swap
                                                                 used for BAR2 requests in this case. If [BAR2_EBIT] \<= 48 in this case, then
                                                                 one or two PCIe BAR2 address ESX field bit(s) are in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit for CAX in a PCIe BAR2 address.

                                                                 When [BAR2_CBIT] is zero, a PCIe BAR2 address does not contain a CAX bit,
                                                                 and [BAR2_CAX] is the cache allocation for all BAR2 requests.

                                                                 When [BAR2_CBIT] is non-zero, the CAX bit is at bit [BAR2_CBIT] in the PCIe
                                                                 BAR2 address. [BAR2_CBIT] must be in the range 16 .. [BAR2_SIZ]+19 and must
                                                                 not conflict with a non-zero [BAR2_EBIT] in this case. [BAR2_CBIT] XOR CAX is
                                                                 the cache allocation for BAR2 requests. If [BAR2_CBIT] \<= 48 in this
                                                                 case, then the PCIe BAR2 address CAX bit is in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded identically to PCIEEP()_CFG190[RBARS]. Resets to 0x1D (512 TB).

                                                                 In EP mode, [BAR2_SIZ] must equal the corresponding PCIEEP()_CFG190[RBARS].

                                                                 In RC mode, [BAR2_SIZ] determines the PEM()_P2N_BAR2_START[ADDR] bits used/compared
                                                                 to an incoming PCIe address.

                                                                 On a BAR2 match, PEM zeroes the PCIe address bits outside [BAR2_SIZ], applies
                                                                 [BAR2_EBIT,BAR2_CBIT], and forwards the request to SLI and the SMMU. */
        uint64_t bar1_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR1 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved. */
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t bar2_esx              : 2;  /**< [  2:  1](R/W) Value is XORed with PCIe addresses as defined by [BAR2_EBIT] to determine the
                                                                 endian swap mode. */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address \<49\> to determine the L2 cache attribute. Not cached in
                                                                 L2 if XOR result is 1. */
#else /* Word 0 - Little Endian */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address \<49\> to determine the L2 cache attribute. Not cached in
                                                                 L2 if XOR result is 1. */
        uint64_t bar2_esx              : 2;  /**< [  2:  1](R/W) Value is XORed with PCIe addresses as defined by [BAR2_EBIT] to determine the
                                                                 endian swap mode. */
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t bar1_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR1 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved. */
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded identically to PCIEEP()_CFG190[RBARS]. Resets to 0x1D (512 TB).

                                                                 In EP mode, [BAR2_SIZ] must equal the corresponding PCIEEP()_CFG190[RBARS].

                                                                 In RC mode, [BAR2_SIZ] determines the PEM()_P2N_BAR2_START[ADDR] bits used/compared
                                                                 to an incoming PCIe address.

                                                                 On a BAR2 match, PEM zeroes the PCIe address bits outside [BAR2_SIZ], applies
                                                                 [BAR2_EBIT,BAR2_CBIT], and forwards the request to SLI and the SMMU. */
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit for CAX in a PCIe BAR2 address.

                                                                 When [BAR2_CBIT] is zero, a PCIe BAR2 address does not contain a CAX bit,
                                                                 and [BAR2_CAX] is the cache allocation for all BAR2 requests.

                                                                 When [BAR2_CBIT] is non-zero, the CAX bit is at bit [BAR2_CBIT] in the PCIe
                                                                 BAR2 address. [BAR2_CBIT] must be in the range 16 .. [BAR2_SIZ]+19 and must
                                                                 not conflict with a non-zero [BAR2_EBIT] in this case. [BAR2_CBIT] XOR CAX is
                                                                 the cache allocation for BAR2 requests. If [BAR2_CBIT] \<= 48 in this
                                                                 case, then the PCIe BAR2 address CAX bit is in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_ebit             : 6;  /**< [ 24: 19](R/W) Address bits for ESX\<1:0\> in a PCIe BAR2 address.

                                                                 When [BAR2_EBIT] is zero, a PCIe BAR2 address does not contain an ESX\<1:0\> field,
                                                                 and [BAR2_ESX] is the endian-swap used for all BAR2 requests.

                                                                 When [BAR2_EBIT] is non-zero, it places ESX\<1:0\> (ESX\<0\> is at PCIe BAR2 address bit
                                                                 [BAR2_EBIT], and ESX\<1\> is at PCIe BAR2 address bit [BAR2_EBIT]+1). [BAR2_EBIT] must
                                                                 be in the range 16 .. [BAR2_SIZ]+18 and must not conflict with a non-zero
                                                                 [BAR2_CBIT] in this case. [BAR2_ESX] XOR ESX\<1:0\> is the endian-swap
                                                                 used for BAR2 requests in this case. If [BAR2_EBIT] \<= 48 in this case, then
                                                                 one or two PCIe BAR2 address ESX field bit(s) are in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_bar_ctl_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t bar1_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR1 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved. */
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t reserved_1_2          : 2;
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address \<49\> to determine the L2 cache attribute. Not cached in
                                                                 L2 if XOR result is 1. */
#else /* Word 0 - Little Endian */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address \<49\> to determine the L2 cache attribute. Not cached in
                                                                 L2 if XOR result is 1. */
        uint64_t reserved_1_2          : 2;
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t bar1_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR1 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_bar_ctl_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t bar2_ebit             : 6;  /**< [ 24: 19](R/W) Address bits for ESX\<1:0\> in a PCIe BAR2 address.

                                                                 When [BAR2_EBIT] is zero, a PCIe BAR2 address does not contain an ESX\<1:0\> field,
                                                                 and [BAR2_ESX] is the endian-swap used for all BAR2 requests.

                                                                 When [BAR2_EBIT] is non-zero, it places ESX\<1:0\> (ESX\<0\> is at PCIe BAR2 address bit
                                                                 [BAR2_EBIT], and ESX\<1\> is at PCIe BAR2 address bit [BAR2_EBIT]+1). [BAR2_EBIT] must
                                                                 be in the range 16 .. [BAR2_SIZ]+18 and must not conflict with a non-zero
                                                                 [BAR2_CBIT] in this case. [BAR2_ESX] XOR ESX\<1:0\> is the endian-swap
                                                                 used for BAR2 requests in this case. If [BAR2_EBIT] \<= 48 in this case, then
                                                                 one or two PCIe BAR2 address ESX field bit(s) are in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit for CAX in a PCIe BAR2 address.

                                                                 When [BAR2_CBIT] is zero, a PCIe BAR2 address does not contain a CAX bit,
                                                                 and [BAR2_CAX] is the cache allocation for all BAR2 requests.

                                                                 When [BAR2_CBIT] is non-zero, the CAX bit is at bit [BAR2_CBIT] in the PCIe
                                                                 BAR2 address. [BAR2_CBIT] must be in the range 16 .. [BAR2_SIZ]+19 and must
                                                                 not conflict with a non-zero [BAR2_EBIT] in this case. [BAR2_CBIT] XOR CAX is
                                                                 the cache allocation for BAR2 requests. If [BAR2_CBIT] \<= 48 in this
                                                                 case, then the PCIe BAR2 address CAX bit is in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded identically to PCIEEP()_CFG190[RBARS]. Resets to 0x1D (512 TB).

                                                                 In EP mode, [BAR2_SIZ] must equal the corresponding PCIEEP()_CFG190[RBARS].

                                                                 In RC mode, [BAR2_SIZ] determines the PEM()_P2N_BAR2_START[ADDR] bits used/compared
                                                                 to an incoming PCIe address.

                                                                 On a BAR2 match, PEM zeroes the PCIe address bits outside [BAR2_SIZ], applies
                                                                 [BAR2_EBIT,BAR2_CBIT], and forwards the request to SLI and the SMMU. */
        uint64_t bar1_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR1 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved. */
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t bar2_esx              : 2;  /**< [  2:  1](R/W) Value is XORed with PCIe addresses as defined by [BAR2_EBIT] to determine the
                                                                 endian swap mode. */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address as defined by [BAR2_CBIT] to determine the L2
                                                                 cache attribute. Not cached in L2 if XOR result is 1. */
#else /* Word 0 - Little Endian */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address as defined by [BAR2_CBIT] to determine the L2
                                                                 cache attribute. Not cached in L2 if XOR result is 1. */
        uint64_t bar2_esx              : 2;  /**< [  2:  1](R/W) Value is XORed with PCIe addresses as defined by [BAR2_EBIT] to determine the
                                                                 endian swap mode. */
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) When set to 1, BAR2 is enabled and will respond; when clear, BAR2 access will cause UR responses. */
        uint64_t bar1_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR1 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved. */
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded identically to PCIEEP()_CFG190[RBARS]. Resets to 0x1D (512 TB).

                                                                 In EP mode, [BAR2_SIZ] must equal the corresponding PCIEEP()_CFG190[RBARS].

                                                                 In RC mode, [BAR2_SIZ] determines the PEM()_P2N_BAR2_START[ADDR] bits used/compared
                                                                 to an incoming PCIe address.

                                                                 On a BAR2 match, PEM zeroes the PCIe address bits outside [BAR2_SIZ], applies
                                                                 [BAR2_EBIT,BAR2_CBIT], and forwards the request to SLI and the SMMU. */
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit for CAX in a PCIe BAR2 address.

                                                                 When [BAR2_CBIT] is zero, a PCIe BAR2 address does not contain a CAX bit,
                                                                 and [BAR2_CAX] is the cache allocation for all BAR2 requests.

                                                                 When [BAR2_CBIT] is non-zero, the CAX bit is at bit [BAR2_CBIT] in the PCIe
                                                                 BAR2 address. [BAR2_CBIT] must be in the range 16 .. [BAR2_SIZ]+19 and must
                                                                 not conflict with a non-zero [BAR2_EBIT] in this case. [BAR2_CBIT] XOR CAX is
                                                                 the cache allocation for BAR2 requests. If [BAR2_CBIT] \<= 48 in this
                                                                 case, then the PCIe BAR2 address CAX bit is in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t bar2_ebit             : 6;  /**< [ 24: 19](R/W) Address bits for ESX\<1:0\> in a PCIe BAR2 address.

                                                                 When [BAR2_EBIT] is zero, a PCIe BAR2 address does not contain an ESX\<1:0\> field,
                                                                 and [BAR2_ESX] is the endian-swap used for all BAR2 requests.

                                                                 When [BAR2_EBIT] is non-zero, it places ESX\<1:0\> (ESX\<0\> is at PCIe BAR2 address bit
                                                                 [BAR2_EBIT], and ESX\<1\> is at PCIe BAR2 address bit [BAR2_EBIT]+1). [BAR2_EBIT] must
                                                                 be in the range 16 .. [BAR2_SIZ]+18 and must not conflict with a non-zero
                                                                 [BAR2_CBIT] in this case. [BAR2_ESX] XOR ESX\<1:0\> is the endian-swap
                                                                 used for BAR2 requests in this case. If [BAR2_EBIT] \<= 48 in this case, then
                                                                 one or two PCIe BAR2 address ESX field bit(s) are in the address forwarded to
                                                                 SLI and the SMMU, in the same position. */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_bar_ctl_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_38_63        : 26;
        uint64_t vf_bar4_enb           : 1;  /**< [ 37: 37](R/W) This bit controls whether BAR4 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR4 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR4 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR4U, PCIEEP_SRIOV_BAR4L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR4 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR4U / PCIEEP_SRIOV_BAR4L. */
        uint64_t vf_bar2_enb           : 1;  /**< [ 36: 36](R/W) This bit controls whether BAR2 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR2 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR2 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR2U, PCIEEP_SRIOV_BAR2L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR2 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR2U / PCIEEP_SRIOV_BAR2L. */
        uint64_t vf_bar0_enb           : 1;  /**< [ 35: 35](R/W) This bit controls whether BAR0 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR0 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR0U, PCIEEP_SRIOV_BAR0L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR0 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR0U / PCIEEP_SRIOV_BAR0L. */
        uint64_t reserved_32_34        : 3;
        uint64_t bar4_enb              : 1;  /**< [ 31: 31](R/W) In RC mode:
                                                                  0 = BAR4 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR4_SEL].
                                                                  1 = BAR4 is enabled and will respond if the corresponding
                                                                  bits in PEM()_BAR4_INDEX() are set and the address matches
                                                                  an enabled indexed address range.

                                                                 In EP mode:

                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is set, BAR4 hits are based on
                                                                  a combination of this bit and config registers PCIEEP_BAR4U / PCIEEP_BAR4L.
                                                                  Both enable bits must be set to enable a BAR4 hit.
                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is clear, BAR4 hits are based
                                                                  on a combination of this bit, the config registers PCIEEP_BAR4U /
                                                                  PCIEEP_BAR4L, and the PEM()_BAR4_INDEX() registers.
                                                                  Both enable bits must be set along with the appropriate bits in
                                                                  PEM()_BAR4_INDEX() in order for a BAR4 access to respond. */
        uint64_t bar0_siz              : 5;  /**< [ 30: 26](R/W) PCIe BAR0 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 KB; 2^16.
                                                                 0x2 = 128 KB; 2^17.
                                                                 0x3 = 256 KB; 2^18.
                                                                 0x4 = 512 KB; 2^19.
                                                                 0x5 = 1 MB; 2^20.
                                                                 0x6 = 2 MB; 2^21.
                                                                 0x7 = 4 MB; 2^22.
                                                                 0x8 = 8 MB; 2^23.
                                                                 0x9 = 16 MB; 2^24.
                                                                 0xA = 32 MB; 2^25.
                                                                 0xB = 64 MB; 2^26.
                                                                 0xC - 0x1F = Reserved.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t bar0_enb              : 1;  /**< [ 25: 25](R/W) In RC mode:
                                                                  0 = BAR0 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR0_SEL].
                                                                  1 = BAR0 is enabled and will respond.

                                                                 In EP mode:

                                                                  * BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_BAR0U / PCIEEP_BAR0L. Both enable
                                                                  bits must be set to enable a BAR0 hit. */
        uint64_t reserved_19_24        : 6;
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit to be mapped to BAR2's CAX. When 0x0, BAR2's CAX is disabled;
                                                                 otherwise must be 16 to 63 inclusive. Not used if PEM()_EBUS_CTL[PF_BAR2_SEL]
                                                                 is set.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded similar to PCIEEP_RBAR_CTL[RBARS]. Used in RC mode to create
                                                                 a mask that is ANDED with the address prior to applying
                                                                 [BAR2_CAX]. Defaults to 0x21 (8192 TB). */
        uint64_t bar4_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR4 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) In RC mode:
                                                                  0 = BAR2 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR2_SEL].
                                                                  1 = BAR2 is enabled and will respond.

                                                                 In EP mode:

                                                                  * BAR2 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_BAR2U / PCIEEP_BAR2L. Both enable
                                                                  bits must be set to enable a BAR2 hit. */
        uint64_t reserved_1_2          : 2;
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address as defined by [BAR2_CBIT] to determine the LLC
                                                                 cache attribute. Not cached in LLC if XOR result is 1. Not used if PEM()_EBUS_CTL[PF_BAR2_SEL]
                                                                 is set.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
#else /* Word 0 - Little Endian */
        uint64_t bar2_cax              : 1;  /**< [  0:  0](R/W) Value is XORed with PCIe address as defined by [BAR2_CBIT] to determine the LLC
                                                                 cache attribute. Not cached in LLC if XOR result is 1. Not used if PEM()_EBUS_CTL[PF_BAR2_SEL]
                                                                 is set.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t reserved_1_2          : 2;
        uint64_t bar2_enb              : 1;  /**< [  3:  3](R/W) In RC mode:
                                                                  0 = BAR2 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR2_SEL].
                                                                  1 = BAR2 is enabled and will respond.

                                                                 In EP mode:

                                                                  * BAR2 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_BAR2U / PCIEEP_BAR2L. Both enable
                                                                  bits must be set to enable a BAR2 hit. */
        uint64_t bar4_siz              : 3;  /**< [  6:  4](R/W) PCIe Port 0 BAR4 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 MB; 2^26.
                                                                 0x2 = 128 MB; 2^27.
                                                                 0x3 = 256 MB; 2^28.
                                                                 0x4 = 512 MB; 2^29.
                                                                 0x5 = 1024 MB; 2^30.
                                                                 0x6 = 2048 MB; 2^31.
                                                                 0x7 = Reserved.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t bar2_siz              : 6;  /**< [ 12:  7](R/W) BAR2 size. Encoded similar to PCIEEP_RBAR_CTL[RBARS]. Used in RC mode to create
                                                                 a mask that is ANDED with the address prior to applying
                                                                 [BAR2_CAX]. Defaults to 0x21 (8192 TB). */
        uint64_t bar2_cbit             : 6;  /**< [ 18: 13](R/W) Address bit to be mapped to BAR2's CAX. When 0x0, BAR2's CAX is disabled;
                                                                 otherwise must be 16 to 63 inclusive. Not used if PEM()_EBUS_CTL[PF_BAR2_SEL]
                                                                 is set.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t reserved_19_24        : 6;
        uint64_t bar0_enb              : 1;  /**< [ 25: 25](R/W) In RC mode:
                                                                  0 = BAR0 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR0_SEL].
                                                                  1 = BAR0 is enabled and will respond.

                                                                 In EP mode:

                                                                  * BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_BAR0U / PCIEEP_BAR0L. Both enable
                                                                  bits must be set to enable a BAR0 hit. */
        uint64_t bar0_siz              : 5;  /**< [ 30: 26](R/W) PCIe BAR0 size.
                                                                 0x0 = Reserved.
                                                                 0x1 = 64 KB; 2^16.
                                                                 0x2 = 128 KB; 2^17.
                                                                 0x3 = 256 KB; 2^18.
                                                                 0x4 = 512 KB; 2^19.
                                                                 0x5 = 1 MB; 2^20.
                                                                 0x6 = 2 MB; 2^21.
                                                                 0x7 = 4 MB; 2^22.
                                                                 0x8 = 8 MB; 2^23.
                                                                 0x9 = 16 MB; 2^24.
                                                                 0xA = 32 MB; 2^25.
                                                                 0xB = 64 MB; 2^26.
                                                                 0xC - 0x1F = Reserved.

                                                                 This field may not be changed while any of [BAR0_ENB], [BAR2_ENB], [BAR4_ENB],
                                                                 [VF_BAR0_ENB], [VF_BAR2_ENB], or [VF_BAR4_ENB] are set. Wait 1 ms after writing
                                                                 this field to set any of the [*_ENB] bits. */
        uint64_t bar4_enb              : 1;  /**< [ 31: 31](R/W) In RC mode:
                                                                  0 = BAR4 access will cause UR responses. This applies no
                                                                  matter the value of PEM()_EBUS_CTL[PF_BAR4_SEL].
                                                                  1 = BAR4 is enabled and will respond if the corresponding
                                                                  bits in PEM()_BAR4_INDEX() are set and the address matches
                                                                  an enabled indexed address range.

                                                                 In EP mode:

                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is set, BAR4 hits are based on
                                                                  a combination of this bit and config registers PCIEEP_BAR4U / PCIEEP_BAR4L.
                                                                  Both enable bits must be set to enable a BAR4 hit.
                                                                  * If PEM()_EBUS_CTL[PF_BAR4_SEL] is clear, BAR4 hits are based
                                                                  on a combination of this bit, the config registers PCIEEP_BAR4U /
                                                                  PCIEEP_BAR4L, and the PEM()_BAR4_INDEX() registers.
                                                                  Both enable bits must be set along with the appropriate bits in
                                                                  PEM()_BAR4_INDEX() in order for a BAR4 access to respond. */
        uint64_t reserved_32_34        : 3;
        uint64_t vf_bar0_enb           : 1;  /**< [ 35: 35](R/W) This bit controls whether BAR0 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR0 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR0 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR0U, PCIEEP_SRIOV_BAR0L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR0 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR0U / PCIEEP_SRIOV_BAR0L. */
        uint64_t vf_bar2_enb           : 1;  /**< [ 36: 36](R/W) This bit controls whether BAR2 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR2 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR2 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR2U, PCIEEP_SRIOV_BAR2L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR2 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR2U / PCIEEP_SRIOV_BAR2L. */
        uint64_t vf_bar4_enb           : 1;  /**< [ 37: 37](R/W) This bit controls whether BAR4 for all virtual functions is enabled.

                                                                 In RC mode:
                                                                 * VF BAR4 does not exist. This bit has no effect.

                                                                 In EP mode:

                                                                  * VF BAR4 hits are based on a combination of this bit and
                                                                  config registers PCIEEP_SRIOV_BAR4U, PCIEEP_SRIOV_BAR4L, and
                                                                  PCIEEP_SRIOV_CTL[VFE].  Both PCIEEP_SRIOV_CTL[VFE] and this
                                                                  bit must be set to enable a VF BAR4 hit to the PCI address
                                                                  specified by PCIEEP_SRIOV_BAR4U / PCIEEP_SRIOV_BAR4L. */
        uint64_t reserved_38_63        : 26;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_bar_ctl bdk_pemx_bar_ctl_t;

static inline uint64_t BDK_PEMX_BAR_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BAR_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c00000a8ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c00000a8ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000168ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000168ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000168ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000168ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BAR_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BAR_CTL(a) bdk_pemx_bar_ctl_t
#define bustype_BDK_PEMX_BAR_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BAR_CTL(a) "PEMX_BAR_CTL"
#define device_bar_BDK_PEMX_BAR_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BAR_CTL(a) (a)
#define arguments_BDK_PEMX_BAR_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_bist_status
 *
 * PEM BIST Status Register
 * This register contains results from BIST runs of PEM's memories.
 */
union bdk_pemx_bist_status
{
    uint64_t u;
    struct bdk_pemx_bist_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t tlpn_d0               : 1;  /**< [  9:  9](RO) BIST status for tlp_n_fifo_data0. */
        uint64_t tlpn_d1               : 1;  /**< [  8:  8](RO) BIST status for tlp_n_fifo_data1. */
        uint64_t tlpn_ctl              : 1;  /**< [  7:  7](RO) BIST status for tlp_n_fifo_ctl. */
        uint64_t tlpp_d0               : 1;  /**< [  6:  6](RO) BIST status for tlp_p_fifo_data0. */
        uint64_t tlpp_d1               : 1;  /**< [  5:  5](RO) BIST status for tlp_p_fifo_data1. */
        uint64_t tlpp_ctl              : 1;  /**< [  4:  4](RO) BIST status for tlp_p_fifo_ctl. */
        uint64_t tlpc_d0               : 1;  /**< [  3:  3](RO) BIST status for tlp_c_fifo_data0. */
        uint64_t tlpc_d1               : 1;  /**< [  2:  2](RO) BIST status for tlp_c_fifo_data1. */
        uint64_t tlpc_ctl              : 1;  /**< [  1:  1](RO) BIST status for tlp_c_fifo_ctl. */
        uint64_t m2s                   : 1;  /**< [  0:  0](RO) BIST status for m2s_fifo. */
#else /* Word 0 - Little Endian */
        uint64_t m2s                   : 1;  /**< [  0:  0](RO) BIST status for m2s_fifo. */
        uint64_t tlpc_ctl              : 1;  /**< [  1:  1](RO) BIST status for tlp_c_fifo_ctl. */
        uint64_t tlpc_d1               : 1;  /**< [  2:  2](RO) BIST status for tlp_c_fifo_data1. */
        uint64_t tlpc_d0               : 1;  /**< [  3:  3](RO) BIST status for tlp_c_fifo_data0. */
        uint64_t tlpp_ctl              : 1;  /**< [  4:  4](RO) BIST status for tlp_p_fifo_ctl. */
        uint64_t tlpp_d1               : 1;  /**< [  5:  5](RO) BIST status for tlp_p_fifo_data1. */
        uint64_t tlpp_d0               : 1;  /**< [  6:  6](RO) BIST status for tlp_p_fifo_data0. */
        uint64_t tlpn_ctl              : 1;  /**< [  7:  7](RO) BIST status for tlp_n_fifo_ctl. */
        uint64_t tlpn_d1               : 1;  /**< [  8:  8](RO) BIST status for tlp_n_fifo_data1. */
        uint64_t tlpn_d0               : 1;  /**< [  9:  9](RO) BIST status for tlp_n_fifo_data0. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bist_status_s cn8; */
    struct bdk_pemx_bist_status_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_26_63        : 38;
        uint64_t retryc                : 1;  /**< [ 25: 25](RO) Retry buffer memory C. */
        uint64_t sot                   : 1;  /**< [ 24: 24](RO) Start of transfer memory. */
        uint64_t rqhdrb0               : 1;  /**< [ 23: 23](RO) RX queue header memory buffer 0. */
        uint64_t rqhdrb1               : 1;  /**< [ 22: 22](RO) RX queue header memory buffer 1. */
        uint64_t rqdatab0              : 1;  /**< [ 21: 21](RO) RX queue data buffer 0. */
        uint64_t rqdatab1              : 1;  /**< [ 20: 20](RO) RX queue data buffer 1. */
        uint64_t tlpan_d0              : 1;  /**< [ 19: 19](RO) Reserved. */
        uint64_t tlpan_d1              : 1;  /**< [ 18: 18](RO) Reserved. */
        uint64_t tlpan_ctl             : 1;  /**< [ 17: 17](RO) Reserved. */
        uint64_t tlpap_d0              : 1;  /**< [ 16: 16](RO) Reserved. */
        uint64_t tlpap_d1              : 1;  /**< [ 15: 15](RO) Reserved. */
        uint64_t tlpap_ctl             : 1;  /**< [ 14: 14](RO) Reserved. */
        uint64_t tlpac_d0              : 1;  /**< [ 13: 13](RO) Reserved. */
        uint64_t tlpac_d1              : 1;  /**< [ 12: 12](RO) Reserved. */
        uint64_t tlpac_ctl             : 1;  /**< [ 11: 11](RO) Reserved. */
        uint64_t peai_p2e              : 1;  /**< [ 10: 10](RO) Reserved. */
        uint64_t tlpn_d0               : 1;  /**< [  9:  9](RO) BIST status for tlp_n_fifo_data0. */
        uint64_t tlpn_d1               : 1;  /**< [  8:  8](RO) BIST status for tlp_n_fifo_data1. */
        uint64_t tlpn_ctl              : 1;  /**< [  7:  7](RO) BIST status for tlp_n_fifo_ctl. */
        uint64_t tlpp_d0               : 1;  /**< [  6:  6](RO) BIST status for tlp_p_fifo_data0. */
        uint64_t tlpp_d1               : 1;  /**< [  5:  5](RO) BIST status for tlp_p_fifo_data1. */
        uint64_t tlpp_ctl              : 1;  /**< [  4:  4](RO) BIST status for tlp_p_fifo_ctl. */
        uint64_t tlpc_d0               : 1;  /**< [  3:  3](RO) BIST status for tlp_c_fifo_data0. */
        uint64_t tlpc_d1               : 1;  /**< [  2:  2](RO) BIST status for tlp_c_fifo_data1. */
        uint64_t tlpc_ctl              : 1;  /**< [  1:  1](RO) BIST status for tlp_c_fifo_ctl. */
        uint64_t m2s                   : 1;  /**< [  0:  0](RO) BIST status for m2s_fifo. */
#else /* Word 0 - Little Endian */
        uint64_t m2s                   : 1;  /**< [  0:  0](RO) BIST status for m2s_fifo. */
        uint64_t tlpc_ctl              : 1;  /**< [  1:  1](RO) BIST status for tlp_c_fifo_ctl. */
        uint64_t tlpc_d1               : 1;  /**< [  2:  2](RO) BIST status for tlp_c_fifo_data1. */
        uint64_t tlpc_d0               : 1;  /**< [  3:  3](RO) BIST status for tlp_c_fifo_data0. */
        uint64_t tlpp_ctl              : 1;  /**< [  4:  4](RO) BIST status for tlp_p_fifo_ctl. */
        uint64_t tlpp_d1               : 1;  /**< [  5:  5](RO) BIST status for tlp_p_fifo_data1. */
        uint64_t tlpp_d0               : 1;  /**< [  6:  6](RO) BIST status for tlp_p_fifo_data0. */
        uint64_t tlpn_ctl              : 1;  /**< [  7:  7](RO) BIST status for tlp_n_fifo_ctl. */
        uint64_t tlpn_d1               : 1;  /**< [  8:  8](RO) BIST status for tlp_n_fifo_data1. */
        uint64_t tlpn_d0               : 1;  /**< [  9:  9](RO) BIST status for tlp_n_fifo_data0. */
        uint64_t peai_p2e              : 1;  /**< [ 10: 10](RO) Reserved. */
        uint64_t tlpac_ctl             : 1;  /**< [ 11: 11](RO) Reserved. */
        uint64_t tlpac_d1              : 1;  /**< [ 12: 12](RO) Reserved. */
        uint64_t tlpac_d0              : 1;  /**< [ 13: 13](RO) Reserved. */
        uint64_t tlpap_ctl             : 1;  /**< [ 14: 14](RO) Reserved. */
        uint64_t tlpap_d1              : 1;  /**< [ 15: 15](RO) Reserved. */
        uint64_t tlpap_d0              : 1;  /**< [ 16: 16](RO) Reserved. */
        uint64_t tlpan_ctl             : 1;  /**< [ 17: 17](RO) Reserved. */
        uint64_t tlpan_d1              : 1;  /**< [ 18: 18](RO) Reserved. */
        uint64_t tlpan_d0              : 1;  /**< [ 19: 19](RO) Reserved. */
        uint64_t rqdatab1              : 1;  /**< [ 20: 20](RO) RX queue data buffer 1. */
        uint64_t rqdatab0              : 1;  /**< [ 21: 21](RO) RX queue data buffer 0. */
        uint64_t rqhdrb1               : 1;  /**< [ 22: 22](RO) RX queue header memory buffer 1. */
        uint64_t rqhdrb0               : 1;  /**< [ 23: 23](RO) RX queue header memory buffer 0. */
        uint64_t sot                   : 1;  /**< [ 24: 24](RO) Start of transfer memory. */
        uint64_t retryc                : 1;  /**< [ 25: 25](RO) Retry buffer memory C. */
        uint64_t reserved_26_63        : 38;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_bist_status_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t retryc                : 1;  /**< [ 15: 15](RO) Retry buffer memory C. */
        uint64_t sot                   : 1;  /**< [ 14: 14](RO) Start of transfer memory. */
        uint64_t rqhdrb0               : 1;  /**< [ 13: 13](RO) RX queue header memory buffer 0. */
        uint64_t rqhdrb1               : 1;  /**< [ 12: 12](RO) RX queue header memory buffer 1. */
        uint64_t rqdatab0              : 1;  /**< [ 11: 11](RO) RX queue data buffer 0. */
        uint64_t rqdatab1              : 1;  /**< [ 10: 10](RO) RX queue data buffer 1. */
        uint64_t tlpn_d0               : 1;  /**< [  9:  9](RO) BIST status for tlp_n_fifo_data0. */
        uint64_t tlpn_d1               : 1;  /**< [  8:  8](RO) BIST status for tlp_n_fifo_data1. */
        uint64_t tlpn_ctl              : 1;  /**< [  7:  7](RO) BIST status for tlp_n_fifo_ctl. */
        uint64_t tlpp_d0               : 1;  /**< [  6:  6](RO) BIST status for tlp_p_fifo_data0. */
        uint64_t tlpp_d1               : 1;  /**< [  5:  5](RO) BIST status for tlp_p_fifo_data1. */
        uint64_t tlpp_ctl              : 1;  /**< [  4:  4](RO) BIST status for tlp_p_fifo_ctl. */
        uint64_t tlpc_d0               : 1;  /**< [  3:  3](RO) BIST status for tlp_c_fifo_data0. */
        uint64_t tlpc_d1               : 1;  /**< [  2:  2](RO) BIST status for tlp_c_fifo_data1. */
        uint64_t tlpc_ctl              : 1;  /**< [  1:  1](RO) BIST status for tlp_c_fifo_ctl. */
        uint64_t m2s                   : 1;  /**< [  0:  0](RO) BIST status for m2s_fifo. */
#else /* Word 0 - Little Endian */
        uint64_t m2s                   : 1;  /**< [  0:  0](RO) BIST status for m2s_fifo. */
        uint64_t tlpc_ctl              : 1;  /**< [  1:  1](RO) BIST status for tlp_c_fifo_ctl. */
        uint64_t tlpc_d1               : 1;  /**< [  2:  2](RO) BIST status for tlp_c_fifo_data1. */
        uint64_t tlpc_d0               : 1;  /**< [  3:  3](RO) BIST status for tlp_c_fifo_data0. */
        uint64_t tlpp_ctl              : 1;  /**< [  4:  4](RO) BIST status for tlp_p_fifo_ctl. */
        uint64_t tlpp_d1               : 1;  /**< [  5:  5](RO) BIST status for tlp_p_fifo_data1. */
        uint64_t tlpp_d0               : 1;  /**< [  6:  6](RO) BIST status for tlp_p_fifo_data0. */
        uint64_t tlpn_ctl              : 1;  /**< [  7:  7](RO) BIST status for tlp_n_fifo_ctl. */
        uint64_t tlpn_d1               : 1;  /**< [  8:  8](RO) BIST status for tlp_n_fifo_data1. */
        uint64_t tlpn_d0               : 1;  /**< [  9:  9](RO) BIST status for tlp_n_fifo_data0. */
        uint64_t rqdatab1              : 1;  /**< [ 10: 10](RO) RX queue data buffer 1. */
        uint64_t rqdatab0              : 1;  /**< [ 11: 11](RO) RX queue data buffer 0. */
        uint64_t rqhdrb1               : 1;  /**< [ 12: 12](RO) RX queue header memory buffer 1. */
        uint64_t rqhdrb0               : 1;  /**< [ 13: 13](RO) RX queue header memory buffer 0. */
        uint64_t sot                   : 1;  /**< [ 14: 14](RO) Start of transfer memory. */
        uint64_t retryc                : 1;  /**< [ 15: 15](RO) Retry buffer memory C. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn83xx;
};
typedef union bdk_pemx_bist_status bdk_pemx_bist_status_t;

static inline uint64_t BDK_PEMX_BIST_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BIST_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000468ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000468ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_BIST_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BIST_STATUS(a) bdk_pemx_bist_status_t
#define bustype_BDK_PEMX_BIST_STATUS(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_BIST_STATUS(a) "PEMX_BIST_STATUS"
#define device_bar_BDK_PEMX_BIST_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BIST_STATUS(a) (a)
#define arguments_BDK_PEMX_BIST_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bp_test0
 *
 * INTERNAL: PEM Backpressure Test Register 0
 *
 * This register is for diagnostic use only.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bp_test0
{
    uint64_t u;
    struct bdk_pemx_bp_test0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Limit the NCBI posted FIFO, backpressure doing posted requests to ncb_gnt.
                                                                 \<62\> = Limit the NCBI nonposted FIFO, backpressure doing nonposted requests to ncb_gnt.
                                                                 \<61\> = Limit the NCBI completion FIFO, backpressure doing completion requests to ncb_gnt.
                                                                 \<60\> = Limit the NCBI CSR completion FIFO, backpressure doing requests for CSR responses
                                                                 to ncb_gnt.

                                                                 During debug that makes use of PEM()_BP_TEST0, do not combine with MAC reset only events. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Limit the NCBI posted FIFO, backpressure doing posted requests to ncb_gnt.
                                                                 \<62\> = Limit the NCBI nonposted FIFO, backpressure doing nonposted requests to ncb_gnt.
                                                                 \<61\> = Limit the NCBI completion FIFO, backpressure doing completion requests to ncb_gnt.
                                                                 \<60\> = Limit the NCBI CSR completion FIFO, backpressure doing requests for CSR responses
                                                                 to ncb_gnt.

                                                                 During debug that makes use of PEM()_BP_TEST0, do not combine with MAC reset only events. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bp_test0_s cn; */
};
typedef union bdk_pemx_bp_test0 bdk_pemx_bp_test0_t;

static inline uint64_t BDK_PEMX_BP_TEST0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BP_TEST0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001e0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001e0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001e0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001e0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BP_TEST0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BP_TEST0(a) bdk_pemx_bp_test0_t
#define bustype_BDK_PEMX_BP_TEST0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BP_TEST0(a) "PEMX_BP_TEST0"
#define device_bar_BDK_PEMX_BP_TEST0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BP_TEST0(a) (a)
#define arguments_BDK_PEMX_BP_TEST0(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bp_test1
 *
 * INTERNAL: PEM Backpressure Test Register 1
 *
 * This register is for diagnostic use only.
 *
 * NOTE: Setting the incoming TLP FIFO backpressure to 100% by use of this
 * register could result the register state machine hanging; subsequently this register
 * will no longer be accessible in order to clear the backpressure and release the hang.
 * This will happen if any config access is attempted after writing the backpressure to 100%.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bp_test1
{
    uint64_t u;
    struct bdk_pemx_bp_test1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Reserved.
                                                                 \<61\> = Reserved.
                                                                 \<60\> = Limit the MAC core incoming TLP FIFO; backpressure taking data from this FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST1, do not combine with MAC reset only events. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Reserved.
                                                                 \<61\> = Reserved.
                                                                 \<60\> = Limit the MAC core incoming TLP FIFO; backpressure taking data from this FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST1, do not combine with MAC reset only events. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bp_test1_s cn; */
};
typedef union bdk_pemx_bp_test1 bdk_pemx_bp_test1_t;

static inline uint64_t BDK_PEMX_BP_TEST1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BP_TEST1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001e8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001e8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001e8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001e8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BP_TEST1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BP_TEST1(a) bdk_pemx_bp_test1_t
#define bustype_BDK_PEMX_BP_TEST1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BP_TEST1(a) "PEMX_BP_TEST1"
#define device_bar_BDK_PEMX_BP_TEST1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BP_TEST1(a) (a)
#define arguments_BDK_PEMX_BP_TEST1(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bp_test2
 *
 * INTERNAL: PEM Backpressure Test Register 2
 *
 * This register is for diagnostic use only.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bp_test2
{
    uint64_t u;
    struct bdk_pemx_bp_test2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 NOTE: Test backpressure will only be applied at an NCBO transaction boundary.
                                                                 \<63\> = Limit the draining of NCBO CSR offloading FIFO.
                                                                 \<62\> = Reserved
                                                                 \<61\> = Limit the draining of NCBO Non-posted offloading FIFO.
                                                                 \<60\> = Limit the draining of NCBO Posted offloading FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST2, do not combine with MAC reset only events. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 NOTE: Test backpressure will only be applied at an NCBO transaction boundary.
                                                                 \<63\> = Limit the draining of NCBO CSR offloading FIFO.
                                                                 \<62\> = Reserved
                                                                 \<61\> = Limit the draining of NCBO Non-posted offloading FIFO.
                                                                 \<60\> = Limit the draining of NCBO Posted offloading FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST2, do not combine with MAC reset only events. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bp_test2_s cn; */
};
typedef union bdk_pemx_bp_test2 bdk_pemx_bp_test2_t;

static inline uint64_t BDK_PEMX_BP_TEST2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BP_TEST2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001f0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001f0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001f0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001f0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BP_TEST2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BP_TEST2(a) bdk_pemx_bp_test2_t
#define bustype_BDK_PEMX_BP_TEST2(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BP_TEST2(a) "PEMX_BP_TEST2"
#define device_bar_BDK_PEMX_BP_TEST2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BP_TEST2(a) (a)
#define arguments_BDK_PEMX_BP_TEST2(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bp_test3
 *
 * INTERNAL: PEM Backpressure Test Register 3
 *
 * This register is for diagnostic use only.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bp_test3
{
    uint64_t u;
    struct bdk_pemx_bp_test3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 NOTE: Test backpressure will only be applied at a TLP boundary.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Limit the transfers of Completion TLPs from pemm to pemc.
                                                                 \<61\> = Limit the transfers of Non-posted TLPs from pemm to pemc.
                                                                 \<60\> = Limit the transfers of Posted TLPs from pemm to pemc.

                                                                 During debug that makes use of PEM()_BP_TEST3, do not combine with MAC reset only events. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 NOTE: Test backpressure will only be applied at a TLP boundary.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Limit the transfers of Completion TLPs from pemm to pemc.
                                                                 \<61\> = Limit the transfers of Non-posted TLPs from pemm to pemc.
                                                                 \<60\> = Limit the transfers of Posted TLPs from pemm to pemc.

                                                                 During debug that makes use of PEM()_BP_TEST3, do not combine with MAC reset only events. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bp_test3_s cn; */
};
typedef union bdk_pemx_bp_test3 bdk_pemx_bp_test3_t;

static inline uint64_t BDK_PEMX_BP_TEST3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BP_TEST3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001f8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001f8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001f8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001f8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BP_TEST3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BP_TEST3(a) bdk_pemx_bp_test3_t
#define bustype_BDK_PEMX_BP_TEST3(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BP_TEST3(a) "PEMX_BP_TEST3"
#define device_bar_BDK_PEMX_BP_TEST3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BP_TEST3(a) (a)
#define arguments_BDK_PEMX_BP_TEST3(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bp_test4
 *
 * INTERNAL: PEM Backpressure Test Register 4
 *
 * This register is for diagnostic use only.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bp_test4
{
    uint64_t u;
    struct bdk_pemx_bp_test4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Limit the EBI posted FIFO.
                                                                 \<62\> = Limit the EBI nonposted FIFO.
                                                                 \<61\> = Limit the EBI completion FIFO.
                                                                 \<60\> = Limit the EBI completion fault FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST4, do not combine with MAC reset only events. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Limit the EBI posted FIFO.
                                                                 \<62\> = Limit the EBI nonposted FIFO.
                                                                 \<61\> = Limit the EBI completion FIFO.
                                                                 \<60\> = Limit the EBI completion fault FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST4, do not combine with MAC reset only events. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bp_test4_s cn; */
};
typedef union bdk_pemx_bp_test4 bdk_pemx_bp_test4_t;

static inline uint64_t BDK_PEMX_BP_TEST4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BP_TEST4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000200ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000200ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000200ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000200ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BP_TEST4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BP_TEST4(a) bdk_pemx_bp_test4_t
#define bustype_BDK_PEMX_BP_TEST4(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BP_TEST4(a) "PEMX_BP_TEST4"
#define device_bar_BDK_PEMX_BP_TEST4(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BP_TEST4(a) (a)
#define arguments_BDK_PEMX_BP_TEST4(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bp_test5
 *
 * INTERNAL: PEM Backpressure Test Register 5
 *
 * This register is for diagnostic use only.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bp_test5
{
    uint64_t u;
    struct bdk_pemx_bp_test5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 Note backpressure will only be applied at an EBO transaction boundary.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Limit the draining of EBO Completion offloading buffer.
                                                                 \<61\> = Limit the draining of EBO Non-posted offloading FIFO.
                                                                 \<60\> = Limit the draining of EBO Posted offloading FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST5, do not combine with MAC reset only events. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 Note backpressure will only be applied at an EBO transaction boundary.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Limit the draining of EBO Completion offloading buffer.
                                                                 \<61\> = Limit the draining of EBO Non-posted offloading FIFO.
                                                                 \<60\> = Limit the draining of EBO Posted offloading FIFO.

                                                                 During debug that makes use of PEM()_BP_TEST5, do not combine with MAC reset only events. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bp_test5_s cn; */
};
typedef union bdk_pemx_bp_test5 bdk_pemx_bp_test5_t;

static inline uint64_t BDK_PEMX_BP_TEST5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BP_TEST5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000208ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000208ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000208ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000208ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BP_TEST5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BP_TEST5(a) bdk_pemx_bp_test5_t
#define bustype_BDK_PEMX_BP_TEST5(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BP_TEST5(a) "PEMX_BP_TEST5"
#define device_bar_BDK_PEMX_BP_TEST5(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BP_TEST5(a) (a)
#define arguments_BDK_PEMX_BP_TEST5(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_bp_test6
 *
 * INTERNAL: PEM Backpressure Test Register 6
 *
 * This register is for diagnostic use only.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_bp_test6
{
    uint64_t u;
    struct bdk_pemx_bp_test6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Limit the PSPI nonposted FIFO.
                                                                 \<61\> = Reserved.
                                                                 \<60\> = Reserved.

                                                                 During debug that makes use of PEM()_BP_TEST6, do not combine with MAC reset only events. */
        uint64_t reserved_24_59        : 36;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
#else /* Word 0 - Little Endian */
        uint64_t lfsr_freq             : 12; /**< [ 11:  0](R/W) Test LFSR update frequency in coprocessor-clocks minus one. */
        uint64_t reserved_12_15        : 4;
        uint64_t bp_cfg                : 8;  /**< [ 23: 16](R/W) Backpressure weight. For diagnostic use only.
                                                                 Internal:
                                                                 There are 2 backpressure configuration bits per enable, with the two bits
                                                                 defined as 0x0=100% of the time, 0x1=75% of the time, 0x2=50% of the time,
                                                                 0x3=25% of the time.
                                                                   \<23:22\> = Config 3.
                                                                   \<21:20\> = Config 2.
                                                                   \<19:18\> = Config 1.
                                                                   \<17:16\> = Config 0. */
        uint64_t reserved_24_59        : 36;
        uint64_t enable                : 4;  /**< [ 63: 60](R/W) Enable test mode. For diagnostic use only.
                                                                 Internal:
                                                                 Once a bit is set, random backpressure is generated
                                                                 at the corresponding point to allow for more frequent backpressure.
                                                                 \<63\> = Reserved.
                                                                 \<62\> = Limit the PSPI nonposted FIFO.
                                                                 \<61\> = Reserved.
                                                                 \<60\> = Reserved.

                                                                 During debug that makes use of PEM()_BP_TEST6, do not combine with MAC reset only events. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_bp_test6_s cn; */
};
typedef union bdk_pemx_bp_test6 bdk_pemx_bp_test6_t;

static inline uint64_t BDK_PEMX_BP_TEST6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_BP_TEST6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000210ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000210ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000210ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000210ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_BP_TEST6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_BP_TEST6(a) bdk_pemx_bp_test6_t
#define bustype_BDK_PEMX_BP_TEST6(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_BP_TEST6(a) "PEMX_BP_TEST6"
#define device_bar_BDK_PEMX_BP_TEST6(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_BP_TEST6(a) (a)
#define arguments_BDK_PEMX_BP_TEST6(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_cfg
 *
 * PEM Application Configuration Register
 * This register configures the PCIe application.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_cfg
{
    uint64_t u;
    struct bdk_pemx_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t reserved_0_7          : 8;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_7          : 8;
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_cfg_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t lanes4                : 1;  /**< [  5:  5](R/W) Determines the number of lanes.
                                                                 When set, the PEM is configured for a maximum of 4 lanes. When clear, the PEM is
                                                                 configured for a maximum of 2 lanes. This value is used to set the maximum link width
                                                                 field in the core's link capabilities register (CFG031) to indicate the maximum number of
                                                                 lanes supported. Note that less lanes than the specified maximum can be configured for use
                                                                 via the core's link control register (CFG032) negotiated link width field. */
        uint64_t laneswap              : 1;  /**< [  4:  4](R/W) Determines lane swapping. When set, lane swapping is
                                                                 performed to/from the SerDes. When clear, no lane swapping is performed. */
        uint64_t lanes8                : 1;  /**< [  3:  3](R/W/H) Enables overwriting the value for the maximum number of lanes. The reset value
                                                                 is captured on cold reset by the pin straps (see PEM()_STRAP[PILANES8]). When set, the
                                                                 PEM is configured for a maximum of 8 lanes. When clear, the PEM is configured for a
                                                                 maximum of 4 or 2 lanes. This value is used to set the maximum link width field in the
                                                                 core's
                                                                 link capabilities register (CFG031) to indicate the maximum number of lanes
                                                                 supported. Note that less lanes than the specified maximum can be configured for use via
                                                                 the core's link control register (CFG032) negotiated link width field. */
        uint64_t hostmd                : 1;  /**< [  2:  2](R/W/H) Enables overwriting the value for host mode. The reset value is captured on
                                                                 cold reset by the pin straps. (See PEM()_STRAP[PIMODE]. The HOSTMD reset value is the
                                                                 bit-wise AND of the PIMODE straps.  When set, the PEM is configured to be a root complex.
                                                                 When clear, the PEM is configured to be an end point. */
        uint64_t md                    : 2;  /**< [  1:  0](R/W) Determines the speed.
                                                                   0x0 = Gen1 speed.
                                                                   0x1 = Gen2 speed.
                                                                   0x2 = Gen3 speed.
                                                                   0x3 = Gen3 speed. */
#else /* Word 0 - Little Endian */
        uint64_t md                    : 2;  /**< [  1:  0](R/W) Determines the speed.
                                                                   0x0 = Gen1 speed.
                                                                   0x1 = Gen2 speed.
                                                                   0x2 = Gen3 speed.
                                                                   0x3 = Gen3 speed. */
        uint64_t hostmd                : 1;  /**< [  2:  2](R/W/H) Enables overwriting the value for host mode. The reset value is captured on
                                                                 cold reset by the pin straps. (See PEM()_STRAP[PIMODE]. The HOSTMD reset value is the
                                                                 bit-wise AND of the PIMODE straps.  When set, the PEM is configured to be a root complex.
                                                                 When clear, the PEM is configured to be an end point. */
        uint64_t lanes8                : 1;  /**< [  3:  3](R/W/H) Enables overwriting the value for the maximum number of lanes. The reset value
                                                                 is captured on cold reset by the pin straps (see PEM()_STRAP[PILANES8]). When set, the
                                                                 PEM is configured for a maximum of 8 lanes. When clear, the PEM is configured for a
                                                                 maximum of 4 or 2 lanes. This value is used to set the maximum link width field in the
                                                                 core's
                                                                 link capabilities register (CFG031) to indicate the maximum number of lanes
                                                                 supported. Note that less lanes than the specified maximum can be configured for use via
                                                                 the core's link control register (CFG032) negotiated link width field. */
        uint64_t laneswap              : 1;  /**< [  4:  4](R/W) Determines lane swapping. When set, lane swapping is
                                                                 performed to/from the SerDes. When clear, no lane swapping is performed. */
        uint64_t lanes4                : 1;  /**< [  5:  5](R/W) Determines the number of lanes.
                                                                 When set, the PEM is configured for a maximum of 4 lanes. When clear, the PEM is
                                                                 configured for a maximum of 2 lanes. This value is used to set the maximum link width
                                                                 field in the core's link capabilities register (CFG031) to indicate the maximum number of
                                                                 lanes supported. Note that less lanes than the specified maximum can be configured for use
                                                                 via the core's link control register (CFG032) negotiated link width field. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_cfg_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t lanes4                : 1;  /**< [  5:  5](R/W) Determines the number of lanes.
                                                                 When set, the PEM is configured for a maximum of 4 lanes. When clear, the PEM is
                                                                 configured for a maximum of 2 lanes. This value is used to set the maximum link width
                                                                 field in the core's link capabilities register (CFG031) to indicate the maximum number of
                                                                 lanes supported. Note that less lanes than the specified maximum can be configured for use
                                                                 via the core's link control register (CFG032) negotiated link width field. */
        uint64_t laneswap              : 1;  /**< [  4:  4](R/W) Determines lane swapping. When set, lane swapping is
                                                                 performed to/from the SerDes. When clear, no lane swapping is performed. */
        uint64_t reserved_2_3          : 2;
        uint64_t md                    : 2;  /**< [  1:  0](R/W) Determines the speed.
                                                                   0x0 = Gen1 speed.
                                                                   0x1 = Gen2 speed.
                                                                   0x2 = Gen3 speed.
                                                                   0x3 = Gen3 speed. */
#else /* Word 0 - Little Endian */
        uint64_t md                    : 2;  /**< [  1:  0](R/W) Determines the speed.
                                                                   0x0 = Gen1 speed.
                                                                   0x1 = Gen2 speed.
                                                                   0x2 = Gen3 speed.
                                                                   0x3 = Gen3 speed. */
        uint64_t reserved_2_3          : 2;
        uint64_t laneswap              : 1;  /**< [  4:  4](R/W) Determines lane swapping. When set, lane swapping is
                                                                 performed to/from the SerDes. When clear, no lane swapping is performed. */
        uint64_t lanes4                : 1;  /**< [  5:  5](R/W) Determines the number of lanes.
                                                                 When set, the PEM is configured for a maximum of 4 lanes. When clear, the PEM is
                                                                 configured for a maximum of 2 lanes. This value is used to set the maximum link width
                                                                 field in the core's link capabilities register (CFG031) to indicate the maximum number of
                                                                 lanes supported. Note that less lanes than the specified maximum can be configured for use
                                                                 via the core's link control register (CFG032) negotiated link width field. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_cfg_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t laneswap              : 1;  /**< [  4:  4](R/W/H) Enables overwriting the value for lane swapping. The reset value is captured on
                                                                 cold reset by the pin straps (see PEM()_STRAP[PILANESWAP]). When set, lane swapping is
                                                                 performed to/from the SerDes. When clear, no lane swapping is performed. */
        uint64_t lanes8                : 1;  /**< [  3:  3](R/W/H) Enables overwriting the value for the maximum number of lanes. The reset value
                                                                 is captured on cold reset by the pin straps (see PEM()_STRAP[PILANES8]). When set, the
                                                                 PEM is configured for a maximum of 8 lanes. When clear, the PEM is configured for a
                                                                 maximum of 4 or 2 lanes. This value is used to set the maximum link width field in the
                                                                 core's
                                                                 link capabilities register (CFG031) to indicate the maximum number of lanes
                                                                 supported. Note that less lanes than the specified maximum can be configured for use via
                                                                 the core's link control register (CFG032) negotiated link width field. */
        uint64_t hostmd                : 1;  /**< [  2:  2](R/W/H) Enables overwriting the value for host mode. The reset value is captured on
                                                                 cold reset by the pin straps. (See PEM()_STRAP[PIMODE]. The HOSTMD reset value is the
                                                                 bit-wise AND of the PIMODE straps.  When set, the PEM is configured to be a root complex.
                                                                 When clear, the PEM is configured to be an end point. */
        uint64_t md                    : 2;  /**< [  1:  0](R/W/H) Enables overwriting the value for speed. The reset value is captured on cold
                                                                 reset by the pin straps (see PEM()_STRAP[PIMODE]). For a root complex configuration
                                                                 that is not running at Gen3 speed, the HOSTMD bit of this register must be set when this
                                                                 field is changed.
                                                                 0x0 = Gen1 speed.
                                                                 0x1 = Gen2 speed.
                                                                 0x2 = Gen3 speed.
                                                                 0x3 = Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t md                    : 2;  /**< [  1:  0](R/W/H) Enables overwriting the value for speed. The reset value is captured on cold
                                                                 reset by the pin straps (see PEM()_STRAP[PIMODE]). For a root complex configuration
                                                                 that is not running at Gen3 speed, the HOSTMD bit of this register must be set when this
                                                                 field is changed.
                                                                 0x0 = Gen1 speed.
                                                                 0x1 = Gen2 speed.
                                                                 0x2 = Gen3 speed.
                                                                 0x3 = Reserved. */
        uint64_t hostmd                : 1;  /**< [  2:  2](R/W/H) Enables overwriting the value for host mode. The reset value is captured on
                                                                 cold reset by the pin straps. (See PEM()_STRAP[PIMODE]. The HOSTMD reset value is the
                                                                 bit-wise AND of the PIMODE straps.  When set, the PEM is configured to be a root complex.
                                                                 When clear, the PEM is configured to be an end point. */
        uint64_t lanes8                : 1;  /**< [  3:  3](R/W/H) Enables overwriting the value for the maximum number of lanes. The reset value
                                                                 is captured on cold reset by the pin straps (see PEM()_STRAP[PILANES8]). When set, the
                                                                 PEM is configured for a maximum of 8 lanes. When clear, the PEM is configured for a
                                                                 maximum of 4 or 2 lanes. This value is used to set the maximum link width field in the
                                                                 core's
                                                                 link capabilities register (CFG031) to indicate the maximum number of lanes
                                                                 supported. Note that less lanes than the specified maximum can be configured for use via
                                                                 the core's link control register (CFG032) negotiated link width field. */
        uint64_t laneswap              : 1;  /**< [  4:  4](R/W/H) Enables overwriting the value for lane swapping. The reset value is captured on
                                                                 cold reset by the pin straps (see PEM()_STRAP[PILANESWAP]). When set, lane swapping is
                                                                 performed to/from the SerDes. When clear, no lane swapping is performed. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_cfg_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t pipe_grp_ptr          : 3;  /**< [  7:  5](R/W) Each PEM brings in 24 lanes of RX Pipe.
                                                                 Configures the PEM to point to the RX Pipe quad containing
                                                                 Lane 0.
                                                                 0x0 = grp0 (lane 0).
                                                                 0x1 = grp1 (lane 4).
                                                                 0x2 = grp2 (lane 8).
                                                                 0x3 = grp3 (lane 12).
                                                                 0x4 = grp4 (lane 16).
                                                                 0x5 = grp5 (lane 20).
                                                                 0x6 - 0x7 = Reserved.

                                                                 CN93XX configuration:
                                                                 \<pre\>
                                                                 PEM0: Configure to grp0 (QLM0/1/2/3).
                                                                 PEM1: Configure to grp0 (QLM1).
                                                                       Configure to grp1 (DLM4/5).
                                                                 PEM2: Configure to grp0 (QLM3).
                                                                       Configure to grp1 (DLM5).
                                                                       Configure to grp2 (QLM6/7).
                                                                 PEM3: Configure to grp0 (QLM2/3).
                                                                 \</pre\> */
        uint64_t pipe                  : 2;  /**< [  4:  3](R/W) Configures the PEM pipe sources.
                                                                 0x0 = Pipe 0.
                                                                 0x1 = Pipe 1.
                                                                 0x2 = Pipe 2.
                                                                 0x3 = Reserved.

                                                                 CN93XX configuration:
                                                                 \<pre\>
                                                                 PEM0: Configure to Pipe 0 (QLM0/1/2/3).
                                                                 PEM1: Configure to Pipe 0 (QLM1).
                                                                       Configure to Pipe 1 (DLM4/5).
                                                                 PEM2: Configure to Pipe 0 (QLM3).
                                                                       Configure to Pipe 1 (DLM5).
                                                                       Configure to Pipe 2 (QLM6/7).
                                                                 PEM3: Configure to Pipe 0 (QLM2/3).
                                                                 \</pre\> */
        uint64_t lanes                 : 2;  /**< [  2:  1](R/W/H) Ties off RX Pipe for unused lanes.
                                                                 0x0 = 2 lanes.
                                                                 0x1 = 4 lanes.
                                                                 0x2 = 8 lanes.
                                                                 0x3 = 16 lanes.

                                                                 CN93XX configuration:
                                                                 \<pre\>
                                                                 PEM0: Configure to 16 Lanes (QLM0/1/2/3).
                                                                       Configure to  8 Lanes (QLM0/1).
                                                                       Configure to  4 Lanes (QLM0).
                                                                 PEM1: Configure to  4 Lanes (QLM1 or DLM4/5).
                                                                       Configure to  2 Lanes (DLM4).
                                                                 PEM2: Configure to  4 Lanes (QLM3).
                                                                       Configure to  2 Lanes (DLM5).
                                                                       Configure to  8 Lanes (QLM6/7).
                                                                       Configure to  4 Lanes (QLM6).
                                                                 PEM3: Configure to  8 Lanes (QLM2/3 or QLM6/7).
                                                                       Configure to  4 Lanes (QLM 2 or QLM6).
                                                                 \</pre\> */
        uint64_t hostmd                : 1;  /**< [  0:  0](R/W/H) Host mode.
                                                                 0 = PEM is configured to be an end point (EP mode).
                                                                 1 = PEM is configured to be a root complex (RC mode).
                                                                 The reset value for this bit is controlled by a strapping pin. */
#else /* Word 0 - Little Endian */
        uint64_t hostmd                : 1;  /**< [  0:  0](R/W/H) Host mode.
                                                                 0 = PEM is configured to be an end point (EP mode).
                                                                 1 = PEM is configured to be a root complex (RC mode).
                                                                 The reset value for this bit is controlled by a strapping pin. */
        uint64_t lanes                 : 2;  /**< [  2:  1](R/W/H) Ties off RX Pipe for unused lanes.
                                                                 0x0 = 2 lanes.
                                                                 0x1 = 4 lanes.
                                                                 0x2 = 8 lanes.
                                                                 0x3 = 16 lanes.

                                                                 CN93XX configuration:
                                                                 \<pre\>
                                                                 PEM0: Configure to 16 Lanes (QLM0/1/2/3).
                                                                       Configure to  8 Lanes (QLM0/1).
                                                                       Configure to  4 Lanes (QLM0).
                                                                 PEM1: Configure to  4 Lanes (QLM1 or DLM4/5).
                                                                       Configure to  2 Lanes (DLM4).
                                                                 PEM2: Configure to  4 Lanes (QLM3).
                                                                       Configure to  2 Lanes (DLM5).
                                                                       Configure to  8 Lanes (QLM6/7).
                                                                       Configure to  4 Lanes (QLM6).
                                                                 PEM3: Configure to  8 Lanes (QLM2/3 or QLM6/7).
                                                                       Configure to  4 Lanes (QLM 2 or QLM6).
                                                                 \</pre\> */
        uint64_t pipe                  : 2;  /**< [  4:  3](R/W) Configures the PEM pipe sources.
                                                                 0x0 = Pipe 0.
                                                                 0x1 = Pipe 1.
                                                                 0x2 = Pipe 2.
                                                                 0x3 = Reserved.

                                                                 CN93XX configuration:
                                                                 \<pre\>
                                                                 PEM0: Configure to Pipe 0 (QLM0/1/2/3).
                                                                 PEM1: Configure to Pipe 0 (QLM1).
                                                                       Configure to Pipe 1 (DLM4/5).
                                                                 PEM2: Configure to Pipe 0 (QLM3).
                                                                       Configure to Pipe 1 (DLM5).
                                                                       Configure to Pipe 2 (QLM6/7).
                                                                 PEM3: Configure to Pipe 0 (QLM2/3).
                                                                 \</pre\> */
        uint64_t pipe_grp_ptr          : 3;  /**< [  7:  5](R/W) Each PEM brings in 24 lanes of RX Pipe.
                                                                 Configures the PEM to point to the RX Pipe quad containing
                                                                 Lane 0.
                                                                 0x0 = grp0 (lane 0).
                                                                 0x1 = grp1 (lane 4).
                                                                 0x2 = grp2 (lane 8).
                                                                 0x3 = grp3 (lane 12).
                                                                 0x4 = grp4 (lane 16).
                                                                 0x5 = grp5 (lane 20).
                                                                 0x6 - 0x7 = Reserved.

                                                                 CN93XX configuration:
                                                                 \<pre\>
                                                                 PEM0: Configure to grp0 (QLM0/1/2/3).
                                                                 PEM1: Configure to grp0 (QLM1).
                                                                       Configure to grp1 (DLM4/5).
                                                                 PEM2: Configure to grp0 (QLM3).
                                                                       Configure to grp1 (DLM5).
                                                                       Configure to grp2 (QLM6/7).
                                                                 PEM3: Configure to grp0 (QLM2/3).
                                                                 \</pre\> */
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn9;
    /* struct bdk_pemx_cfg_cn9 cn96xxp1; */
    struct bdk_pemx_cfg_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t pipe_grp_ptr          : 3;  /**< [  7:  5](R/W) Configures the PEM to point to the RX Pipe quad containing
                                                                 Lane 0.
                                                                 0x0 = grp0 (lane 0).
                                                                 0x1 - 0x7 = Reserved. */
        uint64_t pipe                  : 2;  /**< [  4:  3](R/W) Configures the PEM pipe sources.
                                                                 0x0 = Pipe 0.
                                                                 0x1 - 0x3 = Reserved. */
        uint64_t lanes                 : 2;  /**< [  2:  1](R/W/H) Ties off RX Pipe for unused lanes.
                                                                 0x0 = Reserved.
                                                                 0x1 = 4 lanes.
                                                                 0x2 = 8 lanes.
                                                                 0x3 = 16 lanes.

                                                                 PCIERC_PORT_CTL[LME]/PCIEEP_PORT_CTL[LME] is required to be
                                                                 set to a value which is greater then or equal to [LANES]. */
        uint64_t hostmd                : 1;  /**< [  0:  0](R/W/H) Host mode.
                                                                 0 = PEM is configured to be an end point (EP mode).
                                                                 1 = PEM is configured to be a root complex (RC mode).
                                                                 The reset value for this bit is controlled by a strapping pin. */
#else /* Word 0 - Little Endian */
        uint64_t hostmd                : 1;  /**< [  0:  0](R/W/H) Host mode.
                                                                 0 = PEM is configured to be an end point (EP mode).
                                                                 1 = PEM is configured to be a root complex (RC mode).
                                                                 The reset value for this bit is controlled by a strapping pin. */
        uint64_t lanes                 : 2;  /**< [  2:  1](R/W/H) Ties off RX Pipe for unused lanes.
                                                                 0x0 = Reserved.
                                                                 0x1 = 4 lanes.
                                                                 0x2 = 8 lanes.
                                                                 0x3 = 16 lanes.

                                                                 PCIERC_PORT_CTL[LME]/PCIEEP_PORT_CTL[LME] is required to be
                                                                 set to a value which is greater then or equal to [LANES]. */
        uint64_t pipe                  : 2;  /**< [  4:  3](R/W) Configures the PEM pipe sources.
                                                                 0x0 = Pipe 0.
                                                                 0x1 - 0x3 = Reserved. */
        uint64_t pipe_grp_ptr          : 3;  /**< [  7:  5](R/W) Configures the PEM to point to the RX Pipe quad containing
                                                                 Lane 0.
                                                                 0x0 = grp0 (lane 0).
                                                                 0x1 - 0x7 = Reserved. */
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_pemx_cfg_cn96xxp3 cn98xx; */
    /* struct bdk_pemx_cfg_cn9 cnf95xx; */
    struct bdk_pemx_cfg_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t pipe_grp_ptr          : 3;  /**< [  7:  5](R/W) Configures the PEM to point to the RX Pipe quad containing
                                                                 Lane 0.
                                                                 0x0 = grp0 (lane 0).
                                                                 0x1 - 0x7 = Reserved. */
        uint64_t pipe                  : 2;  /**< [  4:  3](R/W) Configures the PEM pipe sources.
                                                                 0x0 = Pipe 0.
                                                                 0x1 - 0x3 = Reserved. */
        uint64_t lanes                 : 2;  /**< [  2:  1](R/W/H) Ties off RX Pipe for unused lanes.
                                                                 0x0 = Reserved.
                                                                 0x1 = 4 lanes.
                                                                 0x2 = Reserved.
                                                                 0x3 = Reserved.

                                                                 PCIERC_PORT_CTL[LME]/PCIEEP_PORT_CTL[LME] is required to be
                                                                 set to a value which is greater then or equal to [LANES]. */
        uint64_t hostmd                : 1;  /**< [  0:  0](R/W/H) Host mode.
                                                                 0 = PEM is configured to be an end point (EP mode).
                                                                 1 = PEM is configured to be a root complex (RC mode).
                                                                 The reset value for this bit is controlled by a strapping pin. */
#else /* Word 0 - Little Endian */
        uint64_t hostmd                : 1;  /**< [  0:  0](R/W/H) Host mode.
                                                                 0 = PEM is configured to be an end point (EP mode).
                                                                 1 = PEM is configured to be a root complex (RC mode).
                                                                 The reset value for this bit is controlled by a strapping pin. */
        uint64_t lanes                 : 2;  /**< [  2:  1](R/W/H) Ties off RX Pipe for unused lanes.
                                                                 0x0 = Reserved.
                                                                 0x1 = 4 lanes.
                                                                 0x2 = Reserved.
                                                                 0x3 = Reserved.

                                                                 PCIERC_PORT_CTL[LME]/PCIEEP_PORT_CTL[LME] is required to be
                                                                 set to a value which is greater then or equal to [LANES]. */
        uint64_t pipe                  : 2;  /**< [  4:  3](R/W) Configures the PEM pipe sources.
                                                                 0x0 = Pipe 0.
                                                                 0x1 - 0x3 = Reserved. */
        uint64_t pipe_grp_ptr          : 3;  /**< [  7:  5](R/W) Configures the PEM to point to the RX Pipe quad containing
                                                                 Lane 0.
                                                                 0x0 = grp0 (lane 0).
                                                                 0x1 - 0x7 = Reserved. */
        uint64_t auto_dp_clr           : 1;  /**< [  8:  8](R/W/H) Auto disable-port clearing of PEM()_DIS_PORT[DIS_PORT] when link LTSSM
                                                                 state reaches L0 after a MAC reset.

                                                                 0 = Do not auto-clear PEM()_DIS_PORT[DIS_PORT], which will require software to
                                                                 clear PEM()_DIS_PORT[DIS_PORT] after the link is reset.  Typical setting when in
                                                                 EP mode (PEM()_CFG[HOSTMD] = 0).

                                                                 1 = Auto-clear PEM()_DIS_PORT[DIS_PORT], which will typically allow outbound
                                                                 traffic to resume after reset is complete. Typical setting when in RC mode
                                                                 (PEM()_CFG[HOSTMD] = 1).

                                                                 Resets to 0 when strapped as an endpoint (GPIO_STRAP_PIN_E::PCIEn_EP_MODE is
                                                                 strapped high), otherwise 1. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_pemx_cfg bdk_pemx_cfg_t;

static inline uint64_t BDK_PEMX_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CFG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000410ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000410ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000d8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000d8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000d8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000d8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CFG(a) bdk_pemx_cfg_t
#define bustype_BDK_PEMX_CFG(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CFG(a) "PEMX_CFG"
#define device_bar_BDK_PEMX_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CFG(a) (a)
#define arguments_BDK_PEMX_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_cfg_rd
 *
 * PEM Configuration Read Register
 * This register allows read access to the configuration in the PCIe core, but is for
 * legacy application use. PEM()_PF()_CS()_PFCFG() and PEM()_PF()_VF()_VFCFG() should
 * typically be used instead.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_cfg_rd
{
    uint64_t u;
    struct bdk_pemx_cfg_rd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data. */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W/H) Address to read. A write to this register starts a read operation.
                                                                 Following are the sub-fields of the ADDR field.

                                                                 \<11:0\> The offset of the PCIe core CFG register being accessed. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W/H) Address to read. A write to this register starts a read operation.
                                                                 Following are the sub-fields of the ADDR field.

                                                                 \<11:0\> The offset of the PCIe core CFG register being accessed. */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_cfg_rd_s cn8; */
    /* struct bdk_pemx_cfg_rd_s cn81xx; */
    struct bdk_pemx_cfg_rd_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data. */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to read. A write to this register starts a read operation.
                                                                 Following are the subfields of the ADDR field.

                                                                 \<31:24\> = Reserved. Must be zero.

                                                                 \<23\>    = When clear, the read accesses the physical function. When set,
                                                                         the read accesses the virtual function selected by \<22:12\>.
                                                                         Must be zero when SR-IOV is not used in the physical function.
                                                                         Must be zero in RC mode.

                                                                 \<22:18\> = Reserved. Must be zero.

                                                                 \<17:12\> = The selected virtual function. Must be zero when \<23\> is
                                                                         clear. Must be zero in RC mode.

                                                                 \<11:0\>  = Selects the PCIe config space register being read in the
                                                                         function.

                                                                 Internal:
                                                                 \<31\>    = asserts dbi_cs2 at PCIe core.
                                                                   \<23\>    = dbi_vfunc_active to the core.
                                                                   \<22:12\> = dbi_vfunc_num to the core. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to read. A write to this register starts a read operation.
                                                                 Following are the subfields of the ADDR field.

                                                                 \<31:24\> = Reserved. Must be zero.

                                                                 \<23\>    = When clear, the read accesses the physical function. When set,
                                                                         the read accesses the virtual function selected by \<22:12\>.
                                                                         Must be zero when SR-IOV is not used in the physical function.
                                                                         Must be zero in RC mode.

                                                                 \<22:18\> = Reserved. Must be zero.

                                                                 \<17:12\> = The selected virtual function. Must be zero when \<23\> is
                                                                         clear. Must be zero in RC mode.

                                                                 \<11:0\>  = Selects the PCIe config space register being read in the
                                                                         function.

                                                                 Internal:
                                                                 \<31\>    = asserts dbi_cs2 at PCIe core.
                                                                   \<23\>    = dbi_vfunc_active to the core.
                                                                   \<22:12\> = dbi_vfunc_num to the core. */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data. */
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_cfg_rd_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data. */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to read. A write to this register starts a read operation.
                                                                 Following are the subfields of [ADDR].

                                                                 \<31:30\> = Reserved. Must be zero.

                                                                 \<29:22\> = The selected virtual function. Must be zero when \<17\> is
                                                                           clear. Must be zero in RC mode.

                                                                 \<21:18\> = The selected physical function. Must be zero in RC mode.

                                                                 \<17\>    = When clear, the write accesses the physical function. When set,
                                                                           the write accesses the virtual function selected by \<29:22\>.
                                                                           Must be zero when SR-IOV is not used in the physical function.
                                                                           Must be zero in RC mode.

                                                                 \<16\>    = When clear, the write is the same as a config space write received
                                                                           from external. When set, the write can modify more fields than
                                                                           an external write could (i.e. configuration mask register).

                                                                           Corresponds to the CS2 field in Byte2 of the EEPROM.

                                                                 \<15\>    = Must be 1.

                                                                 \<14:12\> = Reserved. Must be zero.

                                                                 \<11:0\>  = Selects the PCIe config space register being written in the
                                                                         function.

                                                                 Internal:
                                                                 \<16\>    = asserts dbi_cs2 at PCIe core.
                                                                 \<17\>    = dbi_vfunc_active to the core.
                                                                 \<29:22\> = dbi_vfunc_num to the core. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to read. A write to this register starts a read operation.
                                                                 Following are the subfields of [ADDR].

                                                                 \<31:30\> = Reserved. Must be zero.

                                                                 \<29:22\> = The selected virtual function. Must be zero when \<17\> is
                                                                           clear. Must be zero in RC mode.

                                                                 \<21:18\> = The selected physical function. Must be zero in RC mode.

                                                                 \<17\>    = When clear, the write accesses the physical function. When set,
                                                                           the write accesses the virtual function selected by \<29:22\>.
                                                                           Must be zero when SR-IOV is not used in the physical function.
                                                                           Must be zero in RC mode.

                                                                 \<16\>    = When clear, the write is the same as a config space write received
                                                                           from external. When set, the write can modify more fields than
                                                                           an external write could (i.e. configuration mask register).

                                                                           Corresponds to the CS2 field in Byte2 of the EEPROM.

                                                                 \<15\>    = Must be 1.

                                                                 \<14:12\> = Reserved. Must be zero.

                                                                 \<11:0\>  = Selects the PCIe config space register being written in the
                                                                         function.

                                                                 Internal:
                                                                 \<16\>    = asserts dbi_cs2 at PCIe core.
                                                                 \<17\>    = dbi_vfunc_active to the core.
                                                                 \<29:22\> = dbi_vfunc_num to the core. */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data. */
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_cfg_rd bdk_pemx_cfg_rd_t;

static inline uint64_t BDK_PEMX_CFG_RD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CFG_RD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000030ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000030ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000020ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000020ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000020ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000020ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CFG_RD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CFG_RD(a) bdk_pemx_cfg_rd_t
#define bustype_BDK_PEMX_CFG_RD(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CFG_RD(a) "PEMX_CFG_RD"
#define device_bar_BDK_PEMX_CFG_RD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CFG_RD(a) (a)
#define arguments_BDK_PEMX_CFG_RD(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_cfg_tbl#
 *
 * PEM Configuration Table Registers
 * Software managed table with list of config registers to update when
 * PEM()_CTL_STATUS[LNK_ENB] is written with a 1. Typically the last
 * table action should be to set PEM()_CTL_STATUS[SCR_DONE].
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_cfg_tblx
{
    uint64_t u;
    struct bdk_pemx_cfg_tblx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 32; /**< [ 63: 32](R/W) Data to write. */
        uint64_t broadcast             : 1;  /**< [ 31: 31](R/W) When set, [PF] field is ignored and the write will occur to every Physical Function.
                                                                 When set and [VF_ACTIVE] is set, write will occur to VF0 within every Physical Function. */
        uint64_t reserved_30           : 1;
        uint64_t vf                    : 8;  /**< [ 29: 22](R/W) The selected virtual function.  Must be zero when [VF_ACTIVE] is clear, or when configured
                                                                 for RC mode. */
        uint64_t pf                    : 4;  /**< [ 21: 18](R/W) Physical function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t vf_active             : 1;  /**< [ 17: 17](R/W) VF active.
                                                                 0 = Write accesses the physical function.
                                                                 1 = Write accesses the virtual function selected by [VF] belonging to [PF].

                                                                 Must be zero when SR-IOV is not used in the physical function.
                                                                 Must be zero in RC mode. */
        uint64_t shadow                : 1;  /**< [ 16: 16](R/W) Shadow space.
                                                                 0 = The destination CSR is the standard PCI configuration write register.
                                                                 This may write WRSL fields.
                                                                 1 = The destination is the shadow CSR space, e.g. PCIEEP_BAR0_MASKL. */
        uint64_t wmask                 : 4;  /**< [ 15: 12](R/W) Byte mask to apply when writing data. If set, the corresponding byte will be written. */
        uint64_t offset                : 12; /**< [ 11:  0](R/W) Selects the PCIe config space register being written in the function. */
#else /* Word 0 - Little Endian */
        uint64_t offset                : 12; /**< [ 11:  0](R/W) Selects the PCIe config space register being written in the function. */
        uint64_t wmask                 : 4;  /**< [ 15: 12](R/W) Byte mask to apply when writing data. If set, the corresponding byte will be written. */
        uint64_t shadow                : 1;  /**< [ 16: 16](R/W) Shadow space.
                                                                 0 = The destination CSR is the standard PCI configuration write register.
                                                                 This may write WRSL fields.
                                                                 1 = The destination is the shadow CSR space, e.g. PCIEEP_BAR0_MASKL. */
        uint64_t vf_active             : 1;  /**< [ 17: 17](R/W) VF active.
                                                                 0 = Write accesses the physical function.
                                                                 1 = Write accesses the virtual function selected by [VF] belonging to [PF].

                                                                 Must be zero when SR-IOV is not used in the physical function.
                                                                 Must be zero in RC mode. */
        uint64_t pf                    : 4;  /**< [ 21: 18](R/W) Physical function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t vf                    : 8;  /**< [ 29: 22](R/W) The selected virtual function.  Must be zero when [VF_ACTIVE] is clear, or when configured
                                                                 for RC mode. */
        uint64_t reserved_30           : 1;
        uint64_t broadcast             : 1;  /**< [ 31: 31](R/W) When set, [PF] field is ignored and the write will occur to every Physical Function.
                                                                 When set and [VF_ACTIVE] is set, write will occur to VF0 within every Physical Function. */
        uint64_t data                  : 32; /**< [ 63: 32](R/W) Data to write. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_cfg_tblx_s cn; */
};
typedef union bdk_pemx_cfg_tblx bdk_pemx_cfg_tblx_t;

static inline uint64_t BDK_PEMX_CFG_TBLX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CFG_TBLX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=1023)))
        return 0x8e0000002000ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3ff);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=1023)))
        return 0x8e0000002000ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3ff);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=1023)))
        return 0x8e0000002000ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3ff);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=1023)))
        return 0x8e0000002000ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3ff);
    __bdk_csr_fatal("PEMX_CFG_TBLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CFG_TBLX(a,b) bdk_pemx_cfg_tblx_t
#define bustype_BDK_PEMX_CFG_TBLX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CFG_TBLX(a,b) "PEMX_CFG_TBLX"
#define device_bar_BDK_PEMX_CFG_TBLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CFG_TBLX(a,b) (a)
#define arguments_BDK_PEMX_CFG_TBLX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_cfg_tbl_size
 *
 * PEM Configuration Table Size Register
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_cfg_tbl_size
{
    uint64_t u;
    struct bdk_pemx_cfg_tbl_size_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t size                  : 11; /**< [ 10:  0](R/W) The number of valid entries in PEM()_CFG_TBL(). When hardware plays out the
                                                                 PEM()_CFG_TBL() table, it will read PEM()_CFG_TBL() entries 0x0 through
                                                                 [SIZE]-1, or take no action if [SIZE] is 0x0.

                                                                 Software, before rewriting PEM()_CFG_TBL(), should clear [SIZE], write all of
                                                                 the desired entries, then write the [SIZE] with the number of written entries. */
#else /* Word 0 - Little Endian */
        uint64_t size                  : 11; /**< [ 10:  0](R/W) The number of valid entries in PEM()_CFG_TBL(). When hardware plays out the
                                                                 PEM()_CFG_TBL() table, it will read PEM()_CFG_TBL() entries 0x0 through
                                                                 [SIZE]-1, or take no action if [SIZE] is 0x0.

                                                                 Software, before rewriting PEM()_CFG_TBL(), should clear [SIZE], write all of
                                                                 the desired entries, then write the [SIZE] with the number of written entries. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_cfg_tbl_size_s cn; */
};
typedef union bdk_pemx_cfg_tbl_size bdk_pemx_cfg_tbl_size_t;

static inline uint64_t BDK_PEMX_CFG_TBL_SIZE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CFG_TBL_SIZE(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000220ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000220ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000220ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000220ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CFG_TBL_SIZE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CFG_TBL_SIZE(a) bdk_pemx_cfg_tbl_size_t
#define bustype_BDK_PEMX_CFG_TBL_SIZE(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CFG_TBL_SIZE(a) "PEMX_CFG_TBL_SIZE"
#define device_bar_BDK_PEMX_CFG_TBL_SIZE(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CFG_TBL_SIZE(a) (a)
#define arguments_BDK_PEMX_CFG_TBL_SIZE(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_cfg_wr
 *
 * PEM Configuration Write Register
 * This register allows write access to the configuration in the PCIe core, but is for
 * legacy application use. PEM()_PF()_CS()_PFCFG() and PEM()_PF()_VF()_VFCFG() should
 * typically be used instead.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_cfg_wr
{
    uint64_t u;
    struct bdk_pemx_cfg_wr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data to write. A write to this register starts a write operation. */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W/H) Address to write. A write to this register starts a write operation.
                                                                 Following are the sub-fields of the ADDR field.

                                                                 \<31\>   When set, asserts dbi_cs2 at PCIe core.
                                                                 \<11:0\> The offset of the PCIe core CFG register being accessed. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W/H) Address to write. A write to this register starts a write operation.
                                                                 Following are the sub-fields of the ADDR field.

                                                                 \<31\>   When set, asserts dbi_cs2 at PCIe core.
                                                                 \<11:0\> The offset of the PCIe core CFG register being accessed. */
        uint64_t data                  : 32; /**< [ 63: 32](R/W/H) Data to write. A write to this register starts a write operation. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_cfg_wr_s cn8; */
    /* struct bdk_pemx_cfg_wr_s cn81xx; */
    struct bdk_pemx_cfg_wr_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 32; /**< [ 63: 32](R/W) Data to write. A write to this register starts a write operation. */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to write. A write to this register starts a write operation.
                                                                 Following are the subfields of the ADDR field.

                                                                 \<31\>    = When clear, the write is the same as a config space write received
                                                                         from external. When set, the write can modify more fields than
                                                                         an external write could (i.e. configuration mask register).

                                                                         Corresponds to the CS2 field in Byte2 of the EEPROM.

                                                                 \<30:24\> = Reserved. Must be zero.

                                                                 \<23\>    = When clear, the write accesses the physical function. When set,
                                                                         the write accesses the virtual function selected by \<22:12\>.
                                                                         Must be zero when SR-IOV is not used in the physical function.
                                                                         Must be zero in RC mode.

                                                                 \<22:18\> = Reserved. Must be zero.

                                                                 \<17:12\> = The selected virtual function. Must be zero when \<23\> is
                                                                         clear. Must be zero in RC mode.

                                                                 \<11:0\>  = Selects the PCIe config space register being written in the
                                                                         function.

                                                                 Internal:
                                                                 \<31\>    = asserts dbi_cs2 at PCIe core.
                                                                   \<23\>    = dbi_vfunc_active to the core.
                                                                   \<22:12\> = dbi_vfunc_num to the core. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to write. A write to this register starts a write operation.
                                                                 Following are the subfields of the ADDR field.

                                                                 \<31\>    = When clear, the write is the same as a config space write received
                                                                         from external. When set, the write can modify more fields than
                                                                         an external write could (i.e. configuration mask register).

                                                                         Corresponds to the CS2 field in Byte2 of the EEPROM.

                                                                 \<30:24\> = Reserved. Must be zero.

                                                                 \<23\>    = When clear, the write accesses the physical function. When set,
                                                                         the write accesses the virtual function selected by \<22:12\>.
                                                                         Must be zero when SR-IOV is not used in the physical function.
                                                                         Must be zero in RC mode.

                                                                 \<22:18\> = Reserved. Must be zero.

                                                                 \<17:12\> = The selected virtual function. Must be zero when \<23\> is
                                                                         clear. Must be zero in RC mode.

                                                                 \<11:0\>  = Selects the PCIe config space register being written in the
                                                                         function.

                                                                 Internal:
                                                                 \<31\>    = asserts dbi_cs2 at PCIe core.
                                                                   \<23\>    = dbi_vfunc_active to the core.
                                                                   \<22:12\> = dbi_vfunc_num to the core. */
        uint64_t data                  : 32; /**< [ 63: 32](R/W) Data to write. A write to this register starts a write operation. */
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_cfg_wr_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 32; /**< [ 63: 32](R/W) Data to write. A write to this register starts a write operation. */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to write. A write to this register starts a write operation.
                                                                 Following are the subfields of [ADDR].

                                                                 \<31:30\> = Reserved. Must be zero.

                                                                 \<29:22\> = The selected virtual function. Must be zero when \<17\> is
                                                                           clear. Must be zero in RC mode.

                                                                 \<21:18\> = The selected physical function. Must be zero in RC mode.

                                                                 \<17\>    = When clear, the write accesses the physical function. When set,
                                                                           the write accesses the virtual function selected by \<29:22\>.
                                                                           Must be zero when SR-IOV is not used in the physical function.
                                                                           Must be zero in RC mode.

                                                                 \<16\>    = When clear, the write is the same as a config space write received
                                                                           from external. When set, the write can modify more fields than
                                                                           an external write could (i.e. configuration mask register).

                                                                           Corresponds to the CS2 field in Byte2 of the EEPROM.

                                                                 \<15\>    = Must be 1.

                                                                 \<14:12\> = Reserved. Must be zero.

                                                                 \<11:0\>  = Selects the PCIe config space register being written in the
                                                                         function.

                                                                 Internal:
                                                                 \<16\>    = asserts dbi_cs2 at PCIe core.
                                                                 \<17\>    = dbi_vfunc_active to the core.
                                                                 \<29:22\> = dbi_vfunc_num to the core. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 32; /**< [ 31:  0](R/W) Address to write. A write to this register starts a write operation.
                                                                 Following are the subfields of [ADDR].

                                                                 \<31:30\> = Reserved. Must be zero.

                                                                 \<29:22\> = The selected virtual function. Must be zero when \<17\> is
                                                                           clear. Must be zero in RC mode.

                                                                 \<21:18\> = The selected physical function. Must be zero in RC mode.

                                                                 \<17\>    = When clear, the write accesses the physical function. When set,
                                                                           the write accesses the virtual function selected by \<29:22\>.
                                                                           Must be zero when SR-IOV is not used in the physical function.
                                                                           Must be zero in RC mode.

                                                                 \<16\>    = When clear, the write is the same as a config space write received
                                                                           from external. When set, the write can modify more fields than
                                                                           an external write could (i.e. configuration mask register).

                                                                           Corresponds to the CS2 field in Byte2 of the EEPROM.

                                                                 \<15\>    = Must be 1.

                                                                 \<14:12\> = Reserved. Must be zero.

                                                                 \<11:0\>  = Selects the PCIe config space register being written in the
                                                                         function.

                                                                 Internal:
                                                                 \<16\>    = asserts dbi_cs2 at PCIe core.
                                                                 \<17\>    = dbi_vfunc_active to the core.
                                                                 \<29:22\> = dbi_vfunc_num to the core. */
        uint64_t data                  : 32; /**< [ 63: 32](R/W) Data to write. A write to this register starts a write operation. */
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_cfg_wr bdk_pemx_cfg_wr_t;

static inline uint64_t BDK_PEMX_CFG_WR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CFG_WR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000028ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000018ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000018ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000018ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000018ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CFG_WR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CFG_WR(a) bdk_pemx_cfg_wr_t
#define bustype_BDK_PEMX_CFG_WR(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CFG_WR(a) "PEMX_CFG_WR"
#define device_bar_BDK_PEMX_CFG_WR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CFG_WR(a) (a)
#define arguments_BDK_PEMX_CFG_WR(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_clk_en
 *
 * PEM Clock Enable Register
 * This register contains the clock enable for CSCLK and PCE_CLK.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_clk_en
{
    uint64_t u;
    struct bdk_pemx_clk_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t pem_mdh_dis           : 1;  /**< [  4:  4](R/W) When set, the memory and diagnostic hubs inside PEM are disabled and
                                                                 will not respond commands from the MDC. If this PEM is not in use, this
                                                                 bit should be set to save power. */
        uint64_t pemc_macclk_force     : 1;  /**< [  3:  3](R/W) When set, aux_clk & radm_clk are forced on at all times to the PEM core MAC.
                                                                 When clear, aux_clk & radm_clk can be gated by the PEM core MAC.
                                                                 For diagnostic use only. */
        uint64_t reserved_0_2          : 3;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_2          : 3;
        uint64_t pemc_macclk_force     : 1;  /**< [  3:  3](R/W) When set, aux_clk & radm_clk are forced on at all times to the PEM core MAC.
                                                                 When clear, aux_clk & radm_clk can be gated by the PEM core MAC.
                                                                 For diagnostic use only. */
        uint64_t pem_mdh_dis           : 1;  /**< [  4:  4](R/W) When set, the memory and diagnostic hubs inside PEM are disabled and
                                                                 will not respond commands from the MDC. If this PEM is not in use, this
                                                                 bit should be set to save power. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_clk_en_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t pceclk_gate           : 1;  /**< [  1:  1](R/W/H) When set, PCE_CLK is gated off. When clear, PCE_CLK is enabled.
                                                                 Software should set this bit when the PEM is in reset or otherwise not
                                                                 being used in order to reduce power. */
        uint64_t csclk_gate            : 1;  /**< [  0:  0](R/W/H) When set, CSCLK is gated off. When clear, CSCLK is enabled.
                                                                 Software should set this bit when the PEM is in reset or otherwise not
                                                                 being used in order to reduce power. */
#else /* Word 0 - Little Endian */
        uint64_t csclk_gate            : 1;  /**< [  0:  0](R/W/H) When set, CSCLK is gated off. When clear, CSCLK is enabled.
                                                                 Software should set this bit when the PEM is in reset or otherwise not
                                                                 being used in order to reduce power. */
        uint64_t pceclk_gate           : 1;  /**< [  1:  1](R/W/H) When set, PCE_CLK is gated off. When clear, PCE_CLK is enabled.
                                                                 Software should set this bit when the PEM is in reset or otherwise not
                                                                 being used in order to reduce power. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn8;
    /* struct bdk_pemx_clk_en_cn8 cn81xx; */
    struct bdk_pemx_clk_en_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t pceclk_gate           : 1;  /**< [  1:  1](R/W/H) When set, PCE_CLK is gated off. When clear, PCE_CLK is enabled.
                                                                 PEM0 & PEM2 will come up with clocks disabled when configured as
                                                                 an RC i.e. PEM()_STRAP[PIMODE] set to 0x3.
                                                                 PEM1 & PEM3 always come up with clocks disabled. */
        uint64_t csclk_gate            : 1;  /**< [  0:  0](R/W/H) When set, ECLK is gated off. When clear, ECLK is enabled.
                                                                 PEM0 & PEM2 will come up with clocks disabled when configured as
                                                                 an RC i.e. PEM()_STRAP[PIMODE] set to 0x3.
                                                                 PEM1 & PEM3 always come up with clocks disabled. */
#else /* Word 0 - Little Endian */
        uint64_t csclk_gate            : 1;  /**< [  0:  0](R/W/H) When set, ECLK is gated off. When clear, ECLK is enabled.
                                                                 PEM0 & PEM2 will come up with clocks disabled when configured as
                                                                 an RC i.e. PEM()_STRAP[PIMODE] set to 0x3.
                                                                 PEM1 & PEM3 always come up with clocks disabled. */
        uint64_t pceclk_gate           : 1;  /**< [  1:  1](R/W/H) When set, PCE_CLK is gated off. When clear, PCE_CLK is enabled.
                                                                 PEM0 & PEM2 will come up with clocks disabled when configured as
                                                                 an RC i.e. PEM()_STRAP[PIMODE] set to 0x3.
                                                                 PEM1 & PEM3 always come up with clocks disabled. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_clk_en_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t pem_mdh_dis           : 1;  /**< [  4:  4](R/W) When set, the memory and diagnostic hubs inside PEM are disabled and
                                                                 will not respond commands from the MDC. If this PEM is not in use, this
                                                                 bit should be set to save power. */
        uint64_t pemc_macclk_force     : 1;  /**< [  3:  3](R/W) When set, aux_clk & radm_clk are forced on at all times to the PEM core MAC.
                                                                 When clear, aux_clk & radm_clk can be gated by the PEM core MAC.
                                                                 For diagnostic use only. */
        uint64_t pceclk_gate           : 1;  /**< [  2:  2](R/W) When set, PCE_CLK is gated off in PEM core.
                                                                 When clear, PCE_CLK is enabled in PEM core. */
        uint64_t pemc_csclk_gate       : 1;  /**< [  1:  1](R/W) When set, SCLK is gated off in PEM core.
                                                                 When clear, SCLK is enabled in PEM core. */
        uint64_t pemm_csclk_force      : 1;  /**< [  0:  0](R/W) When set, CSCLK is forced on at all times in PEM main.
                                                                 When clear, CSCLK gating in PEM main is controlled by hardware. */
#else /* Word 0 - Little Endian */
        uint64_t pemm_csclk_force      : 1;  /**< [  0:  0](R/W) When set, CSCLK is forced on at all times in PEM main.
                                                                 When clear, CSCLK gating in PEM main is controlled by hardware. */
        uint64_t pemc_csclk_gate       : 1;  /**< [  1:  1](R/W) When set, SCLK is gated off in PEM core.
                                                                 When clear, SCLK is enabled in PEM core. */
        uint64_t pceclk_gate           : 1;  /**< [  2:  2](R/W) When set, PCE_CLK is gated off in PEM core.
                                                                 When clear, PCE_CLK is enabled in PEM core. */
        uint64_t pemc_macclk_force     : 1;  /**< [  3:  3](R/W) When set, aux_clk & radm_clk are forced on at all times to the PEM core MAC.
                                                                 When clear, aux_clk & radm_clk can be gated by the PEM core MAC.
                                                                 For diagnostic use only. */
        uint64_t pem_mdh_dis           : 1;  /**< [  4:  4](R/W) When set, the memory and diagnostic hubs inside PEM are disabled and
                                                                 will not respond commands from the MDC. If this PEM is not in use, this
                                                                 bit should be set to save power. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn9;
    /* struct bdk_pemx_clk_en_cn9 cn96xxp1; */
    struct bdk_pemx_clk_en_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t pem_mdh_dis           : 1;  /**< [  4:  4](R/W) When set, the memory and diagnostic hubs inside PEM are disabled and
                                                                 will not respond commands from the MDC. If this PEM is not in use, this
                                                                 bit should be set to save power. */
        uint64_t pemc_macclk_force     : 1;  /**< [  3:  3](R/W) Force MAC clock. For diagnostic use only.
                                                                 0 = Aux_clk & radm_clk can be gated by the PEM core MAC.
                                                                 1 = Aux_clk & radm_clk are forced on at all times to the PEM core MAC. */
        uint64_t pceclk_gate           : 1;  /**< [  2:  2](R/W) Pipe clock gate.
                                                                 0 = PCE_CLK (pipe clock) is enabled in PEM core.
                                                                 1 = PCE_CLK (pipe clock) is gated off in PEM core.

                                                                 It is illegal to gate off PCE_CLK in a already active PEM. */
        uint64_t pemc_csclk_gate       : 1;  /**< [  1:  1](R/W) Conditional SCLK gate.
                                                                 0 = SCLK is enabled in PEM core.
                                                                 1 = SCLK is gated off in PEM core.

                                                                 It is illegal to gate off SCLK in a already active PEM. */
        uint64_t pemm_csclk_force      : 1;  /**< [  0:  0](R/W) Conditional SCLK force. For diagnostic use only.
                                                                 0 = CSCLK gating in PEM main is controlled by hardware.
                                                                 1 = CSCLK is forced on at all times in PEM main. */
#else /* Word 0 - Little Endian */
        uint64_t pemm_csclk_force      : 1;  /**< [  0:  0](R/W) Conditional SCLK force. For diagnostic use only.
                                                                 0 = CSCLK gating in PEM main is controlled by hardware.
                                                                 1 = CSCLK is forced on at all times in PEM main. */
        uint64_t pemc_csclk_gate       : 1;  /**< [  1:  1](R/W) Conditional SCLK gate.
                                                                 0 = SCLK is enabled in PEM core.
                                                                 1 = SCLK is gated off in PEM core.

                                                                 It is illegal to gate off SCLK in a already active PEM. */
        uint64_t pceclk_gate           : 1;  /**< [  2:  2](R/W) Pipe clock gate.
                                                                 0 = PCE_CLK (pipe clock) is enabled in PEM core.
                                                                 1 = PCE_CLK (pipe clock) is gated off in PEM core.

                                                                 It is illegal to gate off PCE_CLK in a already active PEM. */
        uint64_t pemc_macclk_force     : 1;  /**< [  3:  3](R/W) Force MAC clock. For diagnostic use only.
                                                                 0 = Aux_clk & radm_clk can be gated by the PEM core MAC.
                                                                 1 = Aux_clk & radm_clk are forced on at all times to the PEM core MAC. */
        uint64_t pem_mdh_dis           : 1;  /**< [  4:  4](R/W) When set, the memory and diagnostic hubs inside PEM are disabled and
                                                                 will not respond commands from the MDC. If this PEM is not in use, this
                                                                 bit should be set to save power. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_pemx_clk_en_cn96xxp3 cn98xx; */
    /* struct bdk_pemx_clk_en_cn9 cnf95xx; */
    /* struct bdk_pemx_clk_en_cn96xxp3 loki; */
};
typedef union bdk_pemx_clk_en bdk_pemx_clk_en_t;

static inline uint64_t BDK_PEMX_CLK_EN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CLK_EN(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000400ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000400ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000c8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000c8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000c8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000c8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CLK_EN", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CLK_EN(a) bdk_pemx_clk_en_t
#define bustype_BDK_PEMX_CLK_EN(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CLK_EN(a) "PEMX_CLK_EN"
#define device_bar_BDK_PEMX_CLK_EN(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CLK_EN(a) (a)
#define arguments_BDK_PEMX_CLK_EN(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_cmerge_merged_pc
 *
 * PEM Merge Completions Merged Performance Counter Register
 * This register is a performance counter of how many completions merged within the
 * outbound completion merge units.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_cmerge_merged_pc
{
    uint64_t u;
    struct bdk_pemx_cmerge_merged_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBO completion operation that merges with a previous
                                                                 read will increment this count. */
#else /* Word 0 - Little Endian */
        uint64_t cmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBO completion operation that merges with a previous
                                                                 read will increment this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_cmerge_merged_pc_s cn; */
};
typedef union bdk_pemx_cmerge_merged_pc bdk_pemx_cmerge_merged_pc_t;

static inline uint64_t BDK_PEMX_CMERGE_MERGED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CMERGE_MERGED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001b8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001b8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001b8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001b8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CMERGE_MERGED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CMERGE_MERGED_PC(a) bdk_pemx_cmerge_merged_pc_t
#define bustype_BDK_PEMX_CMERGE_MERGED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CMERGE_MERGED_PC(a) "PEMX_CMERGE_MERGED_PC"
#define device_bar_BDK_PEMX_CMERGE_MERGED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CMERGE_MERGED_PC(a) (a)
#define arguments_BDK_PEMX_CMERGE_MERGED_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_cmerge_received_pc
 *
 * PEM Merge Completions Received Performance Counter Register
 * This register reports the number of reads that enter the outbound read merge unit.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_cmerge_received_pc
{
    uint64_t u;
    struct bdk_pemx_cmerge_received_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cmerge_reads          : 64; /**< [ 63:  0](R/W/H) Each NCBO completion operation increments this count. */
#else /* Word 0 - Little Endian */
        uint64_t cmerge_reads          : 64; /**< [ 63:  0](R/W/H) Each NCBO completion operation increments this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_cmerge_received_pc_s cn; */
};
typedef union bdk_pemx_cmerge_received_pc bdk_pemx_cmerge_received_pc_t;

static inline uint64_t BDK_PEMX_CMERGE_RECEIVED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CMERGE_RECEIVED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001b0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001b0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001b0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001b0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CMERGE_RECEIVED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CMERGE_RECEIVED_PC(a) bdk_pemx_cmerge_received_pc_t
#define bustype_BDK_PEMX_CMERGE_RECEIVED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CMERGE_RECEIVED_PC(a) "PEMX_CMERGE_RECEIVED_PC"
#define device_bar_BDK_PEMX_CMERGE_RECEIVED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CMERGE_RECEIVED_PC(a) (a)
#define arguments_BDK_PEMX_CMERGE_RECEIVED_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_const_acc
 *
 * PEM Constant ACC Register
 * Contains contant attributes related to the PEM ACC tables.
 */
union bdk_pemx_const_acc
{
    uint64_t u;
    struct bdk_pemx_const_acc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t bits_huge             : 16; /**< [ 63: 48](RO) Number of bits in the address aperture for a huge-sized ACC table entry. See
                                                                 PEM()_REG_HUGE()_ACC. */
        uint64_t num_huge              : 16; /**< [ 47: 32](RO) Number of huge-sized ACC table entries. See PEM()_REG_HUGE()_ACC. */
        uint64_t bits_norm             : 16; /**< [ 31: 16](RO) Number of bits in the address aperture for a normal-sized ACC table entry. See
                                                                 PEM()_REG_NORM()_ACC. */
        uint64_t num_norm              : 16; /**< [ 15:  0](RO) Number of normal-sized ACC table entries. See PEM()_REG_NORM()_ACC. */
#else /* Word 0 - Little Endian */
        uint64_t num_norm              : 16; /**< [ 15:  0](RO) Number of normal-sized ACC table entries. See PEM()_REG_NORM()_ACC. */
        uint64_t bits_norm             : 16; /**< [ 31: 16](RO) Number of bits in the address aperture for a normal-sized ACC table entry. See
                                                                 PEM()_REG_NORM()_ACC. */
        uint64_t num_huge              : 16; /**< [ 47: 32](RO) Number of huge-sized ACC table entries. See PEM()_REG_HUGE()_ACC. */
        uint64_t bits_huge             : 16; /**< [ 63: 48](RO) Number of bits in the address aperture for a huge-sized ACC table entry. See
                                                                 PEM()_REG_HUGE()_ACC. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_const_acc_s cn; */
};
typedef union bdk_pemx_const_acc bdk_pemx_const_acc_t;

static inline uint64_t BDK_PEMX_CONST_ACC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CONST_ACC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000218ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000218ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000218ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000218ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CONST_ACC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CONST_ACC(a) bdk_pemx_const_acc_t
#define bustype_BDK_PEMX_CONST_ACC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CONST_ACC(a) "PEMX_CONST_ACC"
#define device_bar_BDK_PEMX_CONST_ACC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CONST_ACC(a) (a)
#define arguments_BDK_PEMX_CONST_ACC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_cpl_lut_valid
 *
 * PEM Completion Lookup Table Valid Register
 * This register specifies how many tags are outstanding for reads.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_cpl_lut_valid
{
    uint64_t u;
    struct bdk_pemx_cpl_lut_valid_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tag                   : 64; /**< [ 63:  0](RO/H) Bit vector set corresponds to an outstanding tag. */
#else /* Word 0 - Little Endian */
        uint64_t tag                   : 64; /**< [ 63:  0](RO/H) Bit vector set corresponds to an outstanding tag. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_cpl_lut_valid_s cn8; */
    struct bdk_pemx_cpl_lut_valid_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t tag                   : 10; /**< [  9:  0](RO/H) Number of read tags outstanding for outbound reads on PCIe. */
#else /* Word 0 - Little Endian */
        uint64_t tag                   : 10; /**< [  9:  0](RO/H) Number of read tags outstanding for outbound reads on PCIe. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_cpl_lut_valid bdk_pemx_cpl_lut_valid_t;

static inline uint64_t BDK_PEMX_CPL_LUT_VALID(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CPL_LUT_VALID(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000098ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000098ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000040ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000040ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000040ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000040ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CPL_LUT_VALID", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CPL_LUT_VALID(a) bdk_pemx_cpl_lut_valid_t
#define bustype_BDK_PEMX_CPL_LUT_VALID(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CPL_LUT_VALID(a) "PEMX_CPL_LUT_VALID"
#define device_bar_BDK_PEMX_CPL_LUT_VALID(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CPL_LUT_VALID(a) (a)
#define arguments_BDK_PEMX_CPL_LUT_VALID(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_csclk_active_pc
 *
 * PEM Conditional Coprocessor Clock Counter Register
 * This register counts conditional clocks for power management.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_csclk_active_pc
{
    uint64_t u;
    struct bdk_pemx_csclk_active_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Count of conditional coprocessor-clock cycles since reset. */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Count of conditional coprocessor-clock cycles since reset. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_csclk_active_pc_s cn; */
};
typedef union bdk_pemx_csclk_active_pc bdk_pemx_csclk_active_pc_t;

static inline uint64_t BDK_PEMX_CSCLK_ACTIVE_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CSCLK_ACTIVE_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000058ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000058ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000058ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000058ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CSCLK_ACTIVE_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CSCLK_ACTIVE_PC(a) bdk_pemx_csclk_active_pc_t
#define bustype_BDK_PEMX_CSCLK_ACTIVE_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CSCLK_ACTIVE_PC(a) "PEMX_CSCLK_ACTIVE_PC"
#define device_bar_BDK_PEMX_CSCLK_ACTIVE_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CSCLK_ACTIVE_PC(a) (a)
#define arguments_BDK_PEMX_CSCLK_ACTIVE_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ctl_status
 *
 * PEM Control Status Register
 * This is a general control and status register of the PEM.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset. Note this differs from PEM()_CTL_STATUS2's reset.
 */
union bdk_pemx_ctl_status
{
    uint64_t u;
    struct bdk_pemx_ctl_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t inb_grant_limit       : 3;  /**< [ 54: 52](R/W) The number of inbound TLPs allowed in flight in PEM.to improve
                                                                 small TLP performance. */
        uint64_t reserved_51           : 1;
        uint64_t inv_dpar              : 1;  /**< [ 50: 50](R/W) Invert the generated parity to be written into the most significant data queue buffer RAM
                                                                 block to force a parity error when it is later read. */
        uint64_t reserved_32_49        : 18;
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t reserved_9_15         : 7;
        uint64_t clk_req_n             : 1;  /**< [  8:  8](R/W) Indicates that the application logic is ready to have reference clock
                                                                 removed.

                                                                 0 = The application does not want to have the reference clock removed.

                                                                 1 = The application is ready to have the reference clock removed through
                                                                 either L1 PM Sub-states or L1 CPM.

                                                                 Internal:
                                                                 Controls app_clk_req_n input to the DW core. */
        uint64_t rdy_entr_l23          : 1;  /**< [  7:  7](R/W) Application ready to enter L23.  Indication that the application is
                                                                 ready to enter the L23 state. This provides control of the L23 entry
                                                                 (in case certain tasks must be performed before going into L23).
                                                                 The Mac delays sending PM_Enter_L23 (in response to PM_Turn_Off)
                                                                 until this signal becomes active. When this signal has been asserted
                                                                 by the application, it must be kept asserted until L2 entry has completed

                                                                 Internal:
                                                                 Controls app_ready_entr_l23 input to the DW core. */
        uint64_t reserved_5_6          : 2;
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t reserved_3            : 1;
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
#else /* Word 0 - Little Endian */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t reserved_3            : 1;
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t reserved_5_6          : 2;
        uint64_t rdy_entr_l23          : 1;  /**< [  7:  7](R/W) Application ready to enter L23.  Indication that the application is
                                                                 ready to enter the L23 state. This provides control of the L23 entry
                                                                 (in case certain tasks must be performed before going into L23).
                                                                 The Mac delays sending PM_Enter_L23 (in response to PM_Turn_Off)
                                                                 until this signal becomes active. When this signal has been asserted
                                                                 by the application, it must be kept asserted until L2 entry has completed

                                                                 Internal:
                                                                 Controls app_ready_entr_l23 input to the DW core. */
        uint64_t clk_req_n             : 1;  /**< [  8:  8](R/W) Indicates that the application logic is ready to have reference clock
                                                                 removed.

                                                                 0 = The application does not want to have the reference clock removed.

                                                                 1 = The application is ready to have the reference clock removed through
                                                                 either L1 PM Sub-states or L1 CPM.

                                                                 Internal:
                                                                 Controls app_clk_req_n input to the DW core. */
        uint64_t reserved_9_15         : 7;
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t reserved_32_49        : 18;
        uint64_t inv_dpar              : 1;  /**< [ 50: 50](R/W) Invert the generated parity to be written into the most significant data queue buffer RAM
                                                                 block to force a parity error when it is later read. */
        uint64_t reserved_51           : 1;
        uint64_t inb_grant_limit       : 3;  /**< [ 54: 52](R/W) The number of inbound TLPs allowed in flight in PEM.to improve
                                                                 small TLP performance. */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_ctl_status_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t inb_grant_limit       : 3;  /**< [ 54: 52](R/W) The number of inbound TLPs allowed in flight in PEM.to improve
                                                                 small TLP performance. */
        uint64_t reserved_51           : 1;
        uint64_t inv_dpar              : 1;  /**< [ 50: 50](R/W) Invert the generated parity to be written into the most significant data queue buffer RAM
                                                                 block to force a parity error when it is later read. */
        uint64_t reserved_48_49        : 2;
        uint64_t auto_sd               : 1;  /**< [ 47: 47](RO/H) Link hardware autonomous speed disable. */
        uint64_t dnum                  : 5;  /**< [ 46: 42](RO/H) Primary bus device number. */
        uint64_t pbus                  : 8;  /**< [ 41: 34](RO/H) Primary bus number. */
        uint64_t reserved_32_33        : 2;
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t spares                : 4;  /**< [ 15: 12](R/W) Spare flops. */
        uint64_t pm_xtoff              : 1;  /**< [ 11: 11](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_turnoff port. RC mode. */
        uint64_t pm_xpme               : 1;  /**< [ 10: 10](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_pme port. EP mode. */
        uint64_t ob_p_cmd              : 1;  /**< [  9:  9](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core outband_pwrup_cmd
                                                                 port. EP mode. */
        uint64_t reserved_7_8          : 2;
        uint64_t nf_ecrc               : 1;  /**< [  6:  6](R/W) Do not forward peer-to-peer ECRC TLPs. */
        uint64_t dly_one               : 1;  /**< [  5:  5](R/W/H) When set the output client state machines will wait one cycle before starting a new TLP out. */
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t ro_ctlp               : 1;  /**< [  3:  3](R/W) When set, C-TLPs that have the RO bit set will not wait for P-TLPs that are normally sent first. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
#else /* Word 0 - Little Endian */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t ro_ctlp               : 1;  /**< [  3:  3](R/W) When set, C-TLPs that have the RO bit set will not wait for P-TLPs that are normally sent first. */
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t dly_one               : 1;  /**< [  5:  5](R/W/H) When set the output client state machines will wait one cycle before starting a new TLP out. */
        uint64_t nf_ecrc               : 1;  /**< [  6:  6](R/W) Do not forward peer-to-peer ECRC TLPs. */
        uint64_t reserved_7_8          : 2;
        uint64_t ob_p_cmd              : 1;  /**< [  9:  9](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core outband_pwrup_cmd
                                                                 port. EP mode. */
        uint64_t pm_xpme               : 1;  /**< [ 10: 10](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_pme port. EP mode. */
        uint64_t pm_xtoff              : 1;  /**< [ 11: 11](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_turnoff port. RC mode. */
        uint64_t spares                : 4;  /**< [ 15: 12](R/W) Spare flops. */
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t reserved_32_33        : 2;
        uint64_t pbus                  : 8;  /**< [ 41: 34](RO/H) Primary bus number. */
        uint64_t dnum                  : 5;  /**< [ 46: 42](RO/H) Primary bus device number. */
        uint64_t auto_sd               : 1;  /**< [ 47: 47](RO/H) Link hardware autonomous speed disable. */
        uint64_t reserved_48_49        : 2;
        uint64_t inv_dpar              : 1;  /**< [ 50: 50](R/W) Invert the generated parity to be written into the most significant data queue buffer RAM
                                                                 block to force a parity error when it is later read. */
        uint64_t reserved_51           : 1;
        uint64_t inb_grant_limit       : 3;  /**< [ 54: 52](R/W) The number of inbound TLPs allowed in flight in PEM.to improve
                                                                 small TLP performance. */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_ctl_status_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t inb_grant_limit       : 3;  /**< [ 54: 52](R/W) The number of inbound TLPs allowed in flight in PEM.to improve
                                                                 small TLP performance. */
        uint64_t reserved_51           : 1;
        uint64_t inv_dpar              : 1;  /**< [ 50: 50](R/W) Invert the generated parity to be written into the most significant data queue buffer RAM
                                                                 block to force a parity error when it is later read. */
        uint64_t reserved_48_49        : 2;
        uint64_t auto_sd               : 1;  /**< [ 47: 47](RO/H) Link hardware autonomous speed disable. */
        uint64_t dnum                  : 5;  /**< [ 46: 42](RO/H) Primary bus device number. */
        uint64_t pbus                  : 8;  /**< [ 41: 34](RO/H) Primary bus number. */
        uint64_t reserved_32_33        : 2;
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t spares                : 4;  /**< [ 15: 12](R/W) Spare flops. */
        uint64_t pm_xtoff              : 1;  /**< [ 11: 11](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_turnoff port. RC mode. */
        uint64_t reserved_6_10         : 5;
        uint64_t dly_one               : 1;  /**< [  5:  5](R/W/H) When set the output client state machines will wait one cycle before starting a new TLP out. */
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t ro_ctlp               : 1;  /**< [  3:  3](R/W) When set, C-TLPs that have the RO bit set will not wait for P-TLPs that are normally sent first. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
#else /* Word 0 - Little Endian */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t ro_ctlp               : 1;  /**< [  3:  3](R/W) When set, C-TLPs that have the RO bit set will not wait for P-TLPs that are normally sent first. */
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t dly_one               : 1;  /**< [  5:  5](R/W/H) When set the output client state machines will wait one cycle before starting a new TLP out. */
        uint64_t reserved_6_10         : 5;
        uint64_t pm_xtoff              : 1;  /**< [ 11: 11](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_turnoff port. RC mode. */
        uint64_t spares                : 4;  /**< [ 15: 12](R/W) Spare flops. */
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t reserved_32_33        : 2;
        uint64_t pbus                  : 8;  /**< [ 41: 34](RO/H) Primary bus number. */
        uint64_t dnum                  : 5;  /**< [ 46: 42](RO/H) Primary bus device number. */
        uint64_t auto_sd               : 1;  /**< [ 47: 47](RO/H) Link hardware autonomous speed disable. */
        uint64_t reserved_48_49        : 2;
        uint64_t inv_dpar              : 1;  /**< [ 50: 50](R/W) Invert the generated parity to be written into the most significant data queue buffer RAM
                                                                 block to force a parity error when it is later read. */
        uint64_t reserved_51           : 1;
        uint64_t inb_grant_limit       : 3;  /**< [ 54: 52](R/W) The number of inbound TLPs allowed in flight in PEM.to improve
                                                                 small TLP performance. */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_ctl_status_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t auto_sd               : 1;  /**< [ 47: 47](RO/H) Link hardware autonomous speed disable. */
        uint64_t dnum                  : 5;  /**< [ 46: 42](RO/H) Primary bus device number. */
        uint64_t pbus                  : 8;  /**< [ 41: 34](RO/H) Primary bus number. */
        uint64_t reserved_32_33        : 2;
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t spares                : 4;  /**< [ 15: 12](R/W) Spare flops. */
        uint64_t pm_xtoff              : 1;  /**< [ 11: 11](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_turnoff port. RC mode. */
        uint64_t pm_xpme               : 1;  /**< [ 10: 10](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_pme port. EP mode. */
        uint64_t ob_p_cmd              : 1;  /**< [  9:  9](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core outband_pwrup_cmd
                                                                 port. EP mode. */
        uint64_t reserved_8            : 1;
        uint64_t reserved_7            : 1;
        uint64_t nf_ecrc               : 1;  /**< [  6:  6](R/W) Do not forward peer-to-peer ECRC TLPs. */
        uint64_t reserved_5            : 1;
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t ro_ctlp               : 1;  /**< [  3:  3](R/W) When set, C-TLPs that have the RO bit set will not wait for P-TLPs that are normally sent first. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
#else /* Word 0 - Little Endian */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode. */
        uint64_t ro_ctlp               : 1;  /**< [  3:  3](R/W) When set, C-TLPs that have the RO bit set will not wait for P-TLPs that are normally sent first. */
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W) When set, the link is enabled; when clear (0) the link is disabled. This bit only is
                                                                 active when in RC mode. */
        uint64_t reserved_5            : 1;
        uint64_t nf_ecrc               : 1;  /**< [  6:  6](R/W) Do not forward peer-to-peer ECRC TLPs. */
        uint64_t reserved_7            : 1;
        uint64_t reserved_8            : 1;
        uint64_t ob_p_cmd              : 1;  /**< [  9:  9](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core outband_pwrup_cmd
                                                                 port. EP mode. */
        uint64_t pm_xpme               : 1;  /**< [ 10: 10](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_pme port. EP mode. */
        uint64_t pm_xtoff              : 1;  /**< [ 11: 11](R/W/H) When written with one, a single cycle pulse is sent to the PCIe core pm_xmt_turnoff port. RC mode. */
        uint64_t spares                : 4;  /**< [ 15: 12](R/W) Spare flops. */
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 0x10000 in coprocessor clocks to wait for a CPL to a
                                                                 configuration read that does not carry a retry status. Until such time that the
                                                                 timeout occurs and retry status is received for a configuration read, the read
                                                                 will be resent. A value of 0 disables retries and treats a CPL retry as a CPL
                                                                 UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200ms or
                                                                 less, although the PCI Express Base Specification allows up to 900ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t reserved_32_33        : 2;
        uint64_t pbus                  : 8;  /**< [ 41: 34](RO/H) Primary bus number. */
        uint64_t dnum                  : 5;  /**< [ 46: 42](RO/H) Primary bus device number. */
        uint64_t auto_sd               : 1;  /**< [ 47: 47](RO/H) Link hardware autonomous speed disable. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_ctl_status_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_46_63        : 18;
        uint64_t auto_sd               : 1;  /**< [ 45: 45](RO/H) Link hardware autonomous speed disable. */
        uint64_t dnum                  : 5;  /**< [ 44: 40](RO/H) Primary bus device number. */
        uint64_t pbus                  : 8;  /**< [ 39: 32](RO/H) Primary bus number. */
        uint64_t reserved_16_31        : 16;
        uint64_t spares                : 2;  /**< [ 15: 14](R/W) Spare flops. */
        uint64_t scr_done              : 1;  /**< [ 13: 13](R/W) The ROM script (if present) can test this bit to see if the ROM script has
                                                                 already run. Typical usage is for the ROM script to test [SCR_DONE] and exit if
                                                                 true, else at the end of the ROM script, the script sets this bit. */
        uint64_t pm_xtoff              : 1;  /**< [ 12: 12](WO) When written with one, a single cycle pulse to request from application
                                                                 to generate a PM_Turn_Off message. RC mode.

                                                                 Internal:
                                                                 Controls apps_pm_xmt_turnoff input to the DW core. */
        uint64_t auto_mode             : 1;  /**< [ 11: 11](R/W) Hardware behavior after MAC reset occurs.

                                                                 0 = No hardware intervention for MAC reset / link down (including hot reset).
                                                                 Firmware is responsible for bringing the link up after detecting that a MAC reset has occurred.

                                                                 1 = After MAC reset has deasserted, hardware will automatically set [PLAY]=1.
                                                                 Upon completion of config writes from the Config Table ([PLAY]==0), hardware will set [LNK_ENB]=1.

                                                                 For CNXXXX, this bit should always be set. */
        uint64_t play                  : 1;  /**< [ 10: 10](R/W/H) When written with a one, config registers in PEM()_CFG_TBL() entries 0 through
                                                                 PEM()_CFG_TBL_SIZE[SIZE]-1
                                                                 will be read and the corresponding CSR writes performed. Hardware clears this bit when complete.
                                                                 Hardware automatically sets this bit after MAC reset when [AUTO_MODE] is set. */
        uint64_t ccrs                  : 1;  /**< [  9:  9](R/W) When set, PEM will automatically clear [FRC_RETRY] after the config replay is complete. */
        uint64_t clk_req_n             : 1;  /**< [  8:  8](R/W) Indicates that the application logic is ready to have reference clock
                                                                 removed.

                                                                 0 = The application does not want to have the reference clock removed.

                                                                 1 = The application is ready to have the reference clock removed through
                                                                 either L1 PM Sub-states or L1 CPM.

                                                                 Internal:
                                                                 Controls app_clk_req_n input to the DW core. */
        uint64_t rdy_entr_l23          : 1;  /**< [  7:  7](R/W) Application ready to enter L23.  Indication that the application is
                                                                 ready to enter the L23 state. This provides control of the L23 entry
                                                                 (in case certain tasks must be performed before going into L23).
                                                                 The Mac delays sending PM_Enter_L23 (in response to PM_Turn_Off)
                                                                 until this signal becomes active. When this signal has been asserted
                                                                 by the application, it must be kept asserted until L2 entry has completed

                                                                 Internal:
                                                                 Controls app_ready_entr_l23 input to the DW core. */
        uint64_t margin_rdy            : 1;  /**< [  6:  6](R/W) Margining ready. Indicates when the PHY ready to accept margining commands. This
                                                                 signal is reflected in PCIEEP_MRG_PORT_CAP_STAT[M_RDY] /
                                                                 PCIERC_MRG_PORT_CAP_STAT[M_RDY].

                                                                 Internal:
                                                                 Controls app_margining_ready input to the DW core. */
        uint64_t frc_retry             : 1;  /**< [  5:  5](R/W) When set, forces CRS status to be returned for any config access.

                                                                 Hardware auto clears when CCRS is set and on the completion of
                                                                 config writes from the Config Table.

                                                                 Internal:
                                                                 Controls app_req_retry_en input to the DW core. */
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W/H) Link Enable.

                                                                 Will hardware autoclear with Mac reset.

                                                                 Will hardware autoset if AUTOMODE is set and on the completion of
                                                                 config writes from the Config Table.

                                                                 Internal:
                                                                 Controls app_ltssm_en input to the DW core. */
        uint64_t l1_exit               : 1;  /**< [  3:  3](R/W) L1 exit control.
                                                                 0 = Hardware is allowed to enter L1 power state and will only exit when woken
                                                                 up by the remote link partner or traffic arrives on NCBO or EBO busses.
                                                                 1 = Entry into L1 state is disabled and if already in L1 state, will force an
                                                                 exit.

                                                                 Internal:
                                                                 Controls app_req_exit_l1 input high to the DW core. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode.
                                                                 Internal:
                                                                 Controls diag_ctrl_bus[2] input to the DW core. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted.
                                                                 Internal:
                                                                 Controls diag_ctrl_bus[1] input to the DW core. */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted.
                                                                 Internal:
                                                                 Controls diag_ctrl_bus[0] input to the DW core. */
#else /* Word 0 - Little Endian */
        uint64_t inv_lcrc              : 1;  /**< [  0:  0](R/W) When set, causes the LSB of the LCRC to be inverted.
                                                                 Internal:
                                                                 Controls diag_ctrl_bus[0] input to the DW core. */
        uint64_t inv_ecrc              : 1;  /**< [  1:  1](R/W) When set, causes the LSB of the ECRC to be inverted.
                                                                 Internal:
                                                                 Controls diag_ctrl_bus[1] input to the DW core. */
        uint64_t fast_lm               : 1;  /**< [  2:  2](R/W) When set, forces fast link mode.
                                                                 Internal:
                                                                 Controls diag_ctrl_bus[2] input to the DW core. */
        uint64_t l1_exit               : 1;  /**< [  3:  3](R/W) L1 exit control.
                                                                 0 = Hardware is allowed to enter L1 power state and will only exit when woken
                                                                 up by the remote link partner or traffic arrives on NCBO or EBO busses.
                                                                 1 = Entry into L1 state is disabled and if already in L1 state, will force an
                                                                 exit.

                                                                 Internal:
                                                                 Controls app_req_exit_l1 input high to the DW core. */
        uint64_t lnk_enb               : 1;  /**< [  4:  4](R/W/H) Link Enable.

                                                                 Will hardware autoclear with Mac reset.

                                                                 Will hardware autoset if AUTOMODE is set and on the completion of
                                                                 config writes from the Config Table.

                                                                 Internal:
                                                                 Controls app_ltssm_en input to the DW core. */
        uint64_t frc_retry             : 1;  /**< [  5:  5](R/W) When set, forces CRS status to be returned for any config access.

                                                                 Hardware auto clears when CCRS is set and on the completion of
                                                                 config writes from the Config Table.

                                                                 Internal:
                                                                 Controls app_req_retry_en input to the DW core. */
        uint64_t margin_rdy            : 1;  /**< [  6:  6](R/W) Margining ready. Indicates when the PHY ready to accept margining commands. This
                                                                 signal is reflected in PCIEEP_MRG_PORT_CAP_STAT[M_RDY] /
                                                                 PCIERC_MRG_PORT_CAP_STAT[M_RDY].

                                                                 Internal:
                                                                 Controls app_margining_ready input to the DW core. */
        uint64_t rdy_entr_l23          : 1;  /**< [  7:  7](R/W) Application ready to enter L23.  Indication that the application is
                                                                 ready to enter the L23 state. This provides control of the L23 entry
                                                                 (in case certain tasks must be performed before going into L23).
                                                                 The Mac delays sending PM_Enter_L23 (in response to PM_Turn_Off)
                                                                 until this signal becomes active. When this signal has been asserted
                                                                 by the application, it must be kept asserted until L2 entry has completed

                                                                 Internal:
                                                                 Controls app_ready_entr_l23 input to the DW core. */
        uint64_t clk_req_n             : 1;  /**< [  8:  8](R/W) Indicates that the application logic is ready to have reference clock
                                                                 removed.

                                                                 0 = The application does not want to have the reference clock removed.

                                                                 1 = The application is ready to have the reference clock removed through
                                                                 either L1 PM Sub-states or L1 CPM.

                                                                 Internal:
                                                                 Controls app_clk_req_n input to the DW core. */
        uint64_t ccrs                  : 1;  /**< [  9:  9](R/W) When set, PEM will automatically clear [FRC_RETRY] after the config replay is complete. */
        uint64_t play                  : 1;  /**< [ 10: 10](R/W/H) When written with a one, config registers in PEM()_CFG_TBL() entries 0 through
                                                                 PEM()_CFG_TBL_SIZE[SIZE]-1
                                                                 will be read and the corresponding CSR writes performed. Hardware clears this bit when complete.
                                                                 Hardware automatically sets this bit after MAC reset when [AUTO_MODE] is set. */
        uint64_t auto_mode             : 1;  /**< [ 11: 11](R/W) Hardware behavior after MAC reset occurs.

                                                                 0 = No hardware intervention for MAC reset / link down (including hot reset).
                                                                 Firmware is responsible for bringing the link up after detecting that a MAC reset has occurred.

                                                                 1 = After MAC reset has deasserted, hardware will automatically set [PLAY]=1.
                                                                 Upon completion of config writes from the Config Table ([PLAY]==0), hardware will set [LNK_ENB]=1.

                                                                 For CNXXXX, this bit should always be set. */
        uint64_t pm_xtoff              : 1;  /**< [ 12: 12](WO) When written with one, a single cycle pulse to request from application
                                                                 to generate a PM_Turn_Off message. RC mode.

                                                                 Internal:
                                                                 Controls apps_pm_xmt_turnoff input to the DW core. */
        uint64_t scr_done              : 1;  /**< [ 13: 13](R/W) The ROM script (if present) can test this bit to see if the ROM script has
                                                                 already run. Typical usage is for the ROM script to test [SCR_DONE] and exit if
                                                                 true, else at the end of the ROM script, the script sets this bit. */
        uint64_t spares                : 2;  /**< [ 15: 14](R/W) Spare flops. */
        uint64_t reserved_16_31        : 16;
        uint64_t pbus                  : 8;  /**< [ 39: 32](RO/H) Primary bus number. */
        uint64_t dnum                  : 5;  /**< [ 44: 40](RO/H) Primary bus device number. */
        uint64_t auto_sd               : 1;  /**< [ 45: 45](RO/H) Link hardware autonomous speed disable. */
        uint64_t reserved_46_63        : 18;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_ctl_status bdk_pemx_ctl_status_t;

static inline uint64_t BDK_PEMX_CTL_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CTL_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000000ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000000ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000000ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000000ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000000ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CTL_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CTL_STATUS(a) bdk_pemx_ctl_status_t
#define bustype_BDK_PEMX_CTL_STATUS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CTL_STATUS(a) "PEMX_CTL_STATUS"
#define device_bar_BDK_PEMX_CTL_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CTL_STATUS(a) (a)
#define arguments_BDK_PEMX_CTL_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ctl_status2
 *
 * PEM Control Status 2 Register
 * This register contains additional general control and status of the PEM.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset. Note this differs from PEM()_CTL_STATUS's reset.
 */
union bdk_pemx_ctl_status2
{
    uint64_t u;
    struct bdk_pemx_ctl_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t trgt1_ecc_cor_dis     : 1;  /**< [ 32: 32](R/W) Disable correction of single bit ECC errors on TRGT1 data from PEMC to PEMM. */
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 655,360 ns clocks to wait for a CPL to an
                                                                 outbound configuration read that does not carry a retry status. Until such time
                                                                 that the timeout occurs and retry status is received for a configuration read,
                                                                 the read will be resent. A value of zero disables retries and treats a CPL retry
                                                                 as a CPL UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200 ms or
                                                                 less, although the PCI express base specification allows up to 900 ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t no_fwd_prg            : 16; /**< [ 15:  0](R/W) The time * 0x10000 in core clocks to wait for the TLP FIFOs to be able to unload an entry.
                                                                 If there is no forward progress, such that the timeout occurs, credits are returned to the
                                                                 SLI and an interrupt (if enabled) is asserted. Any more TLPs received are dropped on the
                                                                 floor and the credits associated with those TLPs are returned as well. Note that 0xFFFF is
                                                                 a reserved value that will put the PEM in the 'forward progress stopped' state
                                                                 immediately. This state holds until a MAC reset is received. */
#else /* Word 0 - Little Endian */
        uint64_t no_fwd_prg            : 16; /**< [ 15:  0](R/W) The time * 0x10000 in core clocks to wait for the TLP FIFOs to be able to unload an entry.
                                                                 If there is no forward progress, such that the timeout occurs, credits are returned to the
                                                                 SLI and an interrupt (if enabled) is asserted. Any more TLPs received are dropped on the
                                                                 floor and the credits associated with those TLPs are returned as well. Note that 0xFFFF is
                                                                 a reserved value that will put the PEM in the 'forward progress stopped' state
                                                                 immediately. This state holds until a MAC reset is received. */
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 655,360 ns clocks to wait for a CPL to an
                                                                 outbound configuration read that does not carry a retry status. Until such time
                                                                 that the timeout occurs and retry status is received for a configuration read,
                                                                 the read will be resent. A value of zero disables retries and treats a CPL retry
                                                                 as a CPL UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200 ms or
                                                                 less, although the PCI express base specification allows up to 900 ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t trgt1_ecc_cor_dis     : 1;  /**< [ 32: 32](R/W) Disable correction of single bit ECC errors on TRGT1 data from PEMC to PEMM. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_ctl_status2_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t no_fwd_prg            : 16; /**< [ 15:  0](R/W) The time * 0x10000 in core clocks to wait for the TLP FIFOs to be able to unload an entry.
                                                                 If there is no forward progress, such that the timeout occurs, credits are returned to the
                                                                 SLI and an interrupt (if enabled) is asserted. Any more TLPs received are dropped on the
                                                                 floor and the credits associated with those TLPs are returned as well. Note that 0xFFFF is
                                                                 a reserved value that will put the PEM in the 'forward progress stopped' state
                                                                 immediately. This state holds until a MAC reset is received. */
#else /* Word 0 - Little Endian */
        uint64_t no_fwd_prg            : 16; /**< [ 15:  0](R/W) The time * 0x10000 in core clocks to wait for the TLP FIFOs to be able to unload an entry.
                                                                 If there is no forward progress, such that the timeout occurs, credits are returned to the
                                                                 SLI and an interrupt (if enabled) is asserted. Any more TLPs received are dropped on the
                                                                 floor and the credits associated with those TLPs are returned as well. Note that 0xFFFF is
                                                                 a reserved value that will put the PEM in the 'forward progress stopped' state
                                                                 immediately. This state holds until a MAC reset is received. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_ctl_status2_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t trgt1_ecc_cor_dis     : 1;  /**< [ 32: 32](R/W) Disable correction of single bit ECC errors on TRGT1 data from PEMC to PEMM. */
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 655,360 ns clocks to wait for a CPL to an
                                                                 outbound configuration read that does not carry a retry status. Until such time
                                                                 that the timeout occurs and retry status is received for a configuration read,
                                                                 the read will be resent. A value of zero disables retries and treats a CPL retry
                                                                 as a CPL UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200 ms or
                                                                 less, although the PCI express base specification allows up to 900 ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t no_fwd_prg            : 16; /**< [ 15:  0](R/W) The time in units of 655,360 ns clocks to wait for the TLP FIFOs to be able to
                                                                 unload an outbound entry. If there is no forward progress, such that the timeout
                                                                 occurs, credits are returned to the originating bus and an interrupt (if enabled)
                                                                 is asserted. Further TLPs received are dropped on the floor and the credits
                                                                 associated with those TLPs are returned as well. Non-Posted are dropped with a
                                                                 completion returned (all 1's if config else completion with fault). Note that 0x0000
                                                                 will block detection of no forward progress.  Note that 0xFFFF is a reserved value
                                                                 that will immediately place the PEM into the 'forward progress stopped' state.
                                                                 This state holds until a MAC reset is received. */
#else /* Word 0 - Little Endian */
        uint64_t no_fwd_prg            : 16; /**< [ 15:  0](R/W) The time in units of 655,360 ns clocks to wait for the TLP FIFOs to be able to
                                                                 unload an outbound entry. If there is no forward progress, such that the timeout
                                                                 occurs, credits are returned to the originating bus and an interrupt (if enabled)
                                                                 is asserted. Further TLPs received are dropped on the floor and the credits
                                                                 associated with those TLPs are returned as well. Non-Posted are dropped with a
                                                                 completion returned (all 1's if config else completion with fault). Note that 0x0000
                                                                 will block detection of no forward progress.  Note that 0xFFFF is a reserved value
                                                                 that will immediately place the PEM into the 'forward progress stopped' state.
                                                                 This state holds until a MAC reset is received. */
        uint64_t cfg_rtry              : 16; /**< [ 31: 16](R/W) The time in units of 655,360 ns clocks to wait for a CPL to an
                                                                 outbound configuration read that does not carry a retry status. Until such time
                                                                 that the timeout occurs and retry status is received for a configuration read,
                                                                 the read will be resent. A value of zero disables retries and treats a CPL retry
                                                                 as a CPL UR.

                                                                 To use, it is recommended [CFG_RTRY] be set value corresponding to 200 ms or
                                                                 less, although the PCI express base specification allows up to 900 ms for a
                                                                 device to send a successful completion.  When enabled, only one CFG RD may be
                                                                 issued until either successful completion or CPL UR. */
        uint64_t trgt1_ecc_cor_dis     : 1;  /**< [ 32: 32](R/W) Disable correction of single bit ECC errors on TRGT1 data from PEMC to PEMM. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_ctl_status2 bdk_pemx_ctl_status2_t;

static inline uint64_t BDK_PEMX_CTL_STATUS2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CTL_STATUS2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000008ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000130ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000130ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000130ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000130ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_CTL_STATUS2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CTL_STATUS2(a) bdk_pemx_ctl_status2_t
#define bustype_BDK_PEMX_CTL_STATUS2(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_CTL_STATUS2(a) "PEMX_CTL_STATUS2"
#define device_bar_BDK_PEMX_CTL_STATUS2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CTL_STATUS2(a) (a)
#define arguments_BDK_PEMX_CTL_STATUS2(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_ctl_stream
 *
 * PEM EP Mode Stream Register
 * This register is used to generate the SMMU stream ID when in endpoint mode.
 */
union bdk_pemx_ctl_stream
{
    uint64_t u;
    struct bdk_pemx_ctl_stream_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t epsbmax               : 16; /**< [ 31: 16](R/W) The maximum SSU stream ID that will be generated by inbound endpoint
                                                                 transactions. See [EPSBBASE]. Resets to PCC_DEV_CON_E::PCIERC({a}) where {a} is
                                                                 the PEM number. */
        uint64_t epsbbase              : 16; /**< [ 15:  0](R/W) The base SMMU stream ID that will be generated by inbound endpoint
                                                                 transactions. Resets to PCC_DEV_CON_E::PCIERC({a}) where {a} is the PEM number.

                                                                 When in EP mode:
                                                                   _ stream id = min( (PCI_stream_id\<15:0\> + [EPSBBASE]), [EPSBMAX]).

                                                                 When [EPSBBASE]/[EPSBMAX] are changed from the reset values then:

                                                                 * Different endpoint requestors will map to different SMMU streams, enabling the
                                                                 possibility of having different SMMU translations for each endpoint requestor.

                                                                 * Software must ensure that [EPSBBASE]...[EPSBMAX] are non-overlapping between
                                                                 all endpoint PEMs and non-overlapping with existing PCC devices.

                                                                 * IOBN()_SLITAG()_CONTROL[BITS_DIS] must be set. */
#else /* Word 0 - Little Endian */
        uint64_t epsbbase              : 16; /**< [ 15:  0](R/W) The base SMMU stream ID that will be generated by inbound endpoint
                                                                 transactions. Resets to PCC_DEV_CON_E::PCIERC({a}) where {a} is the PEM number.

                                                                 When in EP mode:
                                                                   _ stream id = min( (PCI_stream_id\<15:0\> + [EPSBBASE]), [EPSBMAX]).

                                                                 When [EPSBBASE]/[EPSBMAX] are changed from the reset values then:

                                                                 * Different endpoint requestors will map to different SMMU streams, enabling the
                                                                 possibility of having different SMMU translations for each endpoint requestor.

                                                                 * Software must ensure that [EPSBBASE]...[EPSBMAX] are non-overlapping between
                                                                 all endpoint PEMs and non-overlapping with existing PCC devices.

                                                                 * IOBN()_SLITAG()_CONTROL[BITS_DIS] must be set. */
        uint64_t epsbmax               : 16; /**< [ 31: 16](R/W) The maximum SSU stream ID that will be generated by inbound endpoint
                                                                 transactions. See [EPSBBASE]. Resets to PCC_DEV_CON_E::PCIERC({a}) where {a} is
                                                                 the PEM number. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ctl_stream_s cn; */
};
typedef union bdk_pemx_ctl_stream bdk_pemx_ctl_stream_t;

static inline uint64_t BDK_PEMX_CTL_STREAM(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_CTL_STREAM(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c00004d0ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_CTL_STREAM", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_CTL_STREAM(a) bdk_pemx_ctl_stream_t
#define bustype_BDK_PEMX_CTL_STREAM(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_CTL_STREAM(a) "PEMX_CTL_STREAM"
#define device_bar_BDK_PEMX_CTL_STREAM(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_CTL_STREAM(a) (a)
#define arguments_BDK_PEMX_CTL_STREAM(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_dbg_ena_w1c
 *
 * PEM Debug Information Enable Clear Register
 * This register clears interrupt enable bits.
 */
union bdk_pemx_dbg_ena_w1c
{
    uint64_t u;
    struct bdk_pemx_dbg_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t reserved_51_55        : 5;
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t reserved_32           : 1;
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t reserved_32           : 1;
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t reserved_51_55        : 5;
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_dbg_ena_w1c_s cn8; */
    struct bdk_pemx_dbg_ena_w1c_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B1_SBE]. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B0_DBE]. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B0_SBE]. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTRY_DBE]. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTRY_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[DATQ_PE]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t reserved_10           : 1;
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t reserved_10           : 1;
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[DATQ_PE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTRY_SBE]. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[RTRY_DBE]. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B0_SBE]. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B0_DBE]. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B1_SBE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Reads or clears enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_dbg_ena_w1c_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RASDP]. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_D_DBE]. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_D_SBE]. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_C_DBE]. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D0_SBE]. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[BMD_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[SPOISON]. */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[SPOISON]. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[LOFP]. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[BMD_E]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[C_C_DBE]. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_C_SBE]. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_C_DBE]. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_D_SBE]. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[M2S_D_DBE]. */
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1C/H) Reads or clears enable for PEM(0..3)_DBG_INFO[RASDP]. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } cn83xx;
};
typedef union bdk_pemx_dbg_ena_w1c bdk_pemx_dbg_ena_w1c_t;

static inline uint64_t BDK_PEMX_DBG_ENA_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_DBG_ENA_W1C(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000458ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000458ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_DBG_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_DBG_ENA_W1C(a) bdk_pemx_dbg_ena_w1c_t
#define bustype_BDK_PEMX_DBG_ENA_W1C(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_DBG_ENA_W1C(a) "PEMX_DBG_ENA_W1C"
#define device_bar_BDK_PEMX_DBG_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_DBG_ENA_W1C(a) (a)
#define arguments_BDK_PEMX_DBG_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_dbg_ena_w1s
 *
 * PEM Debug Information Enable Set Register
 * This register sets interrupt enable bits.
 */
union bdk_pemx_dbg_ena_w1s
{
    uint64_t u;
    struct bdk_pemx_dbg_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t reserved_51_55        : 5;
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t reserved_32           : 1;
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t reserved_32           : 1;
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t reserved_51_55        : 5;
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_dbg_ena_w1s_s cn8; */
    struct bdk_pemx_dbg_ena_w1s_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B1_SBE]. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B0_DBE]. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B0_SBE]. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTRY_DBE]. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTRY_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[DATQ_PE]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t reserved_10           : 1;
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t reserved_10           : 1;
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[DATQ_PE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTRY_SBE]. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[RTRY_DBE]. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B0_SBE]. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B0_DBE]. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B1_SBE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets enable for PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_dbg_ena_w1s_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RASDP]. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_D_DBE]. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_D_SBE]. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_C_DBE]. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D0_SBE]. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[BMD_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[SPOISON]. */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[SPOISON]. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[LOFP]. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[BMD_E]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[C_C_DBE]. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_C_SBE]. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_C_DBE]. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_D_SBE]. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[M2S_D_DBE]. */
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets enable for PEM(0..3)_DBG_INFO[RASDP]. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } cn83xx;
};
typedef union bdk_pemx_dbg_ena_w1s bdk_pemx_dbg_ena_w1s_t;

static inline uint64_t BDK_PEMX_DBG_ENA_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_DBG_ENA_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000460ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000460ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_DBG_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_DBG_ENA_W1S(a) bdk_pemx_dbg_ena_w1s_t
#define bustype_BDK_PEMX_DBG_ENA_W1S(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_DBG_ENA_W1S(a) "PEMX_DBG_ENA_W1S"
#define device_bar_BDK_PEMX_DBG_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_DBG_ENA_W1S(a) (a)
#define arguments_BDK_PEMX_DBG_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_dbg_info
 *
 * PEM Debug Information Register
 * This is a debug information register of the PEM.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_dbg_info
{
    uint64_t u;
    struct bdk_pemx_dbg_info_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Detected a M2S FIFO parity error. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Detected a core header queue bank1 double-bit error. */
        uint64_t reserved_32_55        : 24;
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent.
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent.
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t reserved_32_55        : 24;
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Detected a core header queue bank1 double-bit error. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Detected a M2S FIFO parity error. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_dbg_info_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Detected a M2S FIFO parity error. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Detected a core header queue bank1 double-bit error. */
        uint64_t reserved_51_55        : 5;
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Detected a TLP CPL FIFO control double-bit error. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Detected a TLP CPL FIFO control single-bit error. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Detected a TLP CPL FIFO data1 double-bit error. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Detected a TLP CPL FIFO data1 single-bit error. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Detected a TLP CPL FIFO data0 double-bit error. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Detected a TLP CPL FIFO data0 single-bit error. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Detected a TLP NP FIFO control double-bit error. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Detected a TLP NP FIFO control single-bit error. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Detected a TLP NP FIFO data1 double-bit error. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Detected a TLP NP FIFO data1 single-bit error. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Detected a TLP NP FIFO data0 double-bit error. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Detected a TLP NP FIFO data0 single-bit error. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Detected a TLP posted FIFO control double-bit error. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Detected a TLP posted FIFO control single-bit error. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Detected a TLP posted FIFO data1 double-bit error. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Detected a TLP posted FIFO data1 single-bit error. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Detected a TLP posted FIFO data0 double-bit error. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Detected a TLP posted FIFO data0 single-bit error. */
        uint64_t reserved_32           : 1;
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent.
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent.
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t reserved_32           : 1;
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Detected a TLP posted FIFO data0 single-bit error. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Detected a TLP posted FIFO data0 double-bit error. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Detected a TLP posted FIFO data1 single-bit error. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Detected a TLP posted FIFO data1 double-bit error. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Detected a TLP posted FIFO control single-bit error. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Detected a TLP posted FIFO control double-bit error. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Detected a TLP NP FIFO data0 single-bit error. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Detected a TLP NP FIFO data0 double-bit error. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Detected a TLP NP FIFO data1 single-bit error. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Detected a TLP NP FIFO data1 double-bit error. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Detected a TLP NP FIFO control single-bit error. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Detected a TLP NP FIFO control double-bit error. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Detected a TLP CPL FIFO data0 single-bit error. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Detected a TLP CPL FIFO data0 double-bit error. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Detected a TLP CPL FIFO data1 single-bit error. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Detected a TLP CPL FIFO data1 double-bit error. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Detected a TLP CPL FIFO control single-bit error. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Detected a TLP CPL FIFO control double-bit error. */
        uint64_t reserved_51_55        : 5;
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Detected a core header queue bank1 double-bit error. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Detected a M2S FIFO parity error. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_dbg_info_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Detected a M2S FIFO parity error. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Detected a core header queue bank1 double-bit error. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1C/H) Detected a core header queue bank1 single-bit error. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1C/H) Detected a core header queue bank0 double-bit error. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1C/H) Detected a core header queue bank0 single-bit error. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1C/H) Detected a core retry RAM double-bit error. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1C/H) Detected a core retry RAM single-bit error. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Detected a TLP CPL FIFO control double-bit error. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Detected a TLP CPL FIFO control single-bit error. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Detected a TLP CPL FIFO data1 double-bit error. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Detected a TLP CPL FIFO data1 single-bit error. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Detected a TLP CPL FIFO data0 double-bit error. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Detected a TLP CPL FIFO data0 single-bit error. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Detected a TLP NP FIFO control double-bit error. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Detected a TLP NP FIFO control single-bit error. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Detected a TLP NP FIFO data1 double-bit error. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Detected a TLP NP FIFO data1 single-bit error. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Detected a TLP NP FIFO data0 double-bit error. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Detected a TLP NP FIFO data0 single-bit error. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Detected a TLP posted FIFO control double-bit error. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Detected a TLP posted FIFO control single-bit error. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Detected a TLP posted FIFO data1 double-bit error. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Detected a TLP posted FIFO data1 single-bit error. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Detected a TLP posted FIFO data0 double-bit error. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Detected a TLP posted FIFO data0 single-bit error. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1C/H) Detected a data queue RAM parity error. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t reserved_10           : 1;
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent.
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent.
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t reserved_10           : 1;
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1C/H) Detected a data queue RAM parity error. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Detected a TLP posted FIFO data0 single-bit error. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Detected a TLP posted FIFO data0 double-bit error. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Detected a TLP posted FIFO data1 single-bit error. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Detected a TLP posted FIFO data1 double-bit error. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Detected a TLP posted FIFO control single-bit error. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Detected a TLP posted FIFO control double-bit error. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Detected a TLP NP FIFO data0 single-bit error. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Detected a TLP NP FIFO data0 double-bit error. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Detected a TLP NP FIFO data1 single-bit error. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Detected a TLP NP FIFO data1 double-bit error. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Detected a TLP NP FIFO control single-bit error. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Detected a TLP NP FIFO control double-bit error. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Detected a TLP CPL FIFO data0 single-bit error. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Detected a TLP CPL FIFO data0 double-bit error. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Detected a TLP CPL FIFO data1 single-bit error. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Detected a TLP CPL FIFO data1 double-bit error. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Detected a TLP CPL FIFO control single-bit error. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Detected a TLP CPL FIFO control double-bit error. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1C/H) Detected a core retry RAM single-bit error. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1C/H) Detected a core retry RAM double-bit error. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1C/H) Detected a core header queue bank0 single-bit error. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1C/H) Detected a core header queue bank0 double-bit error. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1C/H) Detected a core header queue bank1 single-bit error. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1C/H) Detected a core header queue bank1 double-bit error. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1C/H) Detected a M2S FIFO parity error. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_dbg_info_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1C/H) Core entered RAS data protection error mode. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1C/H) Detected a M2S data fifo double bit error. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1C/H) Detected a M2S data fifo single bit error. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1C/H) Detected a M2S data fifo double bit error. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1C/H) Detected a M2S control fifo single bit error. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Detected a TLP CPL FIFO control double-bit error. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Detected a TLP CPL FIFO control single-bit error. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Detected a TLP CPL FIFO data1 double-bit error. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Detected a TLP CPL FIFO data1 single-bit error. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Detected a TLP CPL FIFO data0 double-bit error. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Detected a TLP CPL FIFO data0 single-bit error. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Detected a TLP NP FIFO control double-bit error. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Detected a TLP NP FIFO control single-bit error. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Detected a TLP NP FIFO data1 double-bit error. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Detected a TLP NP FIFO data1 single-bit error. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Detected a TLP NP FIFO data0 double-bit error. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Detected a TLP NP FIFO data0 single-bit error. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Detected a TLP posted FIFO control double-bit error. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Detected a TLP posted FIFO control single-bit error. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Detected a TLP posted FIFO data1 double-bit error. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Detected a TLP posted FIFO data1 single-bit error. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Detected a TLP posted FIFO data0 double-bit error. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Detected a TLP posted FIFO data0 single-bit error. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was not allowed to master the bus.
                                                                 If a PF TLP and the PCIEEP()_CFG001[ME] is not set.
                                                                 For VF TLP, either the PCIEEP()_CFG001[ME]/PCIEEPVF()_CFG001[ME] are not set. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message.
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message.
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP not to be forwarded to the peer.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent. This legacy interrupt is deprecated and is never set. */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent. This legacy interrupt is deprecated and is never set. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP not to be forwarded to the peer.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message.
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message.
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                                 is set.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                                 probability of this bit being set increases with the traffic load.

                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Maximum number of retries exceeded.
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Received DLLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Received TLP with datalink layer error.
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) DLLP protocol error (out of sequence DLLP).
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Flow control protocol violation (watchdog timer).
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) PHY reported an 8 B/10 B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                                 0x7).

                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Flow control update violation.
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Receive queue overflow. Normally happens only when flow control advertisements are
                                                                 ignored.

                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Received an unexpected completion.
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Received a completion with UR status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Received a completion with CA status.
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                                 completer aborts. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Received a request which device does not support.
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Received a malformed TLP.
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Received a completion with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Received a write with poisoned payload.
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was not allowed to master the bus.
                                                                 If a PF TLP and the PCIEEP()_CFG001[ME] is not set.
                                                                 For VF TLP, either the PCIEEP()_CFG001[ME]/PCIEEPVF()_CFG001[ME] are not set. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1C/H) Detected a TLP posted FIFO data0 single-bit error. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1C/H) Detected a TLP posted FIFO data0 double-bit error. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1C/H) Detected a TLP posted FIFO data1 single-bit error. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1C/H) Detected a TLP posted FIFO data1 double-bit error. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1C/H) Detected a TLP posted FIFO control single-bit error. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1C/H) Detected a TLP posted FIFO control double-bit error. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1C/H) Detected a TLP NP FIFO data0 single-bit error. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1C/H) Detected a TLP NP FIFO data0 double-bit error. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1C/H) Detected a TLP NP FIFO data1 single-bit error. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1C/H) Detected a TLP NP FIFO data1 double-bit error. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1C/H) Detected a TLP NP FIFO control single-bit error. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1C/H) Detected a TLP NP FIFO control double-bit error. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1C/H) Detected a TLP CPL FIFO data0 single-bit error. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1C/H) Detected a TLP CPL FIFO data0 double-bit error. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1C/H) Detected a TLP CPL FIFO data1 single-bit error. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1C/H) Detected a TLP CPL FIFO data1 double-bit error. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1C/H) Detected a TLP CPL FIFO control single-bit error. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1C/H) Detected a TLP CPL FIFO control double-bit error. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1C/H) Detected a M2S control fifo single bit error. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1C/H) Detected a M2S data fifo double bit error. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1C/H) Detected a M2S data fifo single bit error. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1C/H) Detected a M2S data fifo double bit error. */
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1C/H) Core entered RAS data protection error mode. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_dbg_info_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t bad_zero              : 1;  /**< [ 49: 49](R/W1C/H) An access used ACC table to map to a zero-byte read but was not contained
                                                                 to a single QWord */
        uint64_t p_store_zero_byte     : 1;  /**< [ 48: 48](R/W1C/H) An NCBO store from IOBN P queue had no byte enables active. */
        uint64_t n_store_zero_byte     : 1;  /**< [ 47: 47](R/W1C/H) An NCBO store from IOBN N queue had no byte enables active. */
        uint64_t p_maps_to_n           : 1;  /**< [ 46: 46](R/W1C/H) A store access coming from the IOBN P queue is either an ECAM DID access or
                                                                 an ACC table access that maps to CFG or IO type. */
        uint64_t n_store               : 1;  /**< [ 45: 45](R/W1C/H) An NCBO store used ACC table to map to a CFG or IO type and was not contained
                                                                 to a single DWord. */
        uint64_t atomic_to_csr         : 1;  /**< [ 44: 44](R/W1C/H) An NCBO atomic access was within the CSR DID. */
        uint64_t csr_load              : 1;  /**< [ 43: 43](R/W1C/H) An NCBO load from CSR DID was improperly formatted based on size/alignment. Proper
                                                                 format is either DWord aligned DWord access or QWord aligned QWord access or,
                                                                 if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t p_csr_store           : 1;  /**< [ 42: 42](R/W1C/H) An NCBO store to CSR DID and from IOBN P queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t n_csr_store           : 1;  /**< [ 41: 41](R/W1C/H) An NCBO store to CSR DID and from IOBN N queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t ecam_load             : 1;  /**< [ 40: 40](R/W1C/H) An NCBO load from ECAM DID was 64-bit. */
        uint64_t p_ecam_store          : 1;  /**< [ 39: 39](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN P queue. */
        uint64_t n_ecam_store          : 1;  /**< [ 38: 38](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN N queue. */
        uint64_t atomic_non_mem        : 1;  /**< [ 37: 37](R/W1C/H) An NCBO atomic to an ACC region mapped to CFG or IO. */
        uint64_t non_mem_load          : 1;  /**< [ 36: 36](R/W1C/H) An NCBO load to an ACC region mapped to CFG or IO and not contained to a single DWord. */
        uint64_t vf_en_off             : 1;  /**< [ 35: 35](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to
                                                                 being a VF-based access (vf_active set) while the VF enable was clear. */
        uint64_t in_flr                : 1;  /**< [ 34: 34](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to being in FLR. */
        uint64_t rasdp                 : 1;  /**< [ 33: 33](R/W1C/H) Core entered RAS data protection error mode. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was not allowed to master the bus.
                                                                 If a PF TLP and the PCIEEP_CMD[ME] is not set.
                                                                 For VF TLP, either the PCIEEP_CMD[ME]/PCIEEPVF_CMD[ME] are not set. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reserved. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reserved. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reserved. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reserved. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reserved.. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reserved. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reserved. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reserved. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reserved. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reserved. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reserved. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reserved. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reserved. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reserved. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                                 is received.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message.
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message.
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP not to be forwarded to the peer.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or vendor message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent. This legacy interrupt is deprecated and is never set. */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent. This legacy interrupt is deprecated and is never set. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or vendor message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP not to be forwarded to the peer.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message.
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message.
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                                 is received.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reserved. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reserved. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reserved. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reserved. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reserved. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reserved. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reserved. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reserved. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reserved. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reserved.. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reserved. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reserved. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reserved. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reserved. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was not allowed to master the bus.
                                                                 If a PF TLP and the PCIEEP_CMD[ME] is not set.
                                                                 For VF TLP, either the PCIEEP_CMD[ME]/PCIEEPVF_CMD[ME] are not set. */
        uint64_t rasdp                 : 1;  /**< [ 33: 33](R/W1C/H) Core entered RAS data protection error mode. */
        uint64_t in_flr                : 1;  /**< [ 34: 34](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to being in FLR. */
        uint64_t vf_en_off             : 1;  /**< [ 35: 35](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to
                                                                 being a VF-based access (vf_active set) while the VF enable was clear. */
        uint64_t non_mem_load          : 1;  /**< [ 36: 36](R/W1C/H) An NCBO load to an ACC region mapped to CFG or IO and not contained to a single DWord. */
        uint64_t atomic_non_mem        : 1;  /**< [ 37: 37](R/W1C/H) An NCBO atomic to an ACC region mapped to CFG or IO. */
        uint64_t n_ecam_store          : 1;  /**< [ 38: 38](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN N queue. */
        uint64_t p_ecam_store          : 1;  /**< [ 39: 39](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN P queue. */
        uint64_t ecam_load             : 1;  /**< [ 40: 40](R/W1C/H) An NCBO load from ECAM DID was 64-bit. */
        uint64_t n_csr_store           : 1;  /**< [ 41: 41](R/W1C/H) An NCBO store to CSR DID and from IOBN N queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t p_csr_store           : 1;  /**< [ 42: 42](R/W1C/H) An NCBO store to CSR DID and from IOBN P queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t csr_load              : 1;  /**< [ 43: 43](R/W1C/H) An NCBO load from CSR DID was improperly formatted based on size/alignment. Proper
                                                                 format is either DWord aligned DWord access or QWord aligned QWord access or,
                                                                 if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t atomic_to_csr         : 1;  /**< [ 44: 44](R/W1C/H) An NCBO atomic access was within the CSR DID. */
        uint64_t n_store               : 1;  /**< [ 45: 45](R/W1C/H) An NCBO store used ACC table to map to a CFG or IO type and was not contained
                                                                 to a single DWord. */
        uint64_t p_maps_to_n           : 1;  /**< [ 46: 46](R/W1C/H) A store access coming from the IOBN P queue is either an ECAM DID access or
                                                                 an ACC table access that maps to CFG or IO type. */
        uint64_t n_store_zero_byte     : 1;  /**< [ 47: 47](R/W1C/H) An NCBO store from IOBN N queue had no byte enables active. */
        uint64_t p_store_zero_byte     : 1;  /**< [ 48: 48](R/W1C/H) An NCBO store from IOBN P queue had no byte enables active. */
        uint64_t bad_zero              : 1;  /**< [ 49: 49](R/W1C/H) An access used ACC table to map to a zero-byte read but was not contained
                                                                 to a single QWord */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } cn9;
    /* struct bdk_pemx_dbg_info_cn9 cn96xx; */
    /* struct bdk_pemx_dbg_info_cn9 cn98xx; */
    struct bdk_pemx_dbg_info_cnf95xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t bad_zero              : 1;  /**< [ 49: 49](R/W1C/H) An access used ACC table to map to a zero-byte read but was not contained
                                                                 to a single QWord */
        uint64_t p_store_zero_byte     : 1;  /**< [ 48: 48](R/W1C/H) An NCBO store from IOBN P queue had no byte enables active. */
        uint64_t n_store_zero_byte     : 1;  /**< [ 47: 47](R/W1C/H) An NCBO store from IOBN N queue had no byte enables active. */
        uint64_t p_maps_to_n           : 1;  /**< [ 46: 46](R/W1C/H) A store access coming from the IOBN P queue is either an ECAM DID access or
                                                                 an ACC table access that maps to CFG or IO type. */
        uint64_t n_store               : 1;  /**< [ 45: 45](R/W1C/H) An NCBO store used ACC table to map to a CFG or IO type and was not contained
                                                                 to a single DWord. */
        uint64_t atomic_to_csr         : 1;  /**< [ 44: 44](R/W1C/H) An NCBO atomic access was within the CSR DID. */
        uint64_t csr_load              : 1;  /**< [ 43: 43](R/W1C/H) An NCBO load from CSR DID was improperly formatted based on size/alignment. Proper
                                                                 format is either DWord aligned DWord access or QWord aligned QWord access or,
                                                                 if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t p_csr_store           : 1;  /**< [ 42: 42](R/W1C/H) An NCBO store to CSR DID and from IOBN P queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t n_csr_store           : 1;  /**< [ 41: 41](R/W1C/H) An NCBO store to CSR DID and from IOBN N queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t ecam_load             : 1;  /**< [ 40: 40](R/W1C/H) An NCBO load from ECAM DID was 64-bit. */
        uint64_t p_ecam_store          : 1;  /**< [ 39: 39](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN P queue. */
        uint64_t n_ecam_store          : 1;  /**< [ 38: 38](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN N queue. */
        uint64_t atomic_non_mem        : 1;  /**< [ 37: 37](R/W1C/H) An NCBO atomic to an ACC region mapped to CFG or IO. */
        uint64_t non_mem_load          : 1;  /**< [ 36: 36](R/W1C/H) An NCBO load to an ACC region mapped to CFG or IO and not contained to a single DWord. */
        uint64_t vf_en_off             : 1;  /**< [ 35: 35](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to
                                                                 being a VF-based access (vf_active set) while the VF enable was clear. */
        uint64_t in_flr                : 1;  /**< [ 34: 34](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to being in FLR. */
        uint64_t rasdp                 : 1;  /**< [ 33: 33](R/W1C/H) Core entered RAS data protection error mode. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was not allowed to master the bus.
                                                                 If a PF TLP and the PCIEEP_CMD[ME] is not set.
                                                                 For VF TLP, either the PCIEEP_CMD[ME]/PCIEEPVF_CMD[ME] are not set. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reserved. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reserved. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reserved. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reserved. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reserved. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reserved. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reserved. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reserved. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reserved. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reserved. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reserved. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reserved. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reserved. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reserved. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                                 is received.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message.
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message.
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP not to be forwarded to the peer.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or vendor message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent. This legacy interrupt is deprecated and is never set. */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1C/H) Poisoned TLP sent. This legacy interrupt is deprecated and is never set. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1C/H) Received TLP is malformed or a message. If the core receives a MSG (or vendor message) or
                                                                 if a received AtomicOp violates address/length rules, this bit is set as well.

                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1C/H) Received TLP has link layer error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1C/H) Received ECRC error.
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1C/H) Received poisoned TLP not to be forwarded to the peer.
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1C/H) Received correctable error message.
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1C/H) Received nonfatal error message.
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1C/H) Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                                 is received.

                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1C/H) Received PME message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1C/H) Received PME turnoff acknowledge message (RC mode only).
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1C/H) Received unlock message (EP mode only).
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1C/H) Received vendor-defined message.
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1C/H) A completion timeout occurred.
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1C/H) Reserved. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1C/H) Reserved. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1C/H) Reserved. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1C/H) Reserved. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1C/H) Reserved. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1C/H) Reserved. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1C/H) Reserved. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1C/H) Reserved. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1C/H) Reserved. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1C/H) Reserved. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1C/H) Reserved. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1C/H) Reserved. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1C/H) Reserved. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1C/H) Reserved. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1C/H) Received an ECRC error. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1C/H) Lack of forward progress at TLP FIFOs timeout occurred. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was not allowed to master the bus.
                                                                 If a PF TLP and the PCIEEP_CMD[ME] is not set.
                                                                 For VF TLP, either the PCIEEP_CMD[ME]/PCIEEPVF_CMD[ME] are not set. */
        uint64_t rasdp                 : 1;  /**< [ 33: 33](R/W1C/H) Core entered RAS data protection error mode. */
        uint64_t in_flr                : 1;  /**< [ 34: 34](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to being in FLR. */
        uint64_t vf_en_off             : 1;  /**< [ 35: 35](R/W1C/H) A NP or P TLP was seen in the outbound path, but it was blocked due to
                                                                 being a VF-based access (vf_active set) while the VF enable was clear. */
        uint64_t non_mem_load          : 1;  /**< [ 36: 36](R/W1C/H) An NCBO load to an ACC region mapped to CFG or IO and not contained to a single DWord. */
        uint64_t atomic_non_mem        : 1;  /**< [ 37: 37](R/W1C/H) An NCBO atomic to an ACC region mapped to CFG or IO. */
        uint64_t n_ecam_store          : 1;  /**< [ 38: 38](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN N queue. */
        uint64_t p_ecam_store          : 1;  /**< [ 39: 39](R/W1C/H) An NCBO store to ECAM DID was not contained within a single DWord and from IOBN P queue. */
        uint64_t ecam_load             : 1;  /**< [ 40: 40](R/W1C/H) An NCBO load from ECAM DID was 64-bit. */
        uint64_t n_csr_store           : 1;  /**< [ 41: 41](R/W1C/H) An NCBO store to CSR DID and from IOBN N queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t p_csr_store           : 1;  /**< [ 42: 42](R/W1C/H) An NCBO store to CSR DID and from IOBN P queue was improperly formatted based on
                                                                 size/alignment. Proper format is either DWord aligned DWord access or QWord aligned
                                                                 QWord access or, if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t csr_load              : 1;  /**< [ 43: 43](R/W1C/H) An NCBO load from CSR DID was improperly formatted based on size/alignment. Proper
                                                                 format is either DWord aligned DWord access or QWord aligned QWord access or,
                                                                 if an MSIX register, as long as it is contained within a single QWord. */
        uint64_t atomic_to_csr         : 1;  /**< [ 44: 44](R/W1C/H) An NCBO atomic access was within the CSR DID. */
        uint64_t n_store               : 1;  /**< [ 45: 45](R/W1C/H) An NCBO store used ACC table to map to a CFG or IO type and was not contained
                                                                 to a single DWord. */
        uint64_t p_maps_to_n           : 1;  /**< [ 46: 46](R/W1C/H) A store access coming from the IOBN P queue is either an ECAM DID access or
                                                                 an ACC table access that maps to CFG or IO type. */
        uint64_t n_store_zero_byte     : 1;  /**< [ 47: 47](R/W1C/H) An NCBO store from IOBN N queue had no byte enables active. */
        uint64_t p_store_zero_byte     : 1;  /**< [ 48: 48](R/W1C/H) An NCBO store from IOBN P queue had no byte enables active. */
        uint64_t bad_zero              : 1;  /**< [ 49: 49](R/W1C/H) An access used ACC table to map to a zero-byte read but was not contained
                                                                 to a single QWord */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } cnf95xx;
    /* struct bdk_pemx_dbg_info_cn9 loki; */
};
typedef union bdk_pemx_dbg_info bdk_pemx_dbg_info_t;

static inline uint64_t BDK_PEMX_DBG_INFO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_DBG_INFO(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000448ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000448ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000108ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000108ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000108ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000108ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_DBG_INFO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_DBG_INFO(a) bdk_pemx_dbg_info_t
#define bustype_BDK_PEMX_DBG_INFO(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_DBG_INFO(a) "PEMX_DBG_INFO"
#define device_bar_BDK_PEMX_DBG_INFO(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_DBG_INFO(a) (a)
#define arguments_BDK_PEMX_DBG_INFO(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_dbg_info_w1s
 *
 * PEM Debug Information Set Register
 * This register sets interrupt bits.
 */
union bdk_pemx_dbg_info_w1s
{
    uint64_t u;
    struct bdk_pemx_dbg_info_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t reserved_51_55        : 5;
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t reserved_32           : 1;
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t reserved_32           : 1;
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t reserved_51_55        : 5;
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_dbg_info_w1s_s cn8; */
    struct bdk_pemx_dbg_info_w1s_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B1_SBE]. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B0_DBE]. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B0_SBE]. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTRY_DBE]. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTRY_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[DATQ_PE]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t reserved_10           : 1;
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[SPOISON].
                                                                 Internal:
                                                                 peai__client0_tlp_ep & peai__client0_tlp_hv or
                                                                 peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t reserved_10           : 1;
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[LOFP]. */
        uint64_t datq_pe               : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[DATQ_PE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[C_C_DBE]. */
        uint64_t rtry_sbe              : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTRY_SBE]. */
        uint64_t rtry_dbe              : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[RTRY_DBE]. */
        uint64_t qhdr_b0_sbe           : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B0_SBE]. */
        uint64_t qhdr_b0_dbe           : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B0_DBE]. */
        uint64_t qhdr_b1_sbe           : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B1_SBE]. */
        uint64_t qhdr_b1_dbe           : 1;  /**< [ 56: 56](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[QHDR_B1_DBE]. */
        uint64_t m2s_pe                : 1;  /**< [ 57: 57](R/W1S/H) Reads or sets PEM(0..2)_DBG_INFO[M2S_PE]. */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_dbg_info_w1s_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RASDP]. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_D_DBE]. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_D_SBE]. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_C_DBE]. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_C_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_C_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D0_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_C_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_C_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D0_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_C_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_C_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D0_SBE]. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[BMD_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[LOFP]. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[ECRC_E]. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[CAAR]. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[SPOISON]. */
#else /* Word 0 - Little Endian */
        uint64_t spoison               : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[SPOISON]. */
        uint64_t rtlpmal               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTLPMAL].
                                                                 Internal:
                                                                 pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
        uint64_t rtlplle               : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTLPLLE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_dllp_abort &
                                                                 pedc__radm_trgt1_eot. */
        uint64_t recrce                : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RECRCE].
                                                                 Internal:
                                                                 pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
        uint64_t rpoison               : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPOISON].
                                                                 Internal:
                                                                 pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
        uint64_t rcemrc                : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RCEMRC].
                                                                 Internal:
                                                                 pedc_radm_correctable_err. */
        uint64_t rnfemrc               : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RNFEMRC].
                                                                 Internal:
                                                                 pedc_radm_nonfatal_err. */
        uint64_t rfemrc                : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RFEMRC].
                                                                 Internal:
                                                                 pedc_radm_fatal_err. */
        uint64_t rpmerc                : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPMERC].
                                                                 Internal:
                                                                 pedc_radm_pm_pme. */
        uint64_t rptamrc               : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPTAMRC].
                                                                 Internal:
                                                                 pedc_radm_pm_to_ack. */
        uint64_t rumep                 : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RUMEP].
                                                                 Internal:
                                                                 pedc_radm_msg_unlock. */
        uint64_t rvdm                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RVDM].
                                                                 Internal:
                                                                 pedc_radm_vendor_msg. */
        uint64_t acto                  : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[ACTO].
                                                                 Internal:
                                                                 pedc_radm_cpl_timeout. */
        uint64_t rte                   : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTE].
                                                                 Internal:
                                                                 xdlh_replay_timeout_err. */
        uint64_t mre                   : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[MRE].
                                                                 Internal:
                                                                 xdlh_replay_num_rlover_err. */
        uint64_t rdwdle                : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RDWDLE].
                                                                 Internal:
                                                                 rdlh_bad_dllp_err. */
        uint64_t rtwdle                : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RTWDLE].
                                                                 Internal:
                                                                 rdlh_bad_tlp_err. */
        uint64_t dpeoosd               : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[DPEOOSD].
                                                                 Internal:
                                                                 rdlh_prot_err. */
        uint64_t fcpvwt                : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[FCPVWT].
                                                                 Internal:
                                                                 rtlh_fc_prot_err. */
        uint64_t rpe                   : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RPE].
                                                                 Internal:
                                                                 rmlh_rcvd_err. */
        uint64_t fcuv                  : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[FCUV].
                                                                 Internal:
                                                                 (opt. checks) int_xadm_fc_prot_err. */
        uint64_t rqo                   : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RQO].
                                                                 Internal:
                                                                 radm_qoverflow. */
        uint64_t rauc                  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RAUC].
                                                                 Internal:
                                                                 radm_unexp_cpl_err. */
        uint64_t racur                 : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RACUR].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ur. */
        uint64_t racca                 : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RACCA].
                                                                 Internal:
                                                                 radm_rcvd_cpl_ca. */
        uint64_t caar                  : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[CAAR]. */
        uint64_t rarwdns               : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RARWDNS].
                                                                 Internal:
                                                                 radm_rcvd_ur_req. */
        uint64_t ramtlp                : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RAMTLP].
                                                                 Internal:
                                                                 radm_mlf_tlp_err. */
        uint64_t racpp                 : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RACPP].
                                                                 Internal:
                                                                 radm_rcvd_cpl_poisoned. */
        uint64_t rawwpp                : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RAWWPP].
                                                                 Internal:
                                                                 radm_rcvd_wreq_poisoned. */
        uint64_t ecrc_e                : 1;  /**< [ 30: 30](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[ECRC_E]. */
        uint64_t lofp                  : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[LOFP]. */
        uint64_t bmd_e                 : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[BMD_E]. */
        uint64_t p_d0_sbe              : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D0_SBE]. */
        uint64_t p_d0_dbe              : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D0_DBE]. */
        uint64_t p_d1_sbe              : 1;  /**< [ 35: 35](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D1_SBE]. */
        uint64_t p_d1_dbe              : 1;  /**< [ 36: 36](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_D1_DBE]. */
        uint64_t p_c_sbe               : 1;  /**< [ 37: 37](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_C_SBE]. */
        uint64_t p_c_dbe               : 1;  /**< [ 38: 38](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[P_C_DBE]. */
        uint64_t n_d0_sbe              : 1;  /**< [ 39: 39](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D0_SBE]. */
        uint64_t n_d0_dbe              : 1;  /**< [ 40: 40](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D0_DBE]. */
        uint64_t n_d1_sbe              : 1;  /**< [ 41: 41](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D1_SBE]. */
        uint64_t n_d1_dbe              : 1;  /**< [ 42: 42](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_D1_DBE]. */
        uint64_t n_c_sbe               : 1;  /**< [ 43: 43](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_C_SBE]. */
        uint64_t n_c_dbe               : 1;  /**< [ 44: 44](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[N_C_DBE]. */
        uint64_t c_d0_sbe              : 1;  /**< [ 45: 45](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D0_SBE]. */
        uint64_t c_d0_dbe              : 1;  /**< [ 46: 46](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D0_DBE]. */
        uint64_t c_d1_sbe              : 1;  /**< [ 47: 47](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D1_SBE]. */
        uint64_t c_d1_dbe              : 1;  /**< [ 48: 48](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_D1_DBE]. */
        uint64_t c_c_sbe               : 1;  /**< [ 49: 49](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_C_SBE]. */
        uint64_t c_c_dbe               : 1;  /**< [ 50: 50](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[C_C_DBE]. */
        uint64_t m2s_c_sbe             : 1;  /**< [ 51: 51](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_C_SBE]. */
        uint64_t m2s_c_dbe             : 1;  /**< [ 52: 52](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_C_DBE]. */
        uint64_t m2s_d_sbe             : 1;  /**< [ 53: 53](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_D_SBE]. */
        uint64_t m2s_d_dbe             : 1;  /**< [ 54: 54](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[M2S_D_DBE]. */
        uint64_t rasdp                 : 1;  /**< [ 55: 55](R/W1S/H) Reads or sets PEM(0..3)_DBG_INFO[RASDP]. */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } cn83xx;
};
typedef union bdk_pemx_dbg_info_w1s bdk_pemx_dbg_info_w1s_t;

static inline uint64_t BDK_PEMX_DBG_INFO_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_DBG_INFO_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000450ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000450ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_DBG_INFO_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_DBG_INFO_W1S(a) bdk_pemx_dbg_info_w1s_t
#define bustype_BDK_PEMX_DBG_INFO_W1S(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_DBG_INFO_W1S(a) "PEMX_DBG_INFO_W1S"
#define device_bar_BDK_PEMX_DBG_INFO_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_DBG_INFO_W1S(a) (a)
#define arguments_BDK_PEMX_DBG_INFO_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_debug
 *
 * PEM Debug Register
 * This register contains status of level interrupts for debugging purposes.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_debug
{
    uint64_t u;
    struct bdk_pemx_debug_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t c_tlp_cnt             : 11; /**< [ 30: 20](RO/H) The current count (depth) of the outbound C TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_19           : 1;
        uint64_t p_tlp_cnt             : 11; /**< [ 18:  8](RO/H) The current count (depth) of the outbound P TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t inv_m2s_par           : 1;  /**< [  7:  7](R/W) Invert the generated parity to be written into the M2S FIFO
                                                                 to force a parity error when it is later read. */
        uint64_t reserved_6            : 1;
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, HP_PMEI, and AERI interrupts. */
#else /* Word 0 - Little Endian */
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, HP_PMEI, and AERI interrupts. */
        uint64_t reserved_6            : 1;
        uint64_t inv_m2s_par           : 1;  /**< [  7:  7](R/W) Invert the generated parity to be written into the M2S FIFO
                                                                 to force a parity error when it is later read. */
        uint64_t p_tlp_cnt             : 11; /**< [ 18:  8](RO/H) The current count (depth) of the outbound P TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_19           : 1;
        uint64_t c_tlp_cnt             : 11; /**< [ 30: 20](RO/H) The current count (depth) of the outbound C TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_debug_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t n_tlp_cnt             : 8;  /**< [ 39: 32](RO/H) The current count (depth) of the outbound NP TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 32. */
        uint64_t reserved_31           : 1;
        uint64_t c_tlp_cnt             : 11; /**< [ 30: 20](RO/H) The current count (depth) of the outbound C TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_19           : 1;
        uint64_t p_tlp_cnt             : 11; /**< [ 18:  8](RO/H) The current count (depth) of the outbound P TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t inv_m2s_par           : 1;  /**< [  7:  7](R/W) Invert the generated parity to be written into the M2S FIFO
                                                                 to force a parity error when it is later read. */
        uint64_t reserved_6            : 1;
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, HP_PMEI, and AERI interrupts. */
#else /* Word 0 - Little Endian */
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, HP_PMEI, and AERI interrupts. */
        uint64_t reserved_6            : 1;
        uint64_t inv_m2s_par           : 1;  /**< [  7:  7](R/W) Invert the generated parity to be written into the M2S FIFO
                                                                 to force a parity error when it is later read. */
        uint64_t p_tlp_cnt             : 11; /**< [ 18:  8](RO/H) The current count (depth) of the outbound P TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_19           : 1;
        uint64_t c_tlp_cnt             : 11; /**< [ 30: 20](RO/H) The current count (depth) of the outbound C TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_31           : 1;
        uint64_t n_tlp_cnt             : 8;  /**< [ 39: 32](RO/H) The current count (depth) of the outbound NP TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 32. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_debug_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t inv_m2s_par           : 1;  /**< [  7:  7](R/W) Invert the generated parity to be written into the M2S FIFO
                                                                 to force a parity error when it is later read. */
        uint64_t reserved_6            : 1;
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, HP_PMEI, and AERI interrupts. */
#else /* Word 0 - Little Endian */
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, HP_PMEI, and AERI interrupts. */
        uint64_t reserved_6            : 1;
        uint64_t inv_m2s_par           : 1;  /**< [  7:  7](R/W) Invert the generated parity to be written into the M2S FIFO
                                                                 to force a parity error when it is later read. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_debug_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t n_tlp_cnt             : 8;  /**< [ 39: 32](RO/H) The current count (depth) of the outbound NP TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 32. */
        uint64_t reserved_31           : 1;
        uint64_t c_tlp_cnt             : 11; /**< [ 30: 20](RO/H) The current count (depth) of the outbound C TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_19           : 1;
        uint64_t p_tlp_cnt             : 11; /**< [ 18:  8](RO/H) The current count (depth) of the outbound P TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_6_7          : 2;
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, PMEI, and AERI interrupts. */
#else /* Word 0 - Little Endian */
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, PMEI, and AERI interrupts. */
        uint64_t reserved_6_7          : 2;
        uint64_t p_tlp_cnt             : 11; /**< [ 18:  8](RO/H) The current count (depth) of the outbound P TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_19           : 1;
        uint64_t c_tlp_cnt             : 11; /**< [ 30: 20](RO/H) The current count (depth) of the outbound C TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 244. */
        uint64_t reserved_31           : 1;
        uint64_t n_tlp_cnt             : 8;  /**< [ 39: 32](RO/H) The current count (depth) of the outbound NP TLP FIFO.
                                                                 The value represents the number of used credits out of a total of 32. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_debug_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ib_drop_why           : 32; /**< [ 63: 32](R/W1C/H) Reasons why inbound TLPs were dropped. */
        uint64_t reserved_6_31         : 26;
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, PMEI, and AERI interrupts. */
#else /* Word 0 - Little Endian */
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, PMEI, and AERI interrupts. */
        uint64_t reserved_6_31         : 26;
        uint64_t ib_drop_why           : 32; /**< [ 63: 32](R/W1C/H) Reasons why inbound TLPs were dropped. */
#endif /* Word 0 - End */
    } cn9;
    /* struct bdk_pemx_debug_cn9 cn96xxp1; */
    struct bdk_pemx_debug_cn96xxp3
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ib_drop_why           : 32; /**< [ 63: 32](R/W1C/H) Reasons why inbound TLPs were dropped.
                                                                 \<32\> = No NCB. The TLP targets NCBI but there is no NCBI connected to PEM in this chip.
                                                                 \<33\> = No EBUS. The TLP targets EBI but there is no EBI connected to PEM in this chip.
                                                                 \<34\> = No PSPI. The TLP targets PSPI (ROM) but there is no PSPI connected to PEM in this chip.
                                                                 \<35\> = Core Reset. The TLP was processed during core reset or core reset recovery process.
                                                                 \<36\> = IB Drop. A CFG or IO completion was dropped as marked by outbound at time of NP request.
                                                                 \<37\> = Illegal BAR. BAR miss or improper config to BAR0, BAR2 or BAR4.
                                                                 \<38\> = Illegal EBAR.  The TLP targets EBAR (EROM) but was NOT a read (writes not supported).
                                                                 \<39\> = Zero MemWr.  The TLP was a zero-length memory write operation which we do not support.
                                                                 \<40\> = Illegal PCIe Type.  Inbound TLP is not supported (examples: CFG, IO, RDLOCK).
                                                                 \<41\> = Unsupported AtomicOp.  The TLP was poisoned, to PSPI bus, or to EBI with atomic disabled.
                                                                 \<42\> = Malformed AtomicOp.  Unsupported size/alignment restrictions.
                                                                 \<43\> = Malformed AtomicOp EOT.  The AtomicOp did not indicate EOT on its first beat of data.
                                                                 \<44\> = Mac Reset. The TLP was processed when the Mac was in reset.
                                                                 \<45\> = SBRST.  The TLP was processed when the chip as RC initiates hot reset or link down event.
                                                                 \<46\> = No BME.  The TLP functions PCIEEP_CMD[ME]/PCIEEPVF_CMD[ME] (Bus Master
                                                                 Enable) set OR it was an AtomicOp and PCIERC_DEV_CTL2[ATOM_OP] (AtomicOp requster
                                                                 enable) was not set.
                                                                 \<47\> = In FLR.  The TLP's function (PF/VF) was in Function Level Reset.  Same as bit 54.
                                                                 \<48\> = IN RASDP.  The TLP was processed when the Mac indiacated RAS Data Protection mode.
                                                                 \<49\> = Framing.  The TLP was terminated due to incorrect framing (EOT on the expected beat).
                                                                 \<50\> = Max TLP Size.  The TLP DW length exceeded 1kB.
                                                                 \<51\> = DLLP Error.  The TLP was flagged by the MAC as having a Data Link Error (LCRC) error.
                                                                 \<52\> = TLP Error.  The TLP was flagged by the MAC as being malformed on TRGT1
                                                                 (ECRC or LUT failure).
                                                                 \<53\> = ECRC Error.  The TLP was flagged by the MAC as having an ECRC error on the received TLP.
                                                                 \<54\> = In FLR.  The TLP's function (PF/VF) was in Function Level Reset.  Same as bit 47.
                                                                 \<63:55\> = Reserved. */
        uint64_t reserved_6_31         : 26;
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, PMEI, and AERI interrupts. */
#else /* Word 0 - Little Endian */
        uint64_t intval                : 6;  /**< [  5:  0](RO/H) Status of INTX, PMEI, and AERI interrupts. */
        uint64_t reserved_6_31         : 26;
        uint64_t ib_drop_why           : 32; /**< [ 63: 32](R/W1C/H) Reasons why inbound TLPs were dropped.
                                                                 \<32\> = No NCB. The TLP targets NCBI but there is no NCBI connected to PEM in this chip.
                                                                 \<33\> = No EBUS. The TLP targets EBI but there is no EBI connected to PEM in this chip.
                                                                 \<34\> = No PSPI. The TLP targets PSPI (ROM) but there is no PSPI connected to PEM in this chip.
                                                                 \<35\> = Core Reset. The TLP was processed during core reset or core reset recovery process.
                                                                 \<36\> = IB Drop. A CFG or IO completion was dropped as marked by outbound at time of NP request.
                                                                 \<37\> = Illegal BAR. BAR miss or improper config to BAR0, BAR2 or BAR4.
                                                                 \<38\> = Illegal EBAR.  The TLP targets EBAR (EROM) but was NOT a read (writes not supported).
                                                                 \<39\> = Zero MemWr.  The TLP was a zero-length memory write operation which we do not support.
                                                                 \<40\> = Illegal PCIe Type.  Inbound TLP is not supported (examples: CFG, IO, RDLOCK).
                                                                 \<41\> = Unsupported AtomicOp.  The TLP was poisoned, to PSPI bus, or to EBI with atomic disabled.
                                                                 \<42\> = Malformed AtomicOp.  Unsupported size/alignment restrictions.
                                                                 \<43\> = Malformed AtomicOp EOT.  The AtomicOp did not indicate EOT on its first beat of data.
                                                                 \<44\> = Mac Reset. The TLP was processed when the Mac was in reset.
                                                                 \<45\> = SBRST.  The TLP was processed when the chip as RC initiates hot reset or link down event.
                                                                 \<46\> = No BME.  The TLP functions PCIEEP_CMD[ME]/PCIEEPVF_CMD[ME] (Bus Master
                                                                 Enable) set OR it was an AtomicOp and PCIERC_DEV_CTL2[ATOM_OP] (AtomicOp requster
                                                                 enable) was not set.
                                                                 \<47\> = In FLR.  The TLP's function (PF/VF) was in Function Level Reset.  Same as bit 54.
                                                                 \<48\> = IN RASDP.  The TLP was processed when the Mac indiacated RAS Data Protection mode.
                                                                 \<49\> = Framing.  The TLP was terminated due to incorrect framing (EOT on the expected beat).
                                                                 \<50\> = Max TLP Size.  The TLP DW length exceeded 1kB.
                                                                 \<51\> = DLLP Error.  The TLP was flagged by the MAC as having a Data Link Error (LCRC) error.
                                                                 \<52\> = TLP Error.  The TLP was flagged by the MAC as being malformed on TRGT1
                                                                 (ECRC or LUT failure).
                                                                 \<53\> = ECRC Error.  The TLP was flagged by the MAC as having an ECRC error on the received TLP.
                                                                 \<54\> = In FLR.  The TLP's function (PF/VF) was in Function Level Reset.  Same as bit 47.
                                                                 \<63:55\> = Reserved. */
#endif /* Word 0 - End */
    } cn96xxp3;
    /* struct bdk_pemx_debug_cn96xxp3 cn98xx; */
    /* struct bdk_pemx_debug_cn9 cnf95xx; */
    /* struct bdk_pemx_debug_cn96xxp3 loki; */
};
typedef union bdk_pemx_debug bdk_pemx_debug_t;

static inline uint64_t BDK_PEMX_DEBUG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_DEBUG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000480ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000480ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000110ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000110ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000110ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000110ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_DEBUG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_DEBUG(a) bdk_pemx_debug_t
#define bustype_BDK_PEMX_DEBUG(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_DEBUG(a) "PEMX_DEBUG"
#define device_bar_BDK_PEMX_DEBUG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_DEBUG(a) (a)
#define arguments_BDK_PEMX_DEBUG(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_diag_status
 *
 * PEM Diagnostic Status Register
 * This register contains selection control for the core diagnostic bus.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_diag_status
{
    uint64_t u;
    struct bdk_pemx_diag_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t pclkreqn              : 2;  /**< [ 19: 18](RO/H) Request PCLK removal.
                                                                 0x0 = Do not request PCLK removal.
                                                                 0x1 = Request PCLK removal for executing L1 with Clock PM.
                                                                 0x2 = Request PCLK removal for executing L1 substates.
                                                                 0x3 = Request PCLK removal for executing L1 substates with Clock PM.

                                                                 Internal:
                                                                 mac_phy_pclkreq_n[1:0]. */
        uint64_t sel_aux_clk           : 1;  /**< [ 17: 17](RO/H) When asserted, switches the source of aux_clk from core_clk to the low speed clock.
                                                                 Internal:
                                                                 pm_sel_aux_clk. */
        uint64_t lnk_up                : 1;  /**< [ 16: 16](RO/H) Link is up.
                                                                 Internal:
                                                                 rdlh_link_up. */
        uint64_t lnkst_l1              : 1;  /**< [ 15: 15](RO/H) Power Management State in L1 state.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnkst_l1sub           : 1;  /**< [ 14: 14](RO/H) Power Management State in L1 substate.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnkst_l2              : 1;  /**< [ 13: 13](RO/H) Power Management State in L2 state.
                                                                 Internal:
                                                                 pm_linkst_in_l2. */
        uint64_t lnkst_l2_exit         : 1;  /**< [ 12: 12](RO/H) Power Management State in L2 exit state.
                                                                 Not applicable for downstream port.

                                                                 Internal:
                                                                 pm_linkst_in_l2_exit. */
        uint64_t pclk_rate             : 2;  /**< [ 11: 10](RO/H) Current pclk rate.
                                                                 0x0 = GEN1.
                                                                 0x1 = GEN2.
                                                                 0x2 = GEN3.
                                                                 0x4 = GEN4.

                                                                 Internal:
                                                                 current_data_rate. */
        uint64_t reserved_0_9          : 10;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_9          : 10;
        uint64_t pclk_rate             : 2;  /**< [ 11: 10](RO/H) Current pclk rate.
                                                                 0x0 = GEN1.
                                                                 0x1 = GEN2.
                                                                 0x2 = GEN3.
                                                                 0x4 = GEN4.

                                                                 Internal:
                                                                 current_data_rate. */
        uint64_t lnkst_l2_exit         : 1;  /**< [ 12: 12](RO/H) Power Management State in L2 exit state.
                                                                 Not applicable for downstream port.

                                                                 Internal:
                                                                 pm_linkst_in_l2_exit. */
        uint64_t lnkst_l2              : 1;  /**< [ 13: 13](RO/H) Power Management State in L2 state.
                                                                 Internal:
                                                                 pm_linkst_in_l2. */
        uint64_t lnkst_l1sub           : 1;  /**< [ 14: 14](RO/H) Power Management State in L1 substate.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnkst_l1              : 1;  /**< [ 15: 15](RO/H) Power Management State in L1 state.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnk_up                : 1;  /**< [ 16: 16](RO/H) Link is up.
                                                                 Internal:
                                                                 rdlh_link_up. */
        uint64_t sel_aux_clk           : 1;  /**< [ 17: 17](RO/H) When asserted, switches the source of aux_clk from core_clk to the low speed clock.
                                                                 Internal:
                                                                 pm_sel_aux_clk. */
        uint64_t pclkreqn              : 2;  /**< [ 19: 18](RO/H) Request PCLK removal.
                                                                 0x0 = Do not request PCLK removal.
                                                                 0x1 = Request PCLK removal for executing L1 with Clock PM.
                                                                 0x2 = Request PCLK removal for executing L1 substates.
                                                                 0x3 = Request PCLK removal for executing L1 substates with Clock PM.

                                                                 Internal:
                                                                 mac_phy_pclkreq_n[1:0]. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_diag_status_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t pwrdwn                : 3;  /**< [  8:  6](RO/H) Current mac_phy_powerdown state. */
        uint64_t pm_dst                : 3;  /**< [  5:  3](RO/H) Current power management DSTATE. */
        uint64_t pm_stat               : 1;  /**< [  2:  2](RO) Power management status. */
        uint64_t pm_en                 : 1;  /**< [  1:  1](RO) Power management event enable. */
        uint64_t aux_en                : 1;  /**< [  0:  0](RO) Auxiliary power enable. Always read as zero as auxiliary power is not supported. */
#else /* Word 0 - Little Endian */
        uint64_t aux_en                : 1;  /**< [  0:  0](RO) Auxiliary power enable. Always read as zero as auxiliary power is not supported. */
        uint64_t pm_en                 : 1;  /**< [  1:  1](RO) Power management event enable. */
        uint64_t pm_stat               : 1;  /**< [  2:  2](RO) Power management status. */
        uint64_t pm_dst                : 3;  /**< [  5:  3](RO/H) Current power management DSTATE. */
        uint64_t pwrdwn                : 3;  /**< [  8:  6](RO/H) Current mac_phy_powerdown state. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn8;
    /* struct bdk_pemx_diag_status_cn8 cn81xx; */
    struct bdk_pemx_diag_status_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t pwrdwn                : 3;  /**< [  8:  6](RO/H) Current mac_phy_powerdown state. */
        uint64_t pm_dst                : 3;  /**< [  5:  3](RO/H) Current power management DSTATE. */
        uint64_t pm_stat               : 1;  /**< [  2:  2](RO/H) Power management status. */
        uint64_t pm_en                 : 1;  /**< [  1:  1](RO/H) Power management event enable. */
        uint64_t aux_en                : 1;  /**< [  0:  0](RO/H) Auxiliary power enable. */
#else /* Word 0 - Little Endian */
        uint64_t aux_en                : 1;  /**< [  0:  0](RO/H) Auxiliary power enable. */
        uint64_t pm_en                 : 1;  /**< [  1:  1](RO/H) Power management event enable. */
        uint64_t pm_stat               : 1;  /**< [  2:  2](RO/H) Power management status. */
        uint64_t pm_dst                : 3;  /**< [  5:  3](RO/H) Current power management DSTATE. */
        uint64_t pwrdwn                : 3;  /**< [  8:  6](RO/H) Current mac_phy_powerdown state. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_diag_status_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t pclkreqn              : 2;  /**< [ 19: 18](RO/H) Request PCLK removal.
                                                                 0x0 = Do not request PCLK removal.
                                                                 0x1 = Request PCLK removal for executing L1 with Clock PM.
                                                                 0x2 = Request PCLK removal for executing L1 substates.
                                                                 0x3 = Request PCLK removal for executing L1 substates with Clock PM.

                                                                 Internal:
                                                                 mac_phy_pclkreq_n[1:0]. */
        uint64_t sel_aux_clk           : 1;  /**< [ 17: 17](RO/H) When asserted, switches the source of aux_clk from core_clk to the low speed clock.
                                                                 Internal:
                                                                 pm_sel_aux_clk. */
        uint64_t lnk_up                : 1;  /**< [ 16: 16](RO/H) Link is up.
                                                                 Internal:
                                                                 rdlh_link_up. */
        uint64_t lnkst_l1              : 1;  /**< [ 15: 15](RO/H) Power Management State in L1 state.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnkst_l1sub           : 1;  /**< [ 14: 14](RO/H) Power Management State in L1 substate.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnkst_l2              : 1;  /**< [ 13: 13](RO/H) Power Management State in L2 state.
                                                                 Internal:
                                                                 pm_linkst_in_l2. */
        uint64_t lnkst_l2_exit         : 1;  /**< [ 12: 12](RO/H) Power Management State in L2 exit state.
                                                                 Not applicable for downstream port.

                                                                 Internal:
                                                                 pm_linkst_in_l2_exit. */
        uint64_t pclk_rate             : 2;  /**< [ 11: 10](RO/H) Current pclk rate.
                                                                 0x0 = GEN1.
                                                                 0x1 = GEN2.
                                                                 0x2 = GEN3.
                                                                 0x4 = GEN4.

                                                                 Internal:
                                                                 current_data_rate. */
        uint64_t ltssm                 : 6;  /**< [  9:  4](RO/H) Current  smlh_ltssm_state.
                                                                 Internal:
                                                                 smlh_ltssm_state. */
        uint64_t pwrdwn                : 4;  /**< [  3:  0](RO/H) Current mac_phy_powerdown state.
                                                                 0x0 = D0.
                                                                 0x1 = D1.
                                                                 0x2 = D2.
                                                                 0x3 = D3.
                                                                 0x4 - 0x7: Reserved.

                                                                 Internal:
                                                                 mac_phy_powerdown. */
#else /* Word 0 - Little Endian */
        uint64_t pwrdwn                : 4;  /**< [  3:  0](RO/H) Current mac_phy_powerdown state.
                                                                 0x0 = D0.
                                                                 0x1 = D1.
                                                                 0x2 = D2.
                                                                 0x3 = D3.
                                                                 0x4 - 0x7: Reserved.

                                                                 Internal:
                                                                 mac_phy_powerdown. */
        uint64_t ltssm                 : 6;  /**< [  9:  4](RO/H) Current  smlh_ltssm_state.
                                                                 Internal:
                                                                 smlh_ltssm_state. */
        uint64_t pclk_rate             : 2;  /**< [ 11: 10](RO/H) Current pclk rate.
                                                                 0x0 = GEN1.
                                                                 0x1 = GEN2.
                                                                 0x2 = GEN3.
                                                                 0x4 = GEN4.

                                                                 Internal:
                                                                 current_data_rate. */
        uint64_t lnkst_l2_exit         : 1;  /**< [ 12: 12](RO/H) Power Management State in L2 exit state.
                                                                 Not applicable for downstream port.

                                                                 Internal:
                                                                 pm_linkst_in_l2_exit. */
        uint64_t lnkst_l2              : 1;  /**< [ 13: 13](RO/H) Power Management State in L2 state.
                                                                 Internal:
                                                                 pm_linkst_in_l2. */
        uint64_t lnkst_l1sub           : 1;  /**< [ 14: 14](RO/H) Power Management State in L1 substate.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnkst_l1              : 1;  /**< [ 15: 15](RO/H) Power Management State in L1 state.
                                                                 Internal:
                                                                 pm_linkst_in_l1. */
        uint64_t lnk_up                : 1;  /**< [ 16: 16](RO/H) Link is up.
                                                                 Internal:
                                                                 rdlh_link_up. */
        uint64_t sel_aux_clk           : 1;  /**< [ 17: 17](RO/H) When asserted, switches the source of aux_clk from core_clk to the low speed clock.
                                                                 Internal:
                                                                 pm_sel_aux_clk. */
        uint64_t pclkreqn              : 2;  /**< [ 19: 18](RO/H) Request PCLK removal.
                                                                 0x0 = Do not request PCLK removal.
                                                                 0x1 = Request PCLK removal for executing L1 with Clock PM.
                                                                 0x2 = Request PCLK removal for executing L1 substates.
                                                                 0x3 = Request PCLK removal for executing L1 substates with Clock PM.

                                                                 Internal:
                                                                 mac_phy_pclkreq_n[1:0]. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_diag_status bdk_pemx_diag_status_t;

static inline uint64_t BDK_PEMX_DIAG_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_DIAG_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000020ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000010ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000010ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000010ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000010ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_DIAG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_DIAG_STATUS(a) bdk_pemx_diag_status_t
#define bustype_BDK_PEMX_DIAG_STATUS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_DIAG_STATUS(a) "PEMX_DIAG_STATUS"
#define device_bar_BDK_PEMX_DIAG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_DIAG_STATUS(a) (a)
#define arguments_BDK_PEMX_DIAG_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_dis_port
 *
 * PEM Disable Port Register
 * This register controls whether traffic is allowed to be sent out the PCIe link.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_dis_port
{
    uint64_t u;
    struct bdk_pemx_dis_port_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t dis_port              : 1;  /**< [  0:  0](R/W1C/H) When set, outbound read and writes are disabled (dropped) and reads will
                                                                 return completion with fault over NCBI or EBUS.  For an endpoint, software
                                                                 must clear this bit after power-on reset to be able to send outbound traffic.
                                                                 Further, this bit will be set by hardware when either MAC reset or core reset
                                                                 completes an assertion phase. Writing a one to this location clears the bit and
                                                                 will allow outbound operations to be sent to the MAC at the beginning of the next
                                                                 transfer. This bit cannot be cleared while PEM()_ON[PEMOOR] is clear.

                                                                 This bit is automatically cleared by hardware when the link LTSSM reaches L0
                                                                 state after a MAC reset, and PEM()_CFG[AUTO_DP_CLR] is set. */
#else /* Word 0 - Little Endian */
        uint64_t dis_port              : 1;  /**< [  0:  0](R/W1C/H) When set, outbound read and writes are disabled (dropped) and reads will
                                                                 return completion with fault over NCBI or EBUS.  For an endpoint, software
                                                                 must clear this bit after power-on reset to be able to send outbound traffic.
                                                                 Further, this bit will be set by hardware when either MAC reset or core reset
                                                                 completes an assertion phase. Writing a one to this location clears the bit and
                                                                 will allow outbound operations to be sent to the MAC at the beginning of the next
                                                                 transfer. This bit cannot be cleared while PEM()_ON[PEMOOR] is clear.

                                                                 This bit is automatically cleared by hardware when the link LTSSM reaches L0
                                                                 state after a MAC reset, and PEM()_CFG[AUTO_DP_CLR] is set. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_dis_port_s cn; */
};
typedef union bdk_pemx_dis_port bdk_pemx_dis_port_t;

static inline uint64_t BDK_PEMX_DIS_PORT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_DIS_PORT(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000050ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000050ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000050ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000050ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_DIS_PORT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_DIS_PORT(a) bdk_pemx_dis_port_t
#define bustype_BDK_PEMX_DIS_PORT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_DIS_PORT(a) "PEMX_DIS_PORT"
#define device_bar_BDK_PEMX_DIS_PORT(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_DIS_PORT(a) (a)
#define arguments_BDK_PEMX_DIS_PORT(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ebi_tlp_credits
 *
 * PEM EBUS TLP Credits Register
 * This register specifies the number of credits for use in moving TLPs. When this register is
 * written, the credit values are reset to the register value. This register is for diagnostic
 * use only, and should only be written when PEM()_CTL_STATUS[LNK_ENB] is clear.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_ebi_tlp_credits
{
    uint64_t u;
    struct bdk_pemx_ebi_tlp_credits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ebi_cpl               : 11; /**< [ 31: 21](R/W) TLP 32 B credits for completion TLPs in the PEMs inbound EBUS buffers.
                                                                 Legal values are 0x21 to 0x100. */
        uint64_t ebi_np                : 10; /**< [ 20: 11](R/W) TLP headers for non-posted TLPs in the PEMs inbound EBUS buffers.
                                                                 Legal values are 0x1 to 0x20. */
        uint64_t ebi_p                 : 11; /**< [ 10:  0](R/W) TLP 32 B credits for posted TLPs in the PEMs inbound EBUS buffers.
                                                                 Legal values are 0x21 to 0x100. */
#else /* Word 0 - Little Endian */
        uint64_t ebi_p                 : 11; /**< [ 10:  0](R/W) TLP 32 B credits for posted TLPs in the PEMs inbound EBUS buffers.
                                                                 Legal values are 0x21 to 0x100. */
        uint64_t ebi_np                : 10; /**< [ 20: 11](R/W) TLP headers for non-posted TLPs in the PEMs inbound EBUS buffers.
                                                                 Legal values are 0x1 to 0x20. */
        uint64_t ebi_cpl               : 11; /**< [ 31: 21](R/W) TLP 32 B credits for completion TLPs in the PEMs inbound EBUS buffers.
                                                                 Legal values are 0x21 to 0x100. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ebi_tlp_credits_s cn; */
};
typedef union bdk_pemx_ebi_tlp_credits bdk_pemx_ebi_tlp_credits_t;

static inline uint64_t BDK_PEMX_EBI_TLP_CREDITS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_EBI_TLP_CREDITS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000028ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000028ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000028ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000028ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_EBI_TLP_CREDITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_EBI_TLP_CREDITS(a) bdk_pemx_ebi_tlp_credits_t
#define bustype_BDK_PEMX_EBI_TLP_CREDITS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_EBI_TLP_CREDITS(a) "PEMX_EBI_TLP_CREDITS"
#define device_bar_BDK_PEMX_EBI_TLP_CREDITS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_EBI_TLP_CREDITS(a) (a)
#define arguments_BDK_PEMX_EBI_TLP_CREDITS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ebo_fifo_status
 *
 * PEM EBO Offloading FIFO Status Register
 * This register contains status about the PEM EBO offloading FIFOs.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_ebo_fifo_status
{
    uint64_t u;
    struct bdk_pemx_ebo_fifo_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_54_63        : 10;
        uint64_t c_cmd_volume          : 6;  /**< [ 53: 48](RO/H) Reports the number of valid EBO completion data beats currently held in the
                                                                 EBO completion buffer. Each entry represents a beat of the EBO bus related to a
                                                                 completion operation and the value read can range from 0x0 to a maximum of 0x20
                                                                 which would represent completely full. For diagnostic use only. */
        uint64_t reserved_46_47        : 2;
        uint64_t n_cmd_volume          : 6;  /**< [ 45: 40](RO/H) Reports the number of valid entries currently held in the EBO non-posted
                                                                 offloading FIFO. Each entry represents a beat of the EBO bus related to a
                                                                 Non-Posted operation and the value read can range from 0x0 to a maximum of 0x20
                                                                 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t reserved_38_39        : 2;
        uint64_t p_cmd_volume          : 6;  /**< [ 37: 32](RO/H) Reports the number of valid entries currently held in the EBO posted offloading
                                                                 FIFO. Each entry represents a beat of the EBO bus related to a memory store and
                                                                 the value read can range from 0x0 to a maximum of 0x20 which would represent
                                                                 completely full.
                                                                 For diagnostic use only. */
        uint64_t c_data_volume         : 8;  /**< [ 31: 24](RO/H) Reports the number of valid EBO completion data beats currently held in the
                                                                 EBO completion buffer. Each entry represents a beat of the EBO bus related to a
                                                                 completion operation and the value read can range from 0x0 to a maximum of 0x40
                                                                 which would represent completely full. For diagnostic use only.

                                                                 Internal:
                                                                 Maximum is 32 for 512b EBUS, 64 for 256b EBUS, 128 for 128b EBUS. */
        uint64_t reserved_20_23        : 4;
        uint64_t n_data_volume         : 8;  /**< [ 19: 12](RO/H) Reports the number of valid entries currently held in the EBO non-posted
                                                                 offloading FIFO. Each entry represents a beat of the EBO bus related to a
                                                                 Non-Posted operation and the value read can range from 0x0 to a maximum of 0x40
                                                                 which would represent completely full.
                                                                 For diagnostic use only.

                                                                 Internal:
                                                                 Maximum is 32 for 512b EBUS, 64 for 256b EBUS, 128 for 128b EBUS. */
        uint64_t reserved_8_11         : 4;
        uint64_t p_data_volume         : 8;  /**< [  7:  0](RO/H) Reports the number of valid entries currently held in the EBO posted offloading
                                                                 FIFO. Each entry represents a beat of the EBO bus related to a memory store and
                                                                 the value read can range from 0x0 to a maximum of 0x40 which would represent
                                                                 completely full.
                                                                 For diagnostic use only.

                                                                 Internal:
                                                                 Maximum is 32 for 512b EBUS, 64 for 256b EBUS, 128 for 128b EBUS. */
#else /* Word 0 - Little Endian */
        uint64_t p_data_volume         : 8;  /**< [  7:  0](RO/H) Reports the number of valid entries currently held in the EBO posted offloading
                                                                 FIFO. Each entry represents a beat of the EBO bus related to a memory store and
                                                                 the value read can range from 0x0 to a maximum of 0x40 which would represent
                                                                 completely full.
                                                                 For diagnostic use only.

                                                                 Internal:
                                                                 Maximum is 32 for 512b EBUS, 64 for 256b EBUS, 128 for 128b EBUS. */
        uint64_t reserved_8_11         : 4;
        uint64_t n_data_volume         : 8;  /**< [ 19: 12](RO/H) Reports the number of valid entries currently held in the EBO non-posted
                                                                 offloading FIFO. Each entry represents a beat of the EBO bus related to a
                                                                 Non-Posted operation and the value read can range from 0x0 to a maximum of 0x40
                                                                 which would represent completely full.
                                                                 For diagnostic use only.

                                                                 Internal:
                                                                 Maximum is 32 for 512b EBUS, 64 for 256b EBUS, 128 for 128b EBUS. */
        uint64_t reserved_20_23        : 4;
        uint64_t c_data_volume         : 8;  /**< [ 31: 24](RO/H) Reports the number of valid EBO completion data beats currently held in the
                                                                 EBO completion buffer. Each entry represents a beat of the EBO bus related to a
                                                                 completion operation and the value read can range from 0x0 to a maximum of 0x40
                                                                 which would represent completely full. For diagnostic use only.

                                                                 Internal:
                                                                 Maximum is 32 for 512b EBUS, 64 for 256b EBUS, 128 for 128b EBUS. */
        uint64_t p_cmd_volume          : 6;  /**< [ 37: 32](RO/H) Reports the number of valid entries currently held in the EBO posted offloading
                                                                 FIFO. Each entry represents a beat of the EBO bus related to a memory store and
                                                                 the value read can range from 0x0 to a maximum of 0x20 which would represent
                                                                 completely full.
                                                                 For diagnostic use only. */
        uint64_t reserved_38_39        : 2;
        uint64_t n_cmd_volume          : 6;  /**< [ 45: 40](RO/H) Reports the number of valid entries currently held in the EBO non-posted
                                                                 offloading FIFO. Each entry represents a beat of the EBO bus related to a
                                                                 Non-Posted operation and the value read can range from 0x0 to a maximum of 0x20
                                                                 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t reserved_46_47        : 2;
        uint64_t c_cmd_volume          : 6;  /**< [ 53: 48](RO/H) Reports the number of valid EBO completion data beats currently held in the
                                                                 EBO completion buffer. Each entry represents a beat of the EBO bus related to a
                                                                 completion operation and the value read can range from 0x0 to a maximum of 0x20
                                                                 which would represent completely full. For diagnostic use only. */
        uint64_t reserved_54_63        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ebo_fifo_status_s cn; */
};
typedef union bdk_pemx_ebo_fifo_status bdk_pemx_ebo_fifo_status_t;

static inline uint64_t BDK_PEMX_EBO_FIFO_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_EBO_FIFO_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000140ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000140ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000140ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000140ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_EBO_FIFO_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_EBO_FIFO_STATUS(a) bdk_pemx_ebo_fifo_status_t
#define bustype_BDK_PEMX_EBO_FIFO_STATUS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_EBO_FIFO_STATUS(a) "PEMX_EBO_FIFO_STATUS"
#define device_bar_BDK_PEMX_EBO_FIFO_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_EBO_FIFO_STATUS(a) (a)
#define arguments_BDK_PEMX_EBO_FIFO_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ebus_ctl
 *
 * PEM EBUS Control Register
 * This register contains EBUS related control bits.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_ebus_ctl
{
    uint64_t u;
    struct bdk_pemx_ebus_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t ebo_stf               : 1;  /**< [ 32: 32](R/W) If set, force store and forward mode for offloading FIFOs on outbound EBUS.
                                                                 This might be useful in a system with an EBUS which cannot keep up with
                                                                 the PCIe link bandwidth (e.g. 128B EBUS or many idle cycles on EBUS) where
                                                                 idle cycles introduced in the packet stream could interfere with NCBO
                                                                 performance. In general it should not be set. */
        uint64_t reserved_16_31        : 16;
        uint64_t clken_force           : 1;  /**< [ 15: 15](R/W) Force clock enable on inbound EBUS to be always asserted. For diagnostic use only. */
        uint64_t erom_sel              : 1;  /**< [ 14: 14](R/W) If set, inbound PF EROM BAR accesses are directed to EBUS instead of NCB. This
                                                                 must be clear when the PEM is configured for RC mode.

                                                                 For CNXXXX this bit must be clear. */
        uint64_t vf_bar2_sel           : 1;  /**< [ 13: 13](RO) If set, inbound VF BAR2 accesses are directed to EBUS instead of NCB. This bit is
                                                                 hard-coded to 1. */
        uint64_t vf_bar4_sel           : 1;  /**< [ 12: 12](RO) If set, inbound VF BAR4 accesses are directed to EBUS instead of NCB. This bit is
                                                                 hard-coded to 1. */
        uint64_t vf_bar0_sel           : 1;  /**< [ 11: 11](RO) If set, inbound VF BAR0 accesses are directed to EBUS instead of NCB. This bit is
                                                                 hard-coded to 1. */
        uint64_t pf_bar2_sel           : 1;  /**< [ 10: 10](R/W) If set, inbound PF BAR2 accesses are directed to EBUS instead of NCB. In RC mode,
                                                                 registers PEM()_P2N_BAR2_START / PEM()_BAR_CTL[BAR2_SIZ] are used to determine a BAR2 hit
                                                                 rather than standard PCIe config registers.

                                                                 For CNXXXX this bit must be clear. */
        uint64_t pf_bar4_sel           : 1;  /**< [  9:  9](R/W) If set, inbound PF BAR4 accesses are directed to EBUS instead of NCB. In RC mode,
                                                                 registers PEM()_P2N_BAR4_START / PEM()_BAR_CTL[BAR4_SIZ] are used to determine a BAR4 hit
                                                                 rather than standard PCIe config registers.

                                                                 For CNXXXX this bit must be clear. */
        uint64_t pf_bar0_sel           : 1;  /**< [  8:  8](R/W) If set, inbound PF BAR0 accesses are directed to EBUS instead of NCB. In RC mode,
                                                                 registers PEM()_P2N_BAR0_START / PEM()_BAR_CTL[BAR0_SIZ] are used to determine a BAR0 hit
                                                                 rather than standard PCIe config registers.

                                                                 For CNXXXX this bit must be set. */
        uint64_t reserved_6_7          : 2;
        uint64_t ntlp_ro_dis           : 1;  /**< [  5:  5](R/W) Relaxed ordering disable for non-posted TLPs. Forces relaxed ordering bit off
                                                                 when incoming non-posted TLPs arrive targeting EBUS. */
        uint64_t inv_par               : 1;  /**< [  4:  4](R/W) When set, causes the parity bit on inbound EBUS to be inverted. This bit is for
                                                                 debug only. */
        uint64_t atomic_dis            : 1;  /**< [  3:  3](R/W) If set, incoming atomics targeting EBUS are discarded and a completion with
                                                                 status of unsupported request is returned to the sender.

                                                                 This bit must be set. */
        uint64_t ctlp_ro_dis           : 1;  /**< [  2:  2](R/W) Relaxed ordering disable for completion TLPs. Forces relaxed ordering bit off
                                                                 when incoming completion TLPs arrive targeting EBUS. */
        uint64_t ptlp_ro_dis           : 1;  /**< [  1:  1](R/W) Relaxed ordering disable for posted TLPs. Forces relaxed ordering bit off when
                                                                 incoming posted TLPs arrive targeting EBUS. */
        uint64_t vdm_dis               : 1;  /**< [  0:  0](R/W) If set, incoming vendor defined messages from PCIe will be discarded rather than
                                                                 forwarded on EBUS.

                                                                 For CNXXXX this bit must be set. */
#else /* Word 0 - Little Endian */
        uint64_t vdm_dis               : 1;  /**< [  0:  0](R/W) If set, incoming vendor defined messages from PCIe will be discarded rather than
                                                                 forwarded on EBUS.

                                                                 For CNXXXX this bit must be set. */
        uint64_t ptlp_ro_dis           : 1;  /**< [  1:  1](R/W) Relaxed ordering disable for posted TLPs. Forces relaxed ordering bit off when
                                                                 incoming posted TLPs arrive targeting EBUS. */
        uint64_t ctlp_ro_dis           : 1;  /**< [  2:  2](R/W) Relaxed ordering disable for completion TLPs. Forces relaxed ordering bit off
                                                                 when incoming completion TLPs arrive targeting EBUS. */
        uint64_t atomic_dis            : 1;  /**< [  3:  3](R/W) If set, incoming atomics targeting EBUS are discarded and a completion with
                                                                 status of unsupported request is returned to the sender.

                                                                 This bit must be set. */
        uint64_t inv_par               : 1;  /**< [  4:  4](R/W) When set, causes the parity bit on inbound EBUS to be inverted. This bit is for
                                                                 debug only. */
        uint64_t ntlp_ro_dis           : 1;  /**< [  5:  5](R/W) Relaxed ordering disable for non-posted TLPs. Forces relaxed ordering bit off
                                                                 when incoming non-posted TLPs arrive targeting EBUS. */
        uint64_t reserved_6_7          : 2;
        uint64_t pf_bar0_sel           : 1;  /**< [  8:  8](R/W) If set, inbound PF BAR0 accesses are directed to EBUS instead of NCB. In RC mode,
                                                                 registers PEM()_P2N_BAR0_START / PEM()_BAR_CTL[BAR0_SIZ] are used to determine a BAR0 hit
                                                                 rather than standard PCIe config registers.

                                                                 For CNXXXX this bit must be set. */
        uint64_t pf_bar4_sel           : 1;  /**< [  9:  9](R/W) If set, inbound PF BAR4 accesses are directed to EBUS instead of NCB. In RC mode,
                                                                 registers PEM()_P2N_BAR4_START / PEM()_BAR_CTL[BAR4_SIZ] are used to determine a BAR4 hit
                                                                 rather than standard PCIe config registers.

                                                                 For CNXXXX this bit must be clear. */
        uint64_t pf_bar2_sel           : 1;  /**< [ 10: 10](R/W) If set, inbound PF BAR2 accesses are directed to EBUS instead of NCB. In RC mode,
                                                                 registers PEM()_P2N_BAR2_START / PEM()_BAR_CTL[BAR2_SIZ] are used to determine a BAR2 hit
                                                                 rather than standard PCIe config registers.

                                                                 For CNXXXX this bit must be clear. */
        uint64_t vf_bar0_sel           : 1;  /**< [ 11: 11](RO) If set, inbound VF BAR0 accesses are directed to EBUS instead of NCB. This bit is
                                                                 hard-coded to 1. */
        uint64_t vf_bar4_sel           : 1;  /**< [ 12: 12](RO) If set, inbound VF BAR4 accesses are directed to EBUS instead of NCB. This bit is
                                                                 hard-coded to 1. */
        uint64_t vf_bar2_sel           : 1;  /**< [ 13: 13](RO) If set, inbound VF BAR2 accesses are directed to EBUS instead of NCB. This bit is
                                                                 hard-coded to 1. */
        uint64_t erom_sel              : 1;  /**< [ 14: 14](R/W) If set, inbound PF EROM BAR accesses are directed to EBUS instead of NCB. This
                                                                 must be clear when the PEM is configured for RC mode.

                                                                 For CNXXXX this bit must be clear. */
        uint64_t clken_force           : 1;  /**< [ 15: 15](R/W) Force clock enable on inbound EBUS to be always asserted. For diagnostic use only. */
        uint64_t reserved_16_31        : 16;
        uint64_t ebo_stf               : 1;  /**< [ 32: 32](R/W) If set, force store and forward mode for offloading FIFOs on outbound EBUS.
                                                                 This might be useful in a system with an EBUS which cannot keep up with
                                                                 the PCIe link bandwidth (e.g. 128B EBUS or many idle cycles on EBUS) where
                                                                 idle cycles introduced in the packet stream could interfere with NCBO
                                                                 performance. In general it should not be set. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ebus_ctl_s cn; */
};
typedef union bdk_pemx_ebus_ctl bdk_pemx_ebus_ctl_t;

static inline uint64_t BDK_PEMX_EBUS_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_EBUS_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000080ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000080ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000080ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000080ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_EBUS_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_EBUS_CTL(a) bdk_pemx_ebus_ctl_t
#define bustype_BDK_PEMX_EBUS_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_EBUS_CTL(a) "PEMX_EBUS_CTL"
#define device_bar_BDK_PEMX_EBUS_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_EBUS_CTL(a) (a)
#define arguments_BDK_PEMX_EBUS_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_ecc_ena
 *
 * PEM ECC Enable Register
 * Contains enables for TLP FIFO ECC RAMs.
 */
union bdk_pemx_ecc_ena
{
    uint64_t u;
    struct bdk_pemx_ecc_ena_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t qhdr_b1_ena           : 1;  /**< [ 34: 34](R/W) ECC enable for Core's Q HDR Bank1 RAM. */
        uint64_t qhdr_b0_ena           : 1;  /**< [ 33: 33](R/W) ECC enable for Core's Q HDR Bank0 RAM. */
        uint64_t rtry_ena              : 1;  /**< [ 32: 32](R/W) ECC enable for Core's RETRY RA. */
        uint64_t reserved_11_31        : 21;
        uint64_t m2s_c_ena             : 1;  /**< [ 10: 10](R/W) ECC enable for M2S Control FIFO. */
        uint64_t m2s_d_ena             : 1;  /**< [  9:  9](R/W) ECC enable for M2S Data FIFO. */
        uint64_t c_c_ena               : 1;  /**< [  8:  8](R/W) ECC enable for TLP CPL control FIFO. */
        uint64_t c_d1_ena              : 1;  /**< [  7:  7](R/W) ECC enable for TLP CPL data1 FIFO. */
        uint64_t c_d0_ena              : 1;  /**< [  6:  6](R/W) ECC enable for TLP CPL data0 FIFO. */
        uint64_t n_c_ena               : 1;  /**< [  5:  5](R/W) ECC enable for TLP NP control FIFO. */
        uint64_t n_d1_ena              : 1;  /**< [  4:  4](R/W) ECC enable for TLP NP data1 FIFO. */
        uint64_t n_d0_ena              : 1;  /**< [  3:  3](R/W) ECC enable for TLP NP data0 FIFO. */
        uint64_t p_c_ena               : 1;  /**< [  2:  2](R/W) ECC enable for TLP posted control FIFO. */
        uint64_t p_d1_ena              : 1;  /**< [  1:  1](R/W) ECC enable for TLP posted data1 FIFO. */
        uint64_t p_d0_ena              : 1;  /**< [  0:  0](R/W) ECC enable for TLP posted data0 FIFO. */
#else /* Word 0 - Little Endian */
        uint64_t p_d0_ena              : 1;  /**< [  0:  0](R/W) ECC enable for TLP posted data0 FIFO. */
        uint64_t p_d1_ena              : 1;  /**< [  1:  1](R/W) ECC enable for TLP posted data1 FIFO. */
        uint64_t p_c_ena               : 1;  /**< [  2:  2](R/W) ECC enable for TLP posted control FIFO. */
        uint64_t n_d0_ena              : 1;  /**< [  3:  3](R/W) ECC enable for TLP NP data0 FIFO. */
        uint64_t n_d1_ena              : 1;  /**< [  4:  4](R/W) ECC enable for TLP NP data1 FIFO. */
        uint64_t n_c_ena               : 1;  /**< [  5:  5](R/W) ECC enable for TLP NP control FIFO. */
        uint64_t c_d0_ena              : 1;  /**< [  6:  6](R/W) ECC enable for TLP CPL data0 FIFO. */
        uint64_t c_d1_ena              : 1;  /**< [  7:  7](R/W) ECC enable for TLP CPL data1 FIFO. */
        uint64_t c_c_ena               : 1;  /**< [  8:  8](R/W) ECC enable for TLP CPL control FIFO. */
        uint64_t m2s_d_ena             : 1;  /**< [  9:  9](R/W) ECC enable for M2S Data FIFO. */
        uint64_t m2s_c_ena             : 1;  /**< [ 10: 10](R/W) ECC enable for M2S Control FIFO. */
        uint64_t reserved_11_31        : 21;
        uint64_t rtry_ena              : 1;  /**< [ 32: 32](R/W) ECC enable for Core's RETRY RA. */
        uint64_t qhdr_b0_ena           : 1;  /**< [ 33: 33](R/W) ECC enable for Core's Q HDR Bank0 RAM. */
        uint64_t qhdr_b1_ena           : 1;  /**< [ 34: 34](R/W) ECC enable for Core's Q HDR Bank1 RAM. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ecc_ena_s cn8; */
    struct bdk_pemx_ecc_ena_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t qhdr_b1_ena           : 1;  /**< [ 34: 34](R/W) ECC enable for Core's Q HDR Bank1 RAM. */
        uint64_t qhdr_b0_ena           : 1;  /**< [ 33: 33](R/W) ECC enable for Core's Q HDR Bank0 RAM. */
        uint64_t rtry_ena              : 1;  /**< [ 32: 32](R/W) ECC enable for Core's RETRY RA. */
        uint64_t reserved_9_31         : 23;
        uint64_t c_c_ena               : 1;  /**< [  8:  8](R/W) ECC enable for TLP CPL control FIFO. */
        uint64_t c_d1_ena              : 1;  /**< [  7:  7](R/W) ECC enable for TLP CPL data1 FIFO. */
        uint64_t c_d0_ena              : 1;  /**< [  6:  6](R/W) ECC enable for TLP CPL data0 FIFO. */
        uint64_t n_c_ena               : 1;  /**< [  5:  5](R/W) ECC enable for TLP NP control FIFO. */
        uint64_t n_d1_ena              : 1;  /**< [  4:  4](R/W) ECC enable for TLP NP data1 FIFO. */
        uint64_t n_d0_ena              : 1;  /**< [  3:  3](R/W) ECC enable for TLP NP data0 FIFO. */
        uint64_t p_c_ena               : 1;  /**< [  2:  2](R/W) ECC enable for TLP posted control FIFO. */
        uint64_t p_d1_ena              : 1;  /**< [  1:  1](R/W) ECC enable for TLP posted data1 FIFO. */
        uint64_t p_d0_ena              : 1;  /**< [  0:  0](R/W) ECC enable for TLP posted data0 FIFO. */
#else /* Word 0 - Little Endian */
        uint64_t p_d0_ena              : 1;  /**< [  0:  0](R/W) ECC enable for TLP posted data0 FIFO. */
        uint64_t p_d1_ena              : 1;  /**< [  1:  1](R/W) ECC enable for TLP posted data1 FIFO. */
        uint64_t p_c_ena               : 1;  /**< [  2:  2](R/W) ECC enable for TLP posted control FIFO. */
        uint64_t n_d0_ena              : 1;  /**< [  3:  3](R/W) ECC enable for TLP NP data0 FIFO. */
        uint64_t n_d1_ena              : 1;  /**< [  4:  4](R/W) ECC enable for TLP NP data1 FIFO. */
        uint64_t n_c_ena               : 1;  /**< [  5:  5](R/W) ECC enable for TLP NP control FIFO. */
        uint64_t c_d0_ena              : 1;  /**< [  6:  6](R/W) ECC enable for TLP CPL data0 FIFO. */
        uint64_t c_d1_ena              : 1;  /**< [  7:  7](R/W) ECC enable for TLP CPL data1 FIFO. */
        uint64_t c_c_ena               : 1;  /**< [  8:  8](R/W) ECC enable for TLP CPL control FIFO. */
        uint64_t reserved_9_31         : 23;
        uint64_t rtry_ena              : 1;  /**< [ 32: 32](R/W) ECC enable for Core's RETRY RA. */
        uint64_t qhdr_b0_ena           : 1;  /**< [ 33: 33](R/W) ECC enable for Core's Q HDR Bank0 RAM. */
        uint64_t qhdr_b1_ena           : 1;  /**< [ 34: 34](R/W) ECC enable for Core's Q HDR Bank1 RAM. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_ecc_ena_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t m2s_c_ena             : 1;  /**< [ 10: 10](R/W) ECC enable for M2S Control FIFO. */
        uint64_t m2s_d_ena             : 1;  /**< [  9:  9](R/W) ECC enable for M2S Data FIFO. */
        uint64_t c_c_ena               : 1;  /**< [  8:  8](R/W) ECC enable for TLP CPL control FIFO. */
        uint64_t c_d1_ena              : 1;  /**< [  7:  7](R/W) ECC enable for TLP CPL data1 FIFO. */
        uint64_t c_d0_ena              : 1;  /**< [  6:  6](R/W) ECC enable for TLP CPL data0 FIFO. */
        uint64_t n_c_ena               : 1;  /**< [  5:  5](R/W) ECC enable for TLP NP control FIFO. */
        uint64_t n_d1_ena              : 1;  /**< [  4:  4](R/W) ECC enable for TLP NP data1 FIFO. */
        uint64_t n_d0_ena              : 1;  /**< [  3:  3](R/W) ECC enable for TLP NP data0 FIFO. */
        uint64_t p_c_ena               : 1;  /**< [  2:  2](R/W) ECC enable for TLP posted control FIFO. */
        uint64_t p_d1_ena              : 1;  /**< [  1:  1](R/W) ECC enable for TLP posted data1 FIFO. */
        uint64_t p_d0_ena              : 1;  /**< [  0:  0](R/W) ECC enable for TLP posted data0 FIFO. */
#else /* Word 0 - Little Endian */
        uint64_t p_d0_ena              : 1;  /**< [  0:  0](R/W) ECC enable for TLP posted data0 FIFO. */
        uint64_t p_d1_ena              : 1;  /**< [  1:  1](R/W) ECC enable for TLP posted data1 FIFO. */
        uint64_t p_c_ena               : 1;  /**< [  2:  2](R/W) ECC enable for TLP posted control FIFO. */
        uint64_t n_d0_ena              : 1;  /**< [  3:  3](R/W) ECC enable for TLP NP data0 FIFO. */
        uint64_t n_d1_ena              : 1;  /**< [  4:  4](R/W) ECC enable for TLP NP data1 FIFO. */
        uint64_t n_c_ena               : 1;  /**< [  5:  5](R/W) ECC enable for TLP NP control FIFO. */
        uint64_t c_d0_ena              : 1;  /**< [  6:  6](R/W) ECC enable for TLP CPL data0 FIFO. */
        uint64_t c_d1_ena              : 1;  /**< [  7:  7](R/W) ECC enable for TLP CPL data1 FIFO. */
        uint64_t c_c_ena               : 1;  /**< [  8:  8](R/W) ECC enable for TLP CPL control FIFO. */
        uint64_t m2s_d_ena             : 1;  /**< [  9:  9](R/W) ECC enable for M2S Data FIFO. */
        uint64_t m2s_c_ena             : 1;  /**< [ 10: 10](R/W) ECC enable for M2S Control FIFO. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } cn83xx;
};
typedef union bdk_pemx_ecc_ena bdk_pemx_ecc_ena_t;

static inline uint64_t BDK_PEMX_ECC_ENA(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_ECC_ENA(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000470ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000470ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_ECC_ENA", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_ECC_ENA(a) bdk_pemx_ecc_ena_t
#define bustype_BDK_PEMX_ECC_ENA(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_ECC_ENA(a) "PEMX_ECC_ENA"
#define device_bar_BDK_PEMX_ECC_ENA(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_ECC_ENA(a) (a)
#define arguments_BDK_PEMX_ECC_ENA(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_ecc_synd_ctrl
 *
 * PEM ECC Syndrome Control Register
 * This register contains syndrome control for TLP FIFO ECC RAMs.
 */
union bdk_pemx_ecc_synd_ctrl
{
    uint64_t u;
    struct bdk_pemx_ecc_synd_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_38_63        : 26;
        uint64_t qhdr_b1_syn           : 2;  /**< [ 37: 36](R/W) Syndrome flip bits for Core's Q HDR Bank1 RAM. */
        uint64_t qhdr_b0_syn           : 2;  /**< [ 35: 34](R/W) Syndrome flip bits for Core's Q HDR Bank0 RAM. */
        uint64_t rtry_syn              : 2;  /**< [ 33: 32](R/W) Syndrome flip bits for Core's RETRY RAM. */
        uint64_t reserved_22_31        : 10;
        uint64_t m2s_c_syn             : 2;  /**< [ 21: 20](R/W) Syndrome flip bits for M2S Control FIFO. */
        uint64_t m2s_d_syn             : 2;  /**< [ 19: 18](R/W) Syndrome flip bits for M2S Data FIFO. */
        uint64_t c_c_syn               : 2;  /**< [ 17: 16](R/W) Syndrome flip bits for TLP CPL control FIFO. */
        uint64_t c_d1_syn              : 2;  /**< [ 15: 14](R/W) Syndrome flip bits for TLP CPL data1 FIFO. */
        uint64_t c_d0_syn              : 2;  /**< [ 13: 12](R/W) Syndrome flip bits for TLP CPL data0 FIFO. */
        uint64_t n_c_syn               : 2;  /**< [ 11: 10](R/W) Syndrome flip bits for TLP NP control FIFO. */
        uint64_t n_d1_syn              : 2;  /**< [  9:  8](R/W) Syndrome flip bits for TLP NP data1 FIFO. */
        uint64_t n_d0_syn              : 2;  /**< [  7:  6](R/W) Syndrome flip bits for TLP NP data0 FIFO. */
        uint64_t p_c_syn               : 2;  /**< [  5:  4](R/W) Syndrome flip bits for TLP posted control FIFO. */
        uint64_t p_d1_syn              : 2;  /**< [  3:  2](R/W) Syndrome flip bits for TLP posted data1 FIFO. */
        uint64_t p_d0_syn              : 2;  /**< [  1:  0](R/W) Syndrome flip bits for TLP posted data0 FIFO. */
#else /* Word 0 - Little Endian */
        uint64_t p_d0_syn              : 2;  /**< [  1:  0](R/W) Syndrome flip bits for TLP posted data0 FIFO. */
        uint64_t p_d1_syn              : 2;  /**< [  3:  2](R/W) Syndrome flip bits for TLP posted data1 FIFO. */
        uint64_t p_c_syn               : 2;  /**< [  5:  4](R/W) Syndrome flip bits for TLP posted control FIFO. */
        uint64_t n_d0_syn              : 2;  /**< [  7:  6](R/W) Syndrome flip bits for TLP NP data0 FIFO. */
        uint64_t n_d1_syn              : 2;  /**< [  9:  8](R/W) Syndrome flip bits for TLP NP data1 FIFO. */
        uint64_t n_c_syn               : 2;  /**< [ 11: 10](R/W) Syndrome flip bits for TLP NP control FIFO. */
        uint64_t c_d0_syn              : 2;  /**< [ 13: 12](R/W) Syndrome flip bits for TLP CPL data0 FIFO. */
        uint64_t c_d1_syn              : 2;  /**< [ 15: 14](R/W) Syndrome flip bits for TLP CPL data1 FIFO. */
        uint64_t c_c_syn               : 2;  /**< [ 17: 16](R/W) Syndrome flip bits for TLP CPL control FIFO. */
        uint64_t m2s_d_syn             : 2;  /**< [ 19: 18](R/W) Syndrome flip bits for M2S Data FIFO. */
        uint64_t m2s_c_syn             : 2;  /**< [ 21: 20](R/W) Syndrome flip bits for M2S Control FIFO. */
        uint64_t reserved_22_31        : 10;
        uint64_t rtry_syn              : 2;  /**< [ 33: 32](R/W) Syndrome flip bits for Core's RETRY RAM. */
        uint64_t qhdr_b0_syn           : 2;  /**< [ 35: 34](R/W) Syndrome flip bits for Core's Q HDR Bank0 RAM. */
        uint64_t qhdr_b1_syn           : 2;  /**< [ 37: 36](R/W) Syndrome flip bits for Core's Q HDR Bank1 RAM. */
        uint64_t reserved_38_63        : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ecc_synd_ctrl_s cn8; */
    struct bdk_pemx_ecc_synd_ctrl_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_38_63        : 26;
        uint64_t qhdr_b1_syn           : 2;  /**< [ 37: 36](R/W) Syndrome flip bits for Core's Q HDR Bank1 RAM. */
        uint64_t qhdr_b0_syn           : 2;  /**< [ 35: 34](R/W) Syndrome flip bits for Core's Q HDR Bank0 RAM. */
        uint64_t rtry_syn              : 2;  /**< [ 33: 32](R/W) Syndrome flip bits for Core's RETRY RAM. */
        uint64_t reserved_18_31        : 14;
        uint64_t c_c_syn               : 2;  /**< [ 17: 16](R/W) Syndrome flip bits for TLP CPL control FIFO. */
        uint64_t c_d1_syn              : 2;  /**< [ 15: 14](R/W) Syndrome flip bits for TLP CPL data1 FIFO. */
        uint64_t c_d0_syn              : 2;  /**< [ 13: 12](R/W) Syndrome flip bits for TLP CPL data0 FIFO. */
        uint64_t n_c_syn               : 2;  /**< [ 11: 10](R/W) Syndrome flip bits for TLP NP control FIFO. */
        uint64_t n_d1_syn              : 2;  /**< [  9:  8](R/W) Syndrome flip bits for TLP NP data1 FIFO. */
        uint64_t n_d0_syn              : 2;  /**< [  7:  6](R/W) Syndrome flip bits for TLP NP data0 FIFO. */
        uint64_t p_c_syn               : 2;  /**< [  5:  4](R/W) Syndrome flip bits for TLP posted control FIFO. */
        uint64_t p_d1_syn              : 2;  /**< [  3:  2](R/W) Syndrome flip bits for TLP posted data1 FIFO. */
        uint64_t p_d0_syn              : 2;  /**< [  1:  0](R/W) Syndrome flip bits for TLP posted data0 FIFO. */
#else /* Word 0 - Little Endian */
        uint64_t p_d0_syn              : 2;  /**< [  1:  0](R/W) Syndrome flip bits for TLP posted data0 FIFO. */
        uint64_t p_d1_syn              : 2;  /**< [  3:  2](R/W) Syndrome flip bits for TLP posted data1 FIFO. */
        uint64_t p_c_syn               : 2;  /**< [  5:  4](R/W) Syndrome flip bits for TLP posted control FIFO. */
        uint64_t n_d0_syn              : 2;  /**< [  7:  6](R/W) Syndrome flip bits for TLP NP data0 FIFO. */
        uint64_t n_d1_syn              : 2;  /**< [  9:  8](R/W) Syndrome flip bits for TLP NP data1 FIFO. */
        uint64_t n_c_syn               : 2;  /**< [ 11: 10](R/W) Syndrome flip bits for TLP NP control FIFO. */
        uint64_t c_d0_syn              : 2;  /**< [ 13: 12](R/W) Syndrome flip bits for TLP CPL data0 FIFO. */
        uint64_t c_d1_syn              : 2;  /**< [ 15: 14](R/W) Syndrome flip bits for TLP CPL data1 FIFO. */
        uint64_t c_c_syn               : 2;  /**< [ 17: 16](R/W) Syndrome flip bits for TLP CPL control FIFO. */
        uint64_t reserved_18_31        : 14;
        uint64_t rtry_syn              : 2;  /**< [ 33: 32](R/W) Syndrome flip bits for Core's RETRY RAM. */
        uint64_t qhdr_b0_syn           : 2;  /**< [ 35: 34](R/W) Syndrome flip bits for Core's Q HDR Bank0 RAM. */
        uint64_t qhdr_b1_syn           : 2;  /**< [ 37: 36](R/W) Syndrome flip bits for Core's Q HDR Bank1 RAM. */
        uint64_t reserved_38_63        : 26;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_ecc_synd_ctrl_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t m2s_c_syn             : 2;  /**< [ 21: 20](R/W) Syndrome flip bits for M2S Control FIFO. */
        uint64_t m2s_d_syn             : 2;  /**< [ 19: 18](R/W) Syndrome flip bits for M2S Data FIFO. */
        uint64_t c_c_syn               : 2;  /**< [ 17: 16](R/W) Syndrome flip bits for TLP CPL control FIFO. */
        uint64_t c_d1_syn              : 2;  /**< [ 15: 14](R/W) Syndrome flip bits for TLP CPL data1 FIFO. */
        uint64_t c_d0_syn              : 2;  /**< [ 13: 12](R/W) Syndrome flip bits for TLP CPL data0 FIFO. */
        uint64_t n_c_syn               : 2;  /**< [ 11: 10](R/W) Syndrome flip bits for TLP NP control FIFO. */
        uint64_t n_d1_syn              : 2;  /**< [  9:  8](R/W) Syndrome flip bits for TLP NP data1 FIFO. */
        uint64_t n_d0_syn              : 2;  /**< [  7:  6](R/W) Syndrome flip bits for TLP NP data0 FIFO. */
        uint64_t p_c_syn               : 2;  /**< [  5:  4](R/W) Syndrome flip bits for TLP posted control FIFO. */
        uint64_t p_d1_syn              : 2;  /**< [  3:  2](R/W) Syndrome flip bits for TLP posted data1 FIFO. */
        uint64_t p_d0_syn              : 2;  /**< [  1:  0](R/W) Syndrome flip bits for TLP posted data0 FIFO. */
#else /* Word 0 - Little Endian */
        uint64_t p_d0_syn              : 2;  /**< [  1:  0](R/W) Syndrome flip bits for TLP posted data0 FIFO. */
        uint64_t p_d1_syn              : 2;  /**< [  3:  2](R/W) Syndrome flip bits for TLP posted data1 FIFO. */
        uint64_t p_c_syn               : 2;  /**< [  5:  4](R/W) Syndrome flip bits for TLP posted control FIFO. */
        uint64_t n_d0_syn              : 2;  /**< [  7:  6](R/W) Syndrome flip bits for TLP NP data0 FIFO. */
        uint64_t n_d1_syn              : 2;  /**< [  9:  8](R/W) Syndrome flip bits for TLP NP data1 FIFO. */
        uint64_t n_c_syn               : 2;  /**< [ 11: 10](R/W) Syndrome flip bits for TLP NP control FIFO. */
        uint64_t c_d0_syn              : 2;  /**< [ 13: 12](R/W) Syndrome flip bits for TLP CPL data0 FIFO. */
        uint64_t c_d1_syn              : 2;  /**< [ 15: 14](R/W) Syndrome flip bits for TLP CPL data1 FIFO. */
        uint64_t c_c_syn               : 2;  /**< [ 17: 16](R/W) Syndrome flip bits for TLP CPL control FIFO. */
        uint64_t m2s_d_syn             : 2;  /**< [ 19: 18](R/W) Syndrome flip bits for M2S Data FIFO. */
        uint64_t m2s_c_syn             : 2;  /**< [ 21: 20](R/W) Syndrome flip bits for M2S Control FIFO. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn83xx;
};
typedef union bdk_pemx_ecc_synd_ctrl bdk_pemx_ecc_synd_ctrl_t;

static inline uint64_t BDK_PEMX_ECC_SYND_CTRL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_ECC_SYND_CTRL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000478ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000478ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_ECC_SYND_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_ECC_SYND_CTRL(a) bdk_pemx_ecc_synd_ctrl_t
#define bustype_BDK_PEMX_ECC_SYND_CTRL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_ECC_SYND_CTRL(a) "PEMX_ECC_SYND_CTRL"
#define device_bar_BDK_PEMX_ECC_SYND_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_ECC_SYND_CTRL(a) (a)
#define arguments_BDK_PEMX_ECC_SYND_CTRL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_eco
 *
 * INTERNAL: PEM Core ECO Register
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_eco
{
    uint64_t u;
    struct bdk_pemx_eco_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t eco_rw                : 8;  /**< [  7:  0](R/W) Reserved for ECO usage. */
#else /* Word 0 - Little Endian */
        uint64_t eco_rw                : 8;  /**< [  7:  0](R/W) Reserved for ECO usage. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_eco_s cn; */
};
typedef union bdk_pemx_eco bdk_pemx_eco_t;

static inline uint64_t BDK_PEMX_ECO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_ECO(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000010ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000008ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000008ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000008ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000008ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_ECO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_ECO(a) bdk_pemx_eco_t
#define bustype_BDK_PEMX_ECO(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_ECO(a) "PEMX_ECO"
#define device_bar_BDK_PEMX_ECO(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_ECO(a) (a)
#define arguments_BDK_PEMX_ECO(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_eco2
 *
 * INTERNAL: PEMM ECO Register
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_eco2
{
    uint64_t u;
    struct bdk_pemx_eco2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t eco_rw                : 8;  /**< [  7:  0](R/W) Reserved for ECO usage. */
#else /* Word 0 - Little Endian */
        uint64_t eco_rw                : 8;  /**< [  7:  0](R/W) Reserved for ECO usage. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_eco2_s cn; */
};
typedef union bdk_pemx_eco2 bdk_pemx_eco2_t;

static inline uint64_t BDK_PEMX_ECO2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_ECO2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000238ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000238ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000238ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000238ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_ECO2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_ECO2(a) bdk_pemx_eco2_t
#define bustype_BDK_PEMX_ECO2(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_ECO2(a) "PEMX_ECO2"
#define device_bar_BDK_PEMX_ECO2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_ECO2(a) (a)
#define arguments_BDK_PEMX_ECO2(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_end_merge
 *
 * PEM End Merge Register
 * Any access (read or write) to this register over NCBO will create a merging barrier
 * for both the write and read streams within PEM outbound pipelines such that no NCBO
 * reads or writes received after this register's access will merge with any NCBO accesses
 * that occurred prior to this register's access.  Note that RSL accesses to this register
 * will have no effect on merging.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_end_merge
{
    uint64_t u;
    struct bdk_pemx_end_merge_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_end_merge_s cn; */
};
typedef union bdk_pemx_end_merge bdk_pemx_end_merge_t;

static inline uint64_t BDK_PEMX_END_MERGE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_END_MERGE(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000188ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000188ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000188ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000188ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_END_MERGE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_END_MERGE(a) bdk_pemx_end_merge_t
#define bustype_BDK_PEMX_END_MERGE(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_END_MERGE(a) "PEMX_END_MERGE"
#define device_bar_BDK_PEMX_END_MERGE(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_END_MERGE(a) (a)
#define arguments_BDK_PEMX_END_MERGE(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_erom#
 *
 * PEM Expansion ROM Registers
 * This register accesses the external EEPROM.
 */
union bdk_pemx_eromx
{
    uint64_t u;
    struct bdk_pemx_eromx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t erom                  : 64; /**< [ 63:  0](R/W/H) PCIe express read transactions to BAR3 (through PCIEEP()_CFG012) will appear as
                                                                 8-byte RSL reads to this register.

                                                                 Although 512 KB is advertised from PCIEEP()_CFG012, only the first 448 KB is
                                                                 actually accessible, and reads above 448 KB will return zeros, writes are NOP.

                                                                 Accessible through PEM2 if EP PEM0 is an RC, otherwise accessible through PEM0.
                                                                 Access from a PEM that doesn't own the EEPROM will return fault. */
#else /* Word 0 - Little Endian */
        uint64_t erom                  : 64; /**< [ 63:  0](R/W/H) PCIe express read transactions to BAR3 (through PCIEEP()_CFG012) will appear as
                                                                 8-byte RSL reads to this register.

                                                                 Although 512 KB is advertised from PCIEEP()_CFG012, only the first 448 KB is
                                                                 actually accessible, and reads above 448 KB will return zeros, writes are NOP.

                                                                 Accessible through PEM2 if EP PEM0 is an RC, otherwise accessible through PEM0.
                                                                 Access from a PEM that doesn't own the EEPROM will return fault. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_eromx_s cn; */
};
typedef union bdk_pemx_eromx bdk_pemx_eromx_t;

static inline uint64_t BDK_PEMX_EROMX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_EROMX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b<=65535)))
        return 0x87e0c0080000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xffff);
    __bdk_csr_fatal("PEMX_EROMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_EROMX(a,b) bdk_pemx_eromx_t
#define bustype_BDK_PEMX_EROMX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_EROMX(a,b) "PEMX_EROMX"
#define device_bar_BDK_PEMX_EROMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_EROMX(a,b) (a)
#define arguments_BDK_PEMX_EROMX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_erom_bar_addr
 *
 * PEM EROM BAR Address Register
 * This register configures PEM EROM BAR accesses targeted at NCBI.
 * Fields in this register are only used when PEM()_EBUS_CTL[EROM_SEL]
 * is clear and the PEM is configured for EP mode.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_erom_bar_addr
{
    uint64_t u;
    struct bdk_pemx_erom_bar_addr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t wvirt                 : 1;  /**< [ 63: 63](R/W) Virtual:
                                                                   0 = [RD_ADDR] is a physical addresses.
                                                                   1 = [RD_ADDR] is a virtual address. */
        uint64_t pspi_en               : 1;  /**< [ 62: 62](R/W) If PEM()_EBUS_CTL[EROM_SEL] is clear, PEM is configured for EP mode, and
                                                                 [PSPI_EN] is set, this bit directs EROM BAR hits to a private bus connected
                                                                 to the PSPI interface in MIO rather than NCB. */
        uint64_t reserved_53_61        : 9;
        uint64_t rd_addr               : 37; /**< [ 52: 16](R/W) Base address for PEM EROM BAR transactions that is appended to the offset. This
                                                                 field is only used when PEM()_EBUS_CTL[EROM_SEL] is clear, and PEM is configured for EP mode. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t rd_addr               : 37; /**< [ 52: 16](R/W) Base address for PEM EROM BAR transactions that is appended to the offset. This
                                                                 field is only used when PEM()_EBUS_CTL[EROM_SEL] is clear, and PEM is configured for EP mode. */
        uint64_t reserved_53_61        : 9;
        uint64_t pspi_en               : 1;  /**< [ 62: 62](R/W) If PEM()_EBUS_CTL[EROM_SEL] is clear, PEM is configured for EP mode, and
                                                                 [PSPI_EN] is set, this bit directs EROM BAR hits to a private bus connected
                                                                 to the PSPI interface in MIO rather than NCB. */
        uint64_t wvirt                 : 1;  /**< [ 63: 63](R/W) Virtual:
                                                                   0 = [RD_ADDR] is a physical addresses.
                                                                   1 = [RD_ADDR] is a virtual address. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_erom_bar_addr_s cn; */
};
typedef union bdk_pemx_erom_bar_addr bdk_pemx_erom_bar_addr_t;

static inline uint64_t BDK_PEMX_EROM_BAR_ADDR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_EROM_BAR_ADDR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000160ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000160ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000160ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000160ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_EROM_BAR_ADDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_EROM_BAR_ADDR(a) bdk_pemx_erom_bar_addr_t
#define bustype_BDK_PEMX_EROM_BAR_ADDR(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_EROM_BAR_ADDR(a) "PEMX_EROM_BAR_ADDR"
#define device_bar_BDK_PEMX_EROM_BAR_ADDR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_EROM_BAR_ADDR(a) (a)
#define arguments_BDK_PEMX_EROM_BAR_ADDR(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_erom_size
 *
 * PEM EROM BAR Address Register
 * This register configures PEM EROM BAR accesses targeted at NCBI.
 * Fields in this register are only used when PEM()_EBUS_CTL[EROM_SEL]
 * is clear and the PEM is configured for EP mode.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_erom_size
{
    uint64_t u;
    struct bdk_pemx_erom_size_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t erom_siz              : 3;  /**< [  2:  0](R/W) PCIe EROM BAR size. Used to mask off upper bits of address
                                                                 when sending to NCBI or via private EROM interface to MIO.

                                                                 0x0 = Reserved.
                                                                 0x1 = 64 KB; 2^16.
                                                                 0x2 = 128 KB; 2^17.
                                                                 0x3 = 256 KB; 2^18.
                                                                 0x4 = 512 KB; 2^19.
                                                                 0x5 = 1 MB; 2^20.
                                                                 0x6 = 2 MB; 2^21.
                                                                 0x7 = 4 MB; 2^22. */
#else /* Word 0 - Little Endian */
        uint64_t erom_siz              : 3;  /**< [  2:  0](R/W) PCIe EROM BAR size. Used to mask off upper bits of address
                                                                 when sending to NCBI or via private EROM interface to MIO.

                                                                 0x0 = Reserved.
                                                                 0x1 = 64 KB; 2^16.
                                                                 0x2 = 128 KB; 2^17.
                                                                 0x3 = 256 KB; 2^18.
                                                                 0x4 = 512 KB; 2^19.
                                                                 0x5 = 1 MB; 2^20.
                                                                 0x6 = 2 MB; 2^21.
                                                                 0x7 = 4 MB; 2^22. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_erom_size_s cn; */
};
typedef union bdk_pemx_erom_size bdk_pemx_erom_size_t;

static inline uint64_t BDK_PEMX_EROM_SIZE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_EROM_SIZE(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000230ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000230ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000230ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000230ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_EROM_SIZE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_EROM_SIZE(a) bdk_pemx_erom_size_t
#define bustype_BDK_PEMX_EROM_SIZE(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_EROM_SIZE(a) "PEMX_EROM_SIZE"
#define device_bar_BDK_PEMX_EROM_SIZE(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_EROM_SIZE(a) (a)
#define arguments_BDK_PEMX_EROM_SIZE(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_flr_ctl
 *
 * PEM FLR Control Register
 * This register provides function level reset controls.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_flr_ctl
{
    uint64_t u;
    struct bdk_pemx_flr_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t chge                  : 1;  /**< [  5:  5](R/W) When set, the default 33 ms expiration of the function level reset
                                                                 global counter can be changed. */
        uint64_t inc                   : 1;  /**< [  4:  4](R/W) When [CHGE] is set, this bit determines if the 33 ms expiration of the function
                                                                 level reset global counter will be increased (set) or decreased (not set). */
        uint64_t delta                 : 2;  /**< [  3:  2](R/W) When [CHGE] is set, this field determines the delta time to increase/decrease
                                                                 the 33 ms expiration of the function level reset global counter.
                                                                 0x0 = 1 ms.
                                                                 0x1 = 2 ms.
                                                                 0x2 = 4 ms.
                                                                 0x3 = 8 ms. */
        uint64_t timer_ctl             : 2;  /**< [  1:  0](R/W) Each FLR indication can be cleared within 66-99 ms by use of a timer. Controls how
                                                                 FLR indication is cleared:
                                                                 0x0 = PEM()_FLR_REQ* can be used to clear the FLR indication, if not written before
                                                                 timer expires, the timer will auto-clear FLR.
                                                                 0x1 = PEM()_FLR_REQ* must be used to clear the FLR indication, timers are not used.
                                                                 0x2 = Only timers are used, PEM()_FLR_REQ* is ignored.
                                                                 0x3 = Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t timer_ctl             : 2;  /**< [  1:  0](R/W) Each FLR indication can be cleared within 66-99 ms by use of a timer. Controls how
                                                                 FLR indication is cleared:
                                                                 0x0 = PEM()_FLR_REQ* can be used to clear the FLR indication, if not written before
                                                                 timer expires, the timer will auto-clear FLR.
                                                                 0x1 = PEM()_FLR_REQ* must be used to clear the FLR indication, timers are not used.
                                                                 0x2 = Only timers are used, PEM()_FLR_REQ* is ignored.
                                                                 0x3 = Reserved. */
        uint64_t delta                 : 2;  /**< [  3:  2](R/W) When [CHGE] is set, this field determines the delta time to increase/decrease
                                                                 the 33 ms expiration of the function level reset global counter.
                                                                 0x0 = 1 ms.
                                                                 0x1 = 2 ms.
                                                                 0x2 = 4 ms.
                                                                 0x3 = 8 ms. */
        uint64_t inc                   : 1;  /**< [  4:  4](R/W) When [CHGE] is set, this bit determines if the 33 ms expiration of the function
                                                                 level reset global counter will be increased (set) or decreased (not set). */
        uint64_t chge                  : 1;  /**< [  5:  5](R/W) When set, the default 33 ms expiration of the function level reset
                                                                 global counter can be changed. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_ctl_s cn; */
};
typedef union bdk_pemx_flr_ctl bdk_pemx_flr_ctl_t;

static inline uint64_t BDK_PEMX_FLR_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000070ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000070ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000070ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000070ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_FLR_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_CTL(a) bdk_pemx_flr_ctl_t
#define bustype_BDK_PEMX_FLR_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_FLR_CTL(a) "PEMX_FLR_CTL"
#define device_bar_BDK_PEMX_FLR_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_CTL(a) (a)
#define arguments_BDK_PEMX_FLR_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_flr_glblcnt_ctl
 *
 * PEM FLR Global Count Control Register
 * Function level reset global counter control.
 */
union bdk_pemx_flr_glblcnt_ctl
{
    uint64_t u;
    struct bdk_pemx_flr_glblcnt_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t chge                  : 1;  /**< [  3:  3](R/W) When set, the default 25ms expiration of the function level reset
                                                                 global counter can be changed. */
        uint64_t inc                   : 1;  /**< [  2:  2](R/W) When CHGE is set, this bit determines if the 25ms expiration of the function
                                                                 level reset global counter will be increased (set) or decreased (not set). */
        uint64_t delta                 : 2;  /**< [  1:  0](R/W) When CHGE is set, this field determines the delta time to increase/decrease
                                                                 the 25 ms expiration of the function level reset global counter.
                                                                 0x0 = 1 ms.
                                                                 0x1 = 2 ms.
                                                                 0x2 = 4 ms.
                                                                 0x3 = 8 ms. */
#else /* Word 0 - Little Endian */
        uint64_t delta                 : 2;  /**< [  1:  0](R/W) When CHGE is set, this field determines the delta time to increase/decrease
                                                                 the 25 ms expiration of the function level reset global counter.
                                                                 0x0 = 1 ms.
                                                                 0x1 = 2 ms.
                                                                 0x2 = 4 ms.
                                                                 0x3 = 8 ms. */
        uint64_t inc                   : 1;  /**< [  2:  2](R/W) When CHGE is set, this bit determines if the 25ms expiration of the function
                                                                 level reset global counter will be increased (set) or decreased (not set). */
        uint64_t chge                  : 1;  /**< [  3:  3](R/W) When set, the default 25ms expiration of the function level reset
                                                                 global counter can be changed. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_glblcnt_ctl_s cn; */
};
typedef union bdk_pemx_flr_glblcnt_ctl bdk_pemx_flr_glblcnt_ctl_t;

static inline uint64_t BDK_PEMX_FLR_GLBLCNT_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_GLBLCNT_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000210ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_FLR_GLBLCNT_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_GLBLCNT_CTL(a) bdk_pemx_flr_glblcnt_ctl_t
#define bustype_BDK_PEMX_FLR_GLBLCNT_CTL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_FLR_GLBLCNT_CTL(a) "PEMX_FLR_GLBLCNT_CTL"
#define device_bar_BDK_PEMX_FLR_GLBLCNT_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_GLBLCNT_CTL(a) (a)
#define arguments_BDK_PEMX_FLR_GLBLCNT_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_flr_pf#_stopreq
 *
 * PEM PF Stop Request Register
 * PF function level reset stop outbound requests register.
 * Hardware automatically sets the STOPREQ bit for the PF when it enters a
 * function level reset (FLR).  Software is responsible for clearing the STOPREQ
 * bit but must not do so prior to hardware taking down the FLR, which could be
 * as long as 100 ms.  It may be appropriate for software to wait longer before clearing
 * STOPREQ, software may need to drain deep DPI queues for example.
 * Whenever PEM receives a PF or child VF request mastered by {ProductLine} over NCBO/EBUS
 * (i.e. P or NP), when STOPREQ is set for the function, PEM will discard the outgoing request
 * before sending it to the PCIe core.  If a NP, PEM will schedule an immediate completion
 * with error for the request - no timeout is required. STOPREQ mimics the behavior of
 * PCIEEP_CMD[ME] for outbound requests that will master the PCIe bus (P and NP).
 *
 * STOPREQ has no effect on NCBI/incoming EBUS traffic.
 *
 * STOPREQ will have no effect on completions returned by CNXXXX over NCBO/EBUS.
 *
 * When a PEM()_FLR_PF()_STOPREQ is set, none of the associated
 * PEM()_FLR_VF()_STOPREQ[VF_STOPREQ] will be set.
 *
 * STOPREQ is reset when the MAC is reset, and is not reset after a chip soft reset.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_flr_pfx_stopreq
{
    uint64_t u;
    struct bdk_pemx_flr_pfx_stopreq_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pf_stopreq            : 1;  /**< [  0:  0](R/W1C/H) PF STOPREQ bit. */
#else /* Word 0 - Little Endian */
        uint64_t pf_stopreq            : 1;  /**< [  0:  0](R/W1C/H) PF STOPREQ bit. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_pfx_stopreq_s cn; */
};
typedef union bdk_pemx_flr_pfx_stopreq bdk_pemx_flr_pfx_stopreq_t;

static inline uint64_t BDK_PEMX_FLR_PFX_STOPREQ(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_PFX_STOPREQ(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=15)))
        return 0x8e0000000c00ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=15)))
        return 0x8e0000000c00ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=15)))
        return 0x8e0000000c00ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=15)))
        return 0x8e0000000c00ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_FLR_PFX_STOPREQ", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_PFX_STOPREQ(a,b) bdk_pemx_flr_pfx_stopreq_t
#define bustype_BDK_PEMX_FLR_PFX_STOPREQ(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_FLR_PFX_STOPREQ(a,b) "PEMX_FLR_PFX_STOPREQ"
#define device_bar_BDK_PEMX_FLR_PFX_STOPREQ(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_PFX_STOPREQ(a,b) (a)
#define arguments_BDK_PEMX_FLR_PFX_STOPREQ(a,b) (a),(b),-1,-1

/**
 * Register (RSL) pem#_flr_pf0_vf_stopreq
 *
 * PEM PF0 Virtual Function Stop Request Lower Register
 * PF0 virtual function level reset stop outbound requests register.
 * Hardware automatically sets the STOPREQ bit for the VF when it enters a
 * function level reset (FLR).  Software is responsible for clearing the STOPREQ
 * bit but must not do so prior to hardware taking down the FLR, which could be
 * as long as 100 ms.  It may be appropriate for software to wait longer before clearing
 * STOPREQ, software may need to drain deep DPI queues for example.
 *
 * Whenever PEM receives a request mastered by {ProductLine} over S2M (i.e. P or NP),
 * when STOPREQ is set for the function, PEM will discard the outgoing request
 * before sending it to the PCIe core.  If a NP, PEM will schedule an immediate
 * SWI_RSP_ERROR completion for the request - no timeout is required.
 * In both cases, the PEM()_INT_SUM[BMD_E] bit will be set and a error
 * interrupt is generated.
 *
 * STOPREQ mimics the behavior of PCIEEPVF()_CFG001.ME for outbound requests that will
 * master the PCIe bus (P and NP).
 *
 * Note that STOPREQ will have no effect on completions returned by {ProductLine} over the S2M.
 *
 * Note that STOPREQ will have no effect on M2S traffic.
 */
union bdk_pemx_flr_pf0_vf_stopreq
{
    uint64_t u;
    struct bdk_pemx_flr_pf0_vf_stopreq_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t vf_stopreq_lo         : 64; /**< [ 63:  0](R/W1C/H) STOPREQ for the 64 VFs in PF0. */
#else /* Word 0 - Little Endian */
        uint64_t vf_stopreq_lo         : 64; /**< [ 63:  0](R/W1C/H) STOPREQ for the 64 VFs in PF0. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_pf0_vf_stopreq_s cn; */
};
typedef union bdk_pemx_flr_pf0_vf_stopreq bdk_pemx_flr_pf0_vf_stopreq_t;

static inline uint64_t BDK_PEMX_FLR_PF0_VF_STOPREQ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_PF0_VF_STOPREQ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000220ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_FLR_PF0_VF_STOPREQ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_PF0_VF_STOPREQ(a) bdk_pemx_flr_pf0_vf_stopreq_t
#define bustype_BDK_PEMX_FLR_PF0_VF_STOPREQ(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_FLR_PF0_VF_STOPREQ(a) "PEMX_FLR_PF0_VF_STOPREQ"
#define device_bar_BDK_PEMX_FLR_PF0_VF_STOPREQ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_PF0_VF_STOPREQ(a) (a)
#define arguments_BDK_PEMX_FLR_PF0_VF_STOPREQ(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_flr_pf_stopreq
 *
 * PEM PF Stop Request Register
 * PF function level reset stop outbound requests register.
 * Hardware automatically sets the STOPREQ bit for the PF when it enters a
 * function level reset (FLR).  Software is responsible for clearing the STOPREQ
 * bit but must not do so prior to hardware taking down the FLR, which could be
 * as long as 100 ms.  It may be appropriate for software to wait longer before clearing
 * STOPREQ, software may need to drain deep DPI queues for example.
 * Whenever PEM receives a PF or child VF request mastered by {ProductLine} over S2M (i.e. P or
 * NP),
 * when STOPREQ is set for the function, PEM will discard the outgoing request
 * before sending it to the PCIe core.  If a NP, PEM will schedule an immediate
 * SWI_RSP_ERROR completion for the request - no timeout is required.
 * In both cases, the PEM(0..3)_INT_SUM[PBMD_E] bit will be set and a error
 * interrupt is generated.
 * STOPREQ mimics the behavior of PCIEEP()_CFG001.ME for outbound requests that will
 * master the PCIe bus (P and NP).
 *
 * STOPREQ has no effect on M2S traffic.
 *
 * STOPREQ will have no effect on completions returned by CNXXXX over the S2M.
 *
 * When a PF()_STOPREQ is set, none of the associated
 * PEM()_FLR_PF0_VF_STOPREQ[VF_STOPREQ] will be set.
 *
 * STOPREQ is reset when the MAC is reset, and is not reset after a chip soft reset.
 */
union bdk_pemx_flr_pf_stopreq
{
    uint64_t u;
    struct bdk_pemx_flr_pf_stopreq_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pf0_stopreq           : 1;  /**< [  0:  0](R/W1C/H) PF0 STOPREQ bit. */
#else /* Word 0 - Little Endian */
        uint64_t pf0_stopreq           : 1;  /**< [  0:  0](R/W1C/H) PF0 STOPREQ bit. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_pf_stopreq_s cn; */
};
typedef union bdk_pemx_flr_pf_stopreq bdk_pemx_flr_pf_stopreq_t;

static inline uint64_t BDK_PEMX_FLR_PF_STOPREQ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_PF_STOPREQ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000218ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_FLR_PF_STOPREQ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_PF_STOPREQ(a) bdk_pemx_flr_pf_stopreq_t
#define bustype_BDK_PEMX_FLR_PF_STOPREQ(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_FLR_PF_STOPREQ(a) "PEMX_FLR_PF_STOPREQ"
#define device_bar_BDK_PEMX_FLR_PF_STOPREQ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_PF_STOPREQ(a) (a)
#define arguments_BDK_PEMX_FLR_PF_STOPREQ(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_flr_stopreq_ctl
 *
 * PEM FLR Global Count Control Register
 * Function level reset STOPREQ control register.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_flr_stopreq_ctl
{
    uint64_t u;
    struct bdk_pemx_flr_stopreq_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t stopreqclr            : 1;  /**< [  0:  0](R/W) When [STOPREQCLR] is clear, only software (and reset) can clear
                                                                 PEM()_FLR_PF_STOPREQ[STOPREQ] and PEM()_FLR_PF0_VF_STOPREQ[STOPREQ]
                                                                 bits. When STOPREQCLR is set, PEM hardware
                                                                 also clears the STOPREQ bit when PEM completes an FLR to the PCIe core. In the
                                                                 case of a VF, only one STOPREQ bit gets cleared upon each FLR ack when
                                                                 STOPREQCLR mode bit is set. The srst will assert upon a PF
                                                                 FLR, and srst could be used to reset all STOPREQ bits regardless of
                                                                 STOPREQCLR. Otherwise (e.g. {ProductLine}), where a PF FLR does not
                                                                 assert srst. */
#else /* Word 0 - Little Endian */
        uint64_t stopreqclr            : 1;  /**< [  0:  0](R/W) When [STOPREQCLR] is clear, only software (and reset) can clear
                                                                 PEM()_FLR_PF_STOPREQ[STOPREQ] and PEM()_FLR_PF0_VF_STOPREQ[STOPREQ]
                                                                 bits. When STOPREQCLR is set, PEM hardware
                                                                 also clears the STOPREQ bit when PEM completes an FLR to the PCIe core. In the
                                                                 case of a VF, only one STOPREQ bit gets cleared upon each FLR ack when
                                                                 STOPREQCLR mode bit is set. The srst will assert upon a PF
                                                                 FLR, and srst could be used to reset all STOPREQ bits regardless of
                                                                 STOPREQCLR. Otherwise (e.g. {ProductLine}), where a PF FLR does not
                                                                 assert srst. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_stopreq_ctl_s cn8; */
    struct bdk_pemx_flr_stopreq_ctl_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t stopreqclr            : 1;  /**< [  0:  0](R/W) Stop request clear behavior.

                                                                 0 = Only software (and reset) can clear PEM()_FLR_PF()_STOPREQ[PF_STOPREQ] and
                                                                 PEM()_FLR_VF()_STOPREQ[VF_STOPREQ] bits.

                                                                 1 = PEM hardware also clears the STOPREQ bit when PEM completes an FLR to the
                                                                 PCIe core. In the case of a VF, only one STOPREQ bit gets cleared upon each FLR
                                                                 ack when [STOPREQCLR] is set.

                                                                 The srst will assert upon a PF FLR, and srst could be used to reset all STOPREQ
                                                                 bits regardless of [STOPREQCLR]. Otherwise, a PF FLR does not assert srst. */
#else /* Word 0 - Little Endian */
        uint64_t stopreqclr            : 1;  /**< [  0:  0](R/W) Stop request clear behavior.

                                                                 0 = Only software (and reset) can clear PEM()_FLR_PF()_STOPREQ[PF_STOPREQ] and
                                                                 PEM()_FLR_VF()_STOPREQ[VF_STOPREQ] bits.

                                                                 1 = PEM hardware also clears the STOPREQ bit when PEM completes an FLR to the
                                                                 PCIe core. In the case of a VF, only one STOPREQ bit gets cleared upon each FLR
                                                                 ack when [STOPREQCLR] is set.

                                                                 The srst will assert upon a PF FLR, and srst could be used to reset all STOPREQ
                                                                 bits regardless of [STOPREQCLR]. Otherwise, a PF FLR does not assert srst. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_flr_stopreq_ctl bdk_pemx_flr_stopreq_ctl_t;

static inline uint64_t BDK_PEMX_FLR_STOPREQ_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_STOPREQ_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000238ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000078ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000078ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000078ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000078ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_FLR_STOPREQ_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_STOPREQ_CTL(a) bdk_pemx_flr_stopreq_ctl_t
#define bustype_BDK_PEMX_FLR_STOPREQ_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_FLR_STOPREQ_CTL(a) "PEMX_FLR_STOPREQ_CTL"
#define device_bar_BDK_PEMX_FLR_STOPREQ_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_STOPREQ_CTL(a) (a)
#define arguments_BDK_PEMX_FLR_STOPREQ_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_flr_vf#_stopreq
 *
 * PEM VF Stop Request Register
 * VFI 0-239 virtual function level reset stop outbound requests register.
 * Hardware automatically sets the STOPREQ bit for the VF when it enters a
 * function level reset (FLR).  Software is responsible for clearing the STOPREQ
 * bit but must not do so prior to hardware taking down the FLR, which could be
 * as long as 100 ms.  It may be appropriate for software to wait longer before clearing
 * STOPREQ, software may need to drain deep DPI queues for example.
 *
 * Whenever PEM receives a request mastered by {ProductLine} over NCBO/EBUS (i.e. P or NP),
 * when STOPREQ is set for the function, PEM will discard the outgoing request
 * before sending it to the PCIe core.  If a NP, PEM will schedule an immediate
 * cpl w/error for the request - no timeout is required.
 * In both cases, the PEM()_DBG_INFO[IN_FLR] bit will be set.
 *
 * The index into this array is referred to as a "VFI" and will need to be calculated
 * by software based on the number of VFs assigned to each PF.  {PF0,VF0} is VFI0 and
 * for this VF, bit [0] would be used.  {PF1,VF0} is PCIEEP_SRIOV_VFS[IVF] for PF0.
 * In general, {PFx,VFy} is determined by SUM(PF0..PF(x-1))(PCIEEP_SRIOV_VFS[IVF]) + y.
 *
 * STOPREQ mimics the behavior of PCIEEPVF_CMD[ME] for outbound requests that will
 * master the PCIe bus (P and NP).
 *
 * Note that STOPREQ will have no effect on completions returned by {ProductLine} over the NCBO/EBUS.
 *
 * Note that STOPREQ will have no effect on NCBI or incoming EBUS traffic.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_flr_vfx_stopreq
{
    uint64_t u;
    struct bdk_pemx_flr_vfx_stopreq_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t vf_stopreq            : 64; /**< [ 63:  0](R/W1C/H) STOPREQ for the pool of 240 VFs in shared by the 16 PFs.
                                                                 Each bit corresponds to one of the NVF virtual functions. */
#else /* Word 0 - Little Endian */
        uint64_t vf_stopreq            : 64; /**< [ 63:  0](R/W1C/H) STOPREQ for the pool of 240 VFs in shared by the 16 PFs.
                                                                 Each bit corresponds to one of the NVF virtual functions. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_vfx_stopreq_s cn; */
};
typedef union bdk_pemx_flr_vfx_stopreq bdk_pemx_flr_vfx_stopreq_t;

static inline uint64_t BDK_PEMX_FLR_VFX_STOPREQ(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_VFX_STOPREQ(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=3)))
        return 0x8e0000000e00ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=3)))
        return 0x8e0000000e00ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=3)))
        return 0x8e0000000e00ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=3)))
        return 0x8e0000000e00ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("PEMX_FLR_VFX_STOPREQ", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_VFX_STOPREQ(a,b) bdk_pemx_flr_vfx_stopreq_t
#define bustype_BDK_PEMX_FLR_VFX_STOPREQ(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_FLR_VFX_STOPREQ(a,b) "PEMX_FLR_VFX_STOPREQ"
#define device_bar_BDK_PEMX_FLR_VFX_STOPREQ(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_VFX_STOPREQ(a,b) (a)
#define arguments_BDK_PEMX_FLR_VFX_STOPREQ(a,b) (a),(b),-1,-1

/**
 * Register (RSL) pem#_flr_zombie_ctl
 *
 * PEM FLR Global Count Control Register
 * Function level reset global zombie counter control register.
 */
union bdk_pemx_flr_zombie_ctl
{
    uint64_t u;
    struct bdk_pemx_flr_zombie_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t exp                   : 10; /**< [  9:  0](R/W) The expiration value for the inbound shared global zombie counter. The global zombie
                                                                 counter
                                                                 continuously counts the number of cycles where the PCIe core was allowed to send
                                                                 either a posted request or a completion to the PEM.  When the global zombie counter
                                                                 reaches expiration (EXP), it resets to zero and all the nonzero per PCIe tag zombie
                                                                 counters are decremented. When a per PCIe tag zombie counter decrements to zero, a
                                                                 SWI_RSP_ERROR is
                                                                 sent to the M2S bus and its associated PCIe tag is returned to the pool.
                                                                 This field allows software programmability control of the zombie counter expiration. */
#else /* Word 0 - Little Endian */
        uint64_t exp                   : 10; /**< [  9:  0](R/W) The expiration value for the inbound shared global zombie counter. The global zombie
                                                                 counter
                                                                 continuously counts the number of cycles where the PCIe core was allowed to send
                                                                 either a posted request or a completion to the PEM.  When the global zombie counter
                                                                 reaches expiration (EXP), it resets to zero and all the nonzero per PCIe tag zombie
                                                                 counters are decremented. When a per PCIe tag zombie counter decrements to zero, a
                                                                 SWI_RSP_ERROR is
                                                                 sent to the M2S bus and its associated PCIe tag is returned to the pool.
                                                                 This field allows software programmability control of the zombie counter expiration. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_flr_zombie_ctl_s cn; */
};
typedef union bdk_pemx_flr_zombie_ctl bdk_pemx_flr_zombie_ctl_t;

static inline uint64_t BDK_PEMX_FLR_ZOMBIE_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_FLR_ZOMBIE_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000230ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_FLR_ZOMBIE_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_FLR_ZOMBIE_CTL(a) bdk_pemx_flr_zombie_ctl_t
#define bustype_BDK_PEMX_FLR_ZOMBIE_CTL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_FLR_ZOMBIE_CTL(a) "PEMX_FLR_ZOMBIE_CTL"
#define device_bar_BDK_PEMX_FLR_ZOMBIE_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_FLR_ZOMBIE_CTL(a) (a)
#define arguments_BDK_PEMX_FLR_ZOMBIE_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ib_merge_timer_ctl
 *
 * PEM NCBI Merge Timer Control Register
 * This register controls the merging timer for inbound NCB writes.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_ib_merge_timer_ctl
{
    uint64_t u;
    struct bdk_pemx_ib_merge_timer_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t wmerge_dis            : 1;  /**< [ 10: 10](R/W) For diagnostic use only.  If set, will disable inbound write merging. */
        uint64_t wmerge_total_timer    : 10; /**< [  9:  0](R/W) Write merge encapsulation timer. When PEM accepts a NCBI write which begins
                                                                 a write merging process, [WMERGE_TOTAL_TIMER] specifies the maximum wait, in
                                                                 coprocessor-clock cycles, to merge additional write operations into one larger
                                                                 write. The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
#else /* Word 0 - Little Endian */
        uint64_t wmerge_total_timer    : 10; /**< [  9:  0](R/W) Write merge encapsulation timer. When PEM accepts a NCBI write which begins
                                                                 a write merging process, [WMERGE_TOTAL_TIMER] specifies the maximum wait, in
                                                                 coprocessor-clock cycles, to merge additional write operations into one larger
                                                                 write. The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t wmerge_dis            : 1;  /**< [ 10: 10](R/W) For diagnostic use only.  If set, will disable inbound write merging. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ib_merge_timer_ctl_s cn; */
};
typedef union bdk_pemx_ib_merge_timer_ctl bdk_pemx_ib_merge_timer_ctl_t;

static inline uint64_t BDK_PEMX_IB_MERGE_TIMER_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_IB_MERGE_TIMER_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001c0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001c0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001c0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001c0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_IB_MERGE_TIMER_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_IB_MERGE_TIMER_CTL(a) bdk_pemx_ib_merge_timer_ctl_t
#define bustype_BDK_PEMX_IB_MERGE_TIMER_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_IB_MERGE_TIMER_CTL(a) "PEMX_IB_MERGE_TIMER_CTL"
#define device_bar_BDK_PEMX_IB_MERGE_TIMER_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_IB_MERGE_TIMER_CTL(a) (a)
#define arguments_BDK_PEMX_IB_MERGE_TIMER_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ib_wmerge_merged_pc
 *
 * PEM Inbound Merge Writes Merged Performance Counter Register
 * This register reports how many writes merged within the inbound write merge unit.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_ib_wmerge_merged_pc
{
    uint64_t u;
    struct bdk_pemx_ib_wmerge_merged_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t wmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBI write operation mapped to MEM that merges with a previous
                                                                 write will increment this count. */
#else /* Word 0 - Little Endian */
        uint64_t wmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBI write operation mapped to MEM that merges with a previous
                                                                 write will increment this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ib_wmerge_merged_pc_s cn; */
};
typedef union bdk_pemx_ib_wmerge_merged_pc bdk_pemx_ib_wmerge_merged_pc_t;

static inline uint64_t BDK_PEMX_IB_WMERGE_MERGED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_IB_WMERGE_MERGED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001d0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001d0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001d0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001d0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_IB_WMERGE_MERGED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_IB_WMERGE_MERGED_PC(a) bdk_pemx_ib_wmerge_merged_pc_t
#define bustype_BDK_PEMX_IB_WMERGE_MERGED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_IB_WMERGE_MERGED_PC(a) "PEMX_IB_WMERGE_MERGED_PC"
#define device_bar_BDK_PEMX_IB_WMERGE_MERGED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_IB_WMERGE_MERGED_PC(a) (a)
#define arguments_BDK_PEMX_IB_WMERGE_MERGED_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ib_wmerge_received_pc
 *
 * PEM Inbound Merge Writes Received Performance Counter Register
 * This register reports the number of writes that enter the inbound write merge unit.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_ib_wmerge_received_pc
{
    uint64_t u;
    struct bdk_pemx_ib_wmerge_received_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t wmerge_writes         : 64; /**< [ 63:  0](R/W/H) Each NCBI write operation mapped to MEM type will increment this count. */
#else /* Word 0 - Little Endian */
        uint64_t wmerge_writes         : 64; /**< [ 63:  0](R/W/H) Each NCBI write operation mapped to MEM type will increment this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ib_wmerge_received_pc_s cn; */
};
typedef union bdk_pemx_ib_wmerge_received_pc bdk_pemx_ib_wmerge_received_pc_t;

static inline uint64_t BDK_PEMX_IB_WMERGE_RECEIVED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_IB_WMERGE_RECEIVED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001c8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001c8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001c8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001c8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_IB_WMERGE_RECEIVED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_IB_WMERGE_RECEIVED_PC(a) bdk_pemx_ib_wmerge_received_pc_t
#define bustype_BDK_PEMX_IB_WMERGE_RECEIVED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_IB_WMERGE_RECEIVED_PC(a) "PEMX_IB_WMERGE_RECEIVED_PC"
#define device_bar_BDK_PEMX_IB_WMERGE_RECEIVED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_IB_WMERGE_RECEIVED_PC(a) (a)
#define arguments_BDK_PEMX_IB_WMERGE_RECEIVED_PC(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_inb_read_credits
 *
 * PEM In-flight Read Credits Register
 * This register contains the number of in-flight read operations from PCIe core to SLI.
 */
union bdk_pemx_inb_read_credits
{
    uint64_t u;
    struct bdk_pemx_inb_read_credits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t num                   : 7;  /**< [  6:  0](R/W) The number of reads that may be in flight from the PCIe core to the SLI. Minimum number is
                                                                 6; maximum number is 64. */
#else /* Word 0 - Little Endian */
        uint64_t num                   : 7;  /**< [  6:  0](R/W) The number of reads that may be in flight from the PCIe core to the SLI. Minimum number is
                                                                 6; maximum number is 64. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_inb_read_credits_s cn; */
};
typedef union bdk_pemx_inb_read_credits bdk_pemx_inb_read_credits_t;

static inline uint64_t BDK_PEMX_INB_READ_CREDITS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_INB_READ_CREDITS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c00000b8ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c00000b8ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_INB_READ_CREDITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_INB_READ_CREDITS(a) bdk_pemx_inb_read_credits_t
#define bustype_BDK_PEMX_INB_READ_CREDITS(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_INB_READ_CREDITS(a) "PEMX_INB_READ_CREDITS"
#define device_bar_BDK_PEMX_INB_READ_CREDITS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_INB_READ_CREDITS(a) (a)
#define arguments_BDK_PEMX_INB_READ_CREDITS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_int_ena_w1c
 *
 * PEM Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union bdk_pemx_int_ena_w1c
{
    uint64_t u;
    struct bdk_pemx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t reserved_0_14         : 15;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_14         : 15;
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_int_ena_w1c_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t reserved_2            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2            : 1;
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_int_ena_w1c_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t reserved_2_3          : 2;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2_3          : 2;
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_int_ena_w1c_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B1]. */
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t reserved_2            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2            : 1;
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_int_ena_w1c_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn9;
    /* struct bdk_pemx_int_ena_w1c_cn9 cn96xx; */
    struct bdk_pemx_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0..4)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn98xx;
    struct bdk_pemx_int_ena_w1c_cnf95xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Reads or clears enable for PEM(0)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cnf95xx;
    /* struct bdk_pemx_int_ena_w1c_cnf95xx loki; */
};
typedef union bdk_pemx_int_ena_w1c bdk_pemx_int_ena_w1c_t;

static inline uint64_t BDK_PEMX_INT_ENA_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_INT_ENA_W1C(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000438ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000438ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000f8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000f8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000f8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000f8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_INT_ENA_W1C(a) bdk_pemx_int_ena_w1c_t
#define bustype_BDK_PEMX_INT_ENA_W1C(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_INT_ENA_W1C(a) "PEMX_INT_ENA_W1C"
#define device_bar_BDK_PEMX_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_INT_ENA_W1C(a) (a)
#define arguments_BDK_PEMX_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_int_ena_w1s
 *
 * PEM Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union bdk_pemx_int_ena_w1s
{
    uint64_t u;
    struct bdk_pemx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t reserved_0_14         : 15;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_14         : 15;
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_int_ena_w1s_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t reserved_2            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2            : 1;
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_int_ena_w1s_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t reserved_2_3          : 2;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2_3          : 2;
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_int_ena_w1s_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B1]. */
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t reserved_2            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2            : 1;
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_int_ena_w1s_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn9;
    /* struct bdk_pemx_int_ena_w1s_cn9 cn96xx; */
    struct bdk_pemx_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0..4)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn98xx;
    struct bdk_pemx_int_ena_w1s_cnf95xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets enable for PEM(0)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cnf95xx;
    /* struct bdk_pemx_int_ena_w1s_cnf95xx loki; */
};
typedef union bdk_pemx_int_ena_w1s bdk_pemx_int_ena_w1s_t;

static inline uint64_t BDK_PEMX_INT_ENA_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_INT_ENA_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000440ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000440ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000100ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000100ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000100ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000100ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_INT_ENA_W1S(a) bdk_pemx_int_ena_w1s_t
#define bustype_BDK_PEMX_INT_ENA_W1S(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_INT_ENA_W1S(a) "PEMX_INT_ENA_W1S"
#define device_bar_BDK_PEMX_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_INT_ENA_W1S(a) (a)
#define arguments_BDK_PEMX_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_int_sum
 *
 * PEM Interrupt Summary Register
 * This register contains the different interrupt summary bits of the PEM.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_int_sum
{
    uint64_t u;
    struct bdk_pemx_int_sum_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Received N-TLP for VF BAR0 when VF BAR0 is disabled. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Received N-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Received N-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Received P-TLP for  VF BAR0 when VF BAR0 is disabled. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Received P-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Received P-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) PTM Root is ready to have to context validated.
                                                                 When PEM()_PTM_CTL[PTM_AUTO_LOAD] is not set, the Mac PTM logic does
                                                                 not have a permenantly valid context.  Currently the core invalidates
                                                                 the responder context on two conditions
                                                                 * aux_clk is active
                                                                 * Link speed changes

                                                                 To clear this interrupt, The host programs PCIERC_PTM_RES_LOCAL_MSB and
                                                                 PCIERC_PTM_RES_LOCAL_LSB and then sets the context valid bit
                                                                 (PCIERC_PTM_RES_CTL[PRES_CTX_VLD]). */
        uint64_t reserved_0_14         : 15;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_14         : 15;
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) PTM Root is ready to have to context validated.
                                                                 When PEM()_PTM_CTL[PTM_AUTO_LOAD] is not set, the Mac PTM logic does
                                                                 not have a permenantly valid context.  Currently the core invalidates
                                                                 the responder context on two conditions
                                                                 * aux_clk is active
                                                                 * Link speed changes

                                                                 To clear this interrupt, The host programs PCIERC_PTM_RES_LOCAL_MSB and
                                                                 PCIERC_PTM_RES_LOCAL_LSB and then sets the context valid bit
                                                                 (PCIERC_PTM_RES_CTL[PRES_CTX_VLD]). */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Received P-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Received P-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Received P-TLP for  VF BAR0 when VF BAR0 is disabled. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Received N-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Received N-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Received N-TLP for VF BAR0 when VF BAR0 is disabled. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_int_sum_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1C/H) Indicates that a surprise down event is occuring in the controller. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Had a CRS timeout when retries were disabled. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Had a CRS timeout when retries were enabled. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Received read lock TLP. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Received N-TLP for unknown BAR. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Received N-TLP for BAR2 when BAR2 is disabled. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Received N-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Received P-TLP for an unknown BAR. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Received P-TLP for BAR2 when BAR2 is disabled. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Received P-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1C/H) Received P-TLP for Expansion ROM (BAR3 EP Mode). */
        uint64_t reserved_2            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) System error, RC mode only.
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) System error, RC mode only.
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2            : 1;
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1C/H) Received P-TLP for Expansion ROM (BAR3 EP Mode). */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Received P-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Received P-TLP for BAR2 when BAR2 is disabled. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Received P-TLP for an unknown BAR. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Received N-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Received N-TLP for BAR2 when BAR2 is disabled. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Received N-TLP for unknown BAR. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Received read lock TLP. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Had a CRS timeout when retries were enabled. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Had a CRS timeout when retries were disabled. */
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1C/H) Indicates that a surprise down event is occuring in the controller. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_int_sum_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Had a CRS timeout when retries were disabled. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Had a CRS timeout when retries were enabled. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Received read lock TLP. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Received N-TLP for unknown BAR. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Received N-TLP for BAR2 when BAR2 is disabled. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Received N-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Received P-TLP for an unknown BAR. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Received P-TLP for BAR2 when BAR2 is disabled. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Received P-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t reserved_2_3          : 2;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) System error, RC mode only.
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1C/H) System error, RC mode only.
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2_3          : 2;
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1C/H) Received P-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1C/H) Received P-TLP for BAR2 when BAR2 is disabled. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1C/H) Received P-TLP for an unknown BAR. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1C/H) Received N-TLP for BAR1 when BAR1 index valid is not set. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1C/H) Received N-TLP for BAR2 when BAR2 is disabled. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1C/H) Received N-TLP for unknown BAR. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1C/H) Received read lock TLP. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1C/H) Had a CRS timeout when retries were enabled. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1C/H) Had a CRS timeout when retries were disabled. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn81xx;
    /* struct bdk_pemx_int_sum_cn8 cn83xx; */
    struct bdk_pemx_int_sum_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Received N-TLP for VF BAR0 when VF BAR0 is disabled. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Received N-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Received N-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Received P-TLP for  VF BAR0 when VF BAR0 is disabled. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Received P-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Received P-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) PTM Root is ready to have to context validated.
                                                                 When PEM()_PTM_CTL[PTM_AUTO_LOAD] is not set, the Mac PTM logic does
                                                                 not have a permenantly valid context.  Currently the core invalidates
                                                                 the responder context on two conditions
                                                                 * aux_clk is active
                                                                 * Link speed changes

                                                                 To clear this interrupt, The host programs PCIERC_PTM_RES_LOCAL_MSB and
                                                                 PCIERC_PTM_RES_LOCAL_LSB and then sets the context valid bit
                                                                 (PCIERC_PTM_RES_CTL[PRES_CTX_VLD]). */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Received N-TLP for BAR0 when BAR0 is disabled. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Received P-TLP for BAR0 when BAR0 is disabled. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Indicates that a surprise down event is occuring in the controller. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) AP cores sent a second config read while a current config read was within the timeout window. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Received CRS when retries were disabled. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Had a CRS timeout event. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Received read lock TLP. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Received N-TLP for unknown BAR. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Received N-TLP for BAR2 when BAR2 is disabled. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Received N-TLP for BAR4 when BAR4 is disabled. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Received P-TLP for an unknown BAR. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Received P-TLP for BAR2 when BAR2 is disabled. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Received P-TLP for BAR4 when BAR4 is disabled. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Received P-TLP for Expansion ROM. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) System error, RC mode only.
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1C/H) System error, RC mode only.
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1C/H) Received P-TLP for Expansion ROM. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1C/H) Received P-TLP for BAR4 when BAR4 is disabled. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1C/H) Received P-TLP for BAR2 when BAR2 is disabled. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1C/H) Received P-TLP for an unknown BAR. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1C/H) Received N-TLP for BAR4 when BAR4 is disabled. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1C/H) Received N-TLP for BAR2 when BAR2 is disabled. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1C/H) Received N-TLP for unknown BAR. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1C/H) Received read lock TLP. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1C/H) Had a CRS timeout event. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1C/H) Received CRS when retries were disabled. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1C/H) AP cores sent a second config read while a current config read was within the timeout window. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1C/H) Indicates that a surprise down event is occuring in the controller. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1C/H) Received P-TLP for BAR0 when BAR0 is disabled. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1C/H) Received N-TLP for BAR0 when BAR0 is disabled. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1C/H) PTM Root is ready to have to context validated.
                                                                 When PEM()_PTM_CTL[PTM_AUTO_LOAD] is not set, the Mac PTM logic does
                                                                 not have a permenantly valid context.  Currently the core invalidates
                                                                 the responder context on two conditions
                                                                 * aux_clk is active
                                                                 * Link speed changes

                                                                 To clear this interrupt, The host programs PCIERC_PTM_RES_LOCAL_MSB and
                                                                 PCIERC_PTM_RES_LOCAL_LSB and then sets the context valid bit
                                                                 (PCIERC_PTM_RES_CTL[PRES_CTX_VLD]). */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1C/H) Received P-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1C/H) Received P-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1C/H) Received P-TLP for  VF BAR0 when VF BAR0 is disabled. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1C/H) Received N-TLP for VF BAR4 when VF BAR4 is disabled. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1C/H) Received N-TLP for VF BAR2 when VF BAR2 is disabled. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1C/H) Received N-TLP for VF BAR0 when VF BAR0 is disabled. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_int_sum bdk_pemx_int_sum_t;

static inline uint64_t BDK_PEMX_INT_SUM(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_INT_SUM(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000428ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000428ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000e8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000e8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000e8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000e8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_INT_SUM", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_INT_SUM(a) bdk_pemx_int_sum_t
#define bustype_BDK_PEMX_INT_SUM(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_INT_SUM(a) "PEMX_INT_SUM"
#define device_bar_BDK_PEMX_INT_SUM(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_INT_SUM(a) (a)
#define arguments_BDK_PEMX_INT_SUM(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_int_sum_w1s
 *
 * PEM Interrupt Summary Register
 * This register sets interrupt bits.
 */
union bdk_pemx_int_sum_w1s
{
    uint64_t u;
    struct bdk_pemx_int_sum_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t reserved_0_14         : 15;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_14         : 15;
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_int_sum_w1s_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t reserved_2            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2            : 1;
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_int_sum_w1s_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t reserved_2_3          : 2;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2_3          : 2;
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..2)_INT_SUM[CRS_DR]. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_int_sum_w1s_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t reserved_10           : 1;
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B1]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B1]. */
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t reserved_2            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t se                    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t reserved_2            : 1;
        uint64_t up_b3                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b1                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B1]. */
        uint64_t up_b2                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t un_b1                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B1]. */
        uint64_t un_b2                 : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t reserved_10           : 1;
        uint64_t rdlk                  : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t surp_down             : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_int_sum_w1s_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..3)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn9;
    /* struct bdk_pemx_int_sum_w1s_cn9 cn96xx; */
    struct bdk_pemx_int_sum_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0..4)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn98xx;
    struct bdk_pemx_int_sum_w1s_cnf95xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_VF_B0]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_VF_B4]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_VF_B0]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_VF_B4]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_B0]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B0]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0)_INT_SUM[SURP_DOWN]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0)_INT_SUM[CFG_INF]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0)_INT_SUM[CRS_DR]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0)_INT_SUM[CRS_ER]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0)_INT_SUM[RDLK]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_BX]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_B2]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_B4]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_BX]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B2]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B4]. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B3]. */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
#else /* Word 0 - Little Endian */
        uint64_t se                    : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0)_INT_SUM[SE].
                                                                 Internal:
                                                                 cfg_sys_err_rc. */
        uint64_t up_b3                 : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B3]. */
        uint64_t up_b4                 : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B4]. */
        uint64_t up_b2                 : 1;  /**< [  3:  3](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B2]. */
        uint64_t up_bx                 : 1;  /**< [  4:  4](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_BX]. */
        uint64_t un_b4                 : 1;  /**< [  5:  5](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_B4]. */
        uint64_t un_b2                 : 1;  /**< [  6:  6](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_B2]. */
        uint64_t un_bx                 : 1;  /**< [  7:  7](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_BX]. */
        uint64_t rdlk                  : 1;  /**< [  8:  8](R/W1S/H) Reads or sets PEM(0)_INT_SUM[RDLK]. */
        uint64_t crs_er                : 1;  /**< [  9:  9](R/W1S/H) Reads or sets PEM(0)_INT_SUM[CRS_ER]. */
        uint64_t crs_dr                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets PEM(0)_INT_SUM[CRS_DR]. */
        uint64_t cfg_inf               : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets PEM(0)_INT_SUM[CFG_INF]. */
        uint64_t surp_down             : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets PEM(0)_INT_SUM[SURP_DOWN]. */
        uint64_t up_b0                 : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_B0]. */
        uint64_t un_b0                 : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_B0]. */
        uint64_t ptm_rdy_val           : 1;  /**< [ 15: 15](R/W1S/H) Reads or sets PEM(0)_INT_SUM[PTM_RDY_VAL]. */
        uint64_t up_vf_b4              : 1;  /**< [ 16: 16](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_VF_B4]. */
        uint64_t up_vf_b2              : 1;  /**< [ 17: 17](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_VF_B2]. */
        uint64_t up_vf_b0              : 1;  /**< [ 18: 18](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UP_VF_B0]. */
        uint64_t un_vf_b4              : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_VF_B4]. */
        uint64_t un_vf_b2              : 1;  /**< [ 20: 20](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_VF_B2]. */
        uint64_t un_vf_b0              : 1;  /**< [ 21: 21](R/W1S/H) Reads or sets PEM(0)_INT_SUM[UN_VF_B0]. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cnf95xx;
    /* struct bdk_pemx_int_sum_w1s_cnf95xx loki; */
};
typedef union bdk_pemx_int_sum_w1s bdk_pemx_int_sum_w1s_t;

static inline uint64_t BDK_PEMX_INT_SUM_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_INT_SUM_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000430ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000430ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000f0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000f0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000f0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000f0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_INT_SUM_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_INT_SUM_W1S(a) bdk_pemx_int_sum_w1s_t
#define bustype_BDK_PEMX_INT_SUM_W1S(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_INT_SUM_W1S(a) "PEMX_INT_SUM_W1S"
#define device_bar_BDK_PEMX_INT_SUM_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_INT_SUM_W1S(a) (a)
#define arguments_BDK_PEMX_INT_SUM_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_latency_pc
 *
 * PEM Latency Count Register
 * This register contains read latency count for debugging purposes.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_latency_pc
{
    uint64_t u;
    struct bdk_pemx_latency_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t latency               : 64; /**< [ 63:  0](RO/H) Total read latency count in units of coprocessor-clocks measured from
                                                                 SLI read request until first data is returned from remote memory aggregated
                                                                 across all non-masked SWI tags. */
#else /* Word 0 - Little Endian */
        uint64_t latency               : 64; /**< [ 63:  0](RO/H) Total read latency count in units of coprocessor-clocks measured from
                                                                 SLI read request until first data is returned from remote memory aggregated
                                                                 across all non-masked SWI tags. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_latency_pc_s cn8; */
    struct bdk_pemx_latency_pc_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t latency               : 64; /**< [ 63:  0](R/W/H) Total read latency count in 10 ns units measured from an internal point in PEM
                                                                 after coming from either NCBO (but prior to any merging logic) or EBO, to an
                                                                 internal point in PEM where the corresponding completion is sent to the NCBI
                                                                 or EBI interface logic. PEM()_LATENCY_PC_CTL[EBO_SEL] controls which
                                                                 outbound bus has its reads latency tracked.  This register can only be written
                                                                 by software when PEM()_LATENCY_PC_CTL[ACTIVE] is clear. */
#else /* Word 0 - Little Endian */
        uint64_t latency               : 64; /**< [ 63:  0](R/W/H) Total read latency count in 10 ns units measured from an internal point in PEM
                                                                 after coming from either NCBO (but prior to any merging logic) or EBO, to an
                                                                 internal point in PEM where the corresponding completion is sent to the NCBI
                                                                 or EBI interface logic. PEM()_LATENCY_PC_CTL[EBO_SEL] controls which
                                                                 outbound bus has its reads latency tracked.  This register can only be written
                                                                 by software when PEM()_LATENCY_PC_CTL[ACTIVE] is clear. */
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_latency_pc bdk_pemx_latency_pc_t;

static inline uint64_t BDK_PEMX_LATENCY_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_LATENCY_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000490ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000118ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000118ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000118ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000118ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_LATENCY_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_LATENCY_PC(a) bdk_pemx_latency_pc_t
#define bustype_BDK_PEMX_LATENCY_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_LATENCY_PC(a) "PEMX_LATENCY_PC"
#define device_bar_BDK_PEMX_LATENCY_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_LATENCY_PC(a) (a)
#define arguments_BDK_PEMX_LATENCY_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_latency_pc_ctl
 *
 * PEM Latency Control Register
 * This register controls read latency monitoring for debugging purposes.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_latency_pc_ctl
{
    uint64_t u;
    struct bdk_pemx_latency_pc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t ebo_sel               : 1;  /**< [  2:  2](R/W) If set, latency will be measured on EBO reads instead of NCBO reads. */
        uint64_t complete              : 1;  /**< [  1:  1](RO/H) When software causes a rising edge on [ACTIVE], hardware will clear this
                                                                 bit. Later, when software clears [ACTIVE], hardware will wait for all
                                                                 outstanding reads to get their first data returned and then set this bit to
                                                                 indicate that measurement operations are completed. */
        uint64_t active                : 1;  /**< [  0:  0](R/W) When a software write causes a rising edge on this bit, PEM will begin a
                                                                 measurement which will include PEM clearing PEM()_LATENCY_PC and PEM()_READS_PC
                                                                 to reset all counting as well as PEM clearing PEM()_LATENCY_CTL[COMPLETE]. Only
                                                                 SLI SWI reads that occur after this rising edge will be considered. When
                                                                 software wants to halt measurement, it can clear this bit which will block
                                                                 further reads from being considered. When software reads
                                                                 PEM()_LATENCY_CTL[COMPLETE] as set, it can know that all measurement is
                                                                 completed and PEM()_LATENCY_PC and PEM()_READS_PC reflect a completely accurate
                                                                 and stable set of values. */
#else /* Word 0 - Little Endian */
        uint64_t active                : 1;  /**< [  0:  0](R/W) When a software write causes a rising edge on this bit, PEM will begin a
                                                                 measurement which will include PEM clearing PEM()_LATENCY_PC and PEM()_READS_PC
                                                                 to reset all counting as well as PEM clearing PEM()_LATENCY_CTL[COMPLETE]. Only
                                                                 SLI SWI reads that occur after this rising edge will be considered. When
                                                                 software wants to halt measurement, it can clear this bit which will block
                                                                 further reads from being considered. When software reads
                                                                 PEM()_LATENCY_CTL[COMPLETE] as set, it can know that all measurement is
                                                                 completed and PEM()_LATENCY_PC and PEM()_READS_PC reflect a completely accurate
                                                                 and stable set of values. */
        uint64_t complete              : 1;  /**< [  1:  1](RO/H) When software causes a rising edge on [ACTIVE], hardware will clear this
                                                                 bit. Later, when software clears [ACTIVE], hardware will wait for all
                                                                 outstanding reads to get their first data returned and then set this bit to
                                                                 indicate that measurement operations are completed. */
        uint64_t ebo_sel               : 1;  /**< [  2:  2](R/W) If set, latency will be measured on EBO reads instead of NCBO reads. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_latency_pc_ctl_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t complete              : 1;  /**< [  1:  1](RO/H) When software causes a rising edge on [ACTIVE], hardware will clear this
                                                                 bit. Later, when software clears [ACTIVE], hardware will wait for all
                                                                 outstanding reads to get their first data returned and then set this bit to
                                                                 indicate that measurement operations are completed. */
        uint64_t active                : 1;  /**< [  0:  0](R/W) When a software write causes a rising edge on this bit, PEM will begin a
                                                                 measurement which will include PEM clearing PEM()_LATENCY_PC and PEM()_READS_PC
                                                                 to reset all counting as well as PEM clearing PEM()_LATENCY_CTL[COMPLETE]. Only
                                                                 SLI SWI reads that occur after this rising edge will be considered. When
                                                                 software wants to halt measurement, it can clear this bit which will block
                                                                 further reads from being considered. When software reads
                                                                 PEM()_LATENCY_CTL[COMPLETE] as set, it can know that all measurement is
                                                                 completed and PEM()_LATENCY_PC and PEM()_READS_PC reflect a completely accurate
                                                                 and stable set of values. */
#else /* Word 0 - Little Endian */
        uint64_t active                : 1;  /**< [  0:  0](R/W) When a software write causes a rising edge on this bit, PEM will begin a
                                                                 measurement which will include PEM clearing PEM()_LATENCY_PC and PEM()_READS_PC
                                                                 to reset all counting as well as PEM clearing PEM()_LATENCY_CTL[COMPLETE]. Only
                                                                 SLI SWI reads that occur after this rising edge will be considered. When
                                                                 software wants to halt measurement, it can clear this bit which will block
                                                                 further reads from being considered. When software reads
                                                                 PEM()_LATENCY_CTL[COMPLETE] as set, it can know that all measurement is
                                                                 completed and PEM()_LATENCY_PC and PEM()_READS_PC reflect a completely accurate
                                                                 and stable set of values. */
        uint64_t complete              : 1;  /**< [  1:  1](RO/H) When software causes a rising edge on [ACTIVE], hardware will clear this
                                                                 bit. Later, when software clears [ACTIVE], hardware will wait for all
                                                                 outstanding reads to get their first data returned and then set this bit to
                                                                 indicate that measurement operations are completed. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_latency_pc_ctl_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t ebo_sel               : 1;  /**< [  2:  2](R/W) If set, latency will be measured on EBO reads instead of NCBO reads. */
        uint64_t complete              : 1;  /**< [  1:  1](RO/H) When software causes a rising edge on [ACTIVE], hardware will clear this
                                                                 bit. Later, when software clears [ACTIVE], hardware will wait for all
                                                                 outstanding reads to get their first data returned and then set this bit to
                                                                 indicate that measurement operations are completed. */
        uint64_t active                : 1;  /**< [  0:  0](R/W) When a software write causes a rising edge on [ACTIVE], PEM will begin a
                                                                 measurement using existing values for PEM()_LATENCY_PC and PEM()_READS_PC
                                                                 as well as clear [COMPLETE]. Only NCBO reads that occur
                                                                 after this rising edge will be added into the results. When software wants
                                                                 to halt measurement, it can clear this bit which will block further reads
                                                                 from being considered. When software reads [COMPLETE] as set,
                                                                 it can know that all measurement is completed and PEM()_LATENCY_PC and
                                                                 PEM()_READS_PC reflect a completely accurate and stable set of values.

                                                                 Note that [ACTIVE] does not need to be cleared in order to read
                                                                 PEM()_LATENCY_PC and PEM()_READS_PC to calcuate average latency during active
                                                                 processing, but there will be some small error.

                                                                 Note that because software can write PEM()_LATENCY_PC and PEM()_READS_PC,
                                                                 PEM will not clear these values when a software write causes a rising edge on
                                                                 [ACTIVE].  Instead, software must initialize these two registers (probably
                                                                 both to 0) prior to starting a measurement. */
#else /* Word 0 - Little Endian */
        uint64_t active                : 1;  /**< [  0:  0](R/W) When a software write causes a rising edge on [ACTIVE], PEM will begin a
                                                                 measurement using existing values for PEM()_LATENCY_PC and PEM()_READS_PC
                                                                 as well as clear [COMPLETE]. Only NCBO reads that occur
                                                                 after this rising edge will be added into the results. When software wants
                                                                 to halt measurement, it can clear this bit which will block further reads
                                                                 from being considered. When software reads [COMPLETE] as set,
                                                                 it can know that all measurement is completed and PEM()_LATENCY_PC and
                                                                 PEM()_READS_PC reflect a completely accurate and stable set of values.

                                                                 Note that [ACTIVE] does not need to be cleared in order to read
                                                                 PEM()_LATENCY_PC and PEM()_READS_PC to calcuate average latency during active
                                                                 processing, but there will be some small error.

                                                                 Note that because software can write PEM()_LATENCY_PC and PEM()_READS_PC,
                                                                 PEM will not clear these values when a software write causes a rising edge on
                                                                 [ACTIVE].  Instead, software must initialize these two registers (probably
                                                                 both to 0) prior to starting a measurement. */
        uint64_t complete              : 1;  /**< [  1:  1](RO/H) When software causes a rising edge on [ACTIVE], hardware will clear this
                                                                 bit. Later, when software clears [ACTIVE], hardware will wait for all
                                                                 outstanding reads to get their first data returned and then set this bit to
                                                                 indicate that measurement operations are completed. */
        uint64_t ebo_sel               : 1;  /**< [  2:  2](R/W) If set, latency will be measured on EBO reads instead of NCBO reads. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_latency_pc_ctl bdk_pemx_latency_pc_ctl_t;

static inline uint64_t BDK_PEMX_LATENCY_PC_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_LATENCY_PC_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c00004c0ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000128ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000128ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000128ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000128ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_LATENCY_PC_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_LATENCY_PC_CTL(a) bdk_pemx_latency_pc_ctl_t
#define bustype_BDK_PEMX_LATENCY_PC_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_LATENCY_PC_CTL(a) "PEMX_LATENCY_PC_CTL"
#define device_bar_BDK_PEMX_LATENCY_PC_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_LATENCY_PC_CTL(a) (a)
#define arguments_BDK_PEMX_LATENCY_PC_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_latency_pc_mask#
 *
 * PEM Latency Counts Low Register
 * This register contains read latency masking for debugging purposes.
 */
union bdk_pemx_latency_pc_maskx
{
    uint64_t u;
    struct bdk_pemx_latency_pc_maskx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask                  : 64; /**< [ 63:  0](R/W) Each bit of MASK corresponds to one SWI tag value. PEM()_LATENCY_PC_MASK(0)
                                                                 corresponds to SWI tags [63:0], PEM()_LATENCY_PC_MASK(1) corresponds to
                                                                 SWI tags [127:64].  If a bit of [MASK] is set, then its SWI tag will NOT be
                                                                 included in the values reported in PEM()_LATENCY_PC and PEM()_READS_PC. */
#else /* Word 0 - Little Endian */
        uint64_t mask                  : 64; /**< [ 63:  0](R/W) Each bit of MASK corresponds to one SWI tag value. PEM()_LATENCY_PC_MASK(0)
                                                                 corresponds to SWI tags [63:0], PEM()_LATENCY_PC_MASK(1) corresponds to
                                                                 SWI tags [127:64].  If a bit of [MASK] is set, then its SWI tag will NOT be
                                                                 included in the values reported in PEM()_LATENCY_PC and PEM()_READS_PC. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_latency_pc_maskx_s cn; */
};
typedef union bdk_pemx_latency_pc_maskx bdk_pemx_latency_pc_maskx_t;

static inline uint64_t BDK_PEMX_LATENCY_PC_MASKX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_LATENCY_PC_MASKX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b<=1)))
        return 0x87e0c00004a0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x1);
    __bdk_csr_fatal("PEMX_LATENCY_PC_MASKX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_LATENCY_PC_MASKX(a,b) bdk_pemx_latency_pc_maskx_t
#define bustype_BDK_PEMX_LATENCY_PC_MASKX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_LATENCY_PC_MASKX(a,b) "PEMX_LATENCY_PC_MASKX"
#define device_bar_BDK_PEMX_LATENCY_PC_MASKX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_LATENCY_PC_MASKX(a,b) (a)
#define arguments_BDK_PEMX_LATENCY_PC_MASKX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_ltr_latency
 *
 * PEM Latency Tolerance Reporting Register
 * This register contains the current LTR values reported and in-use
 * by the downstream device.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_ltr_latency
{
    uint64_t u;
    struct bdk_pemx_ltr_latency_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t latency               : 32; /**< [ 31:  0](RO/H) Reflects the captured LTR values from received LTR message in RC mode. */
#else /* Word 0 - Little Endian */
        uint64_t latency               : 32; /**< [ 31:  0](RO/H) Reflects the captured LTR values from received LTR message in RC mode. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ltr_latency_s cn; */
};
typedef union bdk_pemx_ltr_latency bdk_pemx_ltr_latency_t;

static inline uint64_t BDK_PEMX_LTR_LATENCY(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_LTR_LATENCY(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000c0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000c0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000c0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000c0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_LTR_LATENCY", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_LTR_LATENCY(a) bdk_pemx_ltr_latency_t
#define bustype_BDK_PEMX_LTR_LATENCY(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_LTR_LATENCY(a) "PEMX_LTR_LATENCY"
#define device_bar_BDK_PEMX_LTR_LATENCY(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_LTR_LATENCY(a) (a)
#define arguments_BDK_PEMX_LTR_LATENCY(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ltr_val#
 *
 * PEM Latency Tolerance Reporting Register
 * This register contains the values to put into the latency tolerance reporting (LTM) message
 * when triggered by hardware.  EP Mode.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_ltr_valx
{
    uint64_t u;
    struct bdk_pemx_ltr_valx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ns_lat                : 16; /**< [ 31: 16](R/W) No-snoop latency value to put into LTM message when triggered by hardware. */
        uint64_t snoop_lat             : 16; /**< [ 15:  0](R/W) Snoop latency value to put into LTM message when triggered by hardware. */
#else /* Word 0 - Little Endian */
        uint64_t snoop_lat             : 16; /**< [ 15:  0](R/W) Snoop latency value to put into LTM message when triggered by hardware. */
        uint64_t ns_lat                : 16; /**< [ 31: 16](R/W) No-snoop latency value to put into LTM message when triggered by hardware. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ltr_valx_s cn; */
};
typedef union bdk_pemx_ltr_valx bdk_pemx_ltr_valx_t;

static inline uint64_t BDK_PEMX_LTR_VALX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_LTR_VALX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=1)))
        return 0x8e00000000b0ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=1)))
        return 0x8e00000000b0ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=1)))
        return 0x8e00000000b0ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=1)))
        return 0x8e00000000b0ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("PEMX_LTR_VALX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_LTR_VALX(a,b) bdk_pemx_ltr_valx_t
#define bustype_BDK_PEMX_LTR_VALX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_LTR_VALX(a,b) "PEMX_LTR_VALX"
#define device_bar_BDK_PEMX_LTR_VALX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_LTR_VALX(a,b) (a)
#define arguments_BDK_PEMX_LTR_VALX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_mac_lane#_eq
 *
 * PEM MAC Lane RX/TX Equalization Info Register
 * This register specifies the per lane RX/TX Equalization values advertised
 * by the link partner.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_mac_lanex_eq
{
    uint64_t u;
    struct bdk_pemx_mac_lanex_eq_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t pset_coef             : 18; /**< [ 49: 32](RO/H) Presets and coefficients chosen by the PEM. */
        uint64_t reserved_15_31        : 17;
        uint64_t rxphint               : 3;  /**< [ 14: 12](RO/H) Represents the RX equalization preset hint
                                                                 for the receiver. */
        uint64_t lf                    : 6;  /**< [ 11:  6](RO/H) Represents the low frequency value of the remote transmitter
                                                                 captured in Recovery.Equalization Phase 1. */
        uint64_t fs                    : 6;  /**< [  5:  0](RO/H) Represents the full swing value of the remote transmitter
                                                                 captured in Recovery.Equalization Phase 1. */
#else /* Word 0 - Little Endian */
        uint64_t fs                    : 6;  /**< [  5:  0](RO/H) Represents the full swing value of the remote transmitter
                                                                 captured in Recovery.Equalization Phase 1. */
        uint64_t lf                    : 6;  /**< [ 11:  6](RO/H) Represents the low frequency value of the remote transmitter
                                                                 captured in Recovery.Equalization Phase 1. */
        uint64_t rxphint               : 3;  /**< [ 14: 12](RO/H) Represents the RX equalization preset hint
                                                                 for the receiver. */
        uint64_t reserved_15_31        : 17;
        uint64_t pset_coef             : 18; /**< [ 49: 32](RO/H) Presets and coefficients chosen by the PEM. */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_mac_lanex_eq_s cn; */
};
typedef union bdk_pemx_mac_lanex_eq bdk_pemx_mac_lanex_eq_t;

static inline uint64_t BDK_PEMX_MAC_LANEX_EQ(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_MAC_LANEX_EQ(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=15)))
        return 0x8e0000000780ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=15)))
        return 0x8e0000000780ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=15)))
        return 0x8e0000000780ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=15)))
        return 0x8e0000000780ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_MAC_LANEX_EQ", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_MAC_LANEX_EQ(a,b) bdk_pemx_mac_lanex_eq_t
#define bustype_BDK_PEMX_MAC_LANEX_EQ(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_MAC_LANEX_EQ(a,b) "PEMX_MAC_LANEX_EQ"
#define device_bar_BDK_PEMX_MAC_LANEX_EQ(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_MAC_LANEX_EQ(a,b) (a)
#define arguments_BDK_PEMX_MAC_LANEX_EQ(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_merge_timer_ctl
 *
 * PEM Merge Timer Control Register
 * This register controls merging timers and overrides for maximum merging size
 * for outbound reads, writes, and completions.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_merge_timer_ctl
{
    uint64_t u;
    struct bdk_pemx_merge_timer_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cmerge_dis            : 1;  /**< [ 63: 63](R/W) For diagnostic use only.  If set, will disable outbound completion merging. */
        uint64_t cmerge_mps_limit      : 3;  /**< [ 62: 60](R/W) Completion merge maximum payload size limit value. Software can use this value
                                                                 to reduce the maximum size of a merged completion operation to a level below the
                                                                 MPS value coming from the PCIe core. A value of 0x0 limits to 128 bytes with
                                                                 each increase in value doubling the limit. The hardware is controlled by the
                                                                 lower of [CMERGE_MPS_LIMIT] and the MPS value coming from the PCIe core. Resets
                                                                 to a value guaranteed to be at least as large as any legal value for MPS coming
                                                                 from the PCIe core. */
        uint64_t cmerge_total_timer    : 7;  /**< [ 59: 53](R/W) Completion merge encapsulation timer. When PEM accepts an outbound completion
                                                                 which begins a completion merging process, [CMERGE_TOTAL_TIMER] specifies the
                                                                 maximum wait, in units of (coprocessor-clock cycles * 64), to merge additional
                                                                 completion transfers into one larger overall completion. The values for this
                                                                 field range from 1 to 127, with 0x0 used for diagnostics only and treated as
                                                                 never expire. This translates into a range of 64 to 8128 in units of
                                                                 co-processor-clock cycles.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t cmerge_segment_timer  : 7;  /**< [ 52: 46](R/W) Completion merge segment timer. The maximum wait, in coprocessor-clock cycles,
                                                                 to wait between each segment of the overall merge operation. Each iterative
                                                                 completion transfer added to the overall merge restarts this timer. The values
                                                                 for this field range from 1 to 127, with 0x0 used for diagnostics only and
                                                                 treated as never expire. This translates into a range of 64 to 8128 in units of
                                                                 co-processor-clock cycles.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t wmerge_mps_limit      : 3;  /**< [ 45: 43](R/W) Write merge maximum payload size limit value. Software can use this value to
                                                                 reduce the maximum size of a merged write operation to a level below the MPS
                                                                 value coming from the PCIe core. A value of 0 limits to 128 bytes with each
                                                                 increase in value doubling the limit. The hardware will be controlled by the
                                                                 LOWER of [WMERGE_MPS_LIMIT] and the MPS value coming from the PCIe core. Resets
                                                                 to a value guaranteed to be at least as large as any legal value for MPS coming
                                                                 from the PCIe core. */
        uint64_t wmerge_total_timer    : 10; /**< [ 42: 33](R/W) Write merge encapsulation timer. When PEM accepts an outbound write which begins
                                                                 a write merging process, [WMERGE_TOTAL_TIMER] specifies the maximum wait, in
                                                                 coprocessor-clock cycles, to merge additional write operations into one larger
                                                                 write. The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t wmerge_segment_timer  : 10; /**< [ 32: 23](R/W) Write merge segment timer. The maximum wait,
                                                                 in coprocessor-clock cycles, to wait between each segment of the overall merge
                                                                 operation.  Each iterative write operation added to the overall merge restarts this
                                                                 timer.  The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t rmerge_mrrs_limit     : 3;  /**< [ 22: 20](R/W) Read merge maximum read request size limit value. Software can use this value to
                                                                 reduce the maximum size of a merged read operation to a level below the MRRS
                                                                 value coming from the PCIe core. A value of 0x0 limits to 128 bytes with each
                                                                 increase in value doubling the limit. The hardware will be controlled by the
                                                                 LOWER of [RMERGE_MRRS_LIMIT] and the MRRS value coming from the PCIe
                                                                 core. Resets to a value guaranteed to be at least as large as any legal value
                                                                 for MRRS coming from the PCIe core. */
        uint64_t rmerge_total_timer    : 10; /**< [ 19: 10](R/W) Read merge encapsulation timer. When PEM accepts an outbound read which begins a
                                                                 read merging process, [RMERGE_TOTAL_TIMER] specifies the maximum wait, in
                                                                 coprocessor-clock cycles, to merge additional read operations into one larger
                                                                 read. The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t rmerge_segment_timer  : 10; /**< [  9:  0](R/W) Read merge segment timer. specifies the maximum wait, in coprocessor-clock
                                                                 cycles, to wait between each segment of the overall merge operation. Each
                                                                 iterative read operation added to the overall merge restarts this timer. The
                                                                 values for this field range from 1 to 1023, with 0x0 used for diagnostics only
                                                                 and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
#else /* Word 0 - Little Endian */
        uint64_t rmerge_segment_timer  : 10; /**< [  9:  0](R/W) Read merge segment timer. specifies the maximum wait, in coprocessor-clock
                                                                 cycles, to wait between each segment of the overall merge operation. Each
                                                                 iterative read operation added to the overall merge restarts this timer. The
                                                                 values for this field range from 1 to 1023, with 0x0 used for diagnostics only
                                                                 and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t rmerge_total_timer    : 10; /**< [ 19: 10](R/W) Read merge encapsulation timer. When PEM accepts an outbound read which begins a
                                                                 read merging process, [RMERGE_TOTAL_TIMER] specifies the maximum wait, in
                                                                 coprocessor-clock cycles, to merge additional read operations into one larger
                                                                 read. The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t rmerge_mrrs_limit     : 3;  /**< [ 22: 20](R/W) Read merge maximum read request size limit value. Software can use this value to
                                                                 reduce the maximum size of a merged read operation to a level below the MRRS
                                                                 value coming from the PCIe core. A value of 0x0 limits to 128 bytes with each
                                                                 increase in value doubling the limit. The hardware will be controlled by the
                                                                 LOWER of [RMERGE_MRRS_LIMIT] and the MRRS value coming from the PCIe
                                                                 core. Resets to a value guaranteed to be at least as large as any legal value
                                                                 for MRRS coming from the PCIe core. */
        uint64_t wmerge_segment_timer  : 10; /**< [ 32: 23](R/W) Write merge segment timer. The maximum wait,
                                                                 in coprocessor-clock cycles, to wait between each segment of the overall merge
                                                                 operation.  Each iterative write operation added to the overall merge restarts this
                                                                 timer.  The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t wmerge_total_timer    : 10; /**< [ 42: 33](R/W) Write merge encapsulation timer. When PEM accepts an outbound write which begins
                                                                 a write merging process, [WMERGE_TOTAL_TIMER] specifies the maximum wait, in
                                                                 coprocessor-clock cycles, to merge additional write operations into one larger
                                                                 write. The values for this field range from 1 to 1023, with 0x0 used for
                                                                 diagnostics only and treated as never expire.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t wmerge_mps_limit      : 3;  /**< [ 45: 43](R/W) Write merge maximum payload size limit value. Software can use this value to
                                                                 reduce the maximum size of a merged write operation to a level below the MPS
                                                                 value coming from the PCIe core. A value of 0 limits to 128 bytes with each
                                                                 increase in value doubling the limit. The hardware will be controlled by the
                                                                 LOWER of [WMERGE_MPS_LIMIT] and the MPS value coming from the PCIe core. Resets
                                                                 to a value guaranteed to be at least as large as any legal value for MPS coming
                                                                 from the PCIe core. */
        uint64_t cmerge_segment_timer  : 7;  /**< [ 52: 46](R/W) Completion merge segment timer. The maximum wait, in coprocessor-clock cycles,
                                                                 to wait between each segment of the overall merge operation. Each iterative
                                                                 completion transfer added to the overall merge restarts this timer. The values
                                                                 for this field range from 1 to 127, with 0x0 used for diagnostics only and
                                                                 treated as never expire. This translates into a range of 64 to 8128 in units of
                                                                 co-processor-clock cycles.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t cmerge_total_timer    : 7;  /**< [ 59: 53](R/W) Completion merge encapsulation timer. When PEM accepts an outbound completion
                                                                 which begins a completion merging process, [CMERGE_TOTAL_TIMER] specifies the
                                                                 maximum wait, in units of (coprocessor-clock cycles * 64), to merge additional
                                                                 completion transfers into one larger overall completion. The values for this
                                                                 field range from 1 to 127, with 0x0 used for diagnostics only and treated as
                                                                 never expire. This translates into a range of 64 to 8128 in units of
                                                                 co-processor-clock cycles.

                                                                 Internal:
                                                                 If, during diagnostics, a timer value of 0x0 causes final transactions to be
                                                                 stuck within the pipeline, those transactions can be released by changing the
                                                                 timer to a non-zero value. */
        uint64_t cmerge_mps_limit      : 3;  /**< [ 62: 60](R/W) Completion merge maximum payload size limit value. Software can use this value
                                                                 to reduce the maximum size of a merged completion operation to a level below the
                                                                 MPS value coming from the PCIe core. A value of 0x0 limits to 128 bytes with
                                                                 each increase in value doubling the limit. The hardware is controlled by the
                                                                 lower of [CMERGE_MPS_LIMIT] and the MPS value coming from the PCIe core. Resets
                                                                 to a value guaranteed to be at least as large as any legal value for MPS coming
                                                                 from the PCIe core. */
        uint64_t cmerge_dis            : 1;  /**< [ 63: 63](R/W) For diagnostic use only.  If set, will disable outbound completion merging. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_merge_timer_ctl_s cn; */
};
typedef union bdk_pemx_merge_timer_ctl bdk_pemx_merge_timer_ctl_t;

static inline uint64_t BDK_PEMX_MERGE_TIMER_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_MERGE_TIMER_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000180ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000180ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000180ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000180ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_MERGE_TIMER_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_MERGE_TIMER_CTL(a) bdk_pemx_merge_timer_ctl_t
#define bustype_BDK_PEMX_MERGE_TIMER_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_MERGE_TIMER_CTL(a) "PEMX_MERGE_TIMER_CTL"
#define device_bar_BDK_PEMX_MERGE_TIMER_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_MERGE_TIMER_CTL(a) (a)
#define arguments_BDK_PEMX_MERGE_TIMER_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_msix_pba#
 *
 * PEM MSI-X Pending Bit Array Registers
 * This register is the MSI-X PBA table, the bit number is indexed by the PEM_INT_VEC_E enumeration.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_msix_pbax
{
    uint64_t u;
    struct bdk_pemx_msix_pbax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated PEM_MSIX_VEC()_CTL, enumerated by PEM_INT_VEC_E. Bits
                                                                 that have no associated PEM_INT_VEC_E are zero. */
#else /* Word 0 - Little Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated PEM_MSIX_VEC()_CTL, enumerated by PEM_INT_VEC_E. Bits
                                                                 that have no associated PEM_INT_VEC_E are zero. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_msix_pbax_s cn; */
};
typedef union bdk_pemx_msix_pbax bdk_pemx_msix_pbax_t;

static inline uint64_t BDK_PEMX_MSIX_PBAX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_MSIX_PBAX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && ((a<=2) && (b==0)))
        return 0x87e0c0ff0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b==0)))
        return 0x87e0c0ff0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b==0)))
        return 0x8e0f000f0000ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b==0)))
        return 0x8e0f000f0000ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b==0)))
        return 0x8e0f000f0000ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b==0)))
        return 0x8e0f000f0000ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x0);
    __bdk_csr_fatal("PEMX_MSIX_PBAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_MSIX_PBAX(a,b) bdk_pemx_msix_pbax_t
#define bustype_BDK_PEMX_MSIX_PBAX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_MSIX_PBAX(a,b) "PEMX_MSIX_PBAX"
#define device_bar_BDK_PEMX_MSIX_PBAX(a,b) 0x4 /* PF_BAR4 */
#define busnum_BDK_PEMX_MSIX_PBAX(a,b) (a)
#define arguments_BDK_PEMX_MSIX_PBAX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_msix_vec#_addr
 *
 * PEM MSI-X Vector Table Address Registers
 * This register is the MSI-X vector table, indexed by the PEM_INT_VEC_E enumeration.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_msix_vecx_addr
{
    uint64_t u;
    struct bdk_pemx_msix_vecx_addr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_PEM(0..2)_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_PEM(0..2)_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_msix_vecx_addr_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t addr                  : 47; /**< [ 48:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_PEM(0..2)_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_PEM(0..2)_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 47; /**< [ 48:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } cn8;
    /* struct bdk_pemx_msix_vecx_addr_cn8 cn81xx; */
    struct bdk_pemx_msix_vecx_addr_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t addr                  : 47; /**< [ 48:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_PEM(0..3)_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_PEM(0..3)_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 47; /**< [ 48:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_msix_vecx_addr_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 The vector's IOVA is sent to the SMMU as nonsecure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1).

                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.
                                                                 The vector's IOVA is sent to the SMMU as secure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1 or
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1).

                                                                 If PCCPF_PEM()_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set.

                                                                 Also note the following:
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_EN]=1, all secure vectors (including secure
                                                                 VF vectors) will act as if PCCPF/PCCVF_XXX_MSIX_CAP_HDR[MSIXEN]=1,
                                                                 PCCPF/PCCVF_XXX_MSIX_CAP_HDR[FUNM]=0 and PCCPF/PCCVF_XXX_CMD[ME]=1.
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1, all secure vectors (including
                                                                 secure VF vectors) are considered physical, regardless of
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 The vector's IOVA is sent to the SMMU as nonsecure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1).

                                                                 1 = This vector's PEM()_MSIX_VEC()_ADDR, PEM()_MSIX_VEC()_CTL, and
                                                                 corresponding bit of PEM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.
                                                                 The vector's IOVA is sent to the SMMU as secure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1 or
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1).

                                                                 If PCCPF_PEM()_VSEC_SCTL[MSIX_SEC] (for documentation, see
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is
                                                                 set, all vectors are secure and function as if [SECVEC] was set.

                                                                 Also note the following:
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_EN]=1, all secure vectors (including secure
                                                                 VF vectors) will act as if PCCPF/PCCVF_XXX_MSIX_CAP_HDR[MSIXEN]=1,
                                                                 PCCPF/PCCVF_XXX_MSIX_CAP_HDR[FUNM]=0 and PCCPF/PCCVF_XXX_CMD[ME]=1.
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1, all secure vectors (including
                                                                 secure VF vectors) are considered physical, regardless of
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_msix_vecx_addr bdk_pemx_msix_vecx_addr_t;

static inline uint64_t BDK_PEMX_MSIX_VECX_ADDR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_MSIX_VECX_ADDR(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && ((a<=2) && (b<=11)))
        return 0x87e0c0f00000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b<=11)))
        return 0x87e0c0f00000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN96XX_PASS1_X) && ((a<=3) && (b<=8)))
        return 0x8e0f00000000ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=3) && (b<=9)))
        return 0x8e0f00000000ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=9)))
        return 0x8e0f00000000ll + 0x1000000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=8)))
        return 0x8e0f00000000ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=9)))
        return 0x8e0f00000000ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_MSIX_VECX_ADDR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_MSIX_VECX_ADDR(a,b) bdk_pemx_msix_vecx_addr_t
#define bustype_BDK_PEMX_MSIX_VECX_ADDR(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_MSIX_VECX_ADDR(a,b) "PEMX_MSIX_VECX_ADDR"
#define device_bar_BDK_PEMX_MSIX_VECX_ADDR(a,b) 0x4 /* PF_BAR4 */
#define busnum_BDK_PEMX_MSIX_VECX_ADDR(a,b) (a)
#define arguments_BDK_PEMX_MSIX_VECX_ADDR(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_msix_vec#_ctl
 *
 * PEM MSI-X Vector Table Control and Data Registers
 * This register is the MSI-X vector table, indexed by the PEM_INT_VEC_E enumeration.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_msix_vecx_ctl
{
    uint64_t u;
    struct bdk_pemx_msix_vecx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_msix_vecx_ctl_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t reserved_20_31        : 12;
        uint64_t data                  : 20; /**< [ 19:  0](R/W) Data to use for MSI-X delivery of this vector. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 20; /**< [ 19:  0](R/W) Data to use for MSI-X delivery of this vector. */
        uint64_t reserved_20_31        : 12;
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } cn8;
    /* struct bdk_pemx_msix_vecx_ctl_s cn9; */
};
typedef union bdk_pemx_msix_vecx_ctl bdk_pemx_msix_vecx_ctl_t;

static inline uint64_t BDK_PEMX_MSIX_VECX_CTL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_MSIX_VECX_CTL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && ((a<=2) && (b<=11)))
        return 0x87e0c0f00008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b<=11)))
        return 0x87e0c0f00008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN96XX_PASS1_X) && ((a<=3) && (b<=8)))
        return 0x8e0f00000008ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && ((a<=3) && (b<=9)))
        return 0x8e0f00000008ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=9)))
        return 0x8e0f00000008ll + 0x1000000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=8)))
        return 0x8e0f00000008ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=9)))
        return 0x8e0f00000008ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_MSIX_VECX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_MSIX_VECX_CTL(a,b) bdk_pemx_msix_vecx_ctl_t
#define bustype_BDK_PEMX_MSIX_VECX_CTL(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_MSIX_VECX_CTL(a,b) "PEMX_MSIX_VECX_CTL"
#define device_bar_BDK_PEMX_MSIX_VECX_CTL(a,b) 0x4 /* PF_BAR4 */
#define busnum_BDK_PEMX_MSIX_VECX_CTL(a,b) (a)
#define arguments_BDK_PEMX_MSIX_VECX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_ncbi_ctl
 *
 * PEM Inbound NCBI Control Register
 * This register contains control bits for memory accesses targeting the NCBI bus.
 * This register is ignored when PEM()_EBUS_CTL[PF_BAR*_SEL] is set.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_ncbi_ctl
{
    uint64_t u;
    struct bdk_pemx_ncbi_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t bige                  : 1;  /**< [ 20: 20](R/W) Atomics sent on NCBI will be marked as big endian.  If the link partner is
                                                                 big-endian and the processors are big-endian, this allows exchange of big-endian
                                                                 atomics without byte swapping. */
        uint64_t reserved_11_19        : 9;
        uint64_t clken_force           : 1;  /**< [ 10: 10](R/W) Force clock enable on NCBI bus to always enabled. For diagnostic use only. */
        uint64_t ntlp_ro_dis           : 1;  /**< [  9:  9](R/W) Relaxed ordering disable for non-posted TLPs. Will force relaxed ordering bit off when
                                                                 non-posted TLPs are forwarded to IOB over NCBI. */
        uint64_t ctlp_ro_dis           : 1;  /**< [  8:  8](R/W) Relaxed ordering disable for completion TLPs. Will force relaxed ordering bit off when
                                                                 completion TLPs are forwarded to IOB over NCBI. */
        uint64_t ptlp_ro_dis           : 1;  /**< [  7:  7](R/W) Relaxed ordering disable for posted TLPs. Will force relaxed ordering bit off when posted
                                                                 TLPs are forwarded to IOB over NCBI. */
        uint64_t reserved_3_6          : 4;
        uint64_t ld_cmd                : 2;  /**< [  2:  1](R/W) When PEM issues a load command over NCBI to the LLC that is to be cached, this field
                                                                 selects the type of load command to use. Un-cached loads will use LDT:
                                                                 0x0 = LDD.
                                                                 0x1 = LDI.
                                                                 0x2 = LDE.
                                                                 0x3 = LDY. */
        uint64_t wait_com              : 1;  /**< [  0:  0](R/W) Wait for commit. For diagnostic use only.

                                                                 When set, replaces the default automatic store-store ordering with a more
                                                                 conservative and lower performing rule. This causes the PEM to wait for a store
                                                                 done from the NCB before sending additional stores to the NCB from the MAC. The
                                                                 PEM requests a commit on the last store if more than one STORE operation is
                                                                 required on NCBI. When set, inbound write merging must be disabled
                                                                 (PEM()_IB_MERGE_TIMER_CTL[WMERGE_DIS] = 1). */
#else /* Word 0 - Little Endian */
        uint64_t wait_com              : 1;  /**< [  0:  0](R/W) Wait for commit. For diagnostic use only.

                                                                 When set, replaces the default automatic store-store ordering with a more
                                                                 conservative and lower performing rule. This causes the PEM to wait for a store
                                                                 done from the NCB before sending additional stores to the NCB from the MAC. The
                                                                 PEM requests a commit on the last store if more than one STORE operation is
                                                                 required on NCBI. When set, inbound write merging must be disabled
                                                                 (PEM()_IB_MERGE_TIMER_CTL[WMERGE_DIS] = 1). */
        uint64_t ld_cmd                : 2;  /**< [  2:  1](R/W) When PEM issues a load command over NCBI to the LLC that is to be cached, this field
                                                                 selects the type of load command to use. Un-cached loads will use LDT:
                                                                 0x0 = LDD.
                                                                 0x1 = LDI.
                                                                 0x2 = LDE.
                                                                 0x3 = LDY. */
        uint64_t reserved_3_6          : 4;
        uint64_t ptlp_ro_dis           : 1;  /**< [  7:  7](R/W) Relaxed ordering disable for posted TLPs. Will force relaxed ordering bit off when posted
                                                                 TLPs are forwarded to IOB over NCBI. */
        uint64_t ctlp_ro_dis           : 1;  /**< [  8:  8](R/W) Relaxed ordering disable for completion TLPs. Will force relaxed ordering bit off when
                                                                 completion TLPs are forwarded to IOB over NCBI. */
        uint64_t ntlp_ro_dis           : 1;  /**< [  9:  9](R/W) Relaxed ordering disable for non-posted TLPs. Will force relaxed ordering bit off when
                                                                 non-posted TLPs are forwarded to IOB over NCBI. */
        uint64_t clken_force           : 1;  /**< [ 10: 10](R/W) Force clock enable on NCBI bus to always enabled. For diagnostic use only. */
        uint64_t reserved_11_19        : 9;
        uint64_t bige                  : 1;  /**< [ 20: 20](R/W) Atomics sent on NCBI will be marked as big endian.  If the link partner is
                                                                 big-endian and the processors are big-endian, this allows exchange of big-endian
                                                                 atomics without byte swapping. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_ncbi_ctl_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t bige                  : 1;  /**< [ 20: 20](R/W) Atomics sent on NCBI will be marked as big endian.  If the link partner is
                                                                 big-endian and the processors are big-endian, this allows exchange of big-endian
                                                                 atomics without byte swapping. */
        uint64_t reserved_11_19        : 9;
        uint64_t clken_force           : 1;  /**< [ 10: 10](R/W) Force clock enable on NCBI bus to always enabled. For diagnostic use only. */
        uint64_t ntlp_ro_dis           : 1;  /**< [  9:  9](R/W) Relaxed ordering disable for non-posted TLPs. Will force relaxed ordering bit off when
                                                                 non-posted TLPs are forwarded to IOB over NCBI. */
        uint64_t ctlp_ro_dis           : 1;  /**< [  8:  8](R/W) Relaxed ordering disable for completion TLPs. Will force relaxed ordering bit off when
                                                                 completion TLPs are forwarded to IOB over NCBI. */
        uint64_t ptlp_ro_dis           : 1;  /**< [  7:  7](R/W) Relaxed ordering disable for posted TLPs. Will force relaxed ordering bit off when posted
                                                                 TLPs are forwarded to IOB over NCBI. */
        uint64_t reserved_5_6          : 2;
        uint64_t reserved_4            : 1;
        uint64_t reserved_3            : 1;
        uint64_t ld_cmd                : 2;  /**< [  2:  1](R/W) When PEM issues a load command over NCBI to the LLC that is to be cached, this field
                                                                 selects the type of load command to use. Un-cached loads will use LDT:
                                                                 0x0 = LDD.
                                                                 0x1 = LDI.
                                                                 0x2 = LDE.
                                                                 0x3 = LDY. */
        uint64_t wait_com              : 1;  /**< [  0:  0](R/W) Wait for commit. For diagnostic use only.

                                                                 When set, replaces the default automatic store-store ordering with a more
                                                                 conservative and lower performing rule. This causes the PEM to wait for a store
                                                                 done from the NCB before sending additional stores to the NCB from the MAC. The
                                                                 PEM requests a commit on the last store if more than one STORE operation is
                                                                 required on NCBI. When set, inbound write merging must be disabled
                                                                 (PEM()_IB_MERGE_TIMER_CTL[WMERGE_DIS] = 1). */
#else /* Word 0 - Little Endian */
        uint64_t wait_com              : 1;  /**< [  0:  0](R/W) Wait for commit. For diagnostic use only.

                                                                 When set, replaces the default automatic store-store ordering with a more
                                                                 conservative and lower performing rule. This causes the PEM to wait for a store
                                                                 done from the NCB before sending additional stores to the NCB from the MAC. The
                                                                 PEM requests a commit on the last store if more than one STORE operation is
                                                                 required on NCBI. When set, inbound write merging must be disabled
                                                                 (PEM()_IB_MERGE_TIMER_CTL[WMERGE_DIS] = 1). */
        uint64_t ld_cmd                : 2;  /**< [  2:  1](R/W) When PEM issues a load command over NCBI to the LLC that is to be cached, this field
                                                                 selects the type of load command to use. Un-cached loads will use LDT:
                                                                 0x0 = LDD.
                                                                 0x1 = LDI.
                                                                 0x2 = LDE.
                                                                 0x3 = LDY. */
        uint64_t reserved_3            : 1;
        uint64_t reserved_4            : 1;
        uint64_t reserved_5_6          : 2;
        uint64_t ptlp_ro_dis           : 1;  /**< [  7:  7](R/W) Relaxed ordering disable for posted TLPs. Will force relaxed ordering bit off when posted
                                                                 TLPs are forwarded to IOB over NCBI. */
        uint64_t ctlp_ro_dis           : 1;  /**< [  8:  8](R/W) Relaxed ordering disable for completion TLPs. Will force relaxed ordering bit off when
                                                                 completion TLPs are forwarded to IOB over NCBI. */
        uint64_t ntlp_ro_dis           : 1;  /**< [  9:  9](R/W) Relaxed ordering disable for non-posted TLPs. Will force relaxed ordering bit off when
                                                                 non-posted TLPs are forwarded to IOB over NCBI. */
        uint64_t clken_force           : 1;  /**< [ 10: 10](R/W) Force clock enable on NCBI bus to always enabled. For diagnostic use only. */
        uint64_t reserved_11_19        : 9;
        uint64_t bige                  : 1;  /**< [ 20: 20](R/W) Atomics sent on NCBI will be marked as big endian.  If the link partner is
                                                                 big-endian and the processors are big-endian, this allows exchange of big-endian
                                                                 atomics without byte swapping. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_pemx_ncbi_ctl bdk_pemx_ncbi_ctl_t;

static inline uint64_t BDK_PEMX_NCBI_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_NCBI_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000178ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000178ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000178ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000178ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_NCBI_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_NCBI_CTL(a) bdk_pemx_ncbi_ctl_t
#define bustype_BDK_PEMX_NCBI_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_NCBI_CTL(a) "PEMX_NCBI_CTL"
#define device_bar_BDK_PEMX_NCBI_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_NCBI_CTL(a) (a)
#define arguments_BDK_PEMX_NCBI_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ncbi_tlp_credits
 *
 * PEM NCB Inbound TLP Credits Register
 * This register specifies the number of credits for use in moving TLPs. When this register is
 * written, the credit values are reset to the register value. This register is for diagnostic
 * use only, and should only be written when PEM()_CTL_STATUS[LNK_ENB] is clear.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_ncbi_tlp_credits
{
    uint64_t u;
    struct bdk_pemx_ncbi_tlp_credits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ncbi_cpl              : 11; /**< [ 31: 21](R/W) TLP 32 B credits for completion TLPs in the PEMs NCBI buffers.
                                                                 Legal values are 0x21 to 0x100. */
        uint64_t ncbi_np               : 10; /**< [ 20: 11](R/W) TLP headers for non-posted TLPs in the PEMs NCBI buffers.
                                                                 Legal values are 0x20 to 0x100. */
        uint64_t ncbi_p                : 11; /**< [ 10:  0](R/W) TLP 32 B credits for posted TLPs in the PEMs NCBI buffers.
                                                                 Legal values are 0x21 to 0x100. */
#else /* Word 0 - Little Endian */
        uint64_t ncbi_p                : 11; /**< [ 10:  0](R/W) TLP 32 B credits for posted TLPs in the PEMs NCBI buffers.
                                                                 Legal values are 0x21 to 0x100. */
        uint64_t ncbi_np               : 10; /**< [ 20: 11](R/W) TLP headers for non-posted TLPs in the PEMs NCBI buffers.
                                                                 Legal values are 0x20 to 0x100. */
        uint64_t ncbi_cpl              : 11; /**< [ 31: 21](R/W) TLP 32 B credits for completion TLPs in the PEMs NCBI buffers.
                                                                 Legal values are 0x21 to 0x100. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ncbi_tlp_credits_s cn; */
};
typedef union bdk_pemx_ncbi_tlp_credits bdk_pemx_ncbi_tlp_credits_t;

static inline uint64_t BDK_PEMX_NCBI_TLP_CREDITS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_NCBI_TLP_CREDITS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000030ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000030ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000030ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000030ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_NCBI_TLP_CREDITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_NCBI_TLP_CREDITS(a) bdk_pemx_ncbi_tlp_credits_t
#define bustype_BDK_PEMX_NCBI_TLP_CREDITS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_NCBI_TLP_CREDITS(a) "PEMX_NCBI_TLP_CREDITS"
#define device_bar_BDK_PEMX_NCBI_TLP_CREDITS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_NCBI_TLP_CREDITS(a) (a)
#define arguments_BDK_PEMX_NCBI_TLP_CREDITS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ncbo_fifo_status
 *
 * PEM NCBO Offloading FIFO Status Register
 * This register contains status about the PEM NCBO offloading FIFOs.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_ncbo_fifo_status
{
    uint64_t u;
    struct bdk_pemx_ncbo_fifo_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t csr_volume            : 8;  /**< [ 23: 16](RO/H) Reports the number of valid entries currently held in the NCBO CSR offloading
                                                                 FIFO. Each entry represents an NCBO-based CSR access and the value read can
                                                                 range from 0x0 to a maximum of 128 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t reserved_15           : 1;
        uint64_t n_volume              : 7;  /**< [ 14:  8](RO/H) Reports the number of valid entries currently held in the NCBO nonposted
                                                                 offloading FIFO. Each entry represents a beat of the NCBO bus related to a
                                                                 nonposted operation and the value read can range from 0x0 to a maximum of 64
                                                                 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t p_volume              : 8;  /**< [  7:  0](RO/H) Reports the number of valid entries currently held in the NCBO posted offloading
                                                                 FIFO. Each entry represents a beat of the NCBO bus related to a memory store and
                                                                 the value read can range from 0x0 to a maximum of 128 which would represent
                                                                 completely full.
                                                                 For diagnostic use only. */
#else /* Word 0 - Little Endian */
        uint64_t p_volume              : 8;  /**< [  7:  0](RO/H) Reports the number of valid entries currently held in the NCBO posted offloading
                                                                 FIFO. Each entry represents a beat of the NCBO bus related to a memory store and
                                                                 the value read can range from 0x0 to a maximum of 128 which would represent
                                                                 completely full.
                                                                 For diagnostic use only. */
        uint64_t n_volume              : 7;  /**< [ 14:  8](RO/H) Reports the number of valid entries currently held in the NCBO nonposted
                                                                 offloading FIFO. Each entry represents a beat of the NCBO bus related to a
                                                                 nonposted operation and the value read can range from 0x0 to a maximum of 64
                                                                 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t reserved_15           : 1;
        uint64_t csr_volume            : 8;  /**< [ 23: 16](RO/H) Reports the number of valid entries currently held in the NCBO CSR offloading
                                                                 FIFO. Each entry represents an NCBO-based CSR access and the value read can
                                                                 range from 0x0 to a maximum of 128 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ncbo_fifo_status_s cn; */
};
typedef union bdk_pemx_ncbo_fifo_status bdk_pemx_ncbo_fifo_status_t;

static inline uint64_t BDK_PEMX_NCBO_FIFO_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_NCBO_FIFO_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000138ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000138ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000138ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000138ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_NCBO_FIFO_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_NCBO_FIFO_STATUS(a) bdk_pemx_ncbo_fifo_status_t
#define bustype_BDK_PEMX_NCBO_FIFO_STATUS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_NCBO_FIFO_STATUS(a) "PEMX_NCBO_FIFO_STATUS"
#define device_bar_BDK_PEMX_NCBO_FIFO_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_NCBO_FIFO_STATUS(a) (a)
#define arguments_BDK_PEMX_NCBO_FIFO_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ob_cpl_fifo_status
 *
 * PEM Outbound Completion FIFO Status Register
 * This register contains status about the PEM Outbound Completion FIFOs.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_ob_cpl_fifo_status
{
    uint64_t u;
    struct bdk_pemx_ob_cpl_fifo_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_26_63        : 38;
        uint64_t ncbo_c_volume         : 10; /**< [ 25: 16](RO/H) Reports the number of valid entries currently held in the NCBO completion
                                                                 FIFO. Each entry represents a 256-bit beat of data.  The value read can
                                                                 range from 0x0 to a maximum of 512 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t ebo_c_volume          : 8;  /**< [ 15:  8](RO/H) Reports the number of valid entries currently held in the EBO completion
                                                                 FIFO which is downstream and separate from the EBO completion offloading
                                                                 FIFO.  Each entry represents a 256-bit beat of data.  The value read can
                                                                 range from 0x0 to a maximum of 128 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t pspi_c_volume         : 8;  /**< [  7:  0](RO/H) Reports the number of valid entries currently held in the PSPI completion
                                                                 FIFO. Each entry represents a 256-bit beat of data.  The value read can
                                                                 range from 0x0 to a maximum of 128 which would represent completely full.
                                                                 For diagnostic use only. */
#else /* Word 0 - Little Endian */
        uint64_t pspi_c_volume         : 8;  /**< [  7:  0](RO/H) Reports the number of valid entries currently held in the PSPI completion
                                                                 FIFO. Each entry represents a 256-bit beat of data.  The value read can
                                                                 range from 0x0 to a maximum of 128 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t ebo_c_volume          : 8;  /**< [ 15:  8](RO/H) Reports the number of valid entries currently held in the EBO completion
                                                                 FIFO which is downstream and separate from the EBO completion offloading
                                                                 FIFO.  Each entry represents a 256-bit beat of data.  The value read can
                                                                 range from 0x0 to a maximum of 128 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t ncbo_c_volume         : 10; /**< [ 25: 16](RO/H) Reports the number of valid entries currently held in the NCBO completion
                                                                 FIFO. Each entry represents a 256-bit beat of data.  The value read can
                                                                 range from 0x0 to a maximum of 512 which would represent completely full.
                                                                 For diagnostic use only. */
        uint64_t reserved_26_63        : 38;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ob_cpl_fifo_status_s cn; */
};
typedef union bdk_pemx_ob_cpl_fifo_status bdk_pemx_ob_cpl_fifo_status_t;

static inline uint64_t BDK_PEMX_OB_CPL_FIFO_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_OB_CPL_FIFO_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000170ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000170ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000170ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000170ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_OB_CPL_FIFO_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_OB_CPL_FIFO_STATUS(a) bdk_pemx_ob_cpl_fifo_status_t
#define bustype_BDK_PEMX_OB_CPL_FIFO_STATUS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_OB_CPL_FIFO_STATUS(a) "PEMX_OB_CPL_FIFO_STATUS"
#define device_bar_BDK_PEMX_OB_CPL_FIFO_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_OB_CPL_FIFO_STATUS(a) (a)
#define arguments_BDK_PEMX_OB_CPL_FIFO_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_obff_ctl_status
 *
 * PEM Optimized Buffer Flush/Fill Control/Status Register
 * This register is used for EP mode OFF debug.
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_obff_ctl_status
{
    uint64_t u;
    struct bdk_pemx_obff_ctl_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t dec_err               : 1;  /**< [  4:  4](R/W1C) Wake decoder recieved a invalid WAKE pattern.

                                                                 When a invalid WAKE pattern is detected, the OBFF
                                                                 wake decoder is forced into the CPU_ACT state. */
        uint64_t dec_state             : 4;  /**< [  3:  0](RO/H) The current FSM state of the OBFF wake decoder.  EP mode only.
                                                                 For debug purposes only.

                                                                 0x0 = IDLE (RC mode).
                                                                 0x1 = IDLE to OBFF.
                                                                 0x3 = IDLE to CPU.
                                                                 0x4 = OBFF to IDLE.
                                                                 0x5 = OBFF.
                                                                 0x6 = OBFF to CPU 1, inactive pulse.
                                                                 0xa = CPU_IDLE.
                                                                 0xb = CPU_ACT (default state in EP mode).
                                                                 0xe = OBFF to CPU 1, inactive pulse.

                                                                 All other FSM states are undefined. */
#else /* Word 0 - Little Endian */
        uint64_t dec_state             : 4;  /**< [  3:  0](RO/H) The current FSM state of the OBFF wake decoder.  EP mode only.
                                                                 For debug purposes only.

                                                                 0x0 = IDLE (RC mode).
                                                                 0x1 = IDLE to OBFF.
                                                                 0x3 = IDLE to CPU.
                                                                 0x4 = OBFF to IDLE.
                                                                 0x5 = OBFF.
                                                                 0x6 = OBFF to CPU 1, inactive pulse.
                                                                 0xa = CPU_IDLE.
                                                                 0xb = CPU_ACT (default state in EP mode).
                                                                 0xe = OBFF to CPU 1, inactive pulse.

                                                                 All other FSM states are undefined. */
        uint64_t dec_err               : 1;  /**< [  4:  4](R/W1C) Wake decoder recieved a invalid WAKE pattern.

                                                                 When a invalid WAKE pattern is detected, the OBFF
                                                                 wake decoder is forced into the CPU_ACT state. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_obff_ctl_status_s cn; */
};
typedef union bdk_pemx_obff_ctl_status bdk_pemx_obff_ctl_status_t;

static inline uint64_t BDK_PEMX_OBFF_CTL_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_OBFF_CTL_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000088ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000088ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000088ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000088ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_OBFF_CTL_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_OBFF_CTL_STATUS(a) bdk_pemx_obff_ctl_status_t
#define bustype_BDK_PEMX_OBFF_CTL_STATUS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_OBFF_CTL_STATUS(a) "PEMX_OBFF_CTL_STATUS"
#define device_bar_BDK_PEMX_OBFF_CTL_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_OBFF_CTL_STATUS(a) (a)
#define arguments_BDK_PEMX_OBFF_CTL_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_obff_wake_cfg
 *
 * PEM Optimized Buffer Flush/Fill Wake Configuration Register
 * This configures wake configuration.
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_obff_wake_cfg
{
    uint64_t u;
    struct bdk_pemx_obff_wake_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t max_pls               : 8;  /**< [ 31: 24](R/W) Max pulse width for active-inactive-active pulse.
                                                                 Twake_tx_max_pulse = [MAX_PLS] * Tck_period (10ns). */
        uint64_t min_pls               : 8;  /**< [ 23: 16](R/W) Min pulse width for active-inactive pulse.
                                                                 Twake_tx_min_pulse = [MIN_PLS] * Tck_period (10ns). */
        uint64_t max_f2f               : 8;  /**< [ 15:  8](R/W) Max falling to falling edge width.
                                                                 Twake_fall_fall_cpu_active (max) = [MAX_F2F] * Tck_period (10ns). */
        uint64_t min_f2f               : 8;  /**< [  7:  0](R/W) Min falling to falling edge width.
                                                                 Twake_fall_fall_cpu_active (min) = [MIN_F2F] * Tck_period (10ns). */
#else /* Word 0 - Little Endian */
        uint64_t min_f2f               : 8;  /**< [  7:  0](R/W) Min falling to falling edge width.
                                                                 Twake_fall_fall_cpu_active (min) = [MIN_F2F] * Tck_period (10ns). */
        uint64_t max_f2f               : 8;  /**< [ 15:  8](R/W) Max falling to falling edge width.
                                                                 Twake_fall_fall_cpu_active (max) = [MAX_F2F] * Tck_period (10ns). */
        uint64_t min_pls               : 8;  /**< [ 23: 16](R/W) Min pulse width for active-inactive pulse.
                                                                 Twake_tx_min_pulse = [MIN_PLS] * Tck_period (10ns). */
        uint64_t max_pls               : 8;  /**< [ 31: 24](R/W) Max pulse width for active-inactive-active pulse.
                                                                 Twake_tx_max_pulse = [MAX_PLS] * Tck_period (10ns). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_obff_wake_cfg_s cn; */
};
typedef union bdk_pemx_obff_wake_cfg bdk_pemx_obff_wake_cfg_t;

static inline uint64_t BDK_PEMX_OBFF_WAKE_CFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_OBFF_WAKE_CFG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000090ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000090ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000090ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000090ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_OBFF_WAKE_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_OBFF_WAKE_CFG(a) bdk_pemx_obff_wake_cfg_t
#define bustype_BDK_PEMX_OBFF_WAKE_CFG(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_OBFF_WAKE_CFG(a) "PEMX_OBFF_WAKE_CFG"
#define device_bar_BDK_PEMX_OBFF_WAKE_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_OBFF_WAKE_CFG(a) (a)
#define arguments_BDK_PEMX_OBFF_WAKE_CFG(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_on
 *
 * PEM On Status Register
 * This register indicates that PEM is configured and ready.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_on
{
    uint64_t u;
    struct bdk_pemx_on_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t aclr                  : 1;  /**< [  2:  2](R/W) When this bit is set, [PEMON] will auto-clear on core domain reset, in addition
                                                                 to being reset on cold reset. [ACLR] should be 0 in an EP configuration where
                                                                 it is desired to leave the link operational while resetting the chip core.
                                                                 It should normally be 1 in root complex mode. */
        uint64_t pemoor                : 1;  /**< [  1:  1](RO/H) Indication to software that the PEM has been taken out of reset (i.e. BIST is done) and it
                                                                 is safe to configure core CSRs. */
        uint64_t pemon                 : 1;  /**< [  0:  0](R/W/H) Indication to the GSER that the PEM is out of reset, configured, and ready to send/receive
                                                                 traffic. Setting this bit takes the configured PIPE out of reset. */
#else /* Word 0 - Little Endian */
        uint64_t pemon                 : 1;  /**< [  0:  0](R/W/H) Indication to the GSER that the PEM is out of reset, configured, and ready to send/receive
                                                                 traffic. Setting this bit takes the configured PIPE out of reset. */
        uint64_t pemoor                : 1;  /**< [  1:  1](RO/H) Indication to software that the PEM has been taken out of reset (i.e. BIST is done) and it
                                                                 is safe to configure core CSRs. */
        uint64_t aclr                  : 1;  /**< [  2:  2](R/W) When this bit is set, [PEMON] will auto-clear on core domain reset, in addition
                                                                 to being reset on cold reset. [ACLR] should be 0 in an EP configuration where
                                                                 it is desired to leave the link operational while resetting the chip core.
                                                                 It should normally be 1 in root complex mode. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_on_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t pemoor                : 1;  /**< [  1:  1](RO/H) Indication to software that the PEM has been taken out of reset (i.e. BIST is done) and it
                                                                 is safe to configure core CSRs. */
        uint64_t pemon                 : 1;  /**< [  0:  0](R/W/H) Indication to the GSER that the PEM is out of reset, configured, and ready to send/receive
                                                                 traffic. Setting this bit takes the configured PIPE out of reset. */
#else /* Word 0 - Little Endian */
        uint64_t pemon                 : 1;  /**< [  0:  0](R/W/H) Indication to the GSER that the PEM is out of reset, configured, and ready to send/receive
                                                                 traffic. Setting this bit takes the configured PIPE out of reset. */
        uint64_t pemoor                : 1;  /**< [  1:  1](RO/H) Indication to software that the PEM has been taken out of reset (i.e. BIST is done) and it
                                                                 is safe to configure core CSRs. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_on_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t aclr                  : 1;  /**< [  2:  2](R/W) When this bit is set, [PEMON] will auto-clear on core domain reset, in addition
                                                                 to being reset on cold reset. [ACLR] should be 0 in an EP configuration where
                                                                 it is desired to leave the link operational while resetting the chip core.
                                                                 It should normally be 1 in root complex mode. */
        uint64_t pemoor                : 1;  /**< [  1:  1](RO/H) Indication to software that the PEM has been taken out of MAC reset and it
                                                                 is safe to configure CSRs marked as being on MAC reset, as well as all PCIe configuration
                                                                 registers. */
        uint64_t pemon                 : 1;  /**< [  0:  0](R/W/H) Indication to the centralized reset block that the PEM is out of domain reset,
                                                                 and PEM()_CLK_EN and PEM()_CFG have been configured. Setting this bit will allow the
                                                                 configured PIPE to be taken out of reset and MAC reset to be deasserted.
                                                                 This bit is set as part of the initialization/boot sequence for PCIe. */
#else /* Word 0 - Little Endian */
        uint64_t pemon                 : 1;  /**< [  0:  0](R/W/H) Indication to the centralized reset block that the PEM is out of domain reset,
                                                                 and PEM()_CLK_EN and PEM()_CFG have been configured. Setting this bit will allow the
                                                                 configured PIPE to be taken out of reset and MAC reset to be deasserted.
                                                                 This bit is set as part of the initialization/boot sequence for PCIe. */
        uint64_t pemoor                : 1;  /**< [  1:  1](RO/H) Indication to software that the PEM has been taken out of MAC reset and it
                                                                 is safe to configure CSRs marked as being on MAC reset, as well as all PCIe configuration
                                                                 registers. */
        uint64_t aclr                  : 1;  /**< [  2:  2](R/W) When this bit is set, [PEMON] will auto-clear on core domain reset, in addition
                                                                 to being reset on cold reset. [ACLR] should be 0 in an EP configuration where
                                                                 it is desired to leave the link operational while resetting the chip core.
                                                                 It should normally be 1 in root complex mode. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_on bdk_pemx_on_t;

static inline uint64_t BDK_PEMX_ON(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_ON(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000420ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000420ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000e0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000e0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000e0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000e0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_ON", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_ON(a) bdk_pemx_on_t
#define bustype_BDK_PEMX_ON(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_ON(a) "PEMX_ON"
#define device_bar_BDK_PEMX_ON(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_ON(a) (a)
#define arguments_BDK_PEMX_ON(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_p2n_bar0_start
 *
 * PEM PCIe RC BAR0 Start Register
 * This register specifies the starting address for memory requests that are to be forwarded to
 * NCB/EBUS in RC mode. In EP mode, the standard PCIe config space BAR registers are used, and
 * this register is ignored.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_p2n_bar0_start
{
    uint64_t u;
    struct bdk_pemx_p2n_bar0_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_p2n_bar0_start_s cn8; */
    struct bdk_pemx_p2n_bar0_start_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 50; /**< [ 63: 14](R/W) The starting address of the 16KB BAR0 address space. */
        uint64_t reserved_0_13         : 14;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_13         : 14;
        uint64_t addr                  : 50; /**< [ 63: 14](R/W) The starting address of the 16KB BAR0 address space. */
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_p2n_bar0_start_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 41; /**< [ 63: 23](R/W) The starting address of the 8 MB BAR0 address space. */
        uint64_t reserved_0_22         : 23;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_22         : 23;
        uint64_t addr                  : 41; /**< [ 63: 23](R/W) The starting address of the 8 MB BAR0 address space. */
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_p2n_bar0_start_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 48; /**< [ 63: 16](R/W) The starting address of the BAR0 address space, sized as configured by the
                                                                 PEM()_BAR_CTL[BAR0_SIZ] which defaults to ADDR\<63:23\> and used to determine a RC BAR0 hit. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t addr                  : 48; /**< [ 63: 16](R/W) The starting address of the BAR0 address space, sized as configured by the
                                                                 PEM()_BAR_CTL[BAR0_SIZ] which defaults to ADDR\<63:23\> and used to determine a RC BAR0 hit. */
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_p2n_bar0_start bdk_pemx_p2n_bar0_start_t;

static inline uint64_t BDK_PEMX_P2N_BAR0_START(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_P2N_BAR0_START(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000080ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000080ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000158ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000158ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000158ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000158ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_P2N_BAR0_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_P2N_BAR0_START(a) bdk_pemx_p2n_bar0_start_t
#define bustype_BDK_PEMX_P2N_BAR0_START(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_P2N_BAR0_START(a) "PEMX_P2N_BAR0_START"
#define device_bar_BDK_PEMX_P2N_BAR0_START(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_P2N_BAR0_START(a) (a)
#define arguments_BDK_PEMX_P2N_BAR0_START(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_p2n_bar1_start
 *
 * PEM PCIe to SLI BAR1 Start Register
 * This register specifies the starting address for memory requests that are to be forwarded to
 * the SLI in RC mode.
 */
union bdk_pemx_p2n_bar1_start
{
    uint64_t u;
    struct bdk_pemx_p2n_bar1_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 38; /**< [ 63: 26](R/W) The starting address of the 64 MB BAR1 address space. */
        uint64_t reserved_0_25         : 26;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_25         : 26;
        uint64_t addr                  : 38; /**< [ 63: 26](R/W) The starting address of the 64 MB BAR1 address space. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_p2n_bar1_start_s cn; */
};
typedef union bdk_pemx_p2n_bar1_start bdk_pemx_p2n_bar1_start_t;

static inline uint64_t BDK_PEMX_P2N_BAR1_START(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_P2N_BAR1_START(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000088ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000088ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_P2N_BAR1_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_P2N_BAR1_START(a) bdk_pemx_p2n_bar1_start_t
#define bustype_BDK_PEMX_P2N_BAR1_START(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_P2N_BAR1_START(a) "PEMX_P2N_BAR1_START"
#define device_bar_BDK_PEMX_P2N_BAR1_START(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_P2N_BAR1_START(a) (a)
#define arguments_BDK_PEMX_P2N_BAR1_START(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_p2n_bar2_start
 *
 * PEM PCIe RC BAR2 Start Register
 * This register specifies the starting address for memory requests that are to be forwarded to
 * NCB/EBUS in RC mode. In EP mode, the standard PCIe config space BAR registers are used, and
 * this register is ignored.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_p2n_bar2_start
{
    uint64_t u;
    struct bdk_pemx_p2n_bar2_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_p2n_bar2_start_s cn8; */
    struct bdk_pemx_p2n_bar2_start_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 14; /**< [ 63: 50](R/W) The starting address of the 2^50 address space
                                                                 that is the BAR2 address space. */
        uint64_t spares                : 2;  /**< [ 49: 48](R/W) Spare flops. */
        uint64_t reserved_0_47         : 48;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_47         : 48;
        uint64_t spares                : 2;  /**< [ 49: 48](R/W) Spare flops. */
        uint64_t addr                  : 14; /**< [ 63: 50](R/W) The starting address of the 2^50 address space
                                                                 that is the BAR2 address space. */
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_p2n_bar2_start_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 44; /**< [ 63: 20](R/W) The starting address of the BAR2 address space, sized as configured by the
                                                                 PEM()_BAR_CTL[BAR2_SIZ]
                                                                 which defaults to ADDR\<63:50\> and used to determine a RC bar2 hit. */
        uint64_t reserved_0_19         : 20;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_19         : 20;
        uint64_t addr                  : 44; /**< [ 63: 20](R/W) The starting address of the BAR2 address space, sized as configured by the
                                                                 PEM()_BAR_CTL[BAR2_SIZ]
                                                                 which defaults to ADDR\<63:50\> and used to determine a RC bar2 hit. */
#endif /* Word 0 - End */
    } cn83xx;
    struct bdk_pemx_p2n_bar2_start_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 44; /**< [ 63: 20](R/W) The starting address of the BAR2 address space, sized as configured by the
                                                                 PEM()_BAR_CTL[BAR2_SIZ] which defaults to ADDR\<63:50\> and used to determine a RC BAR2 hit. */
        uint64_t reserved_0_19         : 20;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_19         : 20;
        uint64_t addr                  : 44; /**< [ 63: 20](R/W) The starting address of the BAR2 address space, sized as configured by the
                                                                 PEM()_BAR_CTL[BAR2_SIZ] which defaults to ADDR\<63:50\> and used to determine a RC BAR2 hit. */
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_p2n_bar2_start bdk_pemx_p2n_bar2_start_t;

static inline uint64_t BDK_PEMX_P2N_BAR2_START(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_P2N_BAR2_START(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000090ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000090ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000150ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000150ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000150ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000150ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_P2N_BAR2_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_P2N_BAR2_START(a) bdk_pemx_p2n_bar2_start_t
#define bustype_BDK_PEMX_P2N_BAR2_START(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_P2N_BAR2_START(a) "PEMX_P2N_BAR2_START"
#define device_bar_BDK_PEMX_P2N_BAR2_START(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_P2N_BAR2_START(a) (a)
#define arguments_BDK_PEMX_P2N_BAR2_START(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_p2n_bar4_start
 *
 * PEM PCIe RC BAR4 Start Register
 * This register specifies the starting address for memory requests that are to be forwarded to
 * NCB/EBUS in RC mode. In EP mode, the standard PCIe config space BAR registers are used, and
 * this register is ignored.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_p2n_bar4_start
{
    uint64_t u;
    struct bdk_pemx_p2n_bar4_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 38; /**< [ 63: 26](R/W) The starting address of BAR4 address space. */
        uint64_t reserved_0_25         : 26;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_25         : 26;
        uint64_t addr                  : 38; /**< [ 63: 26](R/W) The starting address of BAR4 address space. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_p2n_bar4_start_s cn; */
};
typedef union bdk_pemx_p2n_bar4_start bdk_pemx_p2n_bar4_start_t;

static inline uint64_t BDK_PEMX_P2N_BAR4_START(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_P2N_BAR4_START(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000148ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000148ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000148ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000148ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_P2N_BAR4_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_P2N_BAR4_START(a) bdk_pemx_p2n_bar4_start_t
#define bustype_BDK_PEMX_P2N_BAR4_START(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_P2N_BAR4_START(a) "PEMX_P2N_BAR4_START"
#define device_bar_BDK_PEMX_P2N_BAR4_START(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_P2N_BAR4_START(a) (a)
#define arguments_BDK_PEMX_P2N_BAR4_START(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_p2p_bar#_end
 *
 * PEM Peer-to-Peer BAR0 End Register
 * This register specifies the ending address for memory requests that are to be forwarded to the
 * PCIe peer port.
 */
union bdk_pemx_p2p_barx_end
{
    uint64_t u;
    struct bdk_pemx_p2p_barx_end_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 52; /**< [ 63: 12](R/W) The ending address of the address window created by this field and the
                                                                 PEM_P2P_BAR0_START[63:12] field. The full 64 bits of the address are created by:
                                                                 {ADDR[63:12], 12'b0}. */
        uint64_t reserved_0_11         : 12;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_11         : 12;
        uint64_t addr                  : 52; /**< [ 63: 12](R/W) The ending address of the address window created by this field and the
                                                                 PEM_P2P_BAR0_START[63:12] field. The full 64 bits of the address are created by:
                                                                 {ADDR[63:12], 12'b0}. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_p2p_barx_end_s cn; */
};
typedef union bdk_pemx_p2p_barx_end bdk_pemx_p2p_barx_end_t;

static inline uint64_t BDK_PEMX_P2P_BARX_END(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_P2P_BARX_END(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b<=3)))
        return 0x87e0c0000048ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("PEMX_P2P_BARX_END", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_P2P_BARX_END(a,b) bdk_pemx_p2p_barx_end_t
#define bustype_BDK_PEMX_P2P_BARX_END(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_P2P_BARX_END(a,b) "PEMX_P2P_BARX_END"
#define device_bar_BDK_PEMX_P2P_BARX_END(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_P2P_BARX_END(a,b) (a)
#define arguments_BDK_PEMX_P2P_BARX_END(a,b) (a),(b),-1,-1

/**
 * Register (RSL) pem#_p2p_bar#_start
 *
 * PEM Peer-to-Peer BAR0 Start Register
 * This register specifies the starting address for memory requests that are to be forwarded to
 * the PCIe peer port.
 */
union bdk_pemx_p2p_barx_start
{
    uint64_t u;
    struct bdk_pemx_p2p_barx_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t addr                  : 52; /**< [ 63: 12](R/W) The starting address of the address window created by this field and the
                                                                 PEM_P2P_BAR0_END[63:12] field. The full 64-bits of the address are created by:
                                                                 {ADDR[63:12], 12'b0}. */
        uint64_t reserved_2_11         : 10;
        uint64_t dst                   : 2;  /**< [  1:  0](R/W) The destination peer of the address window created by this field and the
                                                                 PEM_P2P_BAR0_END[63:12] field. It is illegal to configure the destination peer to match
                                                                 the source. */
#else /* Word 0 - Little Endian */
        uint64_t dst                   : 2;  /**< [  1:  0](R/W) The destination peer of the address window created by this field and the
                                                                 PEM_P2P_BAR0_END[63:12] field. It is illegal to configure the destination peer to match
                                                                 the source. */
        uint64_t reserved_2_11         : 10;
        uint64_t addr                  : 52; /**< [ 63: 12](R/W) The starting address of the address window created by this field and the
                                                                 PEM_P2P_BAR0_END[63:12] field. The full 64-bits of the address are created by:
                                                                 {ADDR[63:12], 12'b0}. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_p2p_barx_start_s cn; */
};
typedef union bdk_pemx_p2p_barx_start bdk_pemx_p2p_barx_start_t;

static inline uint64_t BDK_PEMX_P2P_BARX_START(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_P2P_BARX_START(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && ((a<=3) && (b<=3)))
        return 0x87e0c0000040ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("PEMX_P2P_BARX_START", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_P2P_BARX_START(a,b) bdk_pemx_p2p_barx_start_t
#define bustype_BDK_PEMX_P2P_BARX_START(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_P2P_BARX_START(a,b) "PEMX_P2P_BARX_START"
#define device_bar_BDK_PEMX_P2P_BARX_START(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_P2P_BARX_START(a,b) (a)
#define arguments_BDK_PEMX_P2P_BARX_START(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_pb_data#
 *
 * Power Budgeting Data Registers
 * The value in one of these registers is reported in the PCIe config register
 * PCIEEP_PB_DATA. The register index picked is based on the value in PCIe config register
 * PCIEEP_PB_DATA_SEL[PB_DATA_SEL]. If PCIEEP_PB_DATA_SEL[PB_DATA_SEL] \> 7 then
 * PCIEEP_PB_DATA will return 0. Note that there is only one set of PEM()_PB_DATA()
 * registers shared across all PFs.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_pb_datax
{
    uint64_t u;
    struct bdk_pemx_pb_datax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t data                  : 21; /**< [ 20:  0](R/W) Bits [20:0] of PCIEEP_PB_DATA. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 21; /**< [ 20:  0](R/W) Bits [20:0] of PCIEEP_PB_DATA. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_pb_datax_s cn; */
};
typedef union bdk_pemx_pb_datax bdk_pemx_pb_datax_t;

static inline uint64_t BDK_PEMX_PB_DATAX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PB_DATAX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=7)))
        return 0x8e0000000240ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=7)))
        return 0x8e0000000240ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=7)))
        return 0x8e0000000240ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=7)))
        return 0x8e0000000240ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("PEMX_PB_DATAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PB_DATAX(a,b) bdk_pemx_pb_datax_t
#define bustype_BDK_PEMX_PB_DATAX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PB_DATAX(a,b) "PEMX_PB_DATAX"
#define device_bar_BDK_PEMX_PB_DATAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PB_DATAX(a,b) (a)
#define arguments_BDK_PEMX_PB_DATAX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_perr_status
 *
 * PEM Parity Error Status Register
 * This register contains indications of parity errors detected inside PEM.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_perr_status
{
    uint64_t u;
    struct bdk_pemx_perr_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t mac_rx_perr           : 1;  /**< [  6:  6](R/W1C/H) Set when the MAC core has detected a parity error in the receive datapath.
                                                                 Corresponds to app_parity_errs[2] output from MAC core. */
        uint64_t mac_txbe_perr         : 1;  /**< [  5:  5](R/W1C/H) Set when the MAC core has detected a parity error in the back end of the transmit
                                                                 datapath.
                                                                 Corresponds to app_parity_errs[1] output from MAC core. */
        uint64_t mac_txfe_perr         : 1;  /**< [  4:  4](R/W1C/H) Set when the MAC core has detected a parity error in the front end of the transmit
                                                                 datapath.
                                                                 Corresponds to app_parity_errs[0] output from MAC core. */
        uint64_t rasdp                 : 1;  /**< [  3:  3](R/W1C/H) Set when the MAC core has entered RASDP mode due to an uncorrectable error. */
        uint64_t dbe                   : 1;  /**< [  2:  2](R/W1C/H) Set when an uncorrectable (double-bit) error was detected in a RAM inside PEM. */
        uint64_t rx_perr               : 1;  /**< [  1:  1](R/W1C/H) Set when a parity error was detected in the receive datapath. */
        uint64_t tx_perr               : 1;  /**< [  0:  0](R/W1C/H) Set when a parity error was detected in the transmit datapath (only applies to traffic
                                                                 originating on EBO). */
#else /* Word 0 - Little Endian */
        uint64_t tx_perr               : 1;  /**< [  0:  0](R/W1C/H) Set when a parity error was detected in the transmit datapath (only applies to traffic
                                                                 originating on EBO). */
        uint64_t rx_perr               : 1;  /**< [  1:  1](R/W1C/H) Set when a parity error was detected in the receive datapath. */
        uint64_t dbe                   : 1;  /**< [  2:  2](R/W1C/H) Set when an uncorrectable (double-bit) error was detected in a RAM inside PEM. */
        uint64_t rasdp                 : 1;  /**< [  3:  3](R/W1C/H) Set when the MAC core has entered RASDP mode due to an uncorrectable error. */
        uint64_t mac_txfe_perr         : 1;  /**< [  4:  4](R/W1C/H) Set when the MAC core has detected a parity error in the front end of the transmit
                                                                 datapath.
                                                                 Corresponds to app_parity_errs[0] output from MAC core. */
        uint64_t mac_txbe_perr         : 1;  /**< [  5:  5](R/W1C/H) Set when the MAC core has detected a parity error in the back end of the transmit
                                                                 datapath.
                                                                 Corresponds to app_parity_errs[1] output from MAC core. */
        uint64_t mac_rx_perr           : 1;  /**< [  6:  6](R/W1C/H) Set when the MAC core has detected a parity error in the receive datapath.
                                                                 Corresponds to app_parity_errs[2] output from MAC core. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_perr_status_s cn; */
};
typedef union bdk_pemx_perr_status bdk_pemx_perr_status_t;

static inline uint64_t BDK_PEMX_PERR_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PERR_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001d8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001d8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001d8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001d8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_PERR_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PERR_STATUS(a) bdk_pemx_perr_status_t
#define bustype_BDK_PEMX_PERR_STATUS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PERR_STATUS(a) "PEMX_PERR_STATUS"
#define device_bar_BDK_PEMX_PERR_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PERR_STATUS(a) (a)
#define arguments_BDK_PEMX_PERR_STATUS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_pf#_clr_flr_req
 *
 * PEM PF Clear FLR Request Register
 * This register provides clear request for PCIe PF function level reset (FLR).
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_pfx_clr_flr_req
{
    uint64_t u;
    struct bdk_pemx_pfx_clr_flr_req_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t clr                   : 1;  /**< [  0:  0](R/W1C/H) When written with a 1, will cause hardware to clear the FLR condition.
                                                                 This bit always reads as a zero. */
#else /* Word 0 - Little Endian */
        uint64_t clr                   : 1;  /**< [  0:  0](R/W1C/H) When written with a 1, will cause hardware to clear the FLR condition.
                                                                 This bit always reads as a zero. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_pfx_clr_flr_req_s cn; */
};
typedef union bdk_pemx_pfx_clr_flr_req bdk_pemx_pfx_clr_flr_req_t;

static inline uint64_t BDK_PEMX_PFX_CLR_FLR_REQ(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PFX_CLR_FLR_REQ(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=15)))
        return 0x8e0000000a00ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=15)))
        return 0x8e0000000a00ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=15)))
        return 0x8e0000000a00ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=15)))
        return 0x8e0000000a00ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_PFX_CLR_FLR_REQ", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PFX_CLR_FLR_REQ(a,b) bdk_pemx_pfx_clr_flr_req_t
#define bustype_BDK_PEMX_PFX_CLR_FLR_REQ(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PFX_CLR_FLR_REQ(a,b) "PEMX_PFX_CLR_FLR_REQ"
#define device_bar_BDK_PEMX_PFX_CLR_FLR_REQ(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PFX_CLR_FLR_REQ(a,b) (a)
#define arguments_BDK_PEMX_PFX_CLR_FLR_REQ(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_pf#_cs#_pfcfg#
 *
 * PEM PCIe Direct Config PF Registers
 * This register is used to modify PF configuration space. It can only be accessed
 * using 32-bit instructions (either [DATA_LO] or [DATA_HI] but not both
 * simultaneously.)
 *
 * Index {d} is the register number, which is the configuration offset divided by 0x4;
 * e.g. index 1 is for PCIERC_CMD or PCIEEP_CMD.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_pfx_csx_pfcfgx
{
    uint64_t u;
    struct bdk_pemx_pfx_csx_pfcfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_hi               : 32; /**< [ 63: 32](R/W/H) Data bits to write to high config register, or bits read from selected config register. */
        uint64_t data_lo               : 32; /**< [ 31:  0](R/W/H) Data bits to write to low config register, or bits read from selected config register. */
#else /* Word 0 - Little Endian */
        uint64_t data_lo               : 32; /**< [ 31:  0](R/W/H) Data bits to write to low config register, or bits read from selected config register. */
        uint64_t data_hi               : 32; /**< [ 63: 32](R/W/H) Data bits to write to high config register, or bits read from selected config register. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_pfx_csx_pfcfgx_s cn; */
};
typedef union bdk_pemx_pfx_csx_pfcfgx bdk_pemx_pfx_csx_pfcfgx_t;

static inline uint64_t BDK_PEMX_PFX_CSX_PFCFGX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PFX_CSX_PFCFGX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=15) && (c<=1) && (d<=511)))
        return 0x8e0000008000ll + 0x1000000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0xf) + 0x10000ll * ((c) & 0x1) + 8ll * ((d) & 0x1ff);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=15) && (c<=1) && (d<=511)))
        return 0x8e0000008000ll + 0x1000000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0xf) + 0x10000ll * ((c) & 0x1) + 8ll * ((d) & 0x1ff);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=15) && (c<=1) && (d<=511)))
        return 0x8e0000008000ll + 0x1000000000ll * ((a) & 0x0) + 0x40000ll * ((b) & 0xf) + 0x10000ll * ((c) & 0x1) + 8ll * ((d) & 0x1ff);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=15) && (c<=1) && (d<=511)))
        return 0x8e0000008000ll + 0x1000000000ll * ((a) & 0x0) + 0x40000ll * ((b) & 0xf) + 0x10000ll * ((c) & 0x1) + 8ll * ((d) & 0x1ff);
    __bdk_csr_fatal("PEMX_PFX_CSX_PFCFGX", 4, a, b, c, d, 0, 0);
}

#define typedef_BDK_PEMX_PFX_CSX_PFCFGX(a,b,c,d) bdk_pemx_pfx_csx_pfcfgx_t
#define bustype_BDK_PEMX_PFX_CSX_PFCFGX(a,b,c,d) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PFX_CSX_PFCFGX(a,b,c,d) "PEMX_PFX_CSX_PFCFGX"
#define device_bar_BDK_PEMX_PFX_CSX_PFCFGX(a,b,c,d) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PFX_CSX_PFCFGX(a,b,c,d) (a)
#define arguments_BDK_PEMX_PFX_CSX_PFCFGX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB) pem#_pf#_ctl_status
 *
 * PEM PF Control Status Register
 * This is a general PF control and status register of the PEM.
 * There is a register for each PF.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_pfx_ctl_status
{
    uint64_t u;
    struct bdk_pemx_pfx_ctl_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t ob_p_cmd              : 1;  /**< [  4:  4](WO) Wake up.  Writing to a one to set this bit creates a pulse
                                                                 in the application to wake up the PMC state machine
                                                                 from a D1, D2 or D3 power state. This bit will always
                                                                 read a zero.
                                                                 Upon wake-up, the controller sends a PM_PME message. EP mode.

                                                                 Internal:
                                                                 Controls outband_pwrup_cmd input to the DW core. */
        uint64_t pf_flr_en             : 1;  /**< [  3:  3](R/W) When a PF-FLR occurs, an indication will be sent to the central reset controller.
                                                                 The reset controller can decide whether to reset the chip core based on this indication.
                                                                 These bits control which PFs can notify of the reset controller.  If the corresponding
                                                                 bit is set, the PF-FLR will be forwarded to the reset controller.

                                                                 Internal:
                                                                 Indication is on pem__rst_intf.pf_flr */
        uint64_t pm_dst                : 3;  /**< [  2:  0](RO/H) Current power management DSTATE.  There are 3 bits of
                                                                 D-state for each function.
                                                                 0x0 = D0.
                                                                 0x1 = D1.
                                                                 0x2 = D2.
                                                                 0x3 = D3.
                                                                 0x4 = Uninitialized.
                                                                 0x5 - 0x7 = Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t pm_dst                : 3;  /**< [  2:  0](RO/H) Current power management DSTATE.  There are 3 bits of
                                                                 D-state for each function.
                                                                 0x0 = D0.
                                                                 0x1 = D1.
                                                                 0x2 = D2.
                                                                 0x3 = D3.
                                                                 0x4 = Uninitialized.
                                                                 0x5 - 0x7 = Reserved. */
        uint64_t pf_flr_en             : 1;  /**< [  3:  3](R/W) When a PF-FLR occurs, an indication will be sent to the central reset controller.
                                                                 The reset controller can decide whether to reset the chip core based on this indication.
                                                                 These bits control which PFs can notify of the reset controller.  If the corresponding
                                                                 bit is set, the PF-FLR will be forwarded to the reset controller.

                                                                 Internal:
                                                                 Indication is on pem__rst_intf.pf_flr */
        uint64_t ob_p_cmd              : 1;  /**< [  4:  4](WO) Wake up.  Writing to a one to set this bit creates a pulse
                                                                 in the application to wake up the PMC state machine
                                                                 from a D1, D2 or D3 power state. This bit will always
                                                                 read a zero.
                                                                 Upon wake-up, the controller sends a PM_PME message. EP mode.

                                                                 Internal:
                                                                 Controls outband_pwrup_cmd input to the DW core. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_pfx_ctl_status_s cn; */
};
typedef union bdk_pemx_pfx_ctl_status bdk_pemx_pfx_ctl_status_t;

static inline uint64_t BDK_PEMX_PFX_CTL_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PFX_CTL_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=15)))
        return 0x8e0000000800ll + 0x1000000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=15)))
        return 0x8e0000000800ll + 0x1000000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=15)))
        return 0x8e0000000800ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=15)))
        return 0x8e0000000800ll + 0x1000000000ll * ((a) & 0x0) + 8ll * ((b) & 0xf);
    __bdk_csr_fatal("PEMX_PFX_CTL_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PFX_CTL_STATUS(a,b) bdk_pemx_pfx_ctl_status_t
#define bustype_BDK_PEMX_PFX_CTL_STATUS(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PFX_CTL_STATUS(a,b) "PEMX_PFX_CTL_STATUS"
#define device_bar_BDK_PEMX_PFX_CTL_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PFX_CTL_STATUS(a,b) (a)
#define arguments_BDK_PEMX_PFX_CTL_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_pf#_vf#_vfcfg#
 *
 * PEM PCIe Direct Config VF Registers
 * This register is used to modify VF configuration space. It can only be accessed
 * using 32-bit instructions (either [DATA_LO] or [DATA_HI] but not both
 * simultaneously.)
 *
 * Index {d} is the register number, which is the configuration offset divided by 0x4;
 * e.g. index 1 is for PCIEEPVF_CMD.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_pfx_vfx_vfcfgx
{
    uint64_t u;
    struct bdk_pemx_pfx_vfx_vfcfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_hi               : 32; /**< [ 63: 32](R/W/H) Data bits to write to high config register, or bits read from selected config register. */
        uint64_t data_lo               : 32; /**< [ 31:  0](R/W/H) Data bits to write to low config register, or bits read from selected config register. */
#else /* Word 0 - Little Endian */
        uint64_t data_lo               : 32; /**< [ 31:  0](R/W/H) Data bits to write to low config register, or bits read from selected config register. */
        uint64_t data_hi               : 32; /**< [ 63: 32](R/W/H) Data bits to write to high config register, or bits read from selected config register. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_pfx_vfx_vfcfgx_s cn; */
};
typedef union bdk_pemx_pfx_vfx_vfcfgx bdk_pemx_pfx_vfx_vfcfgx_t;

static inline uint64_t BDK_PEMX_PFX_VFX_VFCFGX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PFX_VFX_VFCFGX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=15) && (c<=239) && (d<=511)))
        return 0x8e0000028000ll + 0x1000000000ll * ((a) & 0x3) + 0x40000ll * ((b) & 0xf) + 0x400000ll * ((c) & 0xff) + 8ll * ((d) & 0x1ff);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=15) && (c<=239) && (d<=511)))
        return 0x8e0000028000ll + 0x1000000000ll * ((a) & 0x7) + 0x40000ll * ((b) & 0xf) + 0x400000ll * ((c) & 0xff) + 8ll * ((d) & 0x1ff);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=15) && (c<=239) && (d<=511)))
        return 0x8e0000028000ll + 0x1000000000ll * ((a) & 0x0) + 0x40000ll * ((b) & 0xf) + 0x400000ll * ((c) & 0xff) + 8ll * ((d) & 0x1ff);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=15) && (c<=239) && (d<=511)))
        return 0x8e0000028000ll + 0x1000000000ll * ((a) & 0x0) + 0x40000ll * ((b) & 0xf) + 0x400000ll * ((c) & 0xff) + 8ll * ((d) & 0x1ff);
    __bdk_csr_fatal("PEMX_PFX_VFX_VFCFGX", 4, a, b, c, d, 0, 0);
}

#define typedef_BDK_PEMX_PFX_VFX_VFCFGX(a,b,c,d) bdk_pemx_pfx_vfx_vfcfgx_t
#define bustype_BDK_PEMX_PFX_VFX_VFCFGX(a,b,c,d) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PFX_VFX_VFCFGX(a,b,c,d) "PEMX_PFX_VFX_VFCFGX"
#define device_bar_BDK_PEMX_PFX_VFX_VFCFGX(a,b,c,d) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PFX_VFX_VFCFGX(a,b,c,d) (a)
#define arguments_BDK_PEMX_PFX_VFX_VFCFGX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB) pem#_pspi_tlp_credits
 *
 * PEM NCB Inbound TLP Credits Register
 * This register specifies the number of credits for use in moving TLPs. When this register is
 * written, the credit values are reset to the register value. This register is for diagnostic
 * use only, and should only be written when PEM()_CTL_STATUS[LNK_ENB] is clear.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_pspi_tlp_credits
{
    uint64_t u;
    struct bdk_pemx_pspi_tlp_credits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t pspi_np               : 10; /**< [ 20: 11](R/W) TLP headers for non-posted TLPs in the PEMs inbound PSPI buffers.
                                                                 Legal values are 0x01 to 0x20. */
        uint64_t reserved_0_10         : 11;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_10         : 11;
        uint64_t pspi_np               : 10; /**< [ 20: 11](R/W) TLP headers for non-posted TLPs in the PEMs inbound PSPI buffers.
                                                                 Legal values are 0x01 to 0x20. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_pspi_tlp_credits_s cn; */
};
typedef union bdk_pemx_pspi_tlp_credits bdk_pemx_pspi_tlp_credits_t;

static inline uint64_t BDK_PEMX_PSPI_TLP_CREDITS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PSPI_TLP_CREDITS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000038ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000038ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000038ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000038ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_PSPI_TLP_CREDITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PSPI_TLP_CREDITS(a) bdk_pemx_pspi_tlp_credits_t
#define bustype_BDK_PEMX_PSPI_TLP_CREDITS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PSPI_TLP_CREDITS(a) "PEMX_PSPI_TLP_CREDITS"
#define device_bar_BDK_PEMX_PSPI_TLP_CREDITS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PSPI_TLP_CREDITS(a) (a)
#define arguments_BDK_PEMX_PSPI_TLP_CREDITS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ptm_ctl
 *
 * PEM Miscellaneous Control Register
 * This register contains precision timer control bits.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_ptm_ctl
{
    uint64_t u;
    struct bdk_pemx_ptm_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t ptm_lcl_cap           : 1;  /**< [ 10: 10](WO) When set, causes a hardware pulse to update the follopwing:

                                                                 The local time (PCIEEP_PTM_REQ_LOCALL & PCIEEP_PTM_REQ_LOCALM) is
                                                                 captured in PEM()_PTM_LCL_TIME.

                                                                 The master time master time (as selected by [PTM_MSTR_SEL]) is captured
                                                                 in PEM()_PTM_MAS_TIME.

                                                                 This bit will always read as a zero. */
        uint64_t ptm_auto_load         : 1;  /**< [  9:  9](R/W) Precision time management auto load to (PCIERC/PCIEEP_PTM_REQ_LOCALL and
                                                                 PCIERC/PCIEEP_PTM_REQ_LOCALM) will be loaded.
                                                                 0 = Software.
                                                                 1 = Hardware auto-load when in L0. */
        uint64_t ptm_mstr_sel          : 1;  /**< [  8:  8](R/W) Determines for precision time management protocol which master clock input to use.
                                                                 0 = Master clock from PTP timestamp.
                                                                 1 = Master clock from GTI_CC_CNTCV. */
        uint64_t ptm_mstr_adj          : 8;  /**< [  7:  0](R/W) This value (in ns) is added to the selected ([PTM_MSTR_SEL]) master time input
                                                                 to account for insertion (including clock domain crossing) delays, before
                                                                 being presented to the MAC.

                                                                 To calculate an accurate delay:

                                                                   [PTM_MSTR_ADJ] = 2 sclk cycles + channel_flop_delay + 3.5 core_clk cycles.

                                                                   channel_flop_delay (PEM2 and PEM3 when [PTM_MSTR_SEL] is 0) = 6 sclk cycles
                                                                   channel_flop_delay (All other cases) = 5 sclk cycles

                                                                 The default value assumes the MAC is operating at GEN1, and there are 2 channel
                                                                 flops on the master time inputs. */
#else /* Word 0 - Little Endian */
        uint64_t ptm_mstr_adj          : 8;  /**< [  7:  0](R/W) This value (in ns) is added to the selected ([PTM_MSTR_SEL]) master time input
                                                                 to account for insertion (including clock domain crossing) delays, before
                                                                 being presented to the MAC.

                                                                 To calculate an accurate delay:

                                                                   [PTM_MSTR_ADJ] = 2 sclk cycles + channel_flop_delay + 3.5 core_clk cycles.

                                                                   channel_flop_delay (PEM2 and PEM3 when [PTM_MSTR_SEL] is 0) = 6 sclk cycles
                                                                   channel_flop_delay (All other cases) = 5 sclk cycles

                                                                 The default value assumes the MAC is operating at GEN1, and there are 2 channel
                                                                 flops on the master time inputs. */
        uint64_t ptm_mstr_sel          : 1;  /**< [  8:  8](R/W) Determines for precision time management protocol which master clock input to use.
                                                                 0 = Master clock from PTP timestamp.
                                                                 1 = Master clock from GTI_CC_CNTCV. */
        uint64_t ptm_auto_load         : 1;  /**< [  9:  9](R/W) Precision time management auto load to (PCIERC/PCIEEP_PTM_REQ_LOCALL and
                                                                 PCIERC/PCIEEP_PTM_REQ_LOCALM) will be loaded.
                                                                 0 = Software.
                                                                 1 = Hardware auto-load when in L0. */
        uint64_t ptm_lcl_cap           : 1;  /**< [ 10: 10](WO) When set, causes a hardware pulse to update the follopwing:

                                                                 The local time (PCIEEP_PTM_REQ_LOCALL & PCIEEP_PTM_REQ_LOCALM) is
                                                                 captured in PEM()_PTM_LCL_TIME.

                                                                 The master time master time (as selected by [PTM_MSTR_SEL]) is captured
                                                                 in PEM()_PTM_MAS_TIME.

                                                                 This bit will always read as a zero. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ptm_ctl_s cn; */
};
typedef union bdk_pemx_ptm_ctl bdk_pemx_ptm_ctl_t;

static inline uint64_t BDK_PEMX_PTM_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PTM_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000098ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000098ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000098ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000098ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_PTM_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PTM_CTL(a) bdk_pemx_ptm_ctl_t
#define bustype_BDK_PEMX_PTM_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PTM_CTL(a) "PEMX_PTM_CTL"
#define device_bar_BDK_PEMX_PTM_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PTM_CTL(a) (a)
#define arguments_BDK_PEMX_PTM_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ptm_lcl_time
 *
 * PEM PTM Time Register
 * This register contains the PTM synchronized local time value.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_ptm_lcl_time
{
    uint64_t u;
    struct bdk_pemx_ptm_lcl_time_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t val                   : 64; /**< [ 63:  0](RO/H) When an external hardware trigger occurs, or CSR bit PEM()_PTM_CTL[PTM_LCL_CAP] is written,
                                                                 the local time as tracked by the precision time management protocol
                                                                 PCIEEP_PTM_REQ_LOCALL & PCIEEP_PTM_REQ_LOCALM) is captured to this register. */
#else /* Word 0 - Little Endian */
        uint64_t val                   : 64; /**< [ 63:  0](RO/H) When an external hardware trigger occurs, or CSR bit PEM()_PTM_CTL[PTM_LCL_CAP] is written,
                                                                 the local time as tracked by the precision time management protocol
                                                                 PCIEEP_PTM_REQ_LOCALL & PCIEEP_PTM_REQ_LOCALM) is captured to this register. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ptm_lcl_time_s cn; */
};
typedef union bdk_pemx_ptm_lcl_time bdk_pemx_ptm_lcl_time_t;

static inline uint64_t BDK_PEMX_PTM_LCL_TIME(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PTM_LCL_TIME(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000a0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000a0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000a0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000a0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_PTM_LCL_TIME", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PTM_LCL_TIME(a) bdk_pemx_ptm_lcl_time_t
#define bustype_BDK_PEMX_PTM_LCL_TIME(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PTM_LCL_TIME(a) "PEMX_PTM_LCL_TIME"
#define device_bar_BDK_PEMX_PTM_LCL_TIME(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PTM_LCL_TIME(a) (a)
#define arguments_BDK_PEMX_PTM_LCL_TIME(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ptm_mas_time
 *
 * PEM PTM Time Register
 * This register contains the PTM synchronized local time value.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_ptm_mas_time
{
    uint64_t u;
    struct bdk_pemx_ptm_mas_time_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t val                   : 64; /**< [ 63:  0](RO/H) When an external hardware trigger occurs, or CSR bit PEM()_PTM_CTL[PTM_LCL_CAP] is written,
                                                                 the master time as selected by PEM()_PTM_CTL[PTM_MSTR_SEL] is captured to this
                                                                 register. */
#else /* Word 0 - Little Endian */
        uint64_t val                   : 64; /**< [ 63:  0](RO/H) When an external hardware trigger occurs, or CSR bit PEM()_PTM_CTL[PTM_LCL_CAP] is written,
                                                                 the master time as selected by PEM()_PTM_CTL[PTM_MSTR_SEL] is captured to this
                                                                 register. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ptm_mas_time_s cn; */
};
typedef union bdk_pemx_ptm_mas_time bdk_pemx_ptm_mas_time_t;

static inline uint64_t BDK_PEMX_PTM_MAS_TIME(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_PTM_MAS_TIME(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000a8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000a8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000a8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000a8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_PTM_MAS_TIME", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_PTM_MAS_TIME(a) bdk_pemx_ptm_mas_time_t
#define bustype_BDK_PEMX_PTM_MAS_TIME(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_PTM_MAS_TIME(a) "PEMX_PTM_MAS_TIME"
#define device_bar_BDK_PEMX_PTM_MAS_TIME(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_PTM_MAS_TIME(a) (a)
#define arguments_BDK_PEMX_PTM_MAS_TIME(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_qlm
 *
 * PEM QLM Configuration Register
 * This register configures the PEM QLM.
 */
union bdk_pemx_qlm
{
    uint64_t u;
    struct bdk_pemx_qlm_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pem_bdlm              : 1;  /**< [  0:  0](R/W/H) This bit can only be set for PEM2/PEM3, for all other PEMs it has no
                                                                 function.
                                                                 PEM2: when set, will be configured to send/receive traffic to DLM4.
                                                                       when clear, will be configured to send/receive traffic to QLM2/QLM3.
                                                                 PEM3: when set, will be configured to send/receive traffic to DLM5/DLM6.
                                                                       when clear, will be configured to send/receive traffic to QLM3.
                                                                 Note that this bit must only be set when both the associated PHYs and PEM2/PEM3 are in
                                                                 reset.
                                                                 These conditions can be assured by setting the PEM(2/3)_ON[PEMON] bit after setting this
                                                                 bit. */
#else /* Word 0 - Little Endian */
        uint64_t pem_bdlm              : 1;  /**< [  0:  0](R/W/H) This bit can only be set for PEM2/PEM3, for all other PEMs it has no
                                                                 function.
                                                                 PEM2: when set, will be configured to send/receive traffic to DLM4.
                                                                       when clear, will be configured to send/receive traffic to QLM2/QLM3.
                                                                 PEM3: when set, will be configured to send/receive traffic to DLM5/DLM6.
                                                                       when clear, will be configured to send/receive traffic to QLM3.
                                                                 Note that this bit must only be set when both the associated PHYs and PEM2/PEM3 are in
                                                                 reset.
                                                                 These conditions can be assured by setting the PEM(2/3)_ON[PEMON] bit after setting this
                                                                 bit. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_qlm_s cn; */
};
typedef union bdk_pemx_qlm bdk_pemx_qlm_t;

static inline uint64_t BDK_PEMX_QLM(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_QLM(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000418ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_QLM", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_QLM(a) bdk_pemx_qlm_t
#define bustype_BDK_PEMX_QLM(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_QLM(a) "PEMX_QLM"
#define device_bar_BDK_PEMX_QLM(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_QLM(a) (a)
#define arguments_BDK_PEMX_QLM(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_ras_tba_ctl
 *
 * PEM RAS Time Based Analysis Control Register
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_ras_tba_ctl
{
    uint64_t u;
    struct bdk_pemx_ras_tba_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t tba_ctrl              : 2;  /**< [  1:  0](WO) Controls the start/end of time based analysis (TBA) in the core.  Note that TBA can also
                                                                 be controlled
                                                                 by setting the contents of PCIEEP()_CFG114/RC()_CFG114, and that TBA_CTRL will also
                                                                 affect the contents of PCIEEP()_CFG114/RC()_CFG114[TIMER_START].
                                                                 0x0 = No action.
                                                                 0x1 = Start time based analysis.
                                                                 0x2 = End time based analysis.
                                                                       Only used if PCIEEP()_CFG114/RC()_CFG114[TBASE_DUR_SEL] is set to manual control,
                                                                       otherwise it is ignored.
                                                                 0x3 = Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t tba_ctrl              : 2;  /**< [  1:  0](WO) Controls the start/end of time based analysis (TBA) in the core.  Note that TBA can also
                                                                 be controlled
                                                                 by setting the contents of PCIEEP()_CFG114/RC()_CFG114, and that TBA_CTRL will also
                                                                 affect the contents of PCIEEP()_CFG114/RC()_CFG114[TIMER_START].
                                                                 0x0 = No action.
                                                                 0x1 = Start time based analysis.
                                                                 0x2 = End time based analysis.
                                                                       Only used if PCIEEP()_CFG114/RC()_CFG114[TBASE_DUR_SEL] is set to manual control,
                                                                       otherwise it is ignored.
                                                                 0x3 = Reserved. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_ras_tba_ctl_s cn8; */
    struct bdk_pemx_ras_tba_ctl_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t tba_ctrl              : 2;  /**< [  1:  0](WO) Controls the start/end of time based analysis (TBA) in the core.  Note that TBA can also
                                                                 be controlled
                                                                 by setting the contents of PCIERC_RAS_TBA_CTL, and that will also
                                                                 affect the contents of PCIERC_RAS_TBA_CTL[TIMER_START].
                                                                 0x0 = No action.
                                                                 0x1 = Start time based analysis.
                                                                 0x2 = End time based analysis.
                                                                       Only used if PCIERC_RAS_TBA_CTL[TBASE_DUR_SEL] is set to manual control,
                                                                       otherwise it is ignored.
                                                                 0x3 = Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t tba_ctrl              : 2;  /**< [  1:  0](WO) Controls the start/end of time based analysis (TBA) in the core.  Note that TBA can also
                                                                 be controlled
                                                                 by setting the contents of PCIERC_RAS_TBA_CTL, and that will also
                                                                 affect the contents of PCIERC_RAS_TBA_CTL[TIMER_START].
                                                                 0x0 = No action.
                                                                 0x1 = Start time based analysis.
                                                                 0x2 = End time based analysis.
                                                                       Only used if PCIERC_RAS_TBA_CTL[TBASE_DUR_SEL] is set to manual control,
                                                                       otherwise it is ignored.
                                                                 0x3 = Reserved. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_ras_tba_ctl bdk_pemx_ras_tba_ctl_t;

static inline uint64_t BDK_PEMX_RAS_TBA_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RAS_TBA_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000240ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000068ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000068ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000068ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000068ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RAS_TBA_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RAS_TBA_CTL(a) bdk_pemx_ras_tba_ctl_t
#define bustype_BDK_PEMX_RAS_TBA_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RAS_TBA_CTL(a) "PEMX_RAS_TBA_CTL"
#define device_bar_BDK_PEMX_RAS_TBA_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RAS_TBA_CTL(a) (a)
#define arguments_BDK_PEMX_RAS_TBA_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_reads_pc
 *
 * PEM Read Count Register
 * This register contains read count for debugging purposes.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_reads_pc
{
    uint64_t u;
    struct bdk_pemx_reads_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reads                 : 64; /**< [ 63:  0](RO/H) Total number of SLI reads from remote memory aggregated across all
                                                                 non-masked SWI tags.  Software can calculate the average read latency
                                                                 to first data per SLI read request by dividing PEM()_LATENCY_PC[LATENCY]
                                                                 by PEM()_READS_PC[READS]. */
#else /* Word 0 - Little Endian */
        uint64_t reads                 : 64; /**< [ 63:  0](RO/H) Total number of SLI reads from remote memory aggregated across all
                                                                 non-masked SWI tags.  Software can calculate the average read latency
                                                                 to first data per SLI read request by dividing PEM()_LATENCY_PC[LATENCY]
                                                                 by PEM()_READS_PC[READS]. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_reads_pc_s cn8; */
    struct bdk_pemx_reads_pc_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reads                 : 64; /**< [ 63:  0](R/W/H) Total number of NCBO or EBO reads from remote memory since latency tracking logic was
                                                                 enabled.  PEM()_LATENCY_PC_CTL[EBO_SEL] controls which outbound bus has its reads
                                                                 latency tracked.  This register can only be written by software when
                                                                 PEM()_LATENCY_PC_CTL[ACTIVE] is clear.  Software can calculate the average read
                                                                 latency through PEM and external PCIe interface with the following calculation:
                                                                   * Average Latency = PEM()_LATENCY_PC[LATENCY] / PEM()_READS_PC[READS] * 10 ns
                                                                 This calculation can be done at any time while PEM()_LATENCY_PC_CTL[ACTIVE] is set,
                                                                 but will only be fully accurate by following the control flow outlined in the
                                                                 PEM()_LATENCY_PC_CTL[ACTIVE] description. */
#else /* Word 0 - Little Endian */
        uint64_t reads                 : 64; /**< [ 63:  0](R/W/H) Total number of NCBO or EBO reads from remote memory since latency tracking logic was
                                                                 enabled.  PEM()_LATENCY_PC_CTL[EBO_SEL] controls which outbound bus has its reads
                                                                 latency tracked.  This register can only be written by software when
                                                                 PEM()_LATENCY_PC_CTL[ACTIVE] is clear.  Software can calculate the average read
                                                                 latency through PEM and external PCIe interface with the following calculation:
                                                                   * Average Latency = PEM()_LATENCY_PC[LATENCY] / PEM()_READS_PC[READS] * 10 ns
                                                                 This calculation can be done at any time while PEM()_LATENCY_PC_CTL[ACTIVE] is set,
                                                                 but will only be fully accurate by following the control flow outlined in the
                                                                 PEM()_LATENCY_PC_CTL[ACTIVE] description. */
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_reads_pc bdk_pemx_reads_pc_t;

static inline uint64_t BDK_PEMX_READS_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_READS_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000498ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000120ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000120ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000120ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000120ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_READS_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_READS_PC(a) bdk_pemx_reads_pc_t
#define bustype_BDK_PEMX_READS_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_READS_PC(a) "PEMX_READS_PC"
#define device_bar_BDK_PEMX_READS_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_READS_PC(a) (a)
#define arguments_BDK_PEMX_READS_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_reg_ctl
 *
 * PEM CSR Control Register
 * This register contains control for register accesses.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_reg_ctl
{
    uint64_t u;
    struct bdk_pemx_reg_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t gia_timeout           : 6;  /**< [  5:  0](R/W) GIA timeout (2^[GIA_TIMEOUT] clock cycles). Timeout for MSI-X commits. When zero, wait
                                                                 for commits is disabled. */
#else /* Word 0 - Little Endian */
        uint64_t gia_timeout           : 6;  /**< [  5:  0](R/W) GIA timeout (2^[GIA_TIMEOUT] clock cycles). Timeout for MSI-X commits. When zero, wait
                                                                 for commits is disabled. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_reg_ctl_s cn; */
};
typedef union bdk_pemx_reg_ctl bdk_pemx_reg_ctl_t;

static inline uint64_t BDK_PEMX_REG_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_REG_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000060ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000060ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000060ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000060ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_REG_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_REG_CTL(a) bdk_pemx_reg_ctl_t
#define bustype_BDK_PEMX_REG_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_REG_CTL(a) "PEMX_REG_CTL"
#define device_bar_BDK_PEMX_REG_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_REG_CTL(a) (a)
#define arguments_BDK_PEMX_REG_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_reg_huge#_acc
 *
 * PEM Huge Region Access Registers
 * These registers contains address index and control bits for access to memory from cores.
 * Indexed using NCBO address\<45:38\>.
 *
 * For discovery of the size of this register and fields, see PEM()_CONST_ACC.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 */
union bdk_pemx_reg_hugex_acc
{
    uint64_t u;
    struct bdk_pemx_reg_hugex_acc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t vf                    : 8;  /**< [ 61: 54](R/W) Virtual function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t vf_active             : 1;  /**< [ 53: 53](R/W) Access is to virtual function if set.  Access is to physical function if
                                                                 clear. */
        uint64_t reserved_50_52        : 3;
        uint64_t pf                    : 4;  /**< [ 49: 46](R/W) Physical function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t ctype                 : 2;  /**< [ 45: 44](R/W) The command type to be generated:
                                                                 0x0 = PCI memory.
                                                                 0x1 = PCI configuration. Only operations that access bytes within a single aligned dword
                                                                 are supported.  Note normally the ECAM would be used in place of this CTYPE.
                                                                 0x2 = PCI I/O.  Only operations that access bytes within a single aligned dword are supported.
                                                                 0x3 = Reserved. */
        uint64_t zero                  : 1;  /**< [ 43: 43](R/W) Causes load operations that are eight bytes or less and stay within a single aligned quadword
                                                                 to become zero-length read operations which will return zeros to the EXEC for all read
                                                                 data.
                                                                 Load operations that do not meet the size/alignment requirements above and have [ZERO] set
                                                                 will have unpredictable behavior.

                                                                 Internal:
                                                                 When hardware encounters an improperly formed load operation with [ZERO] set, it
                                                                 will drop the load internally and form up a properly sized completion with fault
                                                                 over NCBI to attempt to indicate an error condition. */
        uint64_t wnmerge               : 1;  /**< [ 42: 42](R/W) When set, no write merging is allowed in this window. */
        uint64_t rnmerge               : 1;  /**< [ 41: 41](R/W) When set, no read merging is allowed in this window. */
        uint64_t wtype                 : 3;  /**< [ 40: 38](R/W) Write type. ADDRTYPE\<2:0\> for write operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t rtype                 : 3;  /**< [ 37: 35](R/W) Read type. ADDRTYPE\<2:0\> for read operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t reserved_26_34        : 9;
        uint64_t ba                    : 26; /**< [ 25:  0](R/W) Bus address. Address bits\<63:38\> for read/write operations that use this region. */
#else /* Word 0 - Little Endian */
        uint64_t ba                    : 26; /**< [ 25:  0](R/W) Bus address. Address bits\<63:38\> for read/write operations that use this region. */
        uint64_t reserved_26_34        : 9;
        uint64_t rtype                 : 3;  /**< [ 37: 35](R/W) Read type. ADDRTYPE\<2:0\> for read operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t wtype                 : 3;  /**< [ 40: 38](R/W) Write type. ADDRTYPE\<2:0\> for write operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t rnmerge               : 1;  /**< [ 41: 41](R/W) When set, no read merging is allowed in this window. */
        uint64_t wnmerge               : 1;  /**< [ 42: 42](R/W) When set, no write merging is allowed in this window. */
        uint64_t zero                  : 1;  /**< [ 43: 43](R/W) Causes load operations that are eight bytes or less and stay within a single aligned quadword
                                                                 to become zero-length read operations which will return zeros to the EXEC for all read
                                                                 data.
                                                                 Load operations that do not meet the size/alignment requirements above and have [ZERO] set
                                                                 will have unpredictable behavior.

                                                                 Internal:
                                                                 When hardware encounters an improperly formed load operation with [ZERO] set, it
                                                                 will drop the load internally and form up a properly sized completion with fault
                                                                 over NCBI to attempt to indicate an error condition. */
        uint64_t ctype                 : 2;  /**< [ 45: 44](R/W) The command type to be generated:
                                                                 0x0 = PCI memory.
                                                                 0x1 = PCI configuration. Only operations that access bytes within a single aligned dword
                                                                 are supported.  Note normally the ECAM would be used in place of this CTYPE.
                                                                 0x2 = PCI I/O.  Only operations that access bytes within a single aligned dword are supported.
                                                                 0x3 = Reserved. */
        uint64_t pf                    : 4;  /**< [ 49: 46](R/W) Physical function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t reserved_50_52        : 3;
        uint64_t vf_active             : 1;  /**< [ 53: 53](R/W) Access is to virtual function if set.  Access is to physical function if
                                                                 clear. */
        uint64_t vf                    : 8;  /**< [ 61: 54](R/W) Virtual function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_reg_hugex_acc_s cn; */
};
typedef union bdk_pemx_reg_hugex_acc bdk_pemx_reg_hugex_acc_t;

static inline uint64_t BDK_PEMX_REG_HUGEX_ACC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_REG_HUGEX_ACC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=255)))
        return 0x8e0000006000ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=255)))
        return 0x8e0000006000ll + 0x1000000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=255)))
        return 0x8e0000006000ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=255)))
        return 0x8e0000006000ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    __bdk_csr_fatal("PEMX_REG_HUGEX_ACC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_REG_HUGEX_ACC(a,b) bdk_pemx_reg_hugex_acc_t
#define bustype_BDK_PEMX_REG_HUGEX_ACC(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_REG_HUGEX_ACC(a,b) "PEMX_REG_HUGEX_ACC"
#define device_bar_BDK_PEMX_REG_HUGEX_ACC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_REG_HUGEX_ACC(a,b) (a)
#define arguments_BDK_PEMX_REG_HUGEX_ACC(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_reg_huge#_acc2
 *
 * PEM Huge Region Access 2 Registers
 * These registers contains address index and control bits for access to memory from cores.
 * Indexed using NCBO address\<45:38\>.
 *
 * For discovery of the size of this register and fields, see PEM()_CONST_ACC.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 */
union bdk_pemx_reg_hugex_acc2
{
    uint64_t u;
    struct bdk_pemx_reg_hugex_acc2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_reg_hugex_acc2_s cn; */
};
typedef union bdk_pemx_reg_hugex_acc2 bdk_pemx_reg_hugex_acc2_t;

static inline uint64_t BDK_PEMX_REG_HUGEX_ACC2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_REG_HUGEX_ACC2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=255)))
        return 0x8e0000006008ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=255)))
        return 0x8e0000006008ll + 0x1000000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=255)))
        return 0x8e0000006008ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=255)))
        return 0x8e0000006008ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    __bdk_csr_fatal("PEMX_REG_HUGEX_ACC2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_REG_HUGEX_ACC2(a,b) bdk_pemx_reg_hugex_acc2_t
#define bustype_BDK_PEMX_REG_HUGEX_ACC2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_REG_HUGEX_ACC2(a,b) "PEMX_REG_HUGEX_ACC2"
#define device_bar_BDK_PEMX_REG_HUGEX_ACC2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_REG_HUGEX_ACC2(a,b) (a)
#define arguments_BDK_PEMX_REG_HUGEX_ACC2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_reg_norm#_acc
 *
 * PEM Normal Region Access Registers
 * These registers contains address index and control bits for access to memory from cores.
 * Indexed using NCBO address\<38:31\>.
 *
 * See PEM()_CONST_ACC.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 */
union bdk_pemx_reg_normx_acc
{
    uint64_t u;
    struct bdk_pemx_reg_normx_acc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t vf                    : 8;  /**< [ 61: 54](R/W) Virtual function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t vf_active             : 1;  /**< [ 53: 53](R/W) Access is to virtual function if set.  Access is to physical function if
                                                                 clear. */
        uint64_t reserved_50_52        : 3;
        uint64_t pf                    : 4;  /**< [ 49: 46](R/W) Physical function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t ctype                 : 2;  /**< [ 45: 44](R/W) The command type to be generated:
                                                                 0x0 = PCI memory.
                                                                 0x1 = PCI configuration. Only operations that access bytes within a single aligned dword
                                                                 are supported.  Note normally the ECAM would be used in place of this CTYPE.
                                                                 0x2 = PCI I/O.  Only operations that access bytes within a single aligned dword are supported.
                                                                 0x3 = Reserved. */
        uint64_t zero                  : 1;  /**< [ 43: 43](R/W) Causes load operations that are eight bytes or less and stay within a single aligned quadword
                                                                 to become zero-length read operations which will return zeros to the EXEC for all read
                                                                 data.
                                                                 Load operations that do not meet the size/alignment requirements above and have [ZERO] set
                                                                 will have unpredictable behavior.

                                                                 Internal:
                                                                 When hardware encounters an improperly formed load operation with [ZERO] set, it
                                                                 will drop the load internally and form up a properly sized completion with fault
                                                                 over NCBI to attempt to indicate an error condition. */
        uint64_t wnmerge               : 1;  /**< [ 42: 42](R/W) When set, no write merging (aka write combining) is allowed in this
                                                                 window. Write combining may result in higher performance. Write combining is
                                                                 legal and typically used in endpoints, or embedded applications. Write combining
                                                                 is not technically permitted in standard operating system root complexes, but
                                                                 typically functions correctly. */
        uint64_t rnmerge               : 1;  /**< [ 41: 41](R/W) When set, no read merging (aka read combining) is allowed in this window. Read
                                                                 combining may result in higher performance. Read combining is typically used in
                                                                 endpoints, or embedded applications. Read combining is not typically used in
                                                                 standard operating system root complexes. */
        uint64_t wtype                 : 3;  /**< [ 40: 38](R/W) Write type. ADDRTYPE\<2:0\> for write operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t rtype                 : 3;  /**< [ 37: 35](R/W) Read type. ADDRTYPE\<2:0\> for read operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t reserved_33_34        : 2;
        uint64_t ba                    : 33; /**< [ 32:  0](R/W) Bus address. Address bits\<63:31\> for read/write operations that use this region. */
#else /* Word 0 - Little Endian */
        uint64_t ba                    : 33; /**< [ 32:  0](R/W) Bus address. Address bits\<63:31\> for read/write operations that use this region. */
        uint64_t reserved_33_34        : 2;
        uint64_t rtype                 : 3;  /**< [ 37: 35](R/W) Read type. ADDRTYPE\<2:0\> for read operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t wtype                 : 3;  /**< [ 40: 38](R/W) Write type. ADDRTYPE\<2:0\> for write operations to this region.
                                                                 ADDRTYPE\<0\> is the relaxed-order attribute.
                                                                 ADDRTYPE\<1\> is the no-snoop attribute.
                                                                 ADDRTYPE\<2\> is the id-based ordering attribute. */
        uint64_t rnmerge               : 1;  /**< [ 41: 41](R/W) When set, no read merging (aka read combining) is allowed in this window. Read
                                                                 combining may result in higher performance. Read combining is typically used in
                                                                 endpoints, or embedded applications. Read combining is not typically used in
                                                                 standard operating system root complexes. */
        uint64_t wnmerge               : 1;  /**< [ 42: 42](R/W) When set, no write merging (aka write combining) is allowed in this
                                                                 window. Write combining may result in higher performance. Write combining is
                                                                 legal and typically used in endpoints, or embedded applications. Write combining
                                                                 is not technically permitted in standard operating system root complexes, but
                                                                 typically functions correctly. */
        uint64_t zero                  : 1;  /**< [ 43: 43](R/W) Causes load operations that are eight bytes or less and stay within a single aligned quadword
                                                                 to become zero-length read operations which will return zeros to the EXEC for all read
                                                                 data.
                                                                 Load operations that do not meet the size/alignment requirements above and have [ZERO] set
                                                                 will have unpredictable behavior.

                                                                 Internal:
                                                                 When hardware encounters an improperly formed load operation with [ZERO] set, it
                                                                 will drop the load internally and form up a properly sized completion with fault
                                                                 over NCBI to attempt to indicate an error condition. */
        uint64_t ctype                 : 2;  /**< [ 45: 44](R/W) The command type to be generated:
                                                                 0x0 = PCI memory.
                                                                 0x1 = PCI configuration. Only operations that access bytes within a single aligned dword
                                                                 are supported.  Note normally the ECAM would be used in place of this CTYPE.
                                                                 0x2 = PCI I/O.  Only operations that access bytes within a single aligned dword are supported.
                                                                 0x3 = Reserved. */
        uint64_t pf                    : 4;  /**< [ 49: 46](R/W) Physical function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t reserved_50_52        : 3;
        uint64_t vf_active             : 1;  /**< [ 53: 53](R/W) Access is to virtual function if set.  Access is to physical function if
                                                                 clear. */
        uint64_t vf                    : 8;  /**< [ 61: 54](R/W) Virtual function number associated with this access. In RC mode, this
                                                                 field must be zero. */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_reg_normx_acc_s cn; */
};
typedef union bdk_pemx_reg_normx_acc bdk_pemx_reg_normx_acc_t;

static inline uint64_t BDK_PEMX_REG_NORMX_ACC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_REG_NORMX_ACC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=255)))
        return 0x8e0000004000ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=255)))
        return 0x8e0000004000ll + 0x1000000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=255)))
        return 0x8e0000004000ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=255)))
        return 0x8e0000004000ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    __bdk_csr_fatal("PEMX_REG_NORMX_ACC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_REG_NORMX_ACC(a,b) bdk_pemx_reg_normx_acc_t
#define bustype_BDK_PEMX_REG_NORMX_ACC(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_REG_NORMX_ACC(a,b) "PEMX_REG_NORMX_ACC"
#define device_bar_BDK_PEMX_REG_NORMX_ACC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_REG_NORMX_ACC(a,b) (a)
#define arguments_BDK_PEMX_REG_NORMX_ACC(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_reg_norm#_acc2
 *
 * PEM Normal Region Access 2 Registers
 * See PEM()_CONST_ACC.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 */
union bdk_pemx_reg_normx_acc2
{
    uint64_t u;
    struct bdk_pemx_reg_normx_acc2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_reg_normx_acc2_s cn; */
};
typedef union bdk_pemx_reg_normx_acc2 bdk_pemx_reg_normx_acc2_t;

static inline uint64_t BDK_PEMX_REG_NORMX_ACC2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_REG_NORMX_ACC2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && ((a<=3) && (b<=255)))
        return 0x8e0000004008ll + 0x1000000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CN98XX) && ((a<=4) && (b<=255)))
        return 0x8e0000004008ll + 0x1000000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && ((a==0) && (b<=255)))
        return 0x8e0000004008ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    if (bdk_is_model(OCTEONTX_LOKI) && ((a==0) && (b<=255)))
        return 0x8e0000004008ll + 0x1000000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0xff);
    __bdk_csr_fatal("PEMX_REG_NORMX_ACC2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_REG_NORMX_ACC2(a,b) bdk_pemx_reg_normx_acc2_t
#define bustype_BDK_PEMX_REG_NORMX_ACC2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_REG_NORMX_ACC2(a,b) "PEMX_REG_NORMX_ACC2"
#define device_bar_BDK_PEMX_REG_NORMX_ACC2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_REG_NORMX_ACC2(a,b) (a)
#define arguments_BDK_PEMX_REG_NORMX_ACC2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) pem#_rmerge_merged_pc
 *
 * PEM Merge Reads Merged Performance Counter Register
 * This register reports how many reads merged within the outbound read merge unit.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_rmerge_merged_pc
{
    uint64_t u;
    struct bdk_pemx_rmerge_merged_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBO read operation mapped to MEM type by the ACC table that merges with a previous
                                                                 read will increment this count. */
#else /* Word 0 - Little Endian */
        uint64_t rmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBO read operation mapped to MEM type by the ACC table that merges with a previous
                                                                 read will increment this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rmerge_merged_pc_s cn; */
};
typedef union bdk_pemx_rmerge_merged_pc bdk_pemx_rmerge_merged_pc_t;

static inline uint64_t BDK_PEMX_RMERGE_MERGED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RMERGE_MERGED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001a8ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001a8ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001a8ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001a8ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RMERGE_MERGED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RMERGE_MERGED_PC(a) bdk_pemx_rmerge_merged_pc_t
#define bustype_BDK_PEMX_RMERGE_MERGED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RMERGE_MERGED_PC(a) "PEMX_RMERGE_MERGED_PC"
#define device_bar_BDK_PEMX_RMERGE_MERGED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RMERGE_MERGED_PC(a) (a)
#define arguments_BDK_PEMX_RMERGE_MERGED_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rmerge_received_pc
 *
 * PEM Merge Reads Received Performance Counter Register
 * This register reports the number of reads that enter the outbound read merge unit.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_rmerge_received_pc
{
    uint64_t u;
    struct bdk_pemx_rmerge_received_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rmerge_reads          : 64; /**< [ 63:  0](R/W/H) Each NCBO read operation mapped to MEM type by the ACC table will increment this count. */
#else /* Word 0 - Little Endian */
        uint64_t rmerge_reads          : 64; /**< [ 63:  0](R/W/H) Each NCBO read operation mapped to MEM type by the ACC table will increment this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rmerge_received_pc_s cn; */
};
typedef union bdk_pemx_rmerge_received_pc bdk_pemx_rmerge_received_pc_t;

static inline uint64_t BDK_PEMX_RMERGE_RECEIVED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RMERGE_RECEIVED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000001a0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000001a0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000001a0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000001a0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RMERGE_RECEIVED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RMERGE_RECEIVED_PC(a) bdk_pemx_rmerge_received_pc_t
#define bustype_BDK_PEMX_RMERGE_RECEIVED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RMERGE_RECEIVED_PC(a) "PEMX_RMERGE_RECEIVED_PC"
#define device_bar_BDK_PEMX_RMERGE_RECEIVED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RMERGE_RECEIVED_PC(a) (a)
#define arguments_BDK_PEMX_RMERGE_RECEIVED_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_cold_state_w1c
 *
 * PEM Interrupt Summary Register
 * This register contains the state of PEM()_RST_INT through core domain reset.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_rst_cold_state_w1c
{
    uint64_t u;
    struct bdk_pemx_rst_cold_state_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reset based on PEM()_RST_INT[L2]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reset based on PEM()_RST_INT[LINKDOWN]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reset based on PEM()_RST_INT[PERST]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reset based on PEM()_RST_INT[PERST]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reset based on PEM()_RST_INT[LINKDOWN]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reset based on PEM()_RST_INT[L2]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_cold_state_w1c_s cn; */
};
typedef union bdk_pemx_rst_cold_state_w1c bdk_pemx_rst_cold_state_w1c_t;

static inline uint64_t BDK_PEMX_RST_COLD_STATE_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_COLD_STATE_W1C(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000320ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000320ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000320ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_COLD_STATE_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_COLD_STATE_W1C(a) bdk_pemx_rst_cold_state_w1c_t
#define bustype_BDK_PEMX_RST_COLD_STATE_W1C(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_COLD_STATE_W1C(a) "PEMX_RST_COLD_STATE_W1C"
#define device_bar_BDK_PEMX_RST_COLD_STATE_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_COLD_STATE_W1C(a) (a)
#define arguments_BDK_PEMX_RST_COLD_STATE_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_cold_state_w1s
 *
 * PEM Reset Cold State Interrupt Summary Register
 */
union bdk_pemx_rst_cold_state_w1s
{
    uint64_t u;
    struct bdk_pemx_rst_cold_state_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reset based on PEM()_RST_INT[L2]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reset based on PEM()_RST_INT[LINKDOWN]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reset based on PEM()_RST_INT[PERST]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reset based on PEM()_RST_INT[PERST]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reset based on PEM()_RST_INT[LINKDOWN]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reset based on PEM()_RST_INT[L2]
                                                                 caused a domain reset specified by PEM()_S_RST_CTL[RESET_TYPE] and is preserved through
                                                                 core domain reset. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_cold_state_w1s_s cn; */
};
typedef union bdk_pemx_rst_cold_state_w1s bdk_pemx_rst_cold_state_w1s_t;

static inline uint64_t BDK_PEMX_RST_COLD_STATE_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_COLD_STATE_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000328ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000328ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000328ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_COLD_STATE_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_COLD_STATE_W1S(a) bdk_pemx_rst_cold_state_w1s_t
#define bustype_BDK_PEMX_RST_COLD_STATE_W1S(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_COLD_STATE_W1S(a) "PEMX_RST_COLD_STATE_W1S"
#define device_bar_BDK_PEMX_RST_COLD_STATE_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_COLD_STATE_W1S(a) (a)
#define arguments_BDK_PEMX_RST_COLD_STATE_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_int
 *
 * PEM Interrupt Summary Register
 * This register contains the different interrupt summary bits of the PEM.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_rst_int
{
    uint64_t u;
    struct bdk_pemx_rst_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reset based on Powerdown (L2) occurred while PEM()_S_RST_CTL[RST_L2] = 0.
                                                                 Software must assert then deassert PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 This field is reinitialized by a core domain reset.
                                                                 Refer to PEM()_RST_COLD_STATE_W1C[L2], which will retain state. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reset based on link down event occurred while PEM()_S_RST_CTL[RST_LNKDWN] = 0.
                                                                 Software must assert then deassert PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 This field is reinitialized by a core domain reset.
                                                                 Refer to PEM()_RST_COLD_STATE_W1C[L2], which will retain state. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reset based on PERST_L pin when PEM()_S_RST_CTL[EN_PERST_RCV] = 1 and
                                                                 PEM()_S_RST_CTL[RST_PERST] = 0.

                                                                 This field is reinitialized by a core domain reset.
                                                                 Refer to PEM()_RST_COLD_STATE_W1C[L2], which will retain state. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reset based on PERST_L pin when PEM()_S_RST_CTL[EN_PERST_RCV] = 1 and
                                                                 PEM()_S_RST_CTL[RST_PERST] = 0.

                                                                 This field is reinitialized by a core domain reset.
                                                                 Refer to PEM()_RST_COLD_STATE_W1C[L2], which will retain state. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reset based on link down event occurred while PEM()_S_RST_CTL[RST_LNKDWN] = 0.
                                                                 Software must assert then deassert PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 This field is reinitialized by a core domain reset.
                                                                 Refer to PEM()_RST_COLD_STATE_W1C[L2], which will retain state. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reset based on Powerdown (L2) occurred while PEM()_S_RST_CTL[RST_L2] = 0.
                                                                 Software must assert then deassert PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 This field is reinitialized by a core domain reset.
                                                                 Refer to PEM()_RST_COLD_STATE_W1C[L2], which will retain state. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_int_s cn; */
};
typedef union bdk_pemx_rst_int bdk_pemx_rst_int_t;

static inline uint64_t BDK_PEMX_RST_INT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_INT(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000300ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000300ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000300ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_INT(a) bdk_pemx_rst_int_t
#define bustype_BDK_PEMX_RST_INT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_INT(a) "PEMX_RST_INT"
#define device_bar_BDK_PEMX_RST_INT(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_INT(a) (a)
#define arguments_BDK_PEMX_RST_INT(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_int_ena_w1c
 *
 * PEM Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union bdk_pemx_rst_int_ena_w1c
{
    uint64_t u;
    struct bdk_pemx_rst_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..3)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..3)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..3)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..3)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..3)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_int_ena_w1c_s cn9; */
    /* struct bdk_pemx_rst_int_ena_w1c_s cn96xx; */
    struct bdk_pemx_rst_int_ena_w1c_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..4)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..4)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..4)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0..4)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0..4)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0..4)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn98xx;
    struct bdk_pemx_rst_int_ena_w1c_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for PEM(0)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for PEM(0)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for PEM(0)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_pemx_rst_int_ena_w1c bdk_pemx_rst_int_ena_w1c_t;

static inline uint64_t BDK_PEMX_RST_INT_ENA_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_INT_ENA_W1C(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000310ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000310ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000310ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_INT_ENA_W1C(a) bdk_pemx_rst_int_ena_w1c_t
#define bustype_BDK_PEMX_RST_INT_ENA_W1C(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_INT_ENA_W1C(a) "PEMX_RST_INT_ENA_W1C"
#define device_bar_BDK_PEMX_RST_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_INT_ENA_W1C(a) (a)
#define arguments_BDK_PEMX_RST_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_int_ena_w1s
 *
 * PEM Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union bdk_pemx_rst_int_ena_w1s
{
    uint64_t u;
    struct bdk_pemx_rst_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..3)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..3)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..3)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..3)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..3)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_int_ena_w1s_s cn9; */
    /* struct bdk_pemx_rst_int_ena_w1s_s cn96xx; */
    struct bdk_pemx_rst_int_ena_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..4)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..4)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..4)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0..4)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0..4)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0..4)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn98xx;
    struct bdk_pemx_rst_int_ena_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for PEM(0)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for PEM(0)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for PEM(0)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_pemx_rst_int_ena_w1s bdk_pemx_rst_int_ena_w1s_t;

static inline uint64_t BDK_PEMX_RST_INT_ENA_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_INT_ENA_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000318ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000318ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000318ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_INT_ENA_W1S(a) bdk_pemx_rst_int_ena_w1s_t
#define bustype_BDK_PEMX_RST_INT_ENA_W1S(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_INT_ENA_W1S(a) "PEMX_RST_INT_ENA_W1S"
#define device_bar_BDK_PEMX_RST_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_INT_ENA_W1S(a) (a)
#define arguments_BDK_PEMX_RST_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_int_w1s
 *
 * PEM Interrupt Summary Register
 * This register sets interrupt bits.
 */
union bdk_pemx_rst_int_w1s
{
    uint64_t u;
    struct bdk_pemx_rst_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..3)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..3)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..3)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..3)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..3)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_int_w1s_s cn9; */
    /* struct bdk_pemx_rst_int_w1s_s cn96xx; */
    struct bdk_pemx_rst_int_w1s_cn98xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..4)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..4)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..4)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0..4)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0..4)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0..4)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn98xx;
    struct bdk_pemx_rst_int_w1s_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0)_RST_INT[L2]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0)_RST_INT[LINKDOWN]. */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0)_RST_INT[PERST]. */
#else /* Word 0 - Little Endian */
        uint64_t perst                 : 1;  /**< [  0:  0](R/W1S/H) Reads or sets PEM(0)_RST_INT[PERST]. */
        uint64_t linkdown              : 1;  /**< [  1:  1](R/W1S/H) Reads or sets PEM(0)_RST_INT[LINKDOWN]. */
        uint64_t l2                    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets PEM(0)_RST_INT[L2]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } loki;
};
typedef union bdk_pemx_rst_int_w1s bdk_pemx_rst_int_w1s_t;

static inline uint64_t BDK_PEMX_RST_INT_W1S(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_INT_W1S(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000308ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000308ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000308ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_INT_W1S(a) bdk_pemx_rst_int_w1s_t
#define bustype_BDK_PEMX_RST_INT_W1S(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_INT_W1S(a) "PEMX_RST_INT_W1S"
#define device_bar_BDK_PEMX_RST_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_INT_W1S(a) (a)
#define arguments_BDK_PEMX_RST_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_lboot
 *
 * PEM Reset Last Boot Register
 * This register contains status last reset cause.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_rst_lboot
{
    uint64_t u;
    struct bdk_pemx_rst_lboot_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t lboot                 : 5;  /**< [  4:  0](R/W1C/H) Bit vector of last reset cause(es).  The value is reset with a
                                                                 cold domain reset.
                                                                 Bit numbers are enumerated by PEM_RST_SOURCE_E. */
#else /* Word 0 - Little Endian */
        uint64_t lboot                 : 5;  /**< [  4:  0](R/W1C/H) Bit vector of last reset cause(es).  The value is reset with a
                                                                 cold domain reset.
                                                                 Bit numbers are enumerated by PEM_RST_SOURCE_E. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_lboot_s cn; */
};
typedef union bdk_pemx_rst_lboot bdk_pemx_rst_lboot_t;

static inline uint64_t BDK_PEMX_RST_LBOOT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_LBOOT(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000280ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000280ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000280ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_LBOOT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_LBOOT(a) bdk_pemx_rst_lboot_t
#define bustype_BDK_PEMX_RST_LBOOT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_LBOOT(a) "PEMX_RST_LBOOT"
#define device_bar_BDK_PEMX_RST_LBOOT(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_LBOOT(a) (a)
#define arguments_BDK_PEMX_RST_LBOOT(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_mac
 *
 * PEM Reset Mac Register
 * This register provides a mechanism to reset the Mac.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_rst_mac
{
    uint64_t u;
    struct bdk_pemx_rst_mac_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t pipe_rst              : 1;  /**< [  1:  1](R/W) When set, resets the PIPE PCS. */
        uint64_t mac_rst               : 1;  /**< [  0:  0](R/W) When set, resets the PCIe Mac as well as its associated application logic.
                                                                 Internal:
                                                                 mac_rst_n. */
#else /* Word 0 - Little Endian */
        uint64_t mac_rst               : 1;  /**< [  0:  0](R/W) When set, resets the PCIe Mac as well as its associated application logic.
                                                                 Internal:
                                                                 mac_rst_n. */
        uint64_t pipe_rst              : 1;  /**< [  1:  1](R/W) When set, resets the PIPE PCS. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_mac_s cn; */
};
typedef union bdk_pemx_rst_mac bdk_pemx_rst_mac_t;

static inline uint64_t BDK_PEMX_RST_MAC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_MAC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000290ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000290ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000290ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_MAC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_MAC(a) bdk_pemx_rst_mac_t
#define bustype_BDK_PEMX_RST_MAC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_MAC(a) "PEMX_RST_MAC"
#define device_bar_BDK_PEMX_RST_MAC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_MAC(a) (a)
#define arguments_BDK_PEMX_RST_MAC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_rst_soft_perst
 *
 * PEM Reset Software PERST Register
 * This register provides a mechanism to drive the PCIe PERSTN pin.
 *
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 */
union bdk_pemx_rst_soft_perst
{
    uint64_t u;
    struct bdk_pemx_rst_soft_perst_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t soft_perst            : 1;  /**< [  0:  0](R/W/H) Soft PCIe reset. Resets the PEM and corresponding GSER SerDes logic.
                                                                 This field is initialized as follows during cold domain resets:
                                                                 * If PEM()_CFG[HOSTMD] is clear, [SOFT_PERST] resets to 0.
                                                                 * If PEM()_CFG[HOSTMD] is set, [SOFT_PERST] resets to 1.

                                                                 It is set by hardware under three conditions:
                                                                 * If PEM()_CFG[HOSTMD] and the PEM domain is reset.
                                                                 * If PEM()_S_RST_CTL[PRST_LNKDWN] is set and the link goes down.
                                                                 * If PEM()_S_RST_CTL[PRST_L2] is set and the PEM goes into L2 (powered down).

                                                                 When PEM()_S_RST_CTL[EN_PERST_DRV] is set, this controls the output value on PERST*_L.
                                                                 While PEM()_S_RST_CTL[EN_PERST_DRV] is set, hardware does not guarantee a minimum assertion time.
                                                                 Table 2-4 in section 2.6.2 of the PCIE CEM spec states that PERST*_L must be
                                                                 asserted for at least 100 us.

                                                                 In the endpoint case, the hardware requires that this signal be set for a
                                                                 minimum of 5 us to guarantee that the PCIe interface shuts down completely.

                                                                 These time period must be implemented by software.

                                                                 When PEM()_S_RST_CTL[EN_PERST_DRV] is clear and [SOFT_PERST] has been set by either hardware
                                                                 or software, a minimum assertion time of 2uS is required.

                                                                 Internal:
                                                                 This bit is also forced high if the corresponding PEM cripple fuse is set. */
#else /* Word 0 - Little Endian */
        uint64_t soft_perst            : 1;  /**< [  0:  0](R/W/H) Soft PCIe reset. Resets the PEM and corresponding GSER SerDes logic.
                                                                 This field is initialized as follows during cold domain resets:
                                                                 * If PEM()_CFG[HOSTMD] is clear, [SOFT_PERST] resets to 0.
                                                                 * If PEM()_CFG[HOSTMD] is set, [SOFT_PERST] resets to 1.

                                                                 It is set by hardware under three conditions:
                                                                 * If PEM()_CFG[HOSTMD] and the PEM domain is reset.
                                                                 * If PEM()_S_RST_CTL[PRST_LNKDWN] is set and the link goes down.
                                                                 * If PEM()_S_RST_CTL[PRST_L2] is set and the PEM goes into L2 (powered down).

                                                                 When PEM()_S_RST_CTL[EN_PERST_DRV] is set, this controls the output value on PERST*_L.
                                                                 While PEM()_S_RST_CTL[EN_PERST_DRV] is set, hardware does not guarantee a minimum assertion time.
                                                                 Table 2-4 in section 2.6.2 of the PCIE CEM spec states that PERST*_L must be
                                                                 asserted for at least 100 us.

                                                                 In the endpoint case, the hardware requires that this signal be set for a
                                                                 minimum of 5 us to guarantee that the PCIe interface shuts down completely.

                                                                 These time period must be implemented by software.

                                                                 When PEM()_S_RST_CTL[EN_PERST_DRV] is clear and [SOFT_PERST] has been set by either hardware
                                                                 or software, a minimum assertion time of 2uS is required.

                                                                 Internal:
                                                                 This bit is also forced high if the corresponding PEM cripple fuse is set. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_rst_soft_perst_s cn; */
};
typedef union bdk_pemx_rst_soft_perst bdk_pemx_rst_soft_perst_t;

static inline uint64_t BDK_PEMX_RST_SOFT_PERST(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_RST_SOFT_PERST(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000298ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000298ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000298ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_RST_SOFT_PERST", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_RST_SOFT_PERST(a) bdk_pemx_rst_soft_perst_t
#define bustype_BDK_PEMX_RST_SOFT_PERST(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_RST_SOFT_PERST(a) "PEMX_RST_SOFT_PERST"
#define device_bar_BDK_PEMX_RST_SOFT_PERST(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_RST_SOFT_PERST(a) (a)
#define arguments_BDK_PEMX_RST_SOFT_PERST(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_s_rst_ctl
 *
 * PEM Secure Reset Controllers Register
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 */
union bdk_pemx_s_rst_ctl
{
    uint64_t u;
    struct bdk_pemx_s_rst_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t reset_type            : 1;  /**< [ 13: 13](SR/W) Type of reset generated internally by PCI MAC PF FLR, link down/hot reset, Powerdown  or
                                                                 PERST events. See [PF_FLR_CHIP], [RST_LNKDWN], [RST_L2] and [RST_PERST].

                                                                 0 = Chip and core domain reset. (A chip domain reset always also causes a core
                                                                 domain reset.)
                                                                 1 = Core domain reset.

                                                                 On cold reset, this field is initialized as follows:
                                                                 _ 0 when PEM()_CFG[HOSTD] = 0.
                                                                 _ 1 when PEM()_CFG[HOSTD] = 1. */
        uint64_t rst_l2                : 1;  /**< [ 12: 12](SR/W) Powerdown event internal reset enable.
                                                                 0 = PEM going into powerdown (L2) does not cause an internal reset.
                                                                 1 = PEM going into powerdown (L2) causes the internal reset
                                                                 specified by [RESET_TYPE].

                                                                 On a cold reset, the field is initialized as follows:
                                                                 _ 0 when PEM()_CFG.HOSTMD is set.
                                                                 _ 1 when PEM()_CFG.HOSTMD is cleared.

                                                                 0 = Upon a Powerdown event PEM()_RST_COLD_STATE_W1S[RST_L2] will be set.
                                                                 1 = Upon a Powerdown event no L2 interrupt will occur, regardless of
                                                                 PEM()_RST_INT_ENA_W1S[RST_L2]

                                                                 Note that a powerdown event can never cause a domain reset when the
                                                                 Mac is already in reset (i.e. when PEM()_ON[PEMOOR] is clear). */
        uint64_t prst_l2               : 1;  /**< [ 11: 11](SR/W) PEM reset on power down.
                                                                 0 = PEM entering L2/P2 power state will set PEM()_RST_INT[RST_L2] for the
                                                                 corresponding controller, and (provided properly configured) the link should
                                                                 come back up automatically.
                                                                 1 = PEM entering L2/P2 power state will set PEM()_RST_INT[RST_L2] for
                                                                 the corresponding controller and set PEM()_RST_SOFT_PERST[SOFT_PERST]. This will
                                                                 hold the link in reset until software clears PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 A core/chip reset does not change this field. On cold reset, this field is
                                                                 initialized to 0. */
        uint64_t rst_pfflr             : 1;  /**< [ 10: 10](SR/W) PF FLR internal reset enable.
                                                                 0 = PF FLR events will not cause an internal reset.
                                                                 1 = A PF FLR event received by the PCIe logic causes the internal reset
                                                                 specified by [RESET_TYPE].

                                                                 On cold reset, this field is initialized as follows:
                                                                 _ 0 when PEM()_CFG[HOSTMD] = 1.
                                                                 _ 1 when PEM()_CFG[HOSTMD] = 0. */
        uint64_t rst_lnkdwn            : 1;  /**< [  9:  9](SR/W) Link down / hot reset event internal reset enable.
                                                                 0 = Link down or hot reset do not cause an internal reset.
                                                                 1 = A link-down or hot-reset event on the PCIe interface causes the internal
                                                                 reset specified by [RESET_TYPE].

                                                                 On a cold reset, the field is initialized as follows:
                                                                 _ 0 when PEM()_CFG[HOSTMD] is set.
                                                                 _ 1 when PEM()_CFG[HOSTMD] is cleared.

                                                                 0 = Upon a Linkdown event PEM()_RST_COLD_STATE_W1S[RST_LINKDWN] will be set.
                                                                 1 = Upon a Linkdown event no LINKDWN interrupt will occur, Regardless of
                                                                 PEM()_RST_INT_ENA_W1S[RST_LINKDWN]

                                                                 Note that a link-down event can never cause a domain reset when the
                                                                 Mac is already in reset (i.e. when PEM()_ON[PEMOOR] is clear). */
        uint64_t prst_lnkdwn           : 1;  /**< [  8:  8](SR/W) PEM reset on link down.
                                                                 0 = Link-down or hot-reset will set PEM()_RST_INT[RST_LNKDWN] for the corresponding
                                                                 controller, and (provided properly configured) the link should come back up
                                                                 automatically.
                                                                 1 = Link-down or hot-reset will set PEM()_RST_INT[RST_LNKDWN] for the corresponding
                                                                 controller, and set PEM()_RST_SOFT_PERST[SOFT_PERST]. This will hold the link in reset
                                                                 until software clears PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 A core/chip reset does not change this field. On cold reset, this field is
                                                                 initialized to 0. */
        uint64_t rst_perst             : 1;  /**< [  7:  7](SR/W) PERST internal reset enable. When set along with [EN_PERST_RCV],
                                                                 logic will generate an internal reset specified by [RESET_TYPE]
                                                                 when the corresponding PERST_L pin is asserted.  When cleared or
                                                                 when [EN_PERST_RCV] is cleared, the PERST_L does not cause an internal reset.

                                                                 0 = Upon a PERST event PEM()_RST_COLD_STATE_W1S[RST_PERST] will be set.
                                                                 1 = Upon a PERST event no PERST interrupt will occur, Regardless of
                                                                 PEM()_RST_INT_ENA_W1S[RST_PERST]

                                                                 If this bit is written while PERST_L pin is asserted and [EN_PERST_RCV]=1 then an
                                                                 internal reset can occur unexpectedly.

                                                                 During a cold domain reset this field is initialized to zero. */
        uint64_t reserved_3_6          : 4;
        uint64_t en_perst_drv          : 1;  /**< [  2:  2](SR/W) Controls whether PERST_L is driven.
                                                                 This field is always reinitialized on a cold domain reset.
                                                                 The field is initialized as follows:
                                                                 _ 0 when PEM()_CFG.HOSTMD is cleared.
                                                                 _ 1 when PEM()_CFG.HOSTMD is set.

                                                                 This bit must not be changed in the same write that sets [EN_PERST_RCV]=1; separate
                                                                 writes to PEM()_S_RST_CTL are required to clear one bit and then set the other. */
        uint64_t en_perst_rcv          : 1;  /**< [  1:  1](SR/W) Reset received. Controls whether PERST_L is received.
                                                                 This field is always reinitialized on a cold domain reset.
                                                                 The field is initialized as follows:
                                                                 _ 0 when PEM()_CFG.HOSTMD is set.
                                                                 _ 1 when PEM()_CFG.HOSTMD is cleared.

                                                                 When [EN_PERST_RCV] = 1, the PERST_L value is received and can be used to reset the
                                                                 controller and (optionally, based on [RST_PERST]) cause a domain reset.

                                                                 When [EN_PERST_RCV] = 1 (and [RST_PERST] = 0), PEM()_RST_INT[PERST] gets set when the PERST_L
                                                                 pin asserts. (This interrupt can alert software whenever the external reset pin initiates
                                                                 a controller reset sequence.)

                                                                 [PERST_PIN] gives the PERST_L pin value when [EN_PERST_RCV] = 1.

                                                                 When [EN_PERST_RCV] = 0, the PERST_L pin value is ignored and always returns a 1.

                                                                 This bit must not be changed in the same write that sets [EN_PERST_DRV]=1; separate
                                                                 writes to PEM()_S_RST_CTL are required to clear one bit and then set the other.
                                                                 If this bit is written while PERST_L pin is de-asserted then the MAC can come
                                                                 out of reset unexpectedly. */
        uint64_t perst_pin             : 1;  /**< [  0:  0](SRO/H) Read-only access to PERST (inverted PERST_L). Unpredictable when [EN_PERST_RCV] = 0.

                                                                 Reads as 0 when [EN_PERST_RCV] = 1 and the PERST_L pin is not asserted.
                                                                 Reads as 1 when [EN_PERST_RCV] = 1 and the PERST_L pin is asserted. */
#else /* Word 0 - Little Endian */
        uint64_t perst_pin             : 1;  /**< [  0:  0](SRO/H) Read-only access to PERST (inverted PERST_L). Unpredictable when [EN_PERST_RCV] = 0.

                                                                 Reads as 0 when [EN_PERST_RCV] = 1 and the PERST_L pin is not asserted.
                                                                 Reads as 1 when [EN_PERST_RCV] = 1 and the PERST_L pin is asserted. */
        uint64_t en_perst_rcv          : 1;  /**< [  1:  1](SR/W) Reset received. Controls whether PERST_L is received.
                                                                 This field is always reinitialized on a cold domain reset.
                                                                 The field is initialized as follows:
                                                                 _ 0 when PEM()_CFG.HOSTMD is set.
                                                                 _ 1 when PEM()_CFG.HOSTMD is cleared.

                                                                 When [EN_PERST_RCV] = 1, the PERST_L value is received and can be used to reset the
                                                                 controller and (optionally, based on [RST_PERST]) cause a domain reset.

                                                                 When [EN_PERST_RCV] = 1 (and [RST_PERST] = 0), PEM()_RST_INT[PERST] gets set when the PERST_L
                                                                 pin asserts. (This interrupt can alert software whenever the external reset pin initiates
                                                                 a controller reset sequence.)

                                                                 [PERST_PIN] gives the PERST_L pin value when [EN_PERST_RCV] = 1.

                                                                 When [EN_PERST_RCV] = 0, the PERST_L pin value is ignored and always returns a 1.

                                                                 This bit must not be changed in the same write that sets [EN_PERST_DRV]=1; separate
                                                                 writes to PEM()_S_RST_CTL are required to clear one bit and then set the other.
                                                                 If this bit is written while PERST_L pin is de-asserted then the MAC can come
                                                                 out of reset unexpectedly. */
        uint64_t en_perst_drv          : 1;  /**< [  2:  2](SR/W) Controls whether PERST_L is driven.
                                                                 This field is always reinitialized on a cold domain reset.
                                                                 The field is initialized as follows:
                                                                 _ 0 when PEM()_CFG.HOSTMD is cleared.
                                                                 _ 1 when PEM()_CFG.HOSTMD is set.

                                                                 This bit must not be changed in the same write that sets [EN_PERST_RCV]=1; separate
                                                                 writes to PEM()_S_RST_CTL are required to clear one bit and then set the other. */
        uint64_t reserved_3_6          : 4;
        uint64_t rst_perst             : 1;  /**< [  7:  7](SR/W) PERST internal reset enable. When set along with [EN_PERST_RCV],
                                                                 logic will generate an internal reset specified by [RESET_TYPE]
                                                                 when the corresponding PERST_L pin is asserted.  When cleared or
                                                                 when [EN_PERST_RCV] is cleared, the PERST_L does not cause an internal reset.

                                                                 0 = Upon a PERST event PEM()_RST_COLD_STATE_W1S[RST_PERST] will be set.
                                                                 1 = Upon a PERST event no PERST interrupt will occur, Regardless of
                                                                 PEM()_RST_INT_ENA_W1S[RST_PERST]

                                                                 If this bit is written while PERST_L pin is asserted and [EN_PERST_RCV]=1 then an
                                                                 internal reset can occur unexpectedly.

                                                                 During a cold domain reset this field is initialized to zero. */
        uint64_t prst_lnkdwn           : 1;  /**< [  8:  8](SR/W) PEM reset on link down.
                                                                 0 = Link-down or hot-reset will set PEM()_RST_INT[RST_LNKDWN] for the corresponding
                                                                 controller, and (provided properly configured) the link should come back up
                                                                 automatically.
                                                                 1 = Link-down or hot-reset will set PEM()_RST_INT[RST_LNKDWN] for the corresponding
                                                                 controller, and set PEM()_RST_SOFT_PERST[SOFT_PERST]. This will hold the link in reset
                                                                 until software clears PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 A core/chip reset does not change this field. On cold reset, this field is
                                                                 initialized to 0. */
        uint64_t rst_lnkdwn            : 1;  /**< [  9:  9](SR/W) Link down / hot reset event internal reset enable.
                                                                 0 = Link down or hot reset do not cause an internal reset.
                                                                 1 = A link-down or hot-reset event on the PCIe interface causes the internal
                                                                 reset specified by [RESET_TYPE].

                                                                 On a cold reset, the field is initialized as follows:
                                                                 _ 0 when PEM()_CFG[HOSTMD] is set.
                                                                 _ 1 when PEM()_CFG[HOSTMD] is cleared.

                                                                 0 = Upon a Linkdown event PEM()_RST_COLD_STATE_W1S[RST_LINKDWN] will be set.
                                                                 1 = Upon a Linkdown event no LINKDWN interrupt will occur, Regardless of
                                                                 PEM()_RST_INT_ENA_W1S[RST_LINKDWN]

                                                                 Note that a link-down event can never cause a domain reset when the
                                                                 Mac is already in reset (i.e. when PEM()_ON[PEMOOR] is clear). */
        uint64_t rst_pfflr             : 1;  /**< [ 10: 10](SR/W) PF FLR internal reset enable.
                                                                 0 = PF FLR events will not cause an internal reset.
                                                                 1 = A PF FLR event received by the PCIe logic causes the internal reset
                                                                 specified by [RESET_TYPE].

                                                                 On cold reset, this field is initialized as follows:
                                                                 _ 0 when PEM()_CFG[HOSTMD] = 1.
                                                                 _ 1 when PEM()_CFG[HOSTMD] = 0. */
        uint64_t prst_l2               : 1;  /**< [ 11: 11](SR/W) PEM reset on power down.
                                                                 0 = PEM entering L2/P2 power state will set PEM()_RST_INT[RST_L2] for the
                                                                 corresponding controller, and (provided properly configured) the link should
                                                                 come back up automatically.
                                                                 1 = PEM entering L2/P2 power state will set PEM()_RST_INT[RST_L2] for
                                                                 the corresponding controller and set PEM()_RST_SOFT_PERST[SOFT_PERST]. This will
                                                                 hold the link in reset until software clears PEM()_RST_SOFT_PERST[SOFT_PERST].

                                                                 A core/chip reset does not change this field. On cold reset, this field is
                                                                 initialized to 0. */
        uint64_t rst_l2                : 1;  /**< [ 12: 12](SR/W) Powerdown event internal reset enable.
                                                                 0 = PEM going into powerdown (L2) does not cause an internal reset.
                                                                 1 = PEM going into powerdown (L2) causes the internal reset
                                                                 specified by [RESET_TYPE].

                                                                 On a cold reset, the field is initialized as follows:
                                                                 _ 0 when PEM()_CFG.HOSTMD is set.
                                                                 _ 1 when PEM()_CFG.HOSTMD is cleared.

                                                                 0 = Upon a Powerdown event PEM()_RST_COLD_STATE_W1S[RST_L2] will be set.
                                                                 1 = Upon a Powerdown event no L2 interrupt will occur, regardless of
                                                                 PEM()_RST_INT_ENA_W1S[RST_L2]

                                                                 Note that a powerdown event can never cause a domain reset when the
                                                                 Mac is already in reset (i.e. when PEM()_ON[PEMOOR] is clear). */
        uint64_t reset_type            : 1;  /**< [ 13: 13](SR/W) Type of reset generated internally by PCI MAC PF FLR, link down/hot reset, Powerdown  or
                                                                 PERST events. See [PF_FLR_CHIP], [RST_LNKDWN], [RST_L2] and [RST_PERST].

                                                                 0 = Chip and core domain reset. (A chip domain reset always also causes a core
                                                                 domain reset.)
                                                                 1 = Core domain reset.

                                                                 On cold reset, this field is initialized as follows:
                                                                 _ 0 when PEM()_CFG[HOSTD] = 0.
                                                                 _ 1 when PEM()_CFG[HOSTD] = 1. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_s_rst_ctl_s cn; */
};
typedef union bdk_pemx_s_rst_ctl bdk_pemx_s_rst_ctl_t;

static inline uint64_t BDK_PEMX_S_RST_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_S_RST_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX_PASS3_X) && (a<=3))
        return 0x8e0000000288ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000288ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000288ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_S_RST_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_S_RST_CTL(a) bdk_pemx_s_rst_ctl_t
#define bustype_BDK_PEMX_S_RST_CTL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_S_RST_CTL(a) "PEMX_S_RST_CTL"
#define device_bar_BDK_PEMX_S_RST_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_S_RST_CTL(a) (a)
#define arguments_BDK_PEMX_S_RST_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_spi_ctl
 *
 * PEM SPI Control Register
 */
union bdk_pemx_spi_ctl
{
    uint64_t u;
    struct bdk_pemx_spi_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_34_63        : 30;
        uint64_t start_busy            : 1;  /**< [ 33: 33](R/W/H) Start/busy status. Starts SPI xctn when written; reads 1 when EEPROM busy, 0 when complete. */
        uint64_t tvalid                : 1;  /**< [ 32: 32](R/W/H) Reads 1 if at least one valid entry was read from EEPROM and written to a CSR. Write to
                                                                 clear status. */
        uint64_t cmd                   : 8;  /**< [ 31: 24](R/W/H) SPI command to be passed to the flash memory.
                                                                 This field will clear when command is complete.

                                                                 Examples of some commonly used commands:
                                                                 0x1  = WRSR: Write status register. A single-byte write of
                                                                        corresponding PEM()_SPI_DATA[DATA\<7:0\>] to the register.
                                                                 0x2  = PAGE PROGRAM/WRITE: An eight-byte page-mode write of the 64-bits of corresponding
                                                                        PEM()_SPI_DATA to the memory array. Can only be issued to Sector 0.
                                                                        Note, most devices require BULK or SECTOR ERASE to set bits first.
                                                                 0x3  = READ: An eight-byte page-mode read access from the memory array
                                                                        with result in the 64-bits of corresponding PEM()_SPI_DATA.
                                                                        Can only be issued to sector 0.
                                                                 0x4  = WRDI: Clear the write-enable latch (i.e. write protect the device).
                                                                 0x5  = RDSR: Read status register. A single-byte read access from
                                                                        the register with result in corresponding PEM()_SPI_DATA[DATA]\<7:0\>.
                                                                 0x6  = WREN: set the write-enable latch (i.e. allow writes to occur).
                                                                 0xB  = READ DATA HIGHER SPEED: Not supported.
                                                                 0xAB = WAKE: Release from deep power-down.
                                                                 0xB9 = SLEEP: Deep power-down.
                                                                 0xC7 = BULK ERASE: Sets all bits to 1.
                                                                 0xD8 = SECTOR ERASE: Sets to 1 all bits to the chosen sector (pointed to by [ADR]\<18:15\>).
                                                                 0x9F = READ ID: a two-byte read access to get device identification
                                                                        with result in the 64-bits of corresponding PEM()_SPI_DATA. */
        uint64_t reserved_19_23        : 5;
        uint64_t adr                   : 19; /**< [ 18:  0](R/W/H) EEPROM CMD byte address.
                                                                 For READ and PAGE PROGRAM commands, forced to a 8-byte aligned entry in sector 0, so
                                                                 \<18:16\> and \<2:0\> are forced to zero.  For all other commands, the entire ADR is passed.

                                                                 This field will clear when command is complete. */
#else /* Word 0 - Little Endian */
        uint64_t adr                   : 19; /**< [ 18:  0](R/W/H) EEPROM CMD byte address.
                                                                 For READ and PAGE PROGRAM commands, forced to a 8-byte aligned entry in sector 0, so
                                                                 \<18:16\> and \<2:0\> are forced to zero.  For all other commands, the entire ADR is passed.

                                                                 This field will clear when command is complete. */
        uint64_t reserved_19_23        : 5;
        uint64_t cmd                   : 8;  /**< [ 31: 24](R/W/H) SPI command to be passed to the flash memory.
                                                                 This field will clear when command is complete.

                                                                 Examples of some commonly used commands:
                                                                 0x1  = WRSR: Write status register. A single-byte write of
                                                                        corresponding PEM()_SPI_DATA[DATA\<7:0\>] to the register.
                                                                 0x2  = PAGE PROGRAM/WRITE: An eight-byte page-mode write of the 64-bits of corresponding
                                                                        PEM()_SPI_DATA to the memory array. Can only be issued to Sector 0.
                                                                        Note, most devices require BULK or SECTOR ERASE to set bits first.
                                                                 0x3  = READ: An eight-byte page-mode read access from the memory array
                                                                        with result in the 64-bits of corresponding PEM()_SPI_DATA.
                                                                        Can only be issued to sector 0.
                                                                 0x4  = WRDI: Clear the write-enable latch (i.e. write protect the device).
                                                                 0x5  = RDSR: Read status register. A single-byte read access from
                                                                        the register with result in corresponding PEM()_SPI_DATA[DATA]\<7:0\>.
                                                                 0x6  = WREN: set the write-enable latch (i.e. allow writes to occur).
                                                                 0xB  = READ DATA HIGHER SPEED: Not supported.
                                                                 0xAB = WAKE: Release from deep power-down.
                                                                 0xB9 = SLEEP: Deep power-down.
                                                                 0xC7 = BULK ERASE: Sets all bits to 1.
                                                                 0xD8 = SECTOR ERASE: Sets to 1 all bits to the chosen sector (pointed to by [ADR]\<18:15\>).
                                                                 0x9F = READ ID: a two-byte read access to get device identification
                                                                        with result in the 64-bits of corresponding PEM()_SPI_DATA. */
        uint64_t tvalid                : 1;  /**< [ 32: 32](R/W/H) Reads 1 if at least one valid entry was read from EEPROM and written to a CSR. Write to
                                                                 clear status. */
        uint64_t start_busy            : 1;  /**< [ 33: 33](R/W/H) Start/busy status. Starts SPI xctn when written; reads 1 when EEPROM busy, 0 when complete. */
        uint64_t reserved_34_63        : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_spi_ctl_s cn; */
};
typedef union bdk_pemx_spi_ctl bdk_pemx_spi_ctl_t;

static inline uint64_t BDK_PEMX_SPI_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_SPI_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000180ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_SPI_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_SPI_CTL(a) bdk_pemx_spi_ctl_t
#define bustype_BDK_PEMX_SPI_CTL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_SPI_CTL(a) "PEMX_SPI_CTL"
#define device_bar_BDK_PEMX_SPI_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_SPI_CTL(a) (a)
#define arguments_BDK_PEMX_SPI_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_spi_data
 *
 * PEM SPI Data Register
 * This register contains the most recently read or written SPI data and is unpredictable upon
 * power-up.
 */
union bdk_pemx_spi_data
{
    uint64_t u;
    struct bdk_pemx_spi_data_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t preamble              : 16; /**< [ 63: 48](R/W/H) EEPROM PREAMBLE read or write data. */
        uint64_t spi_rsvd              : 3;  /**< [ 47: 45](R/W/H) Reserved. */
        uint64_t cs2                   : 1;  /**< [ 44: 44](R/W/H) EEPROM CS2 read or write data bit. */
        uint64_t adr                   : 12; /**< [ 43: 32](R/W/H) EEPROM CFG ADR read or write data. */
        uint64_t data                  : 32; /**< [ 31:  0](R/W/H) EEPROM DATA read or write data. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W/H) EEPROM DATA read or write data. */
        uint64_t adr                   : 12; /**< [ 43: 32](R/W/H) EEPROM CFG ADR read or write data. */
        uint64_t cs2                   : 1;  /**< [ 44: 44](R/W/H) EEPROM CS2 read or write data bit. */
        uint64_t spi_rsvd              : 3;  /**< [ 47: 45](R/W/H) Reserved. */
        uint64_t preamble              : 16; /**< [ 63: 48](R/W/H) EEPROM PREAMBLE read or write data. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_spi_data_s cn; */
};
typedef union bdk_pemx_spi_data bdk_pemx_spi_data_t;

static inline uint64_t BDK_PEMX_SPI_DATA(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_SPI_DATA(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000188ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_SPI_DATA", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_SPI_DATA(a) bdk_pemx_spi_data_t
#define bustype_BDK_PEMX_SPI_DATA(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_SPI_DATA(a) "PEMX_SPI_DATA"
#define device_bar_BDK_PEMX_SPI_DATA(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_SPI_DATA(a) (a)
#define arguments_BDK_PEMX_SPI_DATA(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_strap
 *
 * PEM Pin Strapping Register
 * This register is accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on cold reset.
 */
union bdk_pemx_strap
{
    uint64_t u;
    struct bdk_pemx_strap_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t pilaneswap            : 1;  /**< [  3:  3](RO/H) The value of PCIE_REV_LANES, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, lane swapping is performed to/from the
                                                                 SerDes. When clear, no lane swapping is performed. */
        uint64_t pilanes8              : 1;  /**< [  2:  2](RO/H) The value of bit \<2\> of PCIE*_MODE\<2:0\>, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, the PEM is configured for a maximum of
                                                                 8-lanes, When clear, the PEM is configured for a maximum of 4-lanes. */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t pilanes8              : 1;  /**< [  2:  2](RO/H) The value of bit \<2\> of PCIE*_MODE\<2:0\>, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, the PEM is configured for a maximum of
                                                                 8-lanes, When clear, the PEM is configured for a maximum of 4-lanes. */
        uint64_t pilaneswap            : 1;  /**< [  3:  3](RO/H) The value of PCIE_REV_LANES, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, lane swapping is performed to/from the
                                                                 SerDes. When clear, no lane swapping is performed. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    struct bdk_pemx_strap_cn8
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t pilaneswap            : 1;  /**< [  3:  3](RO/H) The value of PCIE_REV_LANES, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, lane swapping is performed to/from the
                                                                 SerDes. When clear, no lane swapping is performed. */
        uint64_t pilanes8              : 1;  /**< [  2:  2](RO/H) The value of bit \<2\> of PCIE*_MODE\<2:0\>, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, the PEM is configured for a maximum of
                                                                 8-lanes, When clear, the PEM is configured for a maximum of 4-lanes. */
        uint64_t pimode                : 2;  /**< [  1:  0](RO/H) The value of PCIE_MODE\<1:0\>, which are captured on chip cold reset. They are
                                                                 not affected by any other reset.
                                                                 0x0 = EP mode, Gen1 speed.
                                                                 0x1 = EP mode, Gen2 speed.
                                                                 0x2 = EP mode, Gen3 speed.
                                                                 0x3 = RC mode, defaults to Gen3 speed. */
#else /* Word 0 - Little Endian */
        uint64_t pimode                : 2;  /**< [  1:  0](RO/H) The value of PCIE_MODE\<1:0\>, which are captured on chip cold reset. They are
                                                                 not affected by any other reset.
                                                                 0x0 = EP mode, Gen1 speed.
                                                                 0x1 = EP mode, Gen2 speed.
                                                                 0x2 = EP mode, Gen3 speed.
                                                                 0x3 = RC mode, defaults to Gen3 speed. */
        uint64_t pilanes8              : 1;  /**< [  2:  2](RO/H) The value of bit \<2\> of PCIE*_MODE\<2:0\>, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, the PEM is configured for a maximum of
                                                                 8-lanes, When clear, the PEM is configured for a maximum of 4-lanes. */
        uint64_t pilaneswap            : 1;  /**< [  3:  3](RO/H) The value of PCIE_REV_LANES, which is captured on chip cold reset. It is not
                                                                 affected by any other reset.  When set, lane swapping is performed to/from the
                                                                 SerDes. When clear, no lane swapping is performed. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } cn8;
    struct bdk_pemx_strap_cn9
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pirc                  : 1;  /**< [  0:  0](RO/H) The inverted value of the endpoint strap (GPIO_STRAP_PIN_E::PCIE0_EP_MODE,
                                                                 GPIO_STRAP_PIN_E::PCIE2_EP_MODE, 1 for other PEMs) which is captured on
                                                                 DCOK assertion. It is not affected by any other reset. When set, PEM defaults to
                                                                 root complex mode. When clear, PEM defaults to endpoint mode. */
#else /* Word 0 - Little Endian */
        uint64_t pirc                  : 1;  /**< [  0:  0](RO/H) The inverted value of the endpoint strap (GPIO_STRAP_PIN_E::PCIE0_EP_MODE,
                                                                 GPIO_STRAP_PIN_E::PCIE2_EP_MODE, 1 for other PEMs) which is captured on
                                                                 DCOK assertion. It is not affected by any other reset. When set, PEM defaults to
                                                                 root complex mode. When clear, PEM defaults to endpoint mode. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn9;
};
typedef union bdk_pemx_strap bdk_pemx_strap_t;

static inline uint64_t BDK_PEMX_STRAP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_STRAP(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000408ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e00000000d0ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e00000000d0ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e00000000d0ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e00000000d0ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_STRAP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_STRAP(a) bdk_pemx_strap_t
#define bustype_BDK_PEMX_STRAP(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_STRAP(a) "PEMX_STRAP"
#define device_bar_BDK_PEMX_STRAP(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_STRAP(a) (a)
#define arguments_BDK_PEMX_STRAP(a) (a),-1,-1,-1

/**
 * Register (RSL) pem#_tlp_credits
 *
 * PEM TLP Credits Register
 * This register specifies the number of credits for use in moving TLPs. When this register is
 * written, the credit values are reset to the register value. A write to this register should
 * take place before traffic flow starts.
 */
union bdk_pemx_tlp_credits
{
    uint64_t u;
    struct bdk_pemx_tlp_credits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pem_cpl               : 12; /**< [ 63: 52](R/W) TLP 16 B credits for completion TLPs in the peer. Legal values are 0x42 to 0x104. */
        uint64_t pem_np                : 8;  /**< [ 51: 44](R/W) TLP 16 B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x20. */
        uint64_t pem_p                 : 12; /**< [ 43: 32](R/W) TLP 16 B credits for posted TLPs in the peer. Legal values are 0x42 to 0x104. */
        uint64_t reserved_0_31         : 32;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_31         : 32;
        uint64_t pem_p                 : 12; /**< [ 43: 32](R/W) TLP 16 B credits for posted TLPs in the peer. Legal values are 0x42 to 0x104. */
        uint64_t pem_np                : 8;  /**< [ 51: 44](R/W) TLP 16 B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x20. */
        uint64_t pem_cpl               : 12; /**< [ 63: 52](R/W) TLP 16 B credits for completion TLPs in the peer. Legal values are 0x42 to 0x104. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_tlp_credits_s cn8; */
    struct bdk_pemx_tlp_credits_cn81xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t sli_cpl               : 8;  /**< [ 23: 16](R/W) TLP 16B credits for Completion TLPs in the SLI. Legal values are 0x24 to 0x4F
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t sli_np                : 8;  /**< [ 15:  8](R/W) TLP 16B credits for Non-Posted TLPs in the SLI. Legal values are 0x8 to 0x17
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t sli_p                 : 8;  /**< [  7:  0](R/W) TLP 16B credits for Non-Posted TLPs in the SLI. Legal values are 0x24 to 0x4F
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
#else /* Word 0 - Little Endian */
        uint64_t sli_p                 : 8;  /**< [  7:  0](R/W) TLP 16B credits for Non-Posted TLPs in the SLI. Legal values are 0x24 to 0x4F
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t sli_np                : 8;  /**< [ 15:  8](R/W) TLP 16B credits for Non-Posted TLPs in the SLI. Legal values are 0x8 to 0x17
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t sli_cpl               : 8;  /**< [ 23: 16](R/W) TLP 16B credits for Completion TLPs in the SLI. Legal values are 0x24 to 0x4F
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } cn81xx;
    struct bdk_pemx_tlp_credits_cn83xx
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pem_cpl               : 12; /**< [ 63: 52](R/W) TLP 16 B credits for completion TLPs in the peer. Legal values are 0x42 to 0x104. */
        uint64_t pem_np                : 8;  /**< [ 51: 44](R/W) TLP 16 B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x20. */
        uint64_t pem_p                 : 12; /**< [ 43: 32](R/W) TLP 16 B credits for posted TLPs in the peer. Legal values are 0x42 to 0x104. */
        uint64_t sli_cpl               : 12; /**< [ 31: 20](R/W) TLP 16 B credits for completion TLPs in the SLI. Legal values are 0x41 to 0x104
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t sli_np                : 8;  /**< [ 19: 12](R/W) TLP 16 B credits for non-posted TLPs in the SLI. Legal values are 0x3 to 0x20
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t sli_p                 : 12; /**< [ 11:  0](R/W) TLP 16 B credits for posted TLPs in the SLI. Legal values are 0x41 to 0x104 and this value
                                                                 is not dependent of the number of PEMS wire-OR'd together. Software should reprogram this
                                                                 register for performance reasons. */
#else /* Word 0 - Little Endian */
        uint64_t sli_p                 : 12; /**< [ 11:  0](R/W) TLP 16 B credits for posted TLPs in the SLI. Legal values are 0x41 to 0x104 and this value
                                                                 is not dependent of the number of PEMS wire-OR'd together. Software should reprogram this
                                                                 register for performance reasons. */
        uint64_t sli_np                : 8;  /**< [ 19: 12](R/W) TLP 16 B credits for non-posted TLPs in the SLI. Legal values are 0x3 to 0x20
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t sli_cpl               : 12; /**< [ 31: 20](R/W) TLP 16 B credits for completion TLPs in the SLI. Legal values are 0x41 to 0x104
                                                                 and this value is not dependent of the number of PEMS wire-OR'd
                                                                 together. Software should reprogram this register for performance reasons. */
        uint64_t pem_p                 : 12; /**< [ 43: 32](R/W) TLP 16 B credits for posted TLPs in the peer. Legal values are 0x42 to 0x104. */
        uint64_t pem_np                : 8;  /**< [ 51: 44](R/W) TLP 16 B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x20. */
        uint64_t pem_cpl               : 12; /**< [ 63: 52](R/W) TLP 16 B credits for completion TLPs in the peer. Legal values are 0x42 to 0x104. */
#endif /* Word 0 - End */
    } cn83xx;
};
typedef union bdk_pemx_tlp_credits bdk_pemx_tlp_credits_t;

static inline uint64_t BDK_PEMX_TLP_CREDITS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_TLP_CREDITS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN81XX) && (a<=2))
        return 0x87e0c0000038ll + 0x1000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN83XX) && (a<=3))
        return 0x87e0c0000038ll + 0x1000000ll * ((a) & 0x3);
    __bdk_csr_fatal("PEMX_TLP_CREDITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_TLP_CREDITS(a) bdk_pemx_tlp_credits_t
#define bustype_BDK_PEMX_TLP_CREDITS(a) BDK_CSR_TYPE_RSL
#define basename_BDK_PEMX_TLP_CREDITS(a) "PEMX_TLP_CREDITS"
#define device_bar_BDK_PEMX_TLP_CREDITS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_TLP_CREDITS(a) (a)
#define arguments_BDK_PEMX_TLP_CREDITS(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_vf_clr_flr_req
 *
 * PEM FLR Request VF Clear Register
 * This register provides clear request for PCIe PF function level reset (FLR).
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on MAC reset.
 */
union bdk_pemx_vf_clr_flr_req
{
    uint64_t u;
    struct bdk_pemx_vf_clr_flr_req_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vf_num                : 8;  /**< [  7:  0](R/W/H) When written, will cause hardware to clear one of the 240 VF FLR conditions
                                                                 indexed by [VF_NUM].
                                                                 This field always reads as zero. */
#else /* Word 0 - Little Endian */
        uint64_t vf_num                : 8;  /**< [  7:  0](R/W/H) When written, will cause hardware to clear one of the 240 VF FLR conditions
                                                                 indexed by [VF_NUM].
                                                                 This field always reads as zero. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_vf_clr_flr_req_s cn; */
};
typedef union bdk_pemx_vf_clr_flr_req bdk_pemx_vf_clr_flr_req_t;

static inline uint64_t BDK_PEMX_VF_CLR_FLR_REQ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_VF_CLR_FLR_REQ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000228ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000228ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000228ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000228ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_VF_CLR_FLR_REQ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_VF_CLR_FLR_REQ(a) bdk_pemx_vf_clr_flr_req_t
#define bustype_BDK_PEMX_VF_CLR_FLR_REQ(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_VF_CLR_FLR_REQ(a) "PEMX_VF_CLR_FLR_REQ"
#define device_bar_BDK_PEMX_VF_CLR_FLR_REQ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_VF_CLR_FLR_REQ(a) (a)
#define arguments_BDK_PEMX_VF_CLR_FLR_REQ(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_wmerge_merged_pc
 *
 * PEM Merge Writes Merged Performance Counter Register
 * This register reports how many writes merged within the outbound write merge unit.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_wmerge_merged_pc
{
    uint64_t u;
    struct bdk_pemx_wmerge_merged_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t wmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBO write operation mapped to MEM type by the ACC table that merges with a previous
                                                                 write will increment this count. */
#else /* Word 0 - Little Endian */
        uint64_t wmerge_merged         : 64; /**< [ 63:  0](R/W/H) Each NCBO write operation mapped to MEM type by the ACC table that merges with a previous
                                                                 write will increment this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_wmerge_merged_pc_s cn; */
};
typedef union bdk_pemx_wmerge_merged_pc bdk_pemx_wmerge_merged_pc_t;

static inline uint64_t BDK_PEMX_WMERGE_MERGED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_WMERGE_MERGED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000198ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000198ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000198ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000198ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_WMERGE_MERGED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_WMERGE_MERGED_PC(a) bdk_pemx_wmerge_merged_pc_t
#define bustype_BDK_PEMX_WMERGE_MERGED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_WMERGE_MERGED_PC(a) "PEMX_WMERGE_MERGED_PC"
#define device_bar_BDK_PEMX_WMERGE_MERGED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_WMERGE_MERGED_PC(a) (a)
#define arguments_BDK_PEMX_WMERGE_MERGED_PC(a) (a),-1,-1,-1

/**
 * Register (NCB) pem#_wmerge_received_pc
 *
 * PEM Merge Writes Received Performance Counter Register
 * This register reports the number of writes that enter the outbound write merge unit.
 *
 * This register is not accessible through ROM scripts; see SCR_WRITE32_S[ADDR].
 *
 * This register is reset on core domain reset.
 */
union bdk_pemx_wmerge_received_pc
{
    uint64_t u;
    struct bdk_pemx_wmerge_received_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t wmerge_writes         : 64; /**< [ 63:  0](R/W/H) Each NCBO write operation mapped to MEM type by the ACC table will increment this count. */
#else /* Word 0 - Little Endian */
        uint64_t wmerge_writes         : 64; /**< [ 63:  0](R/W/H) Each NCBO write operation mapped to MEM type by the ACC table will increment this count. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_pemx_wmerge_received_pc_s cn; */
};
typedef union bdk_pemx_wmerge_received_pc bdk_pemx_wmerge_received_pc_t;

static inline uint64_t BDK_PEMX_WMERGE_RECEIVED_PC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PEMX_WMERGE_RECEIVED_PC(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_CN96XX) && (a<=3))
        return 0x8e0000000190ll + 0x1000000000ll * ((a) & 0x3);
    if (bdk_is_model(OCTEONTX_CN98XX) && (a<=4))
        return 0x8e0000000190ll + 0x1000000000ll * ((a) & 0x7);
    if (bdk_is_model(OCTEONTX_CNF95XX_PASS1_X) && (a==0))
        return 0x8e0000000190ll + 0x1000000000ll * ((a) & 0x0);
    if (bdk_is_model(OCTEONTX_LOKI) && (a==0))
        return 0x8e0000000190ll + 0x1000000000ll * ((a) & 0x0);
    __bdk_csr_fatal("PEMX_WMERGE_RECEIVED_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_PEMX_WMERGE_RECEIVED_PC(a) bdk_pemx_wmerge_received_pc_t
#define bustype_BDK_PEMX_WMERGE_RECEIVED_PC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_PEMX_WMERGE_RECEIVED_PC(a) "PEMX_WMERGE_RECEIVED_PC"
#define device_bar_BDK_PEMX_WMERGE_RECEIVED_PC(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_PEMX_WMERGE_RECEIVED_PC(a) (a)
#define arguments_BDK_PEMX_WMERGE_RECEIVED_PC(a) (a),-1,-1,-1

#endif /* __BDK_CSRS_PEM_H__ */
