/***********************license start***********************************
* Copyright (C) 2018 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/
#include <bdk.h>
#include "bdk-qsfp.h"

BDK_REQUIRE_DEFINE(DRIVER_NETPORT_QSFP28);

#define MAX_ROM_SIZE 128

typedef struct
{
    char rom[MAX_ROM_SIZE]; /* Contents of the QSFP EEPROM. See comments on rom_info_t for format */
    char rom_page[4][MAX_ROM_SIZE];
    bool module_present;    /* True if there was a module the last time we checked */
    bool allow_link;        /* True if networking is allowing a link */
    bool force_unplug;      /* Override for module presence detect */
    int asim_rom;           /* Index of which ROM to use with Asim */
    int max_power;          /* Max power the QSFP can provide, in mWatts */
    bdk_device_t *twsi;     /* TWSI device connected to this QSFP */
    bdk_device_t *mod_sel;  /* GPIO device for SEL */
    bdk_device_t *reset;    /* GPIO device for RESET */
    bdk_device_t *mod_pres; /* GPIO device for PRES */
    bdk_device_t *intr;     /* GPIO device for INTR */
    bdk_device_t *lowp;     /* GPIO device for LOWP */
    int mod_sel_pin;        /* GPIO pin for SEL (output) */
    int reset_pin;          /* GPIO pin for RESET (output) */
    int mod_pres_pin;       /* GPIO pin for PRES (input) */
    int intr_pin;           /* GPIO pin for INTR (input) */
    int lowp_pin;           /* GPIO pin for LOWP (output) */
} qsfp_state_t;

typedef struct
{
    const char *name;       /* Friendly name for QSFP module */
    const char rom[MAX_ROM_SIZE]; /* 128 bytes of SFP compatible ROM */
    const char rom_page[4][MAX_ROM_SIZE]; /* Four 128 bytes pages of info */
} rom_info_t;

static rom_info_t ROM_TABLE[] = {
    {
        .name = "mellanox-100g-3m",
        .rom = {
            0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x52, 0x00, 0x00, 0x81, 0xf9, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        },
        .rom_page = {
            {
                0x0d, 0x00, 0x23, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x03, 0xa0, 0x4d, 0x65, 0x6c, 0x6c, 0x61, 0x6e, 0x6f, 0x78, 0x20, 0x20, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x1f, 0x00, 0x02, 0xc9, 0x4d, 0x43, 0x50, 0x31, 0x36, 0x30, 0x30, 0x2d,
                0x45, 0x30, 0x30, 0x33, 0x20, 0x20, 0x20, 0x20, 0x41, 0x32, 0x06, 0x08, 0x0a, 0x10, 0x00, 0x4b,
                0x0b, 0x00, 0x00, 0x00, 0x4d, 0x54, 0x31, 0x35, 0x32, 0x33, 0x56, 0x53, 0x30, 0x37, 0x34, 0x32,
                0x33, 0x20, 0x20, 0x20, 0x31, 0x35, 0x30, 0x37, 0x30, 0x32, 0x20, 0x20, 0x00, 0x00, 0x67, 0x56,
                0x31, 0x32, 0x38, 0x38, 0x35, 0x35, 0x32, 0x32, 0x33, 0x30, 0x58, 0x42, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
            },
            {
                0x0d, 0x00, 0x23, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x03, 0xa0, 0x4d, 0x65, 0x6c, 0x6c, 0x61, 0x6e, 0x6f, 0x78, 0x20, 0x20, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x1f, 0x00, 0x02, 0xc9, 0x4d, 0x43, 0x50, 0x31, 0x36, 0x30, 0x30, 0x2d,
                0x45, 0x30, 0x30, 0x33, 0x20, 0x20, 0x20, 0x20, 0x41, 0x32, 0x06, 0x08, 0x0a, 0x10, 0x00, 0x4b,
                0x0b, 0x00, 0x00, 0x00, 0x4d, 0x54, 0x31, 0x35, 0x32, 0x33, 0x56, 0x53, 0x30, 0x37, 0x34, 0x32,
                0x33, 0x20, 0x20, 0x20, 0x31, 0x35, 0x30, 0x37, 0x30, 0x32, 0x20, 0x20, 0x00, 0x00, 0x67, 0x56,
                0x31, 0x32, 0x38, 0x38, 0x35, 0x35, 0x32, 0x32, 0x33, 0x30, 0x58, 0x42, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
            },
            {
                0x0d, 0x00, 0x23, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x03, 0xa0, 0x4d, 0x65, 0x6c, 0x6c, 0x61, 0x6e, 0x6f, 0x78, 0x20, 0x20, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x1f, 0x00, 0x02, 0xc9, 0x4d, 0x43, 0x50, 0x31, 0x36, 0x30, 0x30, 0x2d,
                0x45, 0x30, 0x30, 0x33, 0x20, 0x20, 0x20, 0x20, 0x41, 0x32, 0x06, 0x08, 0x0a, 0x10, 0x00, 0x4b,
                0x0b, 0x00, 0x00, 0x00, 0x4d, 0x54, 0x31, 0x35, 0x32, 0x33, 0x56, 0x53, 0x30, 0x37, 0x34, 0x32,
                0x33, 0x20, 0x20, 0x20, 0x31, 0x35, 0x30, 0x37, 0x30, 0x32, 0x20, 0x20, 0x00, 0x00, 0x67, 0x56,
                0x31, 0x32, 0x38, 0x38, 0x35, 0x35, 0x32, 0x32, 0x33, 0x30, 0x58, 0x42, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
            },
            {
                0x0d, 0x00, 0x23, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x03, 0xa0, 0x4d, 0x65, 0x6c, 0x6c, 0x61, 0x6e, 0x6f, 0x78, 0x20, 0x20, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x1f, 0x00, 0x02, 0xc9, 0x4d, 0x43, 0x50, 0x31, 0x36, 0x30, 0x30, 0x2d,
                0x45, 0x30, 0x30, 0x33, 0x20, 0x20, 0x20, 0x20, 0x41, 0x32, 0x06, 0x08, 0x0a, 0x10, 0x00, 0x4b,
                0x0b, 0x00, 0x00, 0x00, 0x4d, 0x54, 0x31, 0x35, 0x32, 0x33, 0x56, 0x53, 0x30, 0x37, 0x34, 0x32,
                0x33, 0x20, 0x20, 0x20, 0x31, 0x35, 0x30, 0x37, 0x30, 0x32, 0x20, 0x20, 0x00, 0x00, 0x67, 0x56,
                0x31, 0x32, 0x38, 0x38, 0x35, 0x35, 0x32, 0x32, 0x33, 0x30, 0x58, 0x42, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
            },
        }
    },
    {
        .name = "oem-100g-3m",
        .rom = {
            0x11, 0x07, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x7d, 0xfa, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x2f, 0x22, 0x28, 0x20, 0xd7, 0x25, 0x71, 0x0c, 0x1c, 0x0c, 0x19, 0x0c, 0x15,
            0x0c, 0x1f, 0x26, 0x14, 0x26, 0x0a, 0x26, 0x33, 0x26, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        },
        .rom_page = {
            {
                0x11, 0xcc, 0x0c, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xff, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x03, 0x00, 0x4f, 0x45, 0x4d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x10, 0x00, 0x00, 0x00, 0x54, 0x4c, 0x50, 0x38, 0x35, 0x30, 0x4d, 0x32,
                0x38, 0x47, 0x51, 0x41, 0x23, 0x58, 0x58, 0x58, 0x41, 0x31, 0x42, 0x68, 0x07, 0xd0, 0x46, 0x82,
                0x02, 0x00, 0xfb, 0x98, 0x4d, 0x42, 0x31, 0x38, 0x32, 0x32, 0x32, 0x32, 0x30, 0x30, 0x30, 0x34,
                0x2d, 0x32, 0x20, 0x20, 0x31, 0x38, 0x30, 0x35, 0x32, 0x39, 0x20, 0x20, 0x0c, 0x00, 0x67, 0xa4,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x2e, 0x01, 0x00,
            },
            {
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            },
            {
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            },
            {
                0x55, 0x00, 0xf6, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x8c, 0xa0, 0x71, 0x48, 0x88, 0xb8, 0x79, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x62, 0x1f, 0x00, 0x9e, 0x3d, 0xe9, 0x01, 0x8e, 0x1d, 0x4c, 0x00, 0x00, 0x17, 0x70, 0x03, 0xe8,
                0x62, 0x1f, 0x03, 0x67, 0x43, 0xe2, 0x06, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            },
        }
    },
    {
        .name = "fiberstore-40g-150m",
        .rom = {
            0x0d, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xd1, 0x00, 0x00, 0x80, 0xb6, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x08, 0x5e, 0x07, 0xec, 0x08, 0x37,
            0x08, 0x19, 0x14, 0x17, 0x13, 0x05, 0x13, 0xb9, 0x13, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        },
        .rom_page = {
            {
                0x0d, 0x10, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x67, 0x00, 0x00, 0x4b,
                0x00, 0x00, 0x00, 0x00, 0x46, 0x69, 0x62, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x90, 0x65, 0x51, 0x53, 0x46, 0x50, 0x2d, 0x53, 0x52, 0x34,
                0x2d, 0x34, 0x30, 0x47, 0x20, 0x20, 0x20, 0x20, 0x42, 0x20, 0x42, 0x68, 0x07, 0xd0, 0x46, 0x6f,
                0x00, 0x01, 0x04, 0xd8, 0x46, 0x31, 0x36, 0x41, 0x43, 0x4f, 0x35, 0x36, 0x34, 0x38, 0x30, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x31, 0x36, 0x31, 0x30, 0x32, 0x36, 0x0a, 0x00, 0x00, 0xa0,
                0x00, 0x00, 0x08, 0x80, 0xb1, 0xf7, 0xfd, 0x4d, 0x0e, 0x8a, 0x36, 0xbf, 0x16, 0xde, 0x9e, 0x38,
                0xfe, 0xca, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x1c, 0x89, 0x80,
            },
            {
                0x0d, 0x10, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x67, 0x00, 0x00, 0x4b,
                0x00, 0x00, 0x00, 0x00, 0x46, 0x69, 0x62, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x90, 0x65, 0x51, 0x53, 0x46, 0x50, 0x2d, 0x53, 0x52, 0x34,
                0x2d, 0x34, 0x30, 0x47, 0x20, 0x20, 0x20, 0x20, 0x42, 0x20, 0x42, 0x68, 0x07, 0xd0, 0x46, 0x6f,
                0x00, 0x01, 0x04, 0xd8, 0x46, 0x31, 0x36, 0x41, 0x43, 0x4f, 0x35, 0x36, 0x34, 0x38, 0x30, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x31, 0x36, 0x31, 0x30, 0x32, 0x36, 0x0a, 0x00, 0x00, 0xa0,
                0x00, 0x00, 0x08, 0x80, 0xb1, 0xf7, 0xfd, 0x4d, 0x0e, 0x8a, 0x36, 0xbf, 0x16, 0xde, 0x9e, 0x38,
                0xfe, 0xca, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x1c, 0x89, 0x80,
            },
            {
                0x0d, 0x10, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x67, 0x00, 0x00, 0x4b,
                0x00, 0x00, 0x00, 0x00, 0x46, 0x69, 0x62, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x90, 0x65, 0x51, 0x53, 0x46, 0x50, 0x2d, 0x53, 0x52, 0x34,
                0x2d, 0x34, 0x30, 0x47, 0x20, 0x20, 0x20, 0x20, 0x42, 0x20, 0x42, 0x68, 0x07, 0xd0, 0x46, 0x6f,
                0x00, 0x01, 0x04, 0xd8, 0x46, 0x31, 0x36, 0x41, 0x43, 0x4f, 0x35, 0x36, 0x34, 0x38, 0x30, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x31, 0x36, 0x31, 0x30, 0x32, 0x36, 0x0a, 0x00, 0x00, 0xa0,
                0x00, 0x00, 0x08, 0x80, 0xb1, 0xf7, 0xfd, 0x4d, 0x0e, 0x8a, 0x36, 0xbf, 0x16, 0xde, 0x9e, 0x38,
                0xfe, 0xca, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x1c, 0x89, 0x80,
            },
            {
                0x0d, 0x10, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x67, 0x00, 0x00, 0x4b,
                0x00, 0x00, 0x00, 0x00, 0x46, 0x69, 0x62, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x90, 0x65, 0x51, 0x53, 0x46, 0x50, 0x2d, 0x53, 0x52, 0x34,
                0x2d, 0x34, 0x30, 0x47, 0x20, 0x20, 0x20, 0x20, 0x42, 0x20, 0x42, 0x68, 0x07, 0xd0, 0x46, 0x6f,
                0x00, 0x01, 0x04, 0xd8, 0x46, 0x31, 0x36, 0x41, 0x43, 0x4f, 0x35, 0x36, 0x34, 0x38, 0x30, 0x20,
                0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x31, 0x36, 0x31, 0x30, 0x32, 0x36, 0x0a, 0x00, 0x00, 0xa0,
                0x00, 0x00, 0x08, 0x80, 0xb1, 0xf7, 0xfd, 0x4d, 0x0e, 0x8a, 0x36, 0xbf, 0x16, 0xde, 0x9e, 0x38,
                0xfe, 0xca, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x1c, 0x89, 0x80,
            },
        }
    },
};

/**
 * Add a new device based on a bdk-config device string
 *
 * @param device     Device being added
 * @param config_str String from DEVICE in the bdk-config device tree
 */
static void add(bdk_device_t *device, const char *config_str)
{
    qsfp_state_t *qsfp_state = calloc(1, sizeof(qsfp_state_t));

    qsfp_state->max_power = bdk_driver_extract_int(config_str, "max_power", 0, 100000);
    qsfp_state->twsi = bdk_driver_extract_device(config_str, "twsi");
    qsfp_state->mod_sel = bdk_driver_extract_device_arg(config_str, "modsel", &qsfp_state->mod_sel_pin);
    qsfp_state->reset = bdk_driver_extract_device_arg(config_str, "reset", &qsfp_state->reset_pin);
    qsfp_state->mod_pres = bdk_driver_extract_device_arg(config_str, "modprs", &qsfp_state->mod_pres_pin);
    qsfp_state->intr = bdk_driver_extract_device_arg(config_str, "int", &qsfp_state->intr_pin);
    qsfp_state->lowp = bdk_driver_extract_device_arg(config_str, "lpmode", &qsfp_state->lowp_pin);

    device->priv.state = (uint64_t)qsfp_state;

    BDK_TRACE(DEVICE, "%s: QSFP with max power %d mWatts, TWSI=%s,\n"
                   "    MOD_SEL=%s(%d), RESET=%s(%d), MOD_PRES=%s(%d),\n"
                   "    INTR=%s(%d), LPMODE=%s(%d)\n",
        device->name, qsfp_state->max_power, qsfp_state->twsi->name,
        qsfp_state->mod_sel->name, qsfp_state->mod_sel_pin,
        qsfp_state->reset->name, qsfp_state->reset_pin,
        qsfp_state->mod_pres->name, qsfp_state->mod_pres_pin,
        qsfp_state->intr->name, qsfp_state->intr_pin,
        qsfp_state->lowp->name, qsfp_state->lowp_pin);
}

/**
 * Initialize the device, nothing needed
 *
 * @param device to initialize
 *
 * @return Zero on success, negative on failure
 */
static int init(bdk_device_t *device)
{
    return 0;
}

/**
 * Internal function for reading the state of QSFP GPIOs
 *
 * @param device    GPIO device
 * @param gpio      GPIO pin number
 * @param def_value Value to return if the GPIO device is NULL
 *
 * @return State of the GPIO
 */
static int gpio_read(bdk_device_t *device, int gpio, int def_value)
{
    if (!device)
        return def_value;

    int group = gpio / 64;
    int pin = gpio & 63;

    uint64_t gpios = bdk_device_gpio_readstate(device, group);
    return (gpios >> pin) & 1;
}

/**
 * Internal function for controlling QSFP output GPIOs. Does
 * nothing if the GPIO device is NULL
 *
 * @param device GPIO device
 * @param gpio   Pin to change
 * @param value  Value to set
 */
static void gpio_write(bdk_device_t *device, int gpio, int value)
{
    if (!device)
        return;

    int group = gpio / 64;
    int pin = gpio & 63;

    if (value)
        bdk_device_gpio_set1(device, group, 1ull << pin);
    else
        bdk_device_gpio_set0(device, group, 1ull << pin);
}

/**
 * Read the QSFP ROM information over TWSI
 *
 * @param device     QSFP device
 * @param qsfp_state QSFP port state to update
 */
static void rom_read(bdk_device_t *device, qsfp_state_t *qsfp_state)
{
    if (bdk_is_platform(BDK_PLATFORM_ASIM))
    {
        memcpy(qsfp_state->rom, ROM_TABLE[qsfp_state->asim_rom].rom, sizeof(qsfp_state->rom));
        memcpy(qsfp_state->rom_page, ROM_TABLE[qsfp_state->asim_rom].rom_page, sizeof(qsfp_state->rom_page));
        goto skip;
    }

    /* Clear ROM data before read */
    memset(qsfp_state->rom, 0, sizeof(qsfp_state->rom));
    memset(qsfp_state->rom_page, 0, sizeof(qsfp_state->rom_page));

    /* Select the module for access */
    gpio_write(qsfp_state->mod_sel, qsfp_state->mod_sel_pin, 0);

    const int twsi_addr = 0x50; /* From QSFP spec */
    const int twsi_ia_width = 1; /* One address byte for EEPROM */

    /* Loop through EEPROM at 0x50 */
    for (int addr = 0; addr < MAX_ROM_SIZE; addr += 4)
    {
        int64_t data = bdk_device_twsi_read_ia(qsfp_state->twsi, twsi_addr, addr, 4, twsi_ia_width);
        if (data < 0)
            goto skip;
        qsfp_state->rom[addr + 0] = bdk_extract(data, 24, 8);
        qsfp_state->rom[addr + 1] = bdk_extract(data, 16, 8);
        qsfp_state->rom[addr + 2] = bdk_extract(data, 8, 8);
        qsfp_state->rom[addr + 3] = bdk_extract(data, 0, 8);
    }

    bool flat_mem = qsfp_state->rom[2] & 4; /* Status bit 2 says if flatmem or paging */
    if (flat_mem)
        BDK_TRACE(BGX, "%s: QSFP is flat memory, no paging\n", device->name);

    /* Loop through EEPROM pages */
    for (int page = 0; page < (flat_mem ? 1 : 4); page++)
    {
        if (!flat_mem)
        {
            if (bdk_device_twsi_write_ia(qsfp_state->twsi, twsi_addr, 127, 1, 1, page))
                goto skip;
        }

        for (int addr = 0; addr < MAX_ROM_SIZE; addr += 4)
        {
            int64_t data = bdk_device_twsi_read_ia(qsfp_state->twsi, twsi_addr, addr + 128, 4, twsi_ia_width);
            if (data < 0)
                goto skip;
            qsfp_state->rom_page[page][addr + 0] = bdk_extract(data, 24, 8);
            qsfp_state->rom_page[page][addr + 1] = bdk_extract(data, 16, 8);
            qsfp_state->rom_page[page][addr + 2] = bdk_extract(data, 8, 8);
            qsfp_state->rom_page[page][addr + 3] = bdk_extract(data, 0, 8);
        }
    }
    /* Select page 0 again */
    if (!flat_mem)
        bdk_device_twsi_write_ia(qsfp_state->twsi, twsi_addr, 127, 1, 1, 0);

skip:
    /* Deselect the module for access */
    gpio_write(qsfp_state->mod_sel, qsfp_state->mod_sel_pin, 1);

    /* Check base checksum */
    uint8_t csum = 0;
    for (int i = 0; i < 63; i++)
        csum += qsfp_state->rom_page[0][i];
    if (csum != qsfp_state->rom_page[0][63])
        bdk_error("%s: QSFP page 0 base checksum incorrect\n", device->name);
    else
        BDK_TRACE(BGX, "%s: QSFP page 0 base checksum correct\n", device->name);

    /* Check extended checksum */
    csum = 0;
    for (int i = 64; i < 95; i++)
        csum += qsfp_state->rom_page[0][i];
    if (csum != qsfp_state->rom_page[0][95])
        bdk_error("%s: QSFP page 0 extended checksum incorrect\n", device->name);
    else
        BDK_TRACE(BGX, "%s: QSFP page 0 extended checksum correct\n", device->name);

    /* Check page 1 checksum */
    csum = 0;
    for (int i = 1; i < 128; i++)
        csum += qsfp_state->rom_page[1][i];
    if (csum != qsfp_state->rom_page[1][0])
        bdk_error("%s: QSFP page 1 checksum incorrect\n", device->name);
    else
        BDK_TRACE(BGX, "%s: QSFP page 1 checksum correct\n", device->name);
}

/**
 * Process the ROM and set QSFP state accordingly
 *
 * @param device  QSFP device
 * @param state   State returned to network driver
 * @param verbose Show information and errors
 */
static void rom_parse(bdk_device_t *device, bdk_device_netport_state_t *state, bool verbose)
{
    qsfp_state_t *qsfp_state = (qsfp_state_t *)device->priv.state;
    const bdk_qspd_page0_t *page0 = (bdk_qspd_page0_t *)qsfp_state->rom_page[0];

    /* Byte 0: Identifier, should be QSFP/QSFP+/QSFP28 */
    if ((page0->id != 0x0c /* QSFP */) &&
        (page0->id != 0x0d /* QSFP+ */) &&
        (page0->id != 0x11 /* QSFP28 */) &&
        (page0->id != 0x17 /* microQSFP */) &&
        (page0->id != 0x18 /* QSFP-DD */))
    {
        if (verbose)
            BDK_TRACE(BGX, "%s: QSFP/QSFP+ not detected (id=0x%x)\n", device->name, page0->id);
        state->flags |= BDK_DEVICE_NETPORT_FLAG_MISSING;
        state->max_speed = 0;
        return;
    }

    /* Power levels are enoded in 7:6 and 1:0 of EXT_ID */
    int low_power_mode = page0->ext_id >> 6;
    int high_power_mode = page0->ext_id & 3;
    int low_power = 0;
    switch (low_power_mode)
    {
        case 0:
            low_power = 1500;
            break;
        case 1:
            low_power = 2000;
            break;
        case 2:
            low_power = 2500;
            break;
        case 3:
            low_power = 3500;
            break;
    }
    int high_power = 0;
    if (high_power_mode)
        high_power = 3500 + 500 * high_power_mode;

    if (low_power > qsfp_state->max_power)
    {
        qsfp_state->force_unplug = true;
        if (verbose)
            bdk_error("%s: QSFP low power %dmW exceeds max power %dmW\n",
                device->name, low_power, qsfp_state->max_power);
    }

    if (high_power > qsfp_state->max_power)
    {
        qsfp_state->force_unplug = true;
        if (verbose)
            bdk_error("%s: QSFP high power %dmW exceeds max power %dmW\n",
                device->name, low_power, qsfp_state->max_power);
    }

    if (page0->bit_rate == 0xff)
        state->max_speed = 250 * page0->bit_rate_chan;
    else
        state->max_speed = 100 * page0->bit_rate;

    int transmit_tech = page0->technology >> 6;
    bool is_copper = (transmit_tech >= 0xa);
    int channels_implemented = qsfp_state->rom[113] & 0xf;
    int far_end = (qsfp_state->rom[113] >> 4) & 7;

    switch (far_end)
    {
        case 2: /* Two lanes */
        case 5: /* 2x2 breakout */
            state->flags |= BDK_DEVICE_NETPORT_FLAG_DUALLANE;
            break;
        case 3: /* One lane */
        case 4: /* 4x1 breakout */
        case 6: /* 2x1 breakout */
            break;
        case 1: /* Four lanes */
        default: /* Unspecified */
            state->flags |= BDK_DEVICE_NETPORT_FLAG_QUADLANE;
            break;
    }

    if (verbose)
    {
        printf("%s:\n"
            "    Vendor: %16.16s OUI:  %02x:%02x:%02x\n"
            "    Part:   %16.16s Rev:  %2.2s\n"
            "    Serial: %16.16s Date: 20%2.2s-%2.2s-%2.2s Lot: %2.2s\n",
            device->name, page0->vendor, page0->vendor_oui[0],
            page0->vendor_oui[1], page0->vendor_oui[2], page0->vendor_pn,
            page0->vendor_rev, page0->vendor_sn, page0->date_code,
            page0->date_code + 2, page0->date_code + 4, page0->date_code + 6);
        printf("    Low Power: %d mW, High Power: %dmW\n", low_power, high_power);
        if (state->max_speed)
            printf("    Nominal signalling rate: %d MBd\n", state->max_speed);
        if (page0->smf_1000m)
            printf("    SMF Length: %dm\n", 1000 * page0->smf_1000m);
        if (!is_copper && page0->length_1m_2m)
            printf("    OM4 Length: %dm\n", 2 * page0->length_1m_2m);
        if (page0->om3_2m)
            printf("    OM3 Length: %dm\n", 2 * page0->om3_2m);
        if (page0->om2_1m)
            printf("    OM2 Length: %dm\n", page0->om2_1m);
        if (page0->om1_1m)
            printf("    OM1 Length: %dm\n", page0->om1_1m);
        if (is_copper && page0->length_1m_2m)
            printf("    Cable Length: %dm\n", page0->length_1m_2m);
        if (page0->max_temp)
            printf("    Max Temperature: %dC\n", 1 * page0->max_temp);

        const char *TRANSMIT_TECH[] = {
            "850 nm VCSEL",
            "1310 nm VCSEL",
            "1550 nm VCSEL",
            "1310 nm FP",
            "1310 nm DFB",
            "1550 nm DFB",
            "1310 nm EML",
            "1550 nm EML",
            "Other / Undefined",
            "1490 nm DFB",
            "Copper cable unequalized",
            "Copper cable passive equalized",
            "Copper cable, near and far end limiting active equalizers",
            "Copper cable, far end limiting active equalizers",
            "Copper cable, near end limiting active equalizers",
            "Copper cable, linear active equalizers "
        };
        printf("    Transmitter Technology: %s\n", TRANSMIT_TECH[transmit_tech]);
        if (is_copper)
        {
            if (page0->wave_or_attn[0])
                printf("     Cable attenuation at 2.5 GHz: %ddB\n", page0->wave_or_attn[0]);
            if (page0->wave_or_attn[1])
                printf("     Cable attenuation at 5.0 GHz: %ddB\n", page0->wave_or_attn[1]);
            if (page0->wavet_or_attng[0])
                printf("     Cable attenuation at 7.0 GHz: %ddB\n", page0->wavet_or_attng[0]);
            if (page0->wavet_or_attng[1])
                printf("     Cable attenuation at 12.9 GHz: %ddB\n", page0->wavet_or_attng[1]);
        }
        else
        {
            int wavelen_x20 = 256 * page0->wave_or_attn[0] + page0->wave_or_attn[1];
            if (wavelen_x20)
                printf("     Wavelength: %d.%02dnm\n", wavelen_x20 / 20, 5 * (wavelen_x20 % 20));
            int wavetol_x200 = 256 * page0->wavet_or_attng[0] + page0->wavet_or_attng[1];
            if (wavetol_x200)
                printf("     Wavelength Tolerance: %d.%03dnm\n", wavetol_x200 / 200, 5 * (wavetol_x200 % 200));
        }
        if (channels_implemented)
            printf("     Channels Implemented: 0x%x\n", channels_implemented);
        const char *FAR_END[8] = {
            "Far end is unspecified",
            "4 channel connector",
            "2 channel connector",
            "1 channel connector",
            "4x1 break out",
            "2x2 break out",
            "2x1 break out",
            "Reserved"
        };
        printf("     Far End: %s\n", FAR_END[far_end]);
    }
}

/**
 * Network Port API function to initialize a port
 *
 * @param device Device to access
 */
static void netport_init(bdk_device_t *device)
{
    qsfp_state_t *qsfp_state = (qsfp_state_t *)device->priv.state;

    BDK_TRACE(BGX, "%s: Initializing QSFP GPIOs\n", device->name);

    /* Setup GPIOs for QSFP. Start with port disabled */
    bdk_device_gpio_setup(qsfp_state->mod_sel, qsfp_state->mod_sel_pin, true, 1, true, false);
    bdk_device_gpio_setup(qsfp_state->reset, qsfp_state->reset_pin, true, 1, true, false);
    bdk_device_gpio_setup(qsfp_state->mod_pres, qsfp_state->mod_pres_pin, false, 0, true, false);
    bdk_device_gpio_setup(qsfp_state->intr, qsfp_state->intr_pin, false, 0, true, false);
    bdk_device_gpio_setup(qsfp_state->lowp, qsfp_state->lowp_pin, true, 1, true, false);
}

/**
 * Network Port API function to set the state of a port
 *
 * @param device     Device to access
 * @param mode       QLM mode of the network port connected to the network port
 * @param baud_mhz   QLM rate in MHz
 * @param allow_link True if a link is allowed on the port
 * @param link_up    True if the current link is up, ready to move data
 */
static void netport_set(bdk_device_t *device, bdk_qlm_modes_t mode, int baud_mhz, bool allow_link, bool link_up)
{
    qsfp_state_t *qsfp_state = (qsfp_state_t *)device->priv.state;
    if (!allow_link && qsfp_state->allow_link)
    {
        BDK_TRACE(BGX, "%s: Resetting module\n", device->name);
        gpio_write(qsfp_state->lowp, qsfp_state->lowp_pin, 1);
        gpio_write(qsfp_state->reset, qsfp_state->reset_pin, 0);
        bdk_wait_usec(1000);
        gpio_write(qsfp_state->reset, qsfp_state->reset_pin, 1);
    }
    qsfp_state->allow_link = allow_link;
}

/**
 * Network Port API function to get the state of a network port
 *
 * @param device Device to access
 * @param state
 */
static void netport_get(bdk_device_t *device, bdk_device_netport_state_t *state)
{
    qsfp_state_t *qsfp_state = (qsfp_state_t *)device->priv.state;

    state->max_speed = 100000;
    state->flags = 0;

    if (qsfp_state->force_unplug || gpio_read(qsfp_state->mod_pres, qsfp_state->mod_pres_pin, 1))
    {
        BDK_TRACE(BGX, "%s: Module is missing\n", device->name);
        state->flags |= BDK_DEVICE_NETPORT_FLAG_MISSING;
    }

    if ((state->flags & BDK_DEVICE_NETPORT_FLAG_MISSING) && qsfp_state->module_present)
    {
        BDK_TRACE(BGX, "%s: Recording module removal\n", device->name);
        memset(qsfp_state->rom, 0, sizeof(qsfp_state->rom));
        qsfp_state->module_present = false;
        BDK_TRACE(BGX, "%s: Asserting reset and low power mode\n", device->name);
        gpio_write(qsfp_state->lowp, qsfp_state->lowp_pin, 1);
        gpio_write(qsfp_state->reset, qsfp_state->reset_pin, 0);
    }

    if (!(state->flags & BDK_DEVICE_NETPORT_FLAG_MISSING) && !qsfp_state->module_present)
    {
        BDK_TRACE(BGX, "%s: Recording module insert\n", device->name);
        qsfp_state->module_present = true;
        BDK_TRACE(BGX, "%s: Deasserting reset\n", device->name);
        gpio_write(qsfp_state->reset, qsfp_state->reset_pin, 1);
        bdk_wait_usec(1000);
        rom_read(device, qsfp_state);
        rom_parse(device, state, true);
    }
    else
        rom_parse(device, state, false);
}

/**
 * Network port API to force an unplug, regardless if the cable is still connected
 *
 * @param device Device to unplug
 */
static void netport_unplug(bdk_device_t *device)
{
    qsfp_state_t *qsfp_state = (qsfp_state_t *)device->priv.state;
    if (!qsfp_state->force_unplug)
    {
        BDK_TRACE(BGX, "%s: Forced unplug\n", device->name);
        qsfp_state->force_unplug = true;
    }
}

/**
 * Network port API to undo a force unplug. For some ports the string
 * argument can be used to control what is plugged in. For example, this
 * selects which emulated ROM is used for QSFPs in Asim.
 *
 * @param device Device to plug
 * @param param  Parameter for plug
 */
static void netport_plug(bdk_device_t *device, const char *param)
{
    qsfp_state_t *qsfp_state = (qsfp_state_t *)device->priv.state;
    if (!qsfp_state->force_unplug)
    {
        bdk_error("%s: Perform unplug first\n", device->name);
        return;
    }

    BDK_TRACE(BGX, "%s: Forced plug %s\n", device->name, param);

    for (int i = 0; i < (int)(sizeof(ROM_TABLE) / sizeof(ROM_TABLE[0])); i++)
    {
        if (strcmp(param, ROM_TABLE[i].name) == 0)
        {
            BDK_TRACE(BGX, "%s: Setting ROM index %d, %s\n", device->name, i, ROM_TABLE[i].name);
            qsfp_state->asim_rom = i;
            break;
        }
    }
    qsfp_state->force_unplug = false;
}

bdk_driver_t __bdk_driver_netport_qsfp28 = {
    .name = "NETPORT-QSFP28",
    .add = add,
    .init = init,
    .api = BDK_DEVICE_API_NETPORT,
    .funcs.netport.init = netport_init,
    .funcs.netport.set = netport_set,
    .funcs.netport.get = netport_get,
    .funcs.netport.unplug = netport_unplug,
    .funcs.netport.plug = netport_plug,
};
