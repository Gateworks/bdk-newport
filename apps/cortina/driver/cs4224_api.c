


#include "cs4224_api.h"

/** @file cs4224_diags.c
 ****************************************************************************
 *
 * @brief
 *    This module provides diagnostic methods to assist in debugging
 *    or bringup of the device.
 *
 ****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ***************************************************************************/

static cs4224_diags_duplex_loopback_state_t g_cs4224_duplex_loopback_line_state[CS4224_MAX_NUM_CS4343_PORTS] = 
{
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
static cs4224_diags_duplex_loopback_state_t g_cs4224_duplex_loopback_host_state[CS4224_MAX_NUM_CS4343_PORTS] =
{
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

static cs4224_diags_simplex_loopback_state_t g_cs4224_simplex_loopback_state[CS4224_MAX_NUM_CS4224_PORTS] = 
{
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}},
    {{FALSE, 0,0,0,0,0,0}, {FALSE, 0,0,0,0,0,0}}
};

cs_uint16 g_cs4224_simplex_valid_mate_slice[CS4224_MAX_NUM_CS4224_PORTS] = 
/* Rx slice     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13,14,15 */
/* Tx slice */ {1, 0, 4, 5, 2, 3, 7, 6,10,11, 8, 9, 15,14,13,12};

/**
 * This method is called to reset any static state used by the
 * driver to manage enabling/disabling of loopbacks.
 *
 * @param slice [I] - The slice/channel of the device to
 *                    reset the state for.
 */
void cs4224_diags_reset_static_state(cs_uint32 slice)
{
    if (cs4224_is_hw_duplex(slice))
    {
        cs4224_diags_duplex_loopback_state_t* state;

        state = &g_cs4224_duplex_loopback_line_state[slice&0x7];
        state->initialized = FALSE;
        
        state = &g_cs4224_duplex_loopback_host_state[slice&0x7];
        state->initialized = FALSE;
    }
    else
    {
        cs4224_diags_simplex_loopback_state_t* state;

        state = &g_cs4224_simplex_loopback_state[slice&0xf];
        state->slice_state.initialized      = FALSE;
        state->mate_slice_state.initialized = FALSE;
    }
}

#if (CS_HAS_DEBUG_LOOPBACKS == 1)

/**
 * This is an internal method used to save the line or host interface
 * context for when a digital loopback is enabled. 
 * This context will be written back to the chip when the
 * digital loopback is tore down.
 * 
 * @param slice  [I] - The slice upon which the loopback is applied.
 * @param intf   [I] - The interface or point where the loopback
 *                     will be set
 * @param state  [O] - A pointer to the structure where the context is saved.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_diags_duplex_loopback_save_state(
    cs_uint32                             slice, 
    e_cs4224_loopback_interface           intf,
    cs4224_diags_duplex_loopback_state_t *state) 
{
    cs_status status = CS_OK;

    state->initialized = TRUE;

    if (intf == CS4224_LOOPBK_LINE)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, &(state->stx0_misc));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->line_mseq_power_down));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->host_mseq_power_down));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config, &(state->rx0_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config, &(state->tx0_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXELST0_Control, &(state->rxelst0_control));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->line_clkout_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->host_clkout_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, &(state->clkdiv_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_CONTROL, &(state->rxlockd0_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, &(state->line_spare12));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, &(state->host_spare12));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW, &(state->mseq_options));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA, &(state->rx_cpa));
    }
    else /* CS4224_LOOPBK_HOST */
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, &(state->stx0_misc));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->host_mseq_power_down));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->line_mseq_power_down));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, &(state->rx0_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config, &(state->tx0_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXELST0_Control, &(state->rxelst0_control));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->host_clkout_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->line_clkout_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, &(state->clkdiv_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_CONTROL, &(state->rxlockd0_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, &(state->line_spare12));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, &(state->host_spare12));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW, &(state->mseq_options));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA, &(state->rx_cpa));
    }

    status |= cs4224_query_edc_mode(slice, CS4224_DPLX_HOST_MSEQ, &(state->host_edc_mode));
    status |= cs4224_query_edc_mode(slice, CS4224_DPLX_LINE_MSEQ, &(state->line_edc_mode));

    return status;
}

/**
 * This is an internal method used to restore the line or host interface
 * context for when a digital loopback is disabled. 
 * 
 * @param slice  [I] - The slice upon which the loopback is applied.
 * @param intf   [I] - The interface or point where the loopback
 *                     will be set
 * @param state  [I] - A pointer to the structure where the context is saved.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_diags_duplex_loopback_restore_state(
    cs_uint32                             slice, 
    e_cs4224_loopback_interface           intf,
    cs4224_diags_duplex_loopback_state_t *state) 
{
    cs_status status = CS_OK;

    state->initialized = FALSE;

    if (intf == CS4224_LOOPBK_LINE)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, (state->stx0_misc));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->line_mseq_power_down));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->host_mseq_power_down));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config, (state->rx0_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config, (state->tx0_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXELST0_Control, (state->rxelst0_control));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->line_clkout_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->host_clkout_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, (state->clkdiv_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_CONTROL, (state->rxlockd0_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, (state->line_spare12));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, (state->host_spare12));
     /* status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW, (state->mseq_options));*/
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA, (state->rx_cpa));
    }
    else /* CS4224_LOOPBK_HOST */
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, (state->stx0_misc));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->host_mseq_power_down));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->line_mseq_power_down));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, (state->rx0_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config, (state->tx0_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXELST0_Control, (state->rxelst0_control));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->host_clkout_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->line_clkout_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, (state->clkdiv_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_CONTROL, (state->rxlockd0_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, (state->line_spare12));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, (state->host_spare12));
     /* status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW, (state->mseq_options));*/
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA, (state->rx_cpa));
    }

    return status;
}

/**
 * This is an internal method used to save the interface
 * context for when an simplex loopback is enabled. 
 * This context will be written back to the chip when the
 * simplex loopback is tore down.
 * 
 * @param slice  [I] - The slice upon which the loopback is applied.
 * @param state  [O] - A pointer to the structure where the context is saved.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_diags_simplex_loopback_save_state(
    cs_uint32                                   slice, 
    cs4224_diags_simplex_loopback_slice_state_t *state) 
{
    cs_status status = CS_OK;

    state->initialized = TRUE;

    if (cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, &(state->stx0_misc));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &(state->rx_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->mseq_power_down));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, &(state->spare12));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG, &(state->dfe_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1, &(state->agc_config1));
    }
    else
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, &(state->stx0_misc));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &(state->rx_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->mseq_power_down));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, &(state->spare12));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG, &(state->dfe_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, &(state->agc_config1));
    }

    return status;
}

/**
 * This is an internal method used to restore the line or host interface
 * context for when an simplex loopback is tore down. 
 * 
 * @param slice  [I] - The slice upon which the loopback is applied.
 * @param state  [O] - A pointer to the structure where the context is saved.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_diags_simplex_loopback_restore_state(
    cs_uint32                                   slice, 
    cs4224_diags_simplex_loopback_slice_state_t *state) 
{
    cs_status status = CS_OK;

    state->initialized = FALSE;

    if (cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, (state->stx0_misc));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, (state->rx_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->mseq_power_down));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, (state->spare12));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG, (state->dfe_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1, (state->agc_config1));
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, (state->stx0_misc));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, (state->rx_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->mseq_power_down));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, (state->spare12));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG, (state->dfe_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, (state->agc_config1));
    }

    return status;
}

/**
 * This method queries the Duplex loopbacks on a port-pair slice of a Duplex device.
 * It is called to read the loopback type applied (if any) on the line and host interfaces
 * of the device. This method supports line/host near/far digital loopbacks. 
 * 
 *                     Line             Host
 *                    +---------------------+
 *                Rx -+---------->----------+- Tx ingress
 *                    | )   ( Digital )   ( |
 *                Tx -+----------<----------+- Rx egress
 *                    +---------------------+
 *                      1   2         3   4
 *              
 *                  Legend:
 *                  - 1, Line Digital Near
 *                  - 2, Host Digital Far
 *                  - 3, Line Digital Far
 *                  - 4, Host Digital Near
 *    
 * @param slice         [I] - The slice to the port of the device to access 
 * @param line_lb_type  [O] - The line interface loopback. 
 * @param host_lb_type  [O] - The host interface loopback. 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_query_loopbacks(
    cs_uint32           slice,
    e_cs4224_loopback*  line_lb_type,
    e_cs4224_loopback*  host_lb_type)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    *line_lb_type = CS4224_LOOPBK_DUPLEX_NONE;
    *host_lb_type = CS4224_LOOPBK_DUPLEX_NONE;

    if (cs4224_is_hw_simplex(slice))
    {
        CS_TRACE(("ERROR: Loopbacks query supported on Duplex chips only\n"));
        return CS_ERROR;
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config, &data);
    if ((data & 0x0001) == 0x0001)
    {
        /* data_source = TX Loopback Data */
        *line_lb_type = CS4224_LOOPBK_DUPLEX_FAR_DATA;
    }
    else
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config, &data);
        if ((data & 0x0003) == 0x0002)
        {
            /* data_source = RX Loopback Data */
            *line_lb_type = CS4224_LOOPBK_DUPLEX_NEAR_DATA;
        }
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, &data);
    if ((data & 0x0001) == 0x0001)
    {
        /* data_source = TX Loopback Data */
        *host_lb_type = CS4224_LOOPBK_DUPLEX_FAR_DATA;
    }
    else
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config, &data);
        if ((data & 0x0003) == 0x0002)
        {
            /* data_source = RX Loopback Data */
            *host_lb_type = CS4224_LOOPBK_DUPLEX_NEAR_DATA;
        }
    }
  
    return status;

}

/**
 * This method queries then dumps the Duplex loopbacks applied (if any) on a port-pair 
 * slice of a duplex devices.
 *    
 * @param slice         [I] - The slice to the port of the device to access 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_dump_loopbacks(
    cs_uint32  slice)
{
    cs_status status = CS_OK;
    e_cs4224_loopback line_lb_type, host_lb_type;

    status |= cs4224_diags_query_loopbacks(slice, &line_lb_type, &host_lb_type);
         
    CS_PRINTF(("+-----------------------------------+\n"));
    CS_PRINTF(("| Loopbacks Applied to Slice %2x     |\n",slice));
    CS_PRINTF(("+-----------------------------------+\n"));
    CS_PRINTF(("|   Line: "));
  
    if (line_lb_type == CS4224_LOOPBK_DUPLEX_NEAR_DATA)
    {
        CS_PRINTF((" Duplex Near              |\n"));
    } 
    else if (line_lb_type == CS4224_LOOPBK_DUPLEX_FAR_DATA)
    {
        CS_PRINTF((" Duplex Far               |\n"));
    }
    else
    {
        CS_PRINTF((" None                     |\n"));
    }
        
    CS_PRINTF(("|   Host: "));
    if (host_lb_type == CS4224_LOOPBK_DUPLEX_NEAR_DATA)
    {
        CS_PRINTF((" Duplex Near              |\n"));
    } 
    else if (host_lb_type == CS4224_LOOPBK_DUPLEX_FAR_DATA)
    {
        CS_PRINTF((" Duplex Far               |\n"));
    }
    else
    {
        CS_PRINTF((" None                     |\n"));
    }
    CS_PRINTF(("+-----------------------------------+\n"));

    return status;
}

/**
 * This method supports Digital loopbacks on a port-pair slice of a Duplex devices.
 * It is called to enable/disable loopbacks on one of the interfaces 
 * that the device supports. This method supports line/host near/far digital 
 * loopbacks. 
 * 
 * Digital Near loopbacks cannot co-exist with Digital Far loopbacks 
 * ie if an attempt is made to apply a Line Digital Near loopback while 
 * a Line Digital Far loopback is applied, the request will be refused 
 * with an error mesage. Line and Host loopbacks are independant of 
 * each other.
 * 
 * Illustration of the Digital loopback on a duplex port-pair slice.
 *    
 *                     Line             Host
 *                    +---------------------+
 *                Rx -+---------->----------+- Tx ingress
 *                    | )   ( Digital )   ( |
 *                Tx -+----------<----------+- Rx egress
 *                    +---------------------+
 *                      1   2         3   4
 *              
 *                  Legend:
 *                  - 1, Line Digital Near
 *                  - 2, Host Digital Far
 *                  - 3, Line Digital Far
 *                  - 4, Host Digital Near
 *    
 * Note: Loopbacks should only be used on a duplex device. Loopbacks
 *       cannot be combined with 2x2 protection switching.
 *
 * @param slice    [I] - The slice to the port of the device to access 
 * @param lb_type  [I] - The interface to loopback. 
 * @param intf     [I] - The interface or point where the loopback
 *                       will be set
 * @param enable   [I] - TRUE to enable the loopback or FALSE to disable the loopback
 * @param state    [I] - A pointer to a structure containg state information
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_diags_duplex_loopback_set(
    cs_uint32                             slice,
    e_cs4224_loopback                     lb_type,
    e_cs4224_loopback_interface           intf,
    cs_uint8                              enable,
    cs4224_diags_duplex_loopback_state_t* state)
{
    cs_status status = CS_OK;
    cs_uint16 data = 0;
    cs4224_rules_t rules;
    cs_boolean k2a2 = FALSE;

    if (cs4224_is_hw_simplex(slice))
    {
        CS_TRACE(("ERROR: Digital loopbacks supported on Duplex chips only\n"));
        return CS_ERROR;
    }
    /* Note that we can only have one type of loopback enabled at any time, 
       either a near or far digital loopback. The following
       section will bail out of this method with an error code if a near or
       far loopback is already applied. Line and host digital loopbacks can
       be applied at the same time however. Also note that the above static
       variables do not persist accross multiple python method calls. Use method
       cs4224_debug_loopback test for initialized flag testing.
    */
    
    /* Because we are not provided the configuration rules, we define some of them here 
        so that when we call edc_mode_intf to switch to SR, it will configure the bare minimum.
    */
    rules.application = CS4224_TARGET_APPLICATION_10G; /* define app as 10G so as to avoid CPA modifications */
    rules.rx_if.dplx_line_eq.traceloss = CS_HSIO_TRACE_LOSS_LAB; /* avoid equalizer changes */
    rules.rx_if.dplx_host_eq.traceloss = CS_HSIO_TRACE_LOSS_LAB; /* avoid equalizer changes */
    rules.advanced.phsel_bypass = FALSE; /* This should (almost) always be False */

    cs4224_lock(slice);

    if (enable)
    {
        if (intf == CS4224_LOOPBK_LINE)
        {
            /* check to see if Digital Near loopback already applied */
            if (state->initialized)
            {
                CS_TRACE(("ERROR: Digital loopback already applied\n"));
                cs4224_unlock(slice);
                return CS_ERROR;
            }
            /* save context prior to applying loopback to be restored when loopbacks are tore down */
            status = cs4224_diags_duplex_loopback_save_state(slice, CS4224_LOOPBK_LINE, state);

            /* if microsequencer is running */
            if (0 == (0x0008 & state->mseq_options)) 
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, TRUE);
            }

            if ((state->host_edc_mode != CS_HSIO_EDC_MODE_DISABLED) &&
                (state->host_edc_mode != CS_HSIO_EDC_MODE_SR))  
            {
                /* force host side EDC mode to SR
                 * Note: we don't care about traceloss here because the pre-eq
                 *   won't be used in a loopback, even if traceloss is garbage
                 */
                rules.rx_if.dplx_host_edc_mode = CS_HSIO_EDC_MODE_SR;
                status |= cs4224_init_edc_mode_intf(slice, &rules, CS4224_DPLX_HOST_MSEQ);
            }
        }
        else /* CS4224_LOOPBK_HOST */
        {
            /* check to see if Digital Near loopback already applied */
            if (state->initialized)
            {
                CS_TRACE(("ERROR: Digital loopback already applied\n"));
                cs4224_unlock(slice);
                return CS_ERROR;
            }
            /* save context prior to applying loopback to be restored when loopbacks are tore down */
            status = cs4224_diags_duplex_loopback_save_state(slice, CS4224_LOOPBK_HOST, state);

            /* if microsequencer is running */
            if (0 == (0x0008 & state->mseq_options)) 
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, TRUE);
            }

            if ((state->line_edc_mode != CS_HSIO_EDC_MODE_DISABLED) &&
                (state->line_edc_mode != CS_HSIO_EDC_MODE_SR))  
            {
                /* force line side EDC mode to SR
                 * Note: we don't care about traceloss here because the pre-eq
                 *   won't be used in a loopback, even if traceloss is garbage
                 */
                rules.rx_if.dplx_line_edc_mode = CS_HSIO_EDC_MODE_SR;
                status |= cs4224_init_edc_mode_intf(slice, &rules, CS4224_DPLX_LINE_MSEQ);
            }
        }
    }
    else /* disable */
    {
        cs_boolean stalled = TRUE;
        
        if (intf == CS4224_LOOPBK_LINE)
        {
            if (!state->initialized)
            {
                CS_TRACE(("ERROR: Digital loopback not applied\n"));
                cs4224_unlock(slice);
                return CS_ERROR;
            }
            
            /* warning about known limitation of this release */
            CS_TRACE(("WARNING: This method does not fully revert loopback state on the line side of slice 0x%x, this is a known limitation.\n", slice));
            
            /* stall LINE mseq while making changes */
            status |= cs4224_query_mseq_is_stalled(slice, CS4224_DPLX_LINE_MSEQ, &stalled);
            if(!stalled)
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, TRUE);
            }
            
            /* restore context to restore data-path to the state is was in prior to applying the loopback */
            status = cs4224_diags_duplex_loopback_restore_state(slice, CS4224_LOOPBK_LINE, state);

            if ((state->host_edc_mode != CS_HSIO_EDC_MODE_DISABLED) &&
                (state->host_edc_mode != CS_HSIO_EDC_MODE_SR))  
            {
                /* restore the host side EDC mode */
                rules.rx_if.dplx_host_edc_mode = state->host_edc_mode;
                /* traceloss only used in SR, don't care about restoring it */
                status |= cs4224_init_edc_mode_intf(slice, &rules, CS4224_DPLX_HOST_MSEQ);

                /* Revert the power savings register */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, state->host_spare12);
            }

            /* if HOST mseq was previously running */
            if (0 == (0x0008 & state->mseq_options)) 
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, FALSE);
            }
            
            /* unstall LINE mseq if it was running before we started this block */
            if(!stalled)
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
            }
        }
        else /* CS4224_LOOPBK_HOST */
        {
            if (!state->initialized)
            {
                CS_TRACE(("ERROR: Digital loopback not applied\n"));
                cs4224_unlock(slice);
                return CS_ERROR;
            }
            
            /* warning about known limitation of this release */
            CS_TRACE(("WARNING: This method does not fully revert loopback state on the host side of slice 0x%x, this is a known limitation.\n", slice));
            
            /* stall HOST mseq while making changes */
            status |= cs4224_query_mseq_is_stalled(slice, CS4224_DPLX_HOST_MSEQ, &stalled);
            if(!stalled)
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, TRUE);
            }
            
            /* restore context to restore data-path to the state is was in prior to applying the loopback */
            status = cs4224_diags_duplex_loopback_restore_state(slice, CS4224_LOOPBK_HOST, state);

            if ((state->line_edc_mode != CS_HSIO_EDC_MODE_DISABLED) &&
                (state->line_edc_mode != CS_HSIO_EDC_MODE_SR))  
            {
                /* restore the line side EDC mode */
                rules.rx_if.dplx_line_edc_mode = state->line_edc_mode;
                /* traceloss only used in SR, don't care about restoring it */
                status |= cs4224_init_edc_mode_intf(slice, &rules, CS4224_DPLX_LINE_MSEQ);

                /* Revert the power savings register */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, state->line_spare12);
            }
            
            /* if LINE mseq was previously running */
            if (0 == (0x0008 & state->mseq_options)) 
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
            }
            
            /* unstall HOST mseq if it was running before we started this block */
            if(!stalled)
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, FALSE);
            }
        }

        /* re-synch the elastic stores */
        cs4224_resync_elsto(slice, CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);
        cs4224_resync_elsto(slice, CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
        cs4224_resync_elsto(slice, CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);
        cs4224_resync_elsto(slice, CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);

        cs4224_unlock(slice);

        return status;
    }

    /* K2A2 has reworked loopbacks that need special settings
     * top bits of CHIP_ID_MSB are the version, with k2a2 being 0x7
     * this should work with all variants
     */
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_CHIP_ID_MSB, &data);
    if((data & 0xF000) == 0x7000)
    {
        k2a2 = TRUE;
    }
    else
    {
        k2a2 = FALSE;
    }

    /* disable squelch on both interfaces */
    status |= cs4224_mseq_squelch_ctrl(slice, CS4224_LINE_RX_TO_HOST_TX_DIR, FALSE);
    status |= cs4224_mseq_squelch_ctrl(slice, CS4224_HOST_RX_TO_LINE_TX_DIR, FALSE);

    /* unsquelch both Tx interfaces */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH, 0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH, 0);

    /* disable power savings on both interfaces */
    status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
    status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_HOST_MSEQ, FALSE);

    switch(lb_type)
    {
        /* Line and Host Interface Data Loopbacks in data sheet
         *
         * In order to setup the loopbacks it is necessary to set
         * looback enable bits in both the receiver and the transmitter.
         * Setting only one of the bits will cause problems.
         */

        cs_uint16 stx0_misc_addr;
        cs_uint16 rx0_config_addr;
        cs_uint16 tx0_config_addr;
        cs_uint16 clkout_ctrl_div64out_addr;
        cs_uint16 clkout_ctrl_refclk_addr;
        cs_uint16 rxcdr_clkdiv_ctrl_addr;
        cs_uint16 pfdcdr_clkdiv_ctrl_addr;
        cs_uint16 rxlockd0_ctrl_addr;
        cs_uint16 rxelst0_ctrl_addr;
        cs_uint16 txelst0_ctrl_addr;
        cs_uint16 txelst0_ctrl_addr_2;
        cs_uint16 rx_cpa_addr;
        cs_uint16 rx_config_addr;

        case CS4224_LOOPBK_DUPLEX_NEAR_DATA:
        {
            if (intf == CS4224_LOOPBK_LINE)
            {
                /* CS_PRINTF(("Applying a Digital Line Near Loopback\n")); */
                stx0_misc_addr            = CS4224_PP_LINE_SDS_COMMON_STX0_MISC;
                tx0_config_addr           = CS4224_PP_LINE_SDS_COMMON_TX0_Config;
                clkout_ctrl_div64out_addr = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                clkout_ctrl_refclk_addr   = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                pfdcdr_clkdiv_ctrl_addr   = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxcdr_clkdiv_ctrl_addr    = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxlockd0_ctrl_addr        = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_CONTROL;
                rxelst0_ctrl_addr         = CS4224_PP_LINE_SDS_COMMON_RXELST0_Control;
                txelst0_ctrl_addr         = CS4224_PP_LINE_SDS_COMMON_TXELST0_Control;
                rx_cpa_addr               = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA;
                rx_config_addr            = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG;
            }
            else
            {
                /* CS_PRINTF(("Applying a Digital Host Near Loopback\n")); */
                stx0_misc_addr            = CS4224_PP_HOST_SDS_COMMON_STX0_MISC;
                tx0_config_addr           = CS4224_PP_HOST_SDS_COMMON_TX0_Config;
                clkout_ctrl_div64out_addr = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                clkout_ctrl_refclk_addr   = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                pfdcdr_clkdiv_ctrl_addr   = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxcdr_clkdiv_ctrl_addr    = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxlockd0_ctrl_addr        = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_CONTROL;
                rxelst0_ctrl_addr         = CS4224_PP_HOST_SDS_COMMON_RXELST0_Control;
                txelst0_ctrl_addr         = CS4224_PP_HOST_SDS_COMMON_TXELST0_Control;
                rx_cpa_addr               = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA;
                rx_config_addr            = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG;
            }
            
            /* power-up mux, STX_EYEMODE_EN=0 */
            status |= cs4224_reg_get_channel(slice, stx0_misc_addr, &data);
            data &= ~0x11;
            status |= cs4224_reg_set_channel(slice, stx0_misc_addr, data);

            /* elastic stores require the other demux clock powered up, so trickle power-up both */ 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x001f);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x001f);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);

            status |= cs4224_reg_get_channel(slice, tx0_config_addr, &data);
            data |= 0x001a;  /* data_source is RX loopback data, BITSWAP True */
            status |= cs4224_reg_set_channel(slice, tx0_config_addr, data);
            
            if(k2a2)
            {
                /*rxcdr fastdiv_sel to div by 16 */
                status |= cs4224_reg_get_channel(slice, rxcdr_clkdiv_ctrl_addr, &data);
                data = CS_CLR(data, 0xf000);
                data = CS_SET(data, 0x1000);
                status |= cs4224_reg_set_channel(slice, rxcdr_clkdiv_ctrl_addr, data);
                
                /*pfdcdr rdiv to div by 16, ct[rv]div to div by 8 */
                status |= cs4224_reg_get_channel(slice, pfdcdr_clkdiv_ctrl_addr, &data);
                data = CS_CLR(data, 0x0f0f);
                data = CS_SET(data, 0x0f01);
                status |= cs4224_reg_set_channel(slice, pfdcdr_clkdiv_ctrl_addr, data);
                
                status |= cs4224_reg_get_channel(slice, rx_config_addr, &data);
                if (data & CS_BIT7)
                {
                    /* the ring oscillator requires different settings */
                    status |= cs4224_reg_set_channel(slice, rx_cpa_addr, 0x0044);
                }
                else
                {
                    /*rxcdr's rx_cpa to 0x99 */
                    status |= cs4224_reg_set_channel(slice, rx_cpa_addr, 0x0099);
                }
            }
            else
            {
                /*rxcdr div by 64 */
                status |= cs4224_reg_get_channel(slice, clkout_ctrl_div64out_addr, &data);
                data |= 0x4000;  /* SRX_DIV64OUT_EN True */
                status |= cs4224_reg_set_channel(slice, clkout_ctrl_div64out_addr, data);

                /*pfdcdr div by 64 */
                status |= cs4224_reg_get_channel(slice, pfdcdr_clkdiv_ctrl_addr, &data);
                data &= ~0x000f;
                data |= 0x0004;  /* SRX_RDIV_SEL = div by 64 */
                status |= cs4224_reg_set_channel(slice, pfdcdr_clkdiv_ctrl_addr, data);
            }
            
            /* PFD mode on the pfdcdr */
            status |= cs4224_reg_get_channel(slice, clkout_ctrl_refclk_addr, &data);
            data |= 0x8000;  /* SRX_REFCLK_SEL True */
            status |= cs4224_reg_set_channel(slice, clkout_ctrl_refclk_addr, data);

            status |= cs4224_reg_get_channel(slice, rxlockd0_ctrl_addr, &data);
            data |= 0x0001;  /* PD_MODE=0 and FORCE_LOCK=1 */
            status |= cs4224_reg_set_channel(slice, rxlockd0_ctrl_addr, data);

            /* re-synch the elastic stores */
            cs4224_resync_elsto(slice, rxelst0_ctrl_addr);
            cs4224_resync_elsto(slice, txelst0_ctrl_addr);
            
            break;
        }

        case CS4224_LOOPBK_DUPLEX_FAR_DATA:
        {
            if (intf == CS4224_LOOPBK_LINE)
            {
                /* CS_PRINTF(("Applying a Digital Line Far Loopback\n")); */
                stx0_misc_addr            = CS4224_PP_LINE_SDS_COMMON_STX0_MISC;
                rx0_config_addr           = CS4224_PP_HOST_SDS_COMMON_RX0_Config;
                tx0_config_addr           = CS4224_PP_LINE_SDS_COMMON_TX0_Config;
                clkout_ctrl_div64out_addr = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                clkout_ctrl_refclk_addr   = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                pfdcdr_clkdiv_ctrl_addr   = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxcdr_clkdiv_ctrl_addr    = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxlockd0_ctrl_addr        = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_CONTROL;
                rxelst0_ctrl_addr         = CS4224_PP_HOST_SDS_COMMON_RXELST0_Control;
                txelst0_ctrl_addr         = CS4224_PP_HOST_SDS_COMMON_TXELST0_Control;
                txelst0_ctrl_addr_2       = CS4224_PP_LINE_SDS_COMMON_TXELST0_Control;
                rx_cpa_addr               = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA;
                rx_config_addr            = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG;
            }
            else
            {
                /* CS_PRINTF(("Applying a Digital Host Far Loopback\n")); */
                stx0_misc_addr            = CS4224_PP_HOST_SDS_COMMON_STX0_MISC;
                rx0_config_addr           = CS4224_PP_LINE_SDS_COMMON_RX0_Config;
                tx0_config_addr           = CS4224_PP_HOST_SDS_COMMON_TX0_Config;
                clkout_ctrl_div64out_addr = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                clkout_ctrl_refclk_addr   = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
                pfdcdr_clkdiv_ctrl_addr   = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxcdr_clkdiv_ctrl_addr    = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
                rxlockd0_ctrl_addr        = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_CONTROL;
                rxelst0_ctrl_addr         = CS4224_PP_LINE_SDS_COMMON_RXELST0_Control;
                txelst0_ctrl_addr         = CS4224_PP_LINE_SDS_COMMON_TXELST0_Control;
                txelst0_ctrl_addr_2       = CS4224_PP_HOST_SDS_COMMON_TXELST0_Control;
                rx_cpa_addr               = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA;
                rx_config_addr            = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG;
            }
            
            /* power-up mux, STX_EYEMODE_EN=0 */
            status |= cs4224_reg_get_channel(slice, stx0_misc_addr, &data);
            data &= ~0x11;
            status |= cs4224_reg_set_channel(slice, stx0_misc_addr, data);

            /* elastic stores require the other demux clock powered up, so tricle power-up both */ 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x001f);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x001f);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);

            status |= cs4224_reg_get_channel(slice, rx0_config_addr, &data);
            data |= 0x0001;  /* data_source is TX loopback data */
            status |= cs4224_reg_set_channel(slice, rx0_config_addr, data);

            status |= cs4224_reg_get_channel(slice, tx0_config_addr, &data);
            data |= 0x0018;  /* data_source is DIG_TX_DIN, BITSWAP True */
            status |= cs4224_reg_set_channel(slice, tx0_config_addr, data);

            status |= cs4224_reg_get_channel(slice, rxelst0_ctrl_addr, &data);
            data &= ~0x0002;  /* do not use USE_LOCKDET True */
            status |= cs4224_reg_set_channel(slice, rxelst0_ctrl_addr, data);

            if(k2a2)
            {
                /*rxcdr fastdiv_sel to div by 16 */
                status |= cs4224_reg_get_channel(slice, rxcdr_clkdiv_ctrl_addr, &data);
                data = CS_CLR(data, 0xf000);
                data = CS_SET(data, 0x1000);
                status |= cs4224_reg_set_channel(slice, rxcdr_clkdiv_ctrl_addr, data);
                
                /*pfdcdr rdiv to div by 16, ct[rv]div to div by 8 */
                status |= cs4224_reg_get_channel(slice, pfdcdr_clkdiv_ctrl_addr, &data);
                data = CS_CLR(data, 0x0f0f);
                data = CS_SET(data, 0x0f01);
                status |= cs4224_reg_set_channel(slice, pfdcdr_clkdiv_ctrl_addr, data);
                
                status |= cs4224_reg_get_channel(slice, rx_config_addr, &data);
                if (data & CS_BIT7)
                {
                    /* the ring oscillator requires different settings */
                    status |= cs4224_reg_set_channel(slice, rx_cpa_addr, 0x0044);
                }
                else
                {
                    /*rxcdr's rx_cpa to 0x99 */
                    status |= cs4224_reg_set_channel(slice, rx_cpa_addr, 0x0099);
                }
            }
            else
            {
                /*rxcdr div by 64 */
                status |= cs4224_reg_get_channel(slice, clkout_ctrl_div64out_addr, &data);
                data |= 0x4000;  /* SRX_DIV64OUT_EN True */
                status |= cs4224_reg_set_channel(slice, clkout_ctrl_div64out_addr, data);

                /*pfdcdr div by 64 */
                status |= cs4224_reg_get_channel(slice, pfdcdr_clkdiv_ctrl_addr, &data);
                data &= ~0x000f;
                data |= 0x0004;  /* SRX_RDIV_SEL = div by 64 */
                status |= cs4224_reg_set_channel(slice, pfdcdr_clkdiv_ctrl_addr, data);
            }
            
            /* PFD mode on the pfdcdr */
            status |= cs4224_reg_get_channel(slice, clkout_ctrl_refclk_addr, &data);
            data |= 0x8000;  /* SRX_REFCLK_SEL True */
            status |= cs4224_reg_set_channel(slice, clkout_ctrl_refclk_addr, data);

            status |= cs4224_reg_get_channel(slice, rxlockd0_ctrl_addr, &data);
            data |= 0x0001;  /* PD_MODE=0 and FORCE_LOCK=1 */
            status |= cs4224_reg_set_channel(slice, rxlockd0_ctrl_addr, data);

            /* re-synch the elastic stores */
            cs4224_resync_elsto(slice, rxelst0_ctrl_addr);
            cs4224_resync_elsto(slice, txelst0_ctrl_addr);
            cs4224_resync_elsto(slice, txelst0_ctrl_addr_2);
            
            break;
        }

        default:
        {
            CS_TRACE(("ERROR: Invalid loopback type=%d\n", lb_type));
            cs4224_unlock(slice);
            return CS_ERROR;

        }
    }

    cs4224_unlock(slice);

    CS_UDELAY(5);

    return status;
}

/**
 * Simplex loopbacks are supported on Simplex devices only. This method supports 
 * Simplex loopbacks. Unlike digital loopbacks, simplex loopbacks do not loopback
 * on a port-pair. The two slices seem arbitrary, as can be seen in the following 
 * slice/mate association table.
 *
 * 16 port Simplex CS4224 slice/mate association table: 
 *
 *                          (16-port)  
 *                            CS4224   
 *                  Slice     Mate       Direction 
 *                    0        1     Rx (line to host) 
 *                    1        0     Rx (line to host)
 *                    2        4     Rx (line to host) 
 *                    3        5     Tx (host to line) 
 *                    4        2     Rx (line to host) 
 *                    5        3     Tx (host to line) 
 *                    6        7     Tx (host to line) 
 *                    7        6     Tx (host to line) 
 *                    8       10     Rx (line to host) 
 *                    9       11     Rx (line to host) 
 *                   10        8     Rx (line to host)
 *                   11        9     Rx (line to host)
 *                   12       15     Tx (host to line)
 *                   13       14     Tx (host to line)
 *                   14       13     Tx (host to line)
 *                   15       12     Tx (host to line)
 *
 * As can be seen from the above table, on a 16 port simplex CS4224 device, slice 14 
 * can be loopback to slice 13 or vice-versa.
 *
 * Illustration of the simplex loopback location
 *    
 *                         Line             Host
 *                        +---------------------+
 *                    Tx -+----------<-------+--+- Rx (port 13)
 *                        +------------------|--+
 *                                           |
 *                           +------->-------+
 *                           |
 *                        +--|------------------+
 *                    Tx -+--+-------<----------+- Rx (port 14)
 *                        +---------------------+
 *                  
 * @param slice    [I] - The receive (Rx) slice of the loopback
 * @param enable   [I] - TRUE to enable the loopback or FALSE to disable the loopback
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_diags_simplex_loopback_set(
    cs_uint32                              slice,
    cs_uint8                               enable,
    cs4224_diags_simplex_loopback_state_t* state)
{
    cs_status status = CS_OK;
    cs_uint32 mate_slice;
    cs_uint16 data = 0;
    cs_uint16 stx0_misc_addr;
    cs_uint16 rx0_config_addr;
    cs_uint16 rxelst0_addr;
    cs_uint16 txelst0_addr;
    cs_uint16 power_down_addr;     
    cs_uint16 prbs_mseq_spare12;
    cs_uint16 dfe_config;
    cs_uint16 agc_config;

    if (cs4224_is_hw_duplex(slice))
    {
        CS_TRACE(("ERROR: Simplex loopbacks supported on Simplex devices only\n"));
        return CS_ERROR;
    }

    mate_slice = (slice & 0xffffff00) | g_cs4224_simplex_valid_mate_slice[slice&0xf];

    if (cs4224_line_rx_to_host_tx_dir(slice))
    {
        /* CS_PRINTF(("Rx and Tx slices dir are line rx to host tx\n")); */
        stx0_misc_addr    = CS4224_PP_HOST_SDS_COMMON_STX0_MISC;
        rx0_config_addr   = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG;
        rxelst0_addr      = CS4224_PP_LINE_SDS_COMMON_RXELST0_Control;
        txelst0_addr      = CS4224_PP_HOST_SDS_COMMON_TXELST0_Control;
        power_down_addr   = CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        prbs_mseq_spare12 = CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB;
        dfe_config        = CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG;
        agc_config        = CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1;
    }
    else
    {
        /* CS_PRINTF(("Rx and Tx slices dir are host rx to line tx\n")); */
        stx0_misc_addr    = CS4224_PP_LINE_SDS_COMMON_STX0_MISC;
        rx0_config_addr   = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG;
        rxelst0_addr      = CS4224_PP_HOST_SDS_COMMON_RXELST0_Control;
        txelst0_addr      = CS4224_PP_LINE_SDS_COMMON_TXELST0_Control;
        power_down_addr   = CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        prbs_mseq_spare12 = CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB;
        dfe_config        = CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG;
        agc_config        = CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1;
    }

    cs4224_lock(slice);
    cs4224_lock(mate_slice);

    if (TRUE == enable)
    {
        /* check to see if simplex loopback already applied */
        if (state->slice_state.initialized)
        {
            CS_TRACE(("ERROR: Simplex loopback already applied\n"));
            cs4224_unlock(slice);
            cs4224_unlock(mate_slice);
            return CS_ERROR;
        }

        /* CS_PRINTF(("Simplex Loopback, Enable\n"));*/

        /* save context prior to applying loopback to be restored when loopbacks are tore down */
        status = cs4224_diags_simplex_loopback_save_state(slice,      &(state->slice_state));
        status = cs4224_diags_simplex_loopback_save_state(mate_slice, &(state->mate_slice_state));

        status |= cs4224_reg_get_channel(mate_slice, prbs_mseq_spare12, &data);
        data &= ~0x0006; /* disable squelch and power savings */
        status |= cs4224_reg_set_channel(mate_slice, prbs_mseq_spare12, data);

        status |= cs4224_reg_get_channel(slice, prbs_mseq_spare12, &data);
        data &= ~0x0006; /* disable squelch and power savings */
        status |= cs4224_reg_set_channel(slice, prbs_mseq_spare12, data);

        CS_UDELAY(5);

        /* tricle power-up demux */
        status |= cs4224_reg_set_channel(mate_slice, power_down_addr, 0x001f); 
        status |= cs4224_reg_set_channel(slice, power_down_addr, 0x001f); 
        status |= cs4224_reg_set_channel(mate_slice, power_down_addr, 0x0000); 
        status |= cs4224_reg_set_channel(slice, power_down_addr, 0x0000); 

        status |= cs4224_reg_get_channel(mate_slice, rx0_config_addr, &data);
        data |= 0x0001;  /* SRX_LPBK_EN=1 */
        status |= cs4224_reg_set_channel(mate_slice, rx0_config_addr, data);

        status |= cs4224_reg_get_channel(slice, stx0_misc_addr, &data);
        data |= 0x0008; /* STX_LPBK_EN=1 */
        status |= cs4224_reg_set_channel(slice, stx0_misc_addr, data);

        /* enable the DFE path, the simplex loopback requires it */
        status |= cs4224_reg_get_channel(mate_slice, dfe_config, &data);
        data &= ~0x0001; /* SRX_DFE_BYPASS_EN = 0 */
        data = 0x0440;
        status |= cs4224_reg_set_channel(mate_slice, dfe_config, data);

        status |= cs4224_reg_get_channel(mate_slice, agc_config, &data); 
        data |= 0x0001; /* SRX_AGC_ENB_LIMAMP = 1 */
        status |= cs4224_reg_set_channel(mate_slice, agc_config, data); 
    }
    else
    {
        if (!state->slice_state.initialized)
        {
            CS_TRACE(("ERROR: Simplex loopback not applied\n"));
            cs4224_unlock(slice);
            cs4224_unlock(mate_slice);
            return CS_ERROR;
        }

        /* CS_PRINTF(("Simplex Loopback, Disable\n")); */

        /* restore context to restore data-path to the state is was in prior to applying the loopback */
        status = cs4224_diags_simplex_loopback_restore_state(slice,      &(state->slice_state));
        status = cs4224_diags_simplex_loopback_restore_state(mate_slice, &(state->mate_slice_state));
    }

    /* re-synch the Rx elastic stores */
    cs4224_resync_elsto(slice,      rxelst0_addr);
    cs4224_resync_elsto(mate_slice, rxelst0_addr);

    /* re-synch the Tx elastic stores */
    cs4224_resync_elsto(slice,      txelst0_addr);
    cs4224_resync_elsto(mate_slice, txelst0_addr);

    cs4224_unlock(slice);
    cs4224_unlock(mate_slice);

    CS_UDELAY(5);

    return status;
}

/**
 * This method is called to enable a digital loopback on one of the interfaces 
 * of the device. 
 *
 *
 * @param slice   [I] -  The slice to the port of the device to access 
 * @param lb_type [I] -  The interface to loopback. 
 * @param intf    [I] -  The interface or point where the loopback
 *                       will be set
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_duplex_loopback_enable 
 *   instead.
 */
cs_status cs4224_diags_loopback_enable(
        cs_uint32                   slice,
        e_cs4224_loopback           lb_type,
        e_cs4224_loopback_interface intf)
{
    cs_status status = CS_OK;
    cs4224_diags_duplex_loopback_state_t* state;

    if (CS4224_LOOPBK_LINE == intf)
    {
        state = &g_cs4224_duplex_loopback_line_state[slice&0x7];
    }
    else
    {
        state = &g_cs4224_duplex_loopback_host_state[slice&0x7];
    }

    status |= cs4224_diags_duplex_loopback_set(
                  slice, 
                  lb_type, 
                  intf, 
                  TRUE, 
                  state);
    
    return status;
}

/**
 * This method is called to disable a digital loopback that had previously
 * been applied to an interface of the device.
 * 
 *       instead.
 *
 * @param slice   [I] -  The slice to the port of the device to access 
 * @param lb_type [I] -  The interface to disable loopback on. 
 * @param intf    [I] -  The interface or point where the loopback
 *                       will be set
 *
 * @return CS_OK on success, CS_ERROR on failure
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_duplex_loopback_disable 
 */
cs_status cs4224_diags_loopback_disable(
        cs_uint32                   slice,
        e_cs4224_loopback           lb_type,
        e_cs4224_loopback_interface intf)
{
    cs_status status = CS_OK;
    cs4224_diags_duplex_loopback_state_t* state;

    if (CS4224_LOOPBK_LINE == intf)
    {
        state = &g_cs4224_duplex_loopback_line_state[slice&0x7];
    }
    else
    {
        state = &g_cs4224_duplex_loopback_host_state[slice&0x7];
    }

    status |= cs4224_diags_duplex_loopback_set(
                  slice, 
                  lb_type, 
                  intf, 
                  FALSE, 
                  state);
    
    return status;
}

/**
 * This method is called to enable a digital loopback on one of the interfaces 
 * of the device. 
 *
 *
 * @param slice   [I] -  The slice to the port of the device to access 
 * @param lb_type [I] -  The interface to loopback. 
 * @param intf    [I] -  The interface or point where the loopback
 *                       will be set
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_duplex_loopback_enable 
 *   instead.
 */
cs_status cs4224_diags_digital_loopback_enable(
        cs_uint32                   slice,
        e_cs4224_loopback           lb_type,
        e_cs4224_loopback_interface intf)
{
    cs_status status = CS_OK;
    cs4224_diags_duplex_loopback_state_t* state;

    if (CS4224_LOOPBK_LINE == intf)
    {
        state = &g_cs4224_duplex_loopback_line_state[slice&0x7];
    }
    else
    {
        state = &g_cs4224_duplex_loopback_host_state[slice&0x7];
    }

    status |= cs4224_diags_duplex_loopback_set(
                  slice, 
                  lb_type, 
                  intf, 
                  TRUE, 
                  state);
    
    return status;
}

/**
 * This method is called to disable a digital loopback that had previously
 * been applied to an interface of the device.
 * 
 *
 * @param slice   [I] -  The slice to the port of the device to access 
 * @param lb_type [I] -  The interface to disable loopback on. 
 * @param intf    [I] -  The interface or point where the loopback
 *                       will be set
 *
 * @return CS_OK on success, CS_ERROR on failure
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_duplex_loopback_disable 
 *   instead.
 */
cs_status cs4224_diags_digital_loopback_disable(
        cs_uint32                   slice,
        e_cs4224_loopback           lb_type,
        e_cs4224_loopback_interface intf)
{
    cs_status status = CS_OK;
    cs4224_diags_duplex_loopback_state_t* state;

    if (CS4224_LOOPBK_LINE == intf)
    {
        state = &g_cs4224_duplex_loopback_line_state[slice&0x7];
    }
    else
    {
        state = &g_cs4224_duplex_loopback_host_state[slice&0x7];
    }

    status |= cs4224_diags_duplex_loopback_set(
                  slice, 
                  lb_type, 
                  intf, 
                  FALSE, 
                  state);
    
    return status;
}

/**
 * This method is called to enable a duplex loopback on one of the interfaces 
 * of the device. 
 *
 * @param slice   [I] -  The slice to the port of the device to access 
 * @param lb_type [I] -  The interface to loopback. 
 * @param intf    [I] -  The interface or point where the loopback
 *                       will be set
 * @param state   [I] -  A pointer to a structure containg state information
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_duplex_loopback_enable(
        cs_uint32                             slice,
        e_cs4224_loopback                     lb_type,
        e_cs4224_loopback_interface           intf,
        cs4224_diags_duplex_loopback_state_t* state)
{
    cs_status status = CS_OK;

    status |= cs4224_diags_duplex_loopback_set(
                  slice, 
                  lb_type, 
                  intf, 
                  TRUE, 
                  state);
    
    return status;
}

/**
 * This method is called to disable a digital loopback that had previously
 * been applied to an interface of the device.
 * 
 * @param slice   [I] -  The slice to the port of the device to access 
 * @param lb_type [I] -  The interface to disable loopback on. 
 * @param intf    [I] -  The interface or point where the loopback
 *                       will be set
 * @param state   [I] -  A pointer to a structure containg state information
 *
 * @return CS_OK on success, CS_ERROR on failure
 *
 */
cs_status cs4224_diags_duplex_loopback_disable(
        cs_uint32                             slice,
        e_cs4224_loopback                     lb_type,
        e_cs4224_loopback_interface           intf,
        cs4224_diags_duplex_loopback_state_t* state)
{
    cs_status status = CS_OK;

    status |= cs4224_diags_duplex_loopback_set(
                  slice, 
                  lb_type, 
                  intf, 
                  FALSE, 
                  state);
    
    return status;
}

/**
 * This method is called to enable an analog loopback across two slices.
 *
 * @param slice   [I] -  The receive (Rx) slice of the loopback
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_simplex_loopback_enable 
 *   instead.
 */
cs_status cs4224_diags_analog_loopback_enable(
        cs_uint32   slice)
{
    cs_status status = CS_OK;

    status |= cs4224_diags_simplex_loopback_set(
                  slice, 
                  TRUE, 
                  &g_cs4224_simplex_loopback_state[slice&0xf]);
    
    return status;
}

/**
 * This method is called to disable an analog loopback across two slices.
 * 
 * @param slice   [I] -  The receive (Rx) slice of the loopback
 *
 * @return CS_OK on success, CS_ERROR on failure
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_simplex_loopback_disable 
 *   instead.
 */
cs_status cs4224_diags_analog_loopback_disable(
        cs_uint32   slice)
{
    cs_status status = CS_OK;

    status |= cs4224_diags_simplex_loopback_set(
                  slice, 
                  FALSE, 
                  &g_cs4224_simplex_loopback_state[slice&0xf]);
    
    return status;
}

/**
 * This method is called to enable an simplex loopback across two slices.
 *
 * @param slice   [I] -  The receive (Rx) slice of the loopback
 * @param state   [I] -  A pointer to a structure containg state information
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_simplex_loopback_enable(
        cs_uint32                              slice,
        cs4224_diags_simplex_loopback_state_t* state)
{
    cs_status status = CS_OK;

    status |= cs4224_diags_simplex_loopback_set(
                  slice, 
                  TRUE, 
                  state);
    
    return status;
}

/**
 * This method is called to disable an simplex loopback across two slices.
 * 
 * @param slice   [I] -  The receive (Rx) slice of the loopback
 * @param state   [I] -  A pointer to a structure containg state information
 *
 * @return CS_OK on success, CS_ERROR on failure
 */
cs_status cs4224_diags_simplex_loopback_disable(
        cs_uint32                              slice,
        cs4224_diags_simplex_loopback_state_t* state)
{
    cs_status status = CS_OK;

    status |= cs4224_diags_simplex_loopback_set(
                  slice, 
                  FALSE, 
                  state);
    
    return status;
}

#endif /* CS_HAS_DEBUG_LOOPBACKS == 1 */

#if (CS_HAS_DEBUG_PRBS == 1)

/**
 * This method is used in simplex mode to determine which checker
 * is associated with the target slice/channel. 
 *
 * @param slice [I] - The slice or channel of the device to access.
 *
 * @return CS4224_PRBS_LINE_INTERFACE or CS4224_HOST_INTERFACE depending
 *         on which PRBS checker is associated with this channel.
 *
 * @private
 */
e_cs4224_prbs_interface cs4224_diags_prbs_simplex_get_checker(cs_uint32 slice)
{
    if(cs4224_is_hw_simplex(slice))
    {
        if(cs4224_line_rx_to_host_tx_dir(slice))
        {
            return CS4224_PRBS_LINE_INTERFACE;
        }
        else
        {
            return CS4224_PRBS_HOST_INTERFACE;
        }
    }

    /* If it is not simplex just default to the line interface */
    return CS4224_PRBS_LINE_INTERFACE;
}

/**
 * This method is used in simplex mode to determine which generator
 * is associated with the target slice/channel. 
 *
 * @param slice [I] - The slice or channel of the device to access.
 *
 * @return CS4224_PRBS_LINE_INTERFACE or CS4224_HOST_INTERFACE depending
 *         on which PRBS generator is associated with this channel.
 *
 * @private
 */
e_cs4224_prbs_interface cs4224_diags_prbs_simplex_get_generator(cs_uint32 slice)
{
    if(cs4224_is_hw_simplex(slice))
    {
        if(cs4224_line_rx_to_host_tx_dir(slice))
        {
            return CS4224_PRBS_HOST_INTERFACE;
        }
        else
        {
            return CS4224_PRBS_LINE_INTERFACE;
        }
    }

    /* If it is not simplex just default to the line interface */
    return CS4224_PRBS_LINE_INTERFACE;
}

/**
 * This is an internal method used to set the bitswap
 * bit when configuring the PRBS generator or checker.
 * 
 * @param slice    [I] - The slice of the adapter to configure.
 * @param prbs_sel [I] - The PRBS generator or checker
 * @param is_rx    [I] - The RX or the TX direction
 * @param enable   [I] - 1 to set the bit or 0
 *                       to clear it.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_diags_prbs_set_bitswap(
    cs_uint32               slice,
    e_cs4224_prbs_interface prbs_sel,
    cs_boolean              is_rx,
    cs_boolean              enable)
{
    cs_status status = CS_OK;
    cs_uint16 tx_config_addr;
    cs_uint16 rx_config_addr;
    cs_uint16 data = 0;
    
    switch(prbs_sel)
    {
        case CS4224_PRBS_HOST_INTERFACE:
        {
            tx_config_addr = CS4224_PP_HOST_SDS_COMMON_TX0_Config;
            rx_config_addr = CS4224_PP_HOST_SDS_COMMON_RX0_Config;

            break;
        }
        case CS4224_PRBS_LINE_INTERFACE:
        {
            tx_config_addr = CS4224_PP_LINE_SDS_COMMON_TX0_Config;
            rx_config_addr = CS4224_PP_LINE_SDS_COMMON_RX0_Config;
            break;
        }
        default:
        { 
            CS_TRACE(("ERROR: Invalid prbs_sel=%d\n", prbs_sel));
            return CS_ERROR;
        }
    }

    cs4224_lock(slice);

    if(!is_rx)
    {
        /* Set or clear the bitswap bit for the Tx */
        status |= cs4224_reg_get_channel(slice, tx_config_addr, &data);
        if(enable)
        {
            data |= 0x8;
        }
        else
        {
            data &= ~0x8;
        }
        status |= cs4224_reg_set_channel(slice, tx_config_addr, data);
    }
    else
    {
        /* Set the bitswap bit for the Rx  */
        status |= cs4224_reg_get_channel(slice, rx_config_addr, &data);
        if(enable)
        {
            data |= 0x8;
        }
        else
        {
            data &= ~0x8;
        }
        status |= cs4224_reg_set_channel(slice, rx_config_addr, data);
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * Configure the PRBS generator for transmit 
 *
 * NOTE: Some of the config here cannot be reversed without saving state. To fully
 * reverse the config run cs4224_slice_enter_operational_state to reconfig the slice.
 * 
 * @param slice       [I] -  The slice to the port of the device to access 
 * @param prbs_sel    [I] -  Which of the PRBS generator to configure (LINE/HOST/SPLX)
 * @param polynomial  [I] -  Select the polynomial used to generate the pattern 
 * @param invert      [I] -  TRUE to invert the pattern, FALSE leaves the pattern as is. 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_prbs_generator_config(
        cs_uint32                slice,
        e_cs4224_prbs_interface  prbs_sel,
        e_cs4224_prbs_polynomial polynomial,
        cs_uint8                 invert)
{
    /* Any modifications here should go in cs4224_diags_fix_ptrn_generator_cfg as well */
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 prbs_cfg_addr;
    cs_uint16 stx0_misc_addr;
    e_cs4224_mseq_id mseq_id;
    
    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_generator(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    cs4224_lock(slice);
    
    if (CS4224_PRBS_HOST_INTERFACE == prbs_sel)
    {
        stx0_misc_addr       = CS4224_PP_HOST_SDS_COMMON_STX0_MISC;
        prbs_cfg_addr        = CS4224_PP_HOST_SDS_COMMON_PRBSGEN0_Cfg;
        mseq_id              = CS4224_DPLX_LINE_MSEQ;
    }
    else /* CS4224_PRBS_LINE_INTERFACE */
    {
        stx0_misc_addr       = CS4224_PP_LINE_SDS_COMMON_STX0_MISC;
        prbs_cfg_addr        = CS4224_PP_LINE_SDS_COMMON_PRBSGEN0_Cfg;
        mseq_id              = CS4224_DPLX_HOST_MSEQ;
    } 

    /* Disable power savings to get the generator to function
     * correctly */
    cs4224_mseq_enable_power_savings(slice, mseq_id, FALSE);

    status |= cs4224_reg_get_channel(slice, stx0_misc_addr, &data);
    data &= ~0x0011; /* power-up mux, STX_EYEMODE_EN=0 */
    status |= cs4224_reg_set_channel(slice, stx0_misc_addr, data);

    status |= cs4224_reg_get_channel(slice, prbs_cfg_addr, &data);
    /* Clear and set the polynomial */
    data &= ~0x70;
    data |= ((cs_uint16)polynomial << 4);
    /* Set the invert bit if required */ 
    if(invert)
    {
        data |= 0x4;
    }
    else
    {
        data &= ~0x4;
    }
    /* Clear the fixed pattern enable and the prbs gen enable bits */
    data = CS_CLR(data,0x3);
    status |= cs4224_reg_set_channel(slice, prbs_cfg_addr, data);

    cs4224_unlock(slice);

    return status;
}

/**
 * Enable or disable the PRBS generator.
 *
 *  @param slice     [I] -  The slice to the port of the device to access 
 *  @param prbs_sel  [I] -  The PRBS generator to enable/disable (HOST or LINE) 
 *  @param enable    [I] -  Set to TRUE to enable, FALSE to disable 
 *
 *  @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_prbs_generator_enable(
        cs_uint32               slice,
        e_cs4224_prbs_interface prbs_sel,
        cs_uint8                enable)
{
    /* Any modifications here should go in cs4224_diags_fix_ptrn_generator_enable as well */
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 prbs_cfg_addr;
    cs_uint16 tx_cfg_addr;
    
    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_generator(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    switch(prbs_sel)
    {
        case CS4224_PRBS_HOST_INTERFACE:
        {
            prbs_cfg_addr  = CS4224_PP_HOST_SDS_COMMON_PRBSGEN0_Cfg;
            tx_cfg_addr    = CS4224_PP_HOST_SDS_COMMON_TX0_Config;
            break;
        }
        case CS4224_PRBS_LINE_INTERFACE:
        {
            prbs_cfg_addr  = CS4224_PP_LINE_SDS_COMMON_PRBSGEN0_Cfg;
            tx_cfg_addr    = CS4224_PP_LINE_SDS_COMMON_TX0_Config;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Invalid prbs_sel=%d\n", prbs_sel));
            return CS_ERROR;
        }
    }
    cs4224_lock(slice);
    
    status |= cs4224_reg_get_channel(slice, prbs_cfg_addr, &data);
    data = CS_CLR(data, 0x3);
    if(enable)
    {
        /* prbs gen enable */
        data |= CS_BIT0;
    }
    status |= cs4224_reg_set_channel(slice, prbs_cfg_addr, data);
    
    if(enable)
    {
        /* Enable bitswap in TX direction */
        status |= cs4224_diags_prbs_set_bitswap(slice, prbs_sel, FALSE, TRUE);
        
        status |= cs4224_reg_get_channel(slice, tx_cfg_addr, &data);
        data = CS_CLR(data, 0x3);
        /* data_source = PRBS */
        data |= 0x01;
        status |= cs4224_reg_set_channel(slice, tx_cfg_addr, data);

    }
    else
    {
        CS_TRACE(("WARNING: Not all config is rolled back when disabling PRBS generator. Reconfigure slice 0x%x to roll back all config\n",slice));
        
        /* By default bitswap is enabled. Now this is something we need to cache and save
         * outside of the API so that we can roll it back when we disable PRBS generation.
         * For now, just leave this commented out so we don't disable bitswap and we
         * allow traffic to pass through the part.
         */
        /* Disable bitswap in TX direction */
        /*status |= cs4224_diags_prbs_set_bitswap(slice, prbs_sel, FALSE, FALSE);*/

        status |= cs4224_reg_get_channel(slice, tx_cfg_addr, &data);
        /* data_source = DIG_TX_DIN */
        data = CS_CLR(data, 0x3);
        status |= cs4224_reg_set_channel(slice, tx_cfg_addr, data);
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * This method is used to configure the error insertion attributes
 * of the PRBS generator.
 *
 * @param slice    [I] - The slice of the device to configure error
 *                     injection on.
 * @param prbs_sel [I] - The PRBS interface to inject errors on.
 * @param mode     [I] - The selected error injection mode.
 * @param enable   [I] - TRUE to enable the mode, FALSE to disable it.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_prbs_generator_set_error_ctrl(
    cs_uint32                  slice,
    e_cs4224_prbs_interface    prbs_sel,
    e_cs4224_prbsgen_error_cfg mode,
    cs_boolean                 enable)
{
    cs_status status = CS_OK;
    cs_uint32 ctrl_addr = 0;
    cs_uint16 reg_data;
    
    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_generator(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    if(prbs_sel == CS4224_PRBS_LINE_INTERFACE)
    {
        ctrl_addr = CS4224_PP_LINE_SDS_COMMON_PRBSGEN0_Ctrl;
    }
    else
    {
        ctrl_addr = CS4224_PP_HOST_SDS_COMMON_PRBSGEN0_Ctrl;
    }

    status |= cs4224_reg_get_channel(slice, ctrl_addr, &reg_data);

    reg_data &= ~mode;

    if(enable)
    {
        reg_data |= mode;
    }

    status |= cs4224_reg_set_channel(slice, ctrl_addr, reg_data);

    return status;
}

/**
 * This is a diagnostic method that may be used to put the PRBS
 * generator in local timing mode in the scenario where an external
 * data source is not available. This mode is intended for debugging
 * purposes and should never be used for qualification/characterization
 * purposes as it can add significant jitter.
 *
 * This method cannot be used on adjacent lanes as it causes significant
 * jitter which will affect the ability to carry traffic. It can only
 * be used on port pairs that are not adjacent.
 *
 * @param slice    [I] - The slice of the device to put into local timing
 *                       mode.
 * @param prbs_sel [I] - The PRBS interface to put into local timing mode.
 * @param enable   [I] - Set to TRUE to enable local timing mode or FALSE
 *                       to disable local timing mode.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_prbs_generator_set_local_timing_mode(
    cs_uint32               slice,
    e_cs4224_prbs_interface prbs_sel,
    cs_boolean              enable)
{
    return cs4224_diags_prbs_generator_set_pfd_mode(
        slice,
        prbs_sel,
        enable);
}

/**
 * If the PRBS generator is put into PFD mode the microsequencer
 * gets stalled. It does not get un-stalled again if taken out of
 * PFD mode. This would have to be done manually.
 *
 * @param slice    [I] - The slice of the device to put into PFD mode
 * @param prbs_sel [I] - The PRBS interface
 * @param enable   [I] - Set to TRUE to enable PFD mode.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @deprecated This method has been replaced by
 *             cs4224_diags_prbs_generator_set_local_timing_mode() and
 *             should not be used as it may be turned off in future
 *             API releases.
 */
cs_status cs4224_diags_prbs_generator_set_pfd_mode(
    cs_uint32               slice,
    e_cs4224_prbs_interface prbs_sel,
    cs_boolean              enable)
{
    cs_status status = CS_OK;
    cs_uint32 ctrl_addr = 0;
    cs_uint16 reg_data;
    cs_uint16 squelch_addr;
    cs_uint16 mailbox_out_addr, mailbox_in_addr;
    e_cs4224_mseq_id mseq_id;

    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_generator(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    if(prbs_sel == CS4224_PRBS_LINE_INTERFACE)
    {
        ctrl_addr           = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_CONTROL;
        mseq_id             = CS4224_DPLX_HOST_MSEQ;
        squelch_addr        = CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH;
        mailbox_out_addr    = CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_MSB;
        mailbox_in_addr     = CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_IN_MSB;
    }
    else
    {
        ctrl_addr           = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_CONTROL;
        mseq_id             = CS4224_DPLX_LINE_MSEQ;
        squelch_addr        = CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH;
        mailbox_out_addr    = CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_MSB;
        mailbox_in_addr     = CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_MSB;
    }

    if(enable)
    {
        status |= cs4224_mseq_enable_power_savings(slice, mseq_id, FALSE);

        /* must wait for power savings to take effect */
        CS_MDELAY(5);
            
        /* If the microsequencer was running then stall it */
        status |= cs4224_mseq_stall(slice, mseq_id, TRUE);
    }
    else
    {
        CS_TRACE(("WARNING: Disabling local timing mode leaves power savings disabled, use cs4224_mseq_enable_power_savings to re-enable if needed\n"));
        
        /* start the mseq */
        status |= cs4224_mseq_stall(slice, mseq_id, FALSE);
    }
    
    status |= cs4224_reg_get_channel(slice, ctrl_addr, &reg_data);

    reg_data &= ~0x1;

    if(enable)
    {
        reg_data |= 0x1;
    }

    status |= cs4224_reg_set_channel(slice, ctrl_addr, reg_data);

    if(enable)
    {
        /* clear the out mail box queue in case it has a squelch request in it */
        status |= cs4224_reg_set_channel(slice, mailbox_out_addr, 0);

        /* clear the in mail box queue request */
        status |= cs4224_reg_get_channel(slice, mailbox_in_addr, &reg_data);
        reg_data &= ~0x1000;
        status |= cs4224_reg_set_channel(slice, mailbox_in_addr, reg_data);

        /* we must un-squelch the interface in case the ucode had squelched it*/
        status |= cs4224_reg_set_channel(slice, squelch_addr, 0);
    }

    return status;
}

/**
 * This is a diagnostic method used to squelch the output
 * generated by the PRBS generator. It is for testing purposes
 * only.
 *
 * @param slice    [I] - The slice of the generator to squelch
 * @param prbs_sel [I] - The selected generator to squelch.
 * @param squelch  [I] - TRUE to squelch the output, FALSE
 *                       to un-squelch it.
 *
 * @deprecated This method uses cs4224_squelch_driver internally, you may want to
 *             use that method directly instead.
 */
cs_status cs4224_diags_prbs_generator_squelch(
    cs_uint32               slice,
    e_cs4224_prbs_interface prbs_sel,
    cs_boolean              squelch)
{
    cs_status status = CS_OK;
    
    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_generator(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    if(prbs_sel == CS4224_PRBS_LINE_INTERFACE)
    {
        status |= cs4224_squelch_driver(slice, CS4224_CFG_LINE_SIDE, squelch);
    }
    else
    {
        status |= cs4224_squelch_driver(slice, CS4224_CFG_HOST_SIDE, squelch);
    }

    return status;
}

/**
 * Configure the PRBS checker for receiving a test pattern and verifying it is correct. 
 * 
 *  @param slice       [I] -  The slice to the port of the device to access 
 *  @param prbs_sel    [I] -  Which PRBS checker to configure (CS4224_PRBS_HOST_INTERFACE, CS4224_PRBS_LINE_INTERFACE)
 *  @param polynomial  [I] -  The polynomial to use to generate output. 
 *  @param invert      [I] -  TRUE to invert the pattern, FALSE leaves the pattern as is. 
 *  @param lbk_enable  [I] -  Unused.
 *
 *  @return CS_OK on success, CS_ERROR on failure
 */
cs_status cs4224_diags_prbs_checker_config(
        cs_uint32                slice,
        e_cs4224_prbs_interface  prbs_sel,
        e_cs4224_prbs_polynomial polynomial,
        cs_uint8                 invert,
        cs_uint8                 lbk_enable)
{
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 prbs_cfg_addr;
    cs_uint16 prbs_ctrl_addr;
    (void)lbk_enable; /* unused, eliminate compiler warning */

    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_checker(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    cs4224_lock(slice);

    if (CS4224_PRBS_HOST_INTERFACE == prbs_sel)
    {
        prbs_cfg_addr        = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_Cfg;
        prbs_ctrl_addr       = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_Ctrl;
    }
    else /* CS4224_PRBS_LINE_INTERFACE */
    {
        prbs_cfg_addr        = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_Cfg;
        prbs_ctrl_addr       = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_Ctrl;
    }

    /* by default, don't enable auto-polarity since it makes it difficult to tell
     * if there are unknown polarity inversions
     */
    data = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_Ctrl_dft;
#if 0
    data |= CS_BIT1; /* enable auto polarity detect */
#endif
    status |= cs4224_reg_set_channel(slice, prbs_ctrl_addr, data);

    status |= cs4224_reg_get_channel(slice, prbs_cfg_addr, &data);

    /* Clear and set the polynomial */
    data &= ~0x70;
    data |= ((cs_uint16)polynomial << 4);
    
    /* Set the invert bit if required */ 
    if(invert)
    {
        data |= 0x4;
    }
    else
    {
        data &= ~0x4;
    }
    
    /* Disable the checker when reconfiguring as a precaution */
    data &= ~0x1;

    status |= cs4224_reg_set_channel(slice, prbs_cfg_addr, data);

    cs4224_unlock(slice);

    /* Enable bitswap in RX direction */
    status |= cs4224_diags_prbs_set_bitswap(slice, prbs_sel, TRUE, TRUE);

    return status;
}

/**
 * Enable or disable the PRBS checker.
 * 
 * This method currently disables power savings when the PRBS checker is configured by
 * clearing the LSB of CS4224_PP_MSEQ_SPARE2_LSB. The API currently does not
 * disable power savings when the checker is disabled.
 *
 * @param slice     [I] -  The slice to the port of the device to access 
 * @param prbs_sel  [I] -  Which PRBS checker to enable/disable (HOST or LINE) 
 * @param enable    [I] -  Set to TRUE to enable, FALSE to disable 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_prbs_checker_enable(
        cs_uint32               slice,
        e_cs4224_prbs_interface prbs_sel,
        cs_uint8                enable)
{
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 prbs_cfg_addr;
    cs_uint16 prbs_chk_int;
    e_cs4224_mseq_id mseq_id;
    cs_uint32 error_count;

    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_checker(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    switch(prbs_sel)
    {
        case CS4224_PRBS_HOST_INTERFACE:
        {
            prbs_cfg_addr = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_Cfg;
            prbs_chk_int  = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_INTERRUPT;
            mseq_id = CS4224_DPLX_HOST_MSEQ;
            break;
        }
        case CS4224_PRBS_LINE_INTERFACE:
        {
            prbs_cfg_addr = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_Cfg;
            prbs_chk_int  = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_INTERRUPT;
            mseq_id = CS4224_DPLX_LINE_MSEQ;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Invalid prbs_sel=%d\n", prbs_sel));
            return CS_ERROR;
        }
    }
    cs4224_lock(slice);

    /* enable/disable the checker */
    status |= cs4224_reg_get_channel(slice, prbs_cfg_addr, &data);
    if(enable == TRUE)
    {
        data |= CS_BIT0;
    }
    else
    {
        data &= ~CS_BIT0;
    }
    status |= cs4224_reg_set_channel(slice, prbs_cfg_addr, data);
    
    if(enable == TRUE)
    {
        /* turn off power savings */
        status |= cs4224_mseq_enable_power_savings(slice, mseq_id, FALSE);

        /* Enable bitswap in RX direction */
        status |= cs4224_diags_prbs_set_bitswap(slice, prbs_sel, TRUE, TRUE);
    }
    else
    {
        /* turn on power savings before we disable the checker */
        status |= cs4224_mseq_enable_power_savings(slice,mseq_id, TRUE);
        
        /* Disable bitswap in RX direction */
        status |= cs4224_diags_prbs_set_bitswap(slice, prbs_sel, TRUE, FALSE);
    }

    /* clear interrupt status register */
    status |= cs4224_reg_set_channel(slice, prbs_chk_int, 0xffff);
    
    /* clear the counter */
    status |= cs4224_diags_prbs_checker_get_errors(slice, prbs_sel, &error_count);

    cs4224_unlock(slice);

    return status;
}

/**
 * Enable or disable the PRBS checker auto-polarity feature.
 *
 * The auto-polarity feature will compensate for polarity inversions (P/N)
 * in the incoming signal by automatically determining the polarity. Use
 * cs4224_diags_prbs_checker_get_polarity to determine if an inversion was
 * detected
 * 
 * @{note,
 * NOTE: This method must be called after setting up the checker with 
 * cs4224_diags_prbs_checker_config and cs4224_diags_prbs_checker_enable. If
 * called before those methods then the auto-polarity feature will be disabled.
 * }
 *
 * @param slice     [I] -  The slice to the port of the device to access
 * @param prbs_sel  [I] -  Which PRBS checker to configure (HOST or LINE)
 * @param enable    [I] -  Set to TRUE to enable, FALSE to disable
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_prbs_checker_autopol_enable(
        cs_uint32               slice,
        e_cs4224_prbs_interface prbs_sel,
        cs_boolean              enable)
{
    cs_status status = CS_OK;
    cs_uint16 prbs_ctrl = 0;
    cs_uint16 data = 0;

    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_checker(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    switch(prbs_sel)
    {
        case CS4224_PRBS_HOST_INTERFACE:
        {
            prbs_ctrl = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_Ctrl;
            break;
        }
        case CS4224_PRBS_LINE_INTERFACE:
        {
            prbs_ctrl = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_Ctrl;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Invalid prbs_sel=%d\n", prbs_sel));
            return CS_ERROR;
        }
    }
    cs4224_lock(slice);

    status |= cs4224_reg_get_channel(slice, prbs_ctrl, &data);
    data &= ~0x1C; /* clear auto-polarity options */
    data |= 0xC; /* set threshold */
    if(enable)
    {
        data |= CS_BIT1;
    }
    else
    {
        data &= ~CS_BIT1;
    }
    status |= cs4224_reg_set_channel(slice, prbs_ctrl, data);

    return status;
}

/**
 * Check the inverted status of the auto-polarity feature. Must have auto-polarity
 * enabled in order for check to be valid (use cs4224_diags_prbs_checker_autopol_enable
 * to enable).
 *
 * @param slice     [I] -  The slice to the port of the device to access
 * @param prbs_sel  [I] -  Which PRBS checker to configure (HOST or LINE)
 * @param inverted  [O] -  Set to TRUE if signal is inverted, FALSE otherwise
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_prbs_checker_get_polarity(
        cs_uint32               slice,
        e_cs4224_prbs_interface prbs_sel,
        cs_boolean              *inverted)
{
    cs_status status = CS_OK;
    cs_uint16 ints = 0;
    cs_uint16 data = 0;

    *inverted = FALSE;

    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_checker(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    switch(prbs_sel)
    {
        case CS4224_PRBS_HOST_INTERFACE:
        {
            ints = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_INTSTATUS;
            break;
        }
        case CS4224_PRBS_LINE_INTERFACE:
        {
            ints = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_INTSTATUS;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Invalid prbs_sel=%d\n", prbs_sel));
            return CS_ERROR;
        }
    }
    cs4224_lock(slice);

    status |= cs4224_reg_get_channel(slice, ints, &data);
    if(data & CS_BIT2)
    {
        *inverted = TRUE;
    }
    else
    {
        *inverted = FALSE;
    }

    return status;
}

/**
 * Retrieves the 32 bit error count reported by the PRBS checker. 
 *
 * @param slice        [I] -  The slice to the port of the device to access 
 * @param prbs_sel     [I] -  Which PRBS checker to enable/disable (CS4224_PRBS_HOST_INTERFACE, CS4224_PRBS_LINE_INTERFACE) 
 * @param error_count  [O] -  The number of errors dected by the PRBS checker. 
 *
 * @return CS_OK on success, CS_ERROR on failure
 */
cs_status cs4224_diags_prbs_checker_get_errors(
        cs_uint32               slice,
        e_cs4224_prbs_interface prbs_sel,
        cs_uint32*              error_count)
{
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 prbs_chk_count0_addr;
    cs_uint16 prbs_chk_count1_addr;
    
    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_checker(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    /* Determine the addresses of the error count registers based
     * on which PRBS is selected */
    switch(prbs_sel)
    {
        case CS4224_PRBS_HOST_INTERFACE:
        {
            prbs_chk_count0_addr = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_Count0;
            prbs_chk_count1_addr = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_Count1;
            break;
        }
        case CS4224_PRBS_LINE_INTERFACE:
        {
            prbs_chk_count0_addr = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_Count0;
            prbs_chk_count1_addr = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_Count1;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Invalid prbs_sel=%d\n", prbs_sel));
            return CS_ERROR;
        }
    }
    cs4224_lock(slice);
            
    status |= cs4224_reg_get_channel(slice, prbs_chk_count1_addr, &data);
    *error_count = (cs_uint32)data << 16;

    status |= cs4224_reg_get_channel(slice, prbs_chk_count0_addr, &data);
    *error_count |= (cs_uint32)data;

    cs4224_unlock(slice);

    return status;
}

/**
 * This method is called to retrieve the full status of the PRBS checker
 * including the error count, sync status, lock detect
 *
 * @param slice       [I] - The slice/channel of the device to access.
 * @param prbs_sel    [I] - The PRBS checker to access
 * @param error_count [O] - The PRBS error count (0 if there are no errors)
 * @param prbs_sync   [O] - TRUE if the PRBS checker is enabled and synced.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_prbs_checker_get_status(
        cs_uint32               slice,
        e_cs4224_prbs_interface prbs_sel,
        cs_uint32*              error_count,
        cs_boolean*             prbs_sync)
{
    cs_uint32 sync_addr = 0;
    cs_uint16 reg_data = 0;
    cs_status status = CS_OK;

    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_checker(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    if(prbs_sel == CS4224_PRBS_LINE_INTERFACE)
    {
        sync_addr = CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_INTSTATUS;
    }
    else
    {
        sync_addr = CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_INTSTATUS;
    }

    /* Read the sync status */
    status |= cs4224_reg_get_channel(slice, sync_addr, &reg_data);
    
    /* 0 in the PRBS_SYNCs field means synced */
    if(0x0 == (reg_data & 0x1))
    {
        *prbs_sync = TRUE;
    }
    else
    {
        *prbs_sync = FALSE;
    }

    /* Lookup the error count */
    status |= cs4224_diags_prbs_checker_get_errors(slice, prbs_sel, error_count);

    return status;
}

/**
 * This method is called to configure the pattern that the fix pattern generator 
 * transmits. 
 *
 * NOTE: Some of the config here cannot be reversed without saving state. To fully
 * reverse the config run cs4224_slice_enter_operational_state to reconfig the slice.
 * 
 * @param slice       [I] - The slice/channel of the device to access 
 * @param gen_sel     [I] - Which fixed pattern generator to configure (LINE/HOST/SPLX)
 * @param sequence_a  [I] - The bits of sequence A to generate
 * @param repeat_a    [I] - The number of times to repeat sequence A before switching to sequence B. 
 *     
 * @param sequence_b  [I] - The bits of sequence B to generate
 * @param repeat_b    [I] - The number of times to repeat sequence B before switching back to sequence A. 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_fix_ptrn_generator_cfg(
        cs_uint32               slice,
        e_cs4224_prbs_interface gen_sel,
        cs_uint32               sequence_a,
        cs_uint8                repeat_a,
        cs_uint32               sequence_b,
        cs_uint8                repeat_b)
{
    /* based heavily on cs4224_diags_prbs_generator_config, any modifications here should also go there */
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 prbs_cfg_addr;
    cs_uint32 prbs_ptrn_addr;
    cs_uint16 stx0_misc_addr;
    e_cs4224_mseq_id mseq_id;

    if(gen_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            gen_sel = cs4224_diags_prbs_simplex_get_generator(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    if (CS4224_PRBS_HOST_INTERFACE == gen_sel)
    {
        prbs_cfg_addr        = CS4224_PP_HOST_SDS_COMMON_PRBSGEN0_Cfg;
        prbs_ptrn_addr       = CS4224_PP_HOST_SDS_COMMON_PRBSGEN0_Fixed0_Pattern1;
        stx0_misc_addr       = CS4224_PP_HOST_SDS_COMMON_STX0_MISC;
        mseq_id              = CS4224_DPLX_LINE_MSEQ;
    }
    else /* CS4224_PRBS_LINE_INTERFACE */
    {
        prbs_cfg_addr        = CS4224_PP_LINE_SDS_COMMON_PRBSGEN0_Cfg;
        prbs_ptrn_addr       = CS4224_PP_LINE_SDS_COMMON_PRBSGEN0_Fixed0_Pattern1;
        stx0_misc_addr       = CS4224_PP_LINE_SDS_COMMON_STX0_MISC;
        mseq_id              = CS4224_DPLX_HOST_MSEQ;
    }
    cs4224_lock(slice);

    /* Disable power savings to get the generator to function correctly */
    cs4224_mseq_enable_power_savings(slice, mseq_id, FALSE);

    status |= cs4224_reg_get_channel(slice, stx0_misc_addr, &data);
    data &= ~0x0011; /* power-up mux, STX_EYEMODE_EN=0 */
    status |= cs4224_reg_set_channel(slice, stx0_misc_addr, data);

    status |= cs4224_reg_get_channel(slice, prbs_cfg_addr, &data);
    /* Clear the fixed pattern enable and the prbs gen enable bits */
    data = CS_CLR(data,0x3);
    status |= cs4224_reg_set_channel(slice, prbs_cfg_addr, data);

    /* Setup the pattern. The register addresses are based on the
     * location of the PRBSGEN0_Fixed0_Pattern1 register.
     *
     * The most significant
     * bits go into the Fixed0_Pattern1 register and the least significant
     * bits go in the Fixed0_Pattern0 register. */
    status |= cs4224_reg_set_channel(slice, prbs_ptrn_addr, (sequence_a >> 16) & 0xFFFF);
    status |= cs4224_reg_set_channel(slice, prbs_ptrn_addr+1, (sequence_a) & 0xFFFF);

    status |= cs4224_reg_set_channel(slice, prbs_ptrn_addr+2, (sequence_b >> 16) & 0xFFFF);
    status |= cs4224_reg_set_channel(slice, prbs_ptrn_addr+3, (sequence_b) & 0xFFFF);
    
    /* Setup the repeat register */
    status |= cs4224_reg_set_channel(slice, prbs_ptrn_addr+4, ((cs_uint16)repeat_b << 8) | repeat_a); 

    cs4224_unlock(slice);
    
    return status;
}

/**
 * Enable or disable the fixed pattern generator 
 *
 * @param slice     [I] - The slice to the port of the device to access 
 * @param prbs_sel  [I] - Which fixed pattern generator to enable/disable (HOST or LINE) 
 * @param enable    [I] - Set to TRUE to enable, FALSE to disable 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_diags_fix_ptrn_generator_enable(
        cs_uint32               slice,
        e_cs4224_prbs_interface prbs_sel,
        cs_boolean              enable)
{
    /* based heavily on cs4224_diags_prbs_generator_enable, any modifications here should also go there */
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 prbs_cfg_addr;
    cs_uint16 tx_cfg_addr;
    
    if(prbs_sel == CS4224_PRBS_SIMPLEX_INTERFACE)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            prbs_sel = cs4224_diags_prbs_simplex_get_generator(slice);
        }
        else
        {
            /* undefined in duplex mode */
            CS_TRACE(("ERROR: CS4224_PRBS_SIMPLEX_INTERFACE available in simplex mode only\n"));
            return CS_ERROR;
        }
    }

    switch(prbs_sel)
    {
        case CS4224_PRBS_HOST_INTERFACE:
        {
            prbs_cfg_addr  = CS4224_PP_HOST_SDS_COMMON_PRBSGEN0_Cfg;
            tx_cfg_addr    = CS4224_PP_HOST_SDS_COMMON_TX0_Config;
            break;
        }
        case CS4224_PRBS_LINE_INTERFACE:
        {
            prbs_cfg_addr  = CS4224_PP_LINE_SDS_COMMON_PRBSGEN0_Cfg;
            tx_cfg_addr    = CS4224_PP_LINE_SDS_COMMON_TX0_Config;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Invalid prbs_sel=%d\n", prbs_sel));
            return CS_ERROR;
        }
    }
    cs4224_lock(slice);
    
    status |= cs4224_reg_get_channel(slice, prbs_cfg_addr, &data);
    data = CS_CLR(data, 0x3);
    if(enable)
    {
        /* fixed pattern enable */
        data |= CS_BIT1;
    }
    status |= cs4224_reg_set_channel(slice, prbs_cfg_addr, data);
    
    if(enable)
    {
        /* Enable bitswap in TX direction */
        status |= cs4224_diags_prbs_set_bitswap(slice, prbs_sel, FALSE, TRUE);
        
        status |= cs4224_reg_get_channel(slice, tx_cfg_addr, &data);
        data = CS_CLR(data, 0x3);
        /* data_source = PRBS */
        data |= 0x01;
        status |= cs4224_reg_set_channel(slice, tx_cfg_addr, data);

    }
    else
    {
        CS_TRACE(("WARNING: Not all config is rolled back when disabling PRBS generator. Reconfigure slice 0x%x to roll back all config\n",slice));
        
        /* Bitswap is enabled by default, so leave it on here so we can pass traffic after
         * disabling the generator */
        /* Disable bitswap in TX direction */
        /*status |= cs4224_diags_prbs_set_bitswap(slice, prbs_sel, FALSE, FALSE);*/

        status |= cs4224_reg_get_channel(slice, tx_cfg_addr, &data);
        /* data_source = DIG_TX_DIN */
        data = CS_CLR(data, 0x3);
        status |= cs4224_reg_set_channel(slice, tx_cfg_addr, data);
    }

    cs4224_unlock(slice);

    return status;
}

#endif /* CS_HAS_DEBUG_PRBS == 1 */

#if (CS_HAS_DEBUG_STATUS_DUMPS == 1)

/**
 * This is method used to display the current duplex switch state.
 * 
 * @pre
 * +-----------+------------------+-------------------------+------------------+
 * | Slice     | HostRX + HostTX  | Switch State            | LineRX + LineTX  |
 * | DDIV_SEL  |                  | S=Sql,F=Flt,L=Lck,E=Edc |                  |
 * |           |                  | HL=HiLtncy,LL=LowLtncy  |                  |
 * +-----------+------------------+-------------------------+------------------+
 * |     0     | RX:DISABL +Stall | Host     (OFF)     Line | RX:DISABL +Stall |
 * | H:/1 L:/1 | TX:A=0814,B=0004 | S... <-----------> S... | TX:A=0814,B=0004 |
 * |     1     | RX:SR     +Stall |           n/a           | RX:SR     +Run   |
 * | H:/8 L:/8 | TX:A=0814,B=0004 | .F.. <-----------> .FLE | TX:A=0814,B=0004 |
 * +-----------+------------------+-------------------------+------------------+
 * |     2     | RX:DISABL +Stall | Host     (OFF)     Line | RX:DISABL +Stall |
 * | H:/1 L:/1 | TX:A=0814,B=0004 | S... <-----------> S... | TX:A=0814,B=0004 |
 * |     3     | RX:DISABL +Stall |           n/a           | RX:DISABL +Stall |
 * | H:/1 L:/1 | TX:A=0814,B=0004 | S... <-----------> S... | TX:A=0814,B=0004 |
 * +-----------+------------------+-------------------------+------------------+
 * |     4     | RX:DISABL +Stall | Host     (OFF)     Line | RX:DISABL +Stall |
 * | H:/1 L:/1 | TX:A=0814,B=0004 | S... <-----------> S... | TX:A=0814,B=0004 |
 * |     5     | RX:DISABL +Stall |           n/a           | RX:DISABL +Stall |
 * | H:/1 L:/1 | TX:A=0814,B=0004 | S... <-----------> S... | TX:A=0814,B=0004 |
 * +-----------+------------------+-------------------------+------------------+
 * |     6     | RX:SR     +Run   | Host    (2x2)HL    Line | RX:SR     +Run   |
 * | H:/1 L:/8 | TX:A=0814,B=0004 | .FLE <----> <----> .FLE | TX:A=0814,B=0004 |
 * |     7     | RX:SR     +Run   |            X            | RX:10G_BP +Run   |
 * | H:/8 L:/1 | TX:A=0814,B=0004 | .FLE <----> <----> .FLE | TX:A=0814,B=0004 |
 * +-----------+------------------+-------------------------+------------------+
 * 
 * @param slice [I] - A slice on the device to access, only uses the upper bits
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_switch_show_state(
    cs_uint32 slice)
{
    cs_status status = CS_OK;
    e_cs4224_switch_action_t switch_mode;
    e_cs4224_edc_mode        line_edc_mode_0, host_edc_mode_0;
    cs_uint16                line_edc_conv_0, host_edc_conv_0;
    cs_uint16                line_lock_0, host_lock_0;
    cs_uint16                line_squelch_0, host_squelch_0;
    cs_uint16                line_ctrla_0, host_ctrla_0;
    cs_uint16                line_ctrlb_0, host_ctrlb_0;
    cs_boolean               line_mseq_stalled_0, host_mseq_stalled_0;
    cs_uint16                line_clkdiv_ctrl, host_clkdiv_ctrl;
    cs_boolean               low_latency_mode;
    cs_uint32                i, slice_num;

    CS_PRINTF(("+-----------+------------------+-------------------------+------------------+\n"));
    CS_PRINTF(("| Slice     | HostRX + HostTX  | Switch State            | LineRX + LineTX  |\n"));
    CS_PRINTF(("| DDIV_SEL  |                  | S=Sql,F=Flt,L=Lck,E=Edc |                  |\n"));
    CS_PRINTF(("|           |                  | HL=HiLtncy,LL=LowLtncy  |                  |\n"));
    CS_PRINTF(("+-----------+------------------+-------------------------+------------------+\n"));
                
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        slice_num = (slice & ~0xf) + i;

        /* This method can be called to query the current switch state*/
        status = cs4224_switch_query_mode(slice_num, &switch_mode, &low_latency_mode);

        /* get the EDC converged states */
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS, &line_edc_conv_0);
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS, &host_edc_conv_0);
        
        /* get the VCO lock state */
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS, &line_lock_0);
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS, &host_lock_0);
        
        /* get the squelch state */
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH, &line_squelch_0);
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH, &host_squelch_0);
        
        /* get the EDC mode */
        status |= cs4224_query_edc_mode(slice_num,   CS4224_DPLX_LINE_MSEQ, &line_edc_mode_0);
        status |= cs4224_query_edc_mode(slice_num,   CS4224_DPLX_HOST_MSEQ, &host_edc_mode_0);

        /* get the ctrla values */
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, &line_ctrla_0);
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, &host_ctrla_0);

        /* get the ctrlb values */
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, &line_ctrlb_0);
        status |= cs4224_reg_get_channel(slice_num,   CS4224_PP_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, &host_ctrlb_0);

        /* find out if the microsequencer is stalled */
        status |= cs4224_query_mseq_is_stalled(slice_num,   CS4224_DPLX_LINE_MSEQ, &line_mseq_stalled_0);
        status |= cs4224_query_mseq_is_stalled(slice_num,   CS4224_DPLX_HOST_MSEQ, &host_mseq_stalled_0);

        /* find out the clkdiv ctrl */
        status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, &line_clkdiv_ctrl);
        status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, &host_clkdiv_ctrl);
        
        CS_PRINTF(("|     %d     | RX:", i));
        
        /* Host side */

        if      (host_edc_mode_0 == CS_HSIO_EDC_MODE_SR)       {CS_PRINTF(("SR     "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_CX1)      {CS_PRINTF(("CX1    "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_SMLRM)    {CS_PRINTF(("SMLRM  "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_ZR)       {CS_PRINTF(("ZR     "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_DWDM)     {CS_PRINTF(("DWDM   "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_10G_BP)   {CS_PRINTF(("10G_BP "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_15G_BP)   {CS_PRINTF(("15G_BP "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_FCAN)     {CS_PRINTF(("FCAN   "));}
        else if (host_edc_mode_0 == CS_HSIO_EDC_MODE_DISABLED) {CS_PRINTF(("DISABL "));}
        else                                                   {CS_PRINTF(("?????? "));}
        
        if (host_mseq_stalled_0 == TRUE) {CS_PRINTF(("+Stall"));}
        else                             {CS_PRINTF(("+Run  "));}

        if ((i & 1) == 0)
        {
            if (low_latency_mode == FALSE)
            {
                if      (switch_mode == CS4224_SWITCH_DUPLEX_SWITCH_2x2)       {CS_PRINTF((" | Host    (2x2)HL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0) {CS_PRINTF((" | Host    (0_0)HL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1) {CS_PRINTF((" | Host    (0_1)HL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0) {CS_PRINTF((" | Host    (1_0)HL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1) {CS_PRINTF((" | Host    (1_1)HL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DISABLE)                 {CS_PRINTF((" | Host     (OFF)     Line | "));}
            }
            else
            {
                if      (switch_mode == CS4224_SWITCH_DUPLEX_SWITCH_2x2)       {CS_PRINTF((" | Host    (2x2)LL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0) {CS_PRINTF((" | Host    (0_0)LL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1) {CS_PRINTF((" | Host    (0_1)LL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0) {CS_PRINTF((" | Host    (1_0)LL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1) {CS_PRINTF((" | Host    (1_1)LL    Line | "));}
                else if (switch_mode == CS4224_SWITCH_DISABLE)                 {CS_PRINTF((" | Host     (OFF)     Line | "));}
            }
        }
        else
        {
            if      (switch_mode == CS4224_SWITCH_DUPLEX_SWITCH_2x2)       {CS_PRINTF((" |            X            | "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0) {CS_PRINTF((" |            \\            | "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1) {CS_PRINTF((" |            \\            | "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0) {CS_PRINTF((" |            /            | "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1) {CS_PRINTF((" |            /            | "));}
            else                                                           {CS_PRINTF((" |           n/a           | "));}
        }
        
        /* Line side */
        CS_PRINTF(("RX:"));
        
        if      (line_edc_mode_0 == CS_HSIO_EDC_MODE_SR)       {CS_PRINTF(("SR     "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_CX1)      {CS_PRINTF(("CX1    "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_SMLRM)    {CS_PRINTF(("SMLRM  "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_ZR)       {CS_PRINTF(("ZR     "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_DWDM)     {CS_PRINTF(("DWDM   "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_10G_BP)   {CS_PRINTF(("10G_BP "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_15G_BP)   {CS_PRINTF(("15G_BP "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_FCAN)     {CS_PRINTF(("FCAN   "));}
        else if (line_edc_mode_0 == CS_HSIO_EDC_MODE_DISABLED) {CS_PRINTF(("DISABL "));}
        else                                                   {CS_PRINTF(("?????? "));}
        
        if (line_mseq_stalled_0 == TRUE) {CS_PRINTF(("+Stall |"));}
        else                             {CS_PRINTF(("+Run   |"));}
        
        CS_PRINTF(("\n| "));
        
        if(0x3 == (host_clkdiv_ctrl >> 4 & 0x7))
        {
            CS_PRINTF(("H:/8 "));
        }
        else
        {
            CS_PRINTF(("H:/1 "));
        }
        
        if(0x3 == (line_clkdiv_ctrl >> 4 & 0x7))
        {
            CS_PRINTF(("L:/8"));
        }
        else
        {
            CS_PRINTF(("L:/1"));
        }

        CS_PRINTF((" | TX:A=%04x,B=%04x | ", host_ctrla_0, host_ctrlb_0));
        
        if (host_squelch_0 == 1)    {CS_PRINTF(("S"));}
        else                        {CS_PRINTF(("."));}
        if (host_lock_0 & 0x40)     {CS_PRINTF(("F"));}
        else                        {CS_PRINTF(("."));}
        if (host_lock_0 & 0x01)     {CS_PRINTF(("L"));}
        else                        {CS_PRINTF(("."));}
        if (host_edc_conv_0 & 0x20) {CS_PRINTF(("E"));}
        else                        {CS_PRINTF(("."));}
        
        if ((i & 1) == 0)
        {
            if      (switch_mode == CS4224_SWITCH_DUPLEX_SWITCH_2x2)       {CS_PRINTF((" <----> <----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0) {CS_PRINTF((" <----> <----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1) {CS_PRINTF((" <----> -----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0) {CS_PRINTF(("        <----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1) {CS_PRINTF(("        -----> "));}
            else                                                           {CS_PRINTF((" <-----------> "));}
        }
        else
        {
            if      (switch_mode == CS4224_SWITCH_DUPLEX_SWITCH_2x2)       {CS_PRINTF((" <----> <----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0) {CS_PRINTF(("        -----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1) {CS_PRINTF(("        <----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0) {CS_PRINTF((" <----> -----> "));}
            else if (switch_mode == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1) {CS_PRINTF((" <----> <----> "));}
            else                                                           {CS_PRINTF((" <-----------> "));}
        } 
        if (line_squelch_0 == 1)    {CS_PRINTF(("S"));}
        else                        {CS_PRINTF(("."));}
        if (line_lock_0 & 0x40)     {CS_PRINTF(("F"));}
        else                        {CS_PRINTF(("."));}
        if (line_lock_0 & 0x01)     {CS_PRINTF(("L"));}
        else                        {CS_PRINTF(("."));}
        if (line_edc_conv_0 & 0x20) {CS_PRINTF(("E"));}
        else                        {CS_PRINTF(("."));}
        
        CS_PRINTF((" | TX:A=%04x,B=%04x |\n", line_ctrla_0, line_ctrlb_0));
        
        if ((i & 1) == 1)
        {
            CS_PRINTF(("+-----------+------------------+-------------------------+------------------+\n"));
        }
    }
    return status;
}

/**
 *
 * This method is called to display the VCO lock status on all interfaces
 * of an ASIC.
 *
 * @param slice     [I] - The slice to the port of the device to access 
 * @param prefix    [I] - The prefix string to prepend to the VCO status
 *                        report.
 *
 * Note that this method assumes the Alternate Coarse Tuning (ACT) algorithm
 * is used.
 *
 */
void cs4224_diags_show_vco_status_prefixed(
    cs_uint32   slice,
    const char* prefix)
{
    cs_uint16  line_lock_status,  host_lock_status;
    cs_uint16  line_altct_status, host_altct_status;
    cs_uint8   phy;

    CS_PRINTF(("%s+---------------------------+\n", prefix));
    CS_PRINTF(("%s| VCO Lock Status           |\n", prefix));
    CS_PRINTF(("%s+-----+----------+----------+\n", prefix));
    CS_PRINTF(("%s| Phy | Line FLT | Host FLT |\n", prefix));
    CS_PRINTF(("%s+-----+----------+----------+\n", prefix));
 
    for (phy=0; phy < CS4224_MAX_NUM_SLICES(slice); phy++)
    {
        slice = (slice & 0xffffff00) | phy;

        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS,  &line_lock_status); 
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_STATUS, &line_altct_status); 

        cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS,  &host_lock_status); 
        cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXVCO0_ALTCT_STATUS, &host_altct_status); 

        if (cs4224_is_hw_simplex(slice))
        {
            if (cs4224_line_rx_to_host_tx_dir(slice))
            {
                CS_PRINTF(("%s|  %2d | (Rx) %s%s%s | (Rx) %s%s%s |\n",  
                  prefix,
                  phy, (line_lock_status  & 0x0040)? "1": "0", 
                       (line_lock_status  & 0x0001)? "1": "0", 
                       (line_altct_status & 0x8000)? "1": "0",
                       "-", "-", "-"));
            }
            else
            {
                CS_PRINTF(("%s|  %2d | (Rx) %s%s%s | (Rx) %s%s%s |\n",  
                  prefix,
                  phy, "-", "-", "-",   
                       (host_lock_status  & 0x0040)? "1": "0", 
                       (host_lock_status  & 0x0001)? "1": "0", 
                       (host_altct_status & 0x8000)? "1": "0"));
            }
        }
        else /* duplex */
        {
            CS_PRINTF(("%s|  %2d | (Rx) %s%s%s | (Rx) %s%s%s |\n",  
              prefix,
              phy, (line_lock_status  & 0x0040)? "1": "0", 
                   (line_lock_status  & 0x0001)? "1": "0", 
                   (line_altct_status & 0x8000)? "1": "0",
                   (host_lock_status  & 0x0040)? "1": "0", 
                   (host_lock_status  & 0x0001)? "1": "0", 
                   (host_altct_status & 0x8000)? "1": "0"));
        }  
    }

    CS_PRINTF(("%s+-----+----------+----------+\n",prefix));

    CS_PRINTF(("%sColumns: F is Lock Debounce Filter, 0=No, 1=Yes\n",prefix)); 
    CS_PRINTF(("%s         L is VCO Lock, 0=No, 1=Yes\n",prefix));
    CS_PRINTF(("%s         T is Coarse Tuning Freq, 0=Saturated, 1=Good\n",prefix));
    if (cs4224_is_hw_simplex(slice))
    {
        CS_PRINTF(("%s         - is not applicable\n",prefix));
    }
}

/**
 *
 * This method is called to display the VCO lock status on all interfaces
 * of an ASIC.
 *
 * @param slice     [I] - The slice to the port of the device to access 
 *
 * Note that this method assumes the Alternate Coarse Tuning (ACT) algorithm
 * is used.
 *
 */
void cs4224_diags_show_vco_status(
    cs_uint32 slice)
{
    cs4224_diags_show_vco_status_prefixed(slice, "");
}

/**
 *
 * This method is called to display the VCO lock status on all interfaces.
 *
 * Note that this method assumes the Alternate Coarse Tuning (ACT) algorithm
 * is used.
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_show_vco_status 
 *   instead.
 */
void cs4224_diags_show_vco_lock_status(void)
{
    cs4224_diags_show_vco_status(0);
}

/**
 *
 * This method is called to return a string pointer argument containing the status
 * of all the VCO lock status on all interfaces of an ASIC. The format of the string pointer is
 * similar to that which is displayed when calling the cs4224_diags_show_vco_lock_status method.
 *
 * @param slice     [I] - The slice to the port of the device to access 
 * @param buffer    [O] - Pointer to a buffer containing dump of lock status
 * 
 * Note that this method assumes the Alternate Coarse Tuning (ACT) algorithm
 * is used.
 *
 * Note that this method will overwrite buffer
 * 
 * @return Pointer to buffer
 *
 */
const char* cs4224_diags_get_vco_status_string(
    cs_uint32 slice,
    char*     buffer) 
{
    cs_uint16  line_lock_status,  host_lock_status;
    cs_uint16  line_altct_status, host_altct_status;
    cs_uint8   phy;
    char       phy_str[3] = {0,0,0};

    /* init buffer before using strcat */
    buffer[0] = 0;

    CS_STRCAT(buffer, "\n");
    CS_STRCAT(buffer, "+---------------------------+\n");
    CS_STRCAT(buffer, "| VCO Lock Status           |\n");
    CS_STRCAT(buffer, "+-----+----------+----------+\n");
    CS_STRCAT(buffer, "| Phy | Line FLT | Host FLT |\n");
    CS_STRCAT(buffer, "+-----+----------+----------+\n");
 
    for (phy=0; phy < CS4224_MAX_NUM_SLICES(slice); phy++)
    {
        slice = (slice & 0xffffff00) | phy;

        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS,  &line_lock_status); 
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_STATUS, &line_altct_status); 

        cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS,  &host_lock_status); 
        cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXVCO0_ALTCT_STATUS, &host_altct_status); 

        if (phy < 10)
        {
            phy_str[0] = ' ';
            phy_str[1] = phy + '0';
        }
        else
        {
            phy_str[0] = '1';
            phy_str[1] = (phy - 10) + '0';
        }

        if (cs4224_is_hw_simplex(slice))
        {
            if (cs4224_line_rx_to_host_tx_dir(slice))
            {
                CS_STRCAT(buffer, "|  ");
                CS_STRCAT(buffer, phy_str);
                CS_STRCAT(buffer, " | (Rx) " );
                CS_STRCAT(buffer, (line_lock_status  & 0x0040)? "1": "0");
                CS_STRCAT(buffer, (line_lock_status  & 0x0001)? "1": "0");
                CS_STRCAT(buffer, (line_altct_status & 0x8000)? "1": "0");
                CS_STRCAT(buffer, " | (Rx) ");
                CS_STRCAT(buffer, "-");
                CS_STRCAT(buffer, "-");
                CS_STRCAT(buffer, "- |\n");
            }
            else
            {
                CS_STRCAT(buffer, "|  ");
                CS_STRCAT(buffer, phy_str);
                CS_STRCAT(buffer, " | (Rx) " );
                CS_STRCAT(buffer, "-");
                CS_STRCAT(buffer, "-");
                CS_STRCAT(buffer, "-");
                CS_STRCAT(buffer, " | (Rx) ");
                CS_STRCAT(buffer, (host_lock_status  & 0x0040)? "1": "0");
                CS_STRCAT(buffer, (host_lock_status  & 0x0001)? "1": "0");
                CS_STRCAT(buffer, (host_altct_status & 0x8000)? "1 |\n": "0 |\n");
            }
        }
        else /* duplex */
        {
            CS_STRCAT(buffer, "|  ");
            CS_STRCAT(buffer, phy_str);
            CS_STRCAT(buffer, " | (Rx) " );
            CS_STRCAT(buffer, (line_lock_status  & 0x0040)? "1": "0");
            CS_STRCAT(buffer, (line_lock_status  & 0x0001)? "1": "0");
            CS_STRCAT(buffer, (line_altct_status & 0x8000)? "1": "0");
            CS_STRCAT(buffer, " | (Rx) ");
            CS_STRCAT(buffer, (host_lock_status  & 0x0040)? "1": "0");
            CS_STRCAT(buffer, (host_lock_status  & 0x0001)? "1": "0");
            CS_STRCAT(buffer, (host_altct_status & 0x8000)? "1 |\n": "0 |\n");
        }  
    }

    CS_STRCAT(buffer, "+-----+----------+----------+\n");

    CS_STRCAT(buffer, "Columns: F is Lock Debounce Filter, 0=No, 1=Yes\n"); 
    CS_STRCAT(buffer, "         L is VCO Lock, 0=No, 1=Yes\n");
    CS_STRCAT(buffer, "         T is Coarse Tuning Freq, 0=Saturated, 1=Good\n");
    if (cs4224_is_hw_simplex(slice))
    {
        CS_STRCAT(buffer, "         - is not applicable\n");
    }
    
    return buffer;
}

/**
 *
 * This method is called to return a string pointer argument containing the status
 * of all the VCO lock status on all interfaces of an ASIC. The format of the string pointer is
 * similar to that which is displayed when calling the cs4224_diags_show_vco_lock_status method.
 *
 * @param buffer    [O] - Pointer to a buffer containing dump of lock status
 *
 *
 * Note that this method assumes the Alternate Coarse Tuning (ACT) algorithm
 * is used.
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_get_vco_status_string 
 *   instead.
 *
 */
void cs4224_diags_get_vco_lock_status_string(
    char* buffer) 
{
    cs4224_diags_get_vco_status_string(0, buffer);
}

/**
 *
 * This method is called to return the VCO lock status on one simplex or
 * two duplex VCOs. The receiver VCO lock status(s) are returned in the 
 * vco argument pointer. 
 * 
 * Note that on a simplex slice, both the line and host structure elements
 * will be set to the VCO lock status regardless of the direction.
 *
 * @param slice  [I] - The slice to the port of the device to access 
 * @param vco    [O] - A structure contining the status of the VCO lock(s)
 *
 * @deprecated Use cs4224_query_link_ready, cs4224_query_links_ready,
 * cs4224_wait_for_link_ready, cs4224_wait_for_links_ready
 * 
 */
void cs4224_diags_is_vco_locked(
    cs_uint32 slice,
    cs4224_vco_lock_status_t *vco)
{
    cs_uint16  line_lock_status,  host_lock_status;
    cs_uint16  line_altct_status, host_altct_status;

    vco->rx_line_lock = FALSE;
    vco->rx_host_lock = FALSE;

    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS,  &line_lock_status); 
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_STATUS, &line_altct_status); 

    cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS,  &host_lock_status); 
    cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXVCO0_ALTCT_STATUS, &host_altct_status); 

    if ((cs4224_is_hw_simplex(slice) && cs4224_line_rx_to_host_tx_dir(slice)) ||
        (cs4224_is_hw_duplex(slice)))
    {
        if (((line_lock_status  & 0x0041) == 0x0041) &&
             (line_altct_status & 0x8000))
        {
            vco->rx_line_lock = TRUE;
            if (cs4224_is_hw_simplex(slice))
            {
                vco->rx_host_lock = TRUE;
            }
        }
    }
    if ((cs4224_is_hw_simplex(slice) && !cs4224_line_rx_to_host_tx_dir(slice)) ||
        (cs4224_is_hw_duplex(slice)))
    {
        if (((host_lock_status  & 0x0041) == 0x0041) &&
             (host_altct_status & 0x8000))
        {
            vco->rx_host_lock = TRUE;
            if (cs4224_is_hw_simplex(slice))
            {
                vco->rx_line_lock = TRUE;
            }
        }
    }
}

/**
 * This is an internal debug method that is used to display
 * the temperature as part of the diagnostics status report
 *
 * @param slice     [I] - The slice of the device to read
 *                        the temperature on.
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_temperature(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint32 temp = 0;
    cs4224_mon_temp_read_fixp(slice, &temp);
    CS_SNPRINTF((buffer, len, "%05d", temp));
    return buffer;
}

/**
 * This is an internal debug method that is used to display
 * the reset count as part of the diagnostics status report
 *
 * @param slice     [I] - The slice of the device to read
 *                        the reset count on.
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_reset_count(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint32 count = 0;
    int offset = 0;
    cs_uint16 data;
    
    if(interface == CS4224_CFG_HOST_SIDE)
    {
        offset = 0x800;
    }
    
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_MSB + offset, &data);
    count = (cs_uint32)data << 16;
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_LSB + offset, &data);
    count |= (cs_uint32)data;
    
    CS_SNPRINTF((buffer, len, "%x", count));
    
    return buffer;
}

/**
 * This is an internal method to get the edc mode in human-readable format.
 *
 * This method is somewhat inefficient and should probably be combined with
 * the already existing method cs4224_translate_edc_mode to save code space.
 * Right now the strings returned from the other method are too verbose.
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_edc_mode(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    e_cs4224_mseq_id  mseq_id;
    e_cs4224_edc_mode edc_mode;
    const char* output;

    if(interface == CS4224_CFG_LINE_SIDE) 
    {
        mseq_id = CS4224_DPLX_LINE_MSEQ;
    }
    else
    {
        mseq_id = CS4224_DPLX_HOST_MSEQ;
    }

    cs4224_query_edc_mode(slice, mseq_id, &edc_mode);

    switch(edc_mode)
    {
        case CS_HSIO_EDC_MODE_DISABLED:
        {
            output = "OFF";
            break;
        }
        case CS_HSIO_EDC_MODE_CX1:
        {
            output = "CX1";
            break;
        }
        case CS_HSIO_EDC_MODE_SR:
        {
            output = "SR";
            break;
        }
        case CS_HSIO_EDC_MODE_ZR:
        {
            output = "ZR";
            break;
        }
        case CS_HSIO_EDC_MODE_DWDM:
        {
            output = "DWDM";
            break;
        }
        case CS_HSIO_EDC_MODE_10G_BP:
        {
            output = "10G_BP";
            break;
        }
        case CS_HSIO_EDC_MODE_15G_BP:
        {
            output = "15G_BP";
            break;
        }
        case CS_HSIO_EDC_MODE_5G_BP:
        {
            output = "5G_BP";
            break;
        }
        case CS_HSIO_EDC_MODE_7p5G_BP:
        {
            output = "7p5GBP";
            break;
        }
        case CS_HSIO_EDC_MODE_8p5G_BP:
        {
            output = "8p5GBP";
            break;
        }
        case CS_HSIO_EDC_MODE_FCAN:
        {
            output = "FCAN";
            break;
        }
        case CS_HSIO_EDC_MODE_15G_BP_27dB:
        {
            output = "15G_27";
            break;
        }
        case CS_HSIO_EDC_MODE_SMLRM:
        {
            output = "SMLRM ";
            break;
        }
        default:
        {
            output = "???";
            break;
        }
    }

    CS_SNPRINTF((buffer, len, "%s", output));
    buffer[len] = 0;

    return buffer;
}

/**
 * This is an internal method used to format the voltage in order to display
 * it in the status report
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_voltage_0p9(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint32 voltage = 0;
    cs4224_mon_volt_read_fixp(slice, CS4224_VLT_SUPPLY_0p9V, &voltage);
    CS_SNPRINTF((buffer, len, "%05d", voltage));
    
    return buffer;
}

/**
 * This is an internal method used to format the voltage in order to display
 * it in the status report
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_voltage_1p8(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint32 voltage = 0;
    cs4224_mon_volt_read_fixp(slice, CS4224_VLT_SUPPLY_1p8V, &voltage);
    CS_SNPRINTF((buffer, len, "%05d", voltage));
    
    return buffer;
}

/**
 * This is an internal method used to format the SKU in order to display
 * it in the status report
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_sku(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint16 sku;
    const char* sku_string = NULL;
    cs4224_reg_get_channel(slice, CS4224_EFUSE_PDF_SKU, &sku);
    
    switch(sku & 0x17)
    {
        /* production */
        case CS4224_HW_CS4223:
        {
            sku_string = "4223-4D"; break;
        }
        case CS4224_HW_CS4224:
        {
            sku_string = "4224-16S"; break;
        }
        case CS4224_HW_CS4343:
        {
            sku_string =  "4343-8D"; break;
        }
        case CS4224_HW_CS4221:
        {
            sku_string = "4221-10S"; break;
        }
        case CS4224_HW_CS4227:
        {
            sku_string = "4227-2D"; break;
        }
        case CS4224_HW_CS4210:
        {
            sku_string = "4210-16S"; break;
        }
        case CS4224_HW_CS4341:
        {
            sku_string = "4341-8D"; break;
        }
        default:
        {
            sku_string = "--"; break;
        }
    }
            
    /* Check to see if this is an engineering SKU */
    if(0x8 == (sku & 0x8))
    {
        CS_SNPRINTF((buffer, len, "%sE", sku_string));
    }
    else
    {
        CS_SNPRINTF((buffer, len, "%sP", sku_string));
    }

    return buffer;
}

/**
 * This is an internal method to display the clock divider configuration.
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_dividers(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint32 clkdiv_ctrl_addr;
    cs_uint16 reg_data;
    const char* fastdiv = NULL;
    const char* ddiv = NULL;
    const char* rdiv = NULL;

    if(interface == CS4224_CFG_LINE_SIDE) 
    {
        clkdiv_ctrl_addr = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
    }
    else
    {
        clkdiv_ctrl_addr = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
    }

    cs4224_reg_get_channel(slice, clkdiv_ctrl_addr, &reg_data);

    switch(reg_data & 0xF)
    {
        case 0: rdiv="/8"; break;
        case 1: rdiv="/16"; break;
        case 2: rdiv="/32"; break;
        case 3: rdiv="/40"; break;
        case 4: rdiv="/64"; break;
        case 5: rdiv="/66"; break;
        case 6: rdiv="/80"; break;
        case 7: rdiv="/100"; break;
        case 8: rdiv="/128"; break;
        case 9: rdiv="/FRC"; break;
        default: rdiv="???"; break;
    }

    switch((reg_data >> 4) & 0xF)
    {
        case 0: ddiv="/1"; break;
        case 1: ddiv="/2"; break;
        case 2: ddiv="/4"; break;
        case 3: ddiv="/8"; break;
        case 4: ddiv="/16"; break;
        case 5: ddiv="/32"; break;
        case 6: ddiv="/64"; break;
        case 7: ddiv="/128"; break;
        default: ddiv="???"; break;
    }

    switch((reg_data >> 12) & 0xF)
    {
        case 0: fastdiv="/8"; break;
        case 1: fastdiv="/16"; break;
        case 2: fastdiv="/32"; break;
        case 3: fastdiv="/40"; break;
        case 4: fastdiv="/64"; break;
        case 5: fastdiv="/66"; break;
        case 6: fastdiv="/80"; break;
        case 7: fastdiv="/100"; break;
        case 8: fastdiv="/128"; break;
        case 9: fastdiv="/FRC"; break;
        default: fastdiv="???"; break;
    }

    CS_SNPRINTF((buffer, len, "%4s,%4s,%4s", rdiv, ddiv, fastdiv));

    return buffer;
}

/**
 * This is an internal method to display the fractional divider configuration.
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_fracn(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint16 reg_data;
    cs_uint32 numerator;
    cs_uint8 divisor;
    int offset = 0;

    if(interface == CS4224_CFG_HOST_SIDE) 
    {
        offset = 0x800;
    }

    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_NUMERATOR1 + offset, &reg_data);
    numerator = (cs_uint32)reg_data << 16;
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_NUMERATOR0 + offset, &reg_data);
    numerator |= (cs_uint32)reg_data;

    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_FRAC0_INTDIV + offset, &reg_data);
    divisor = reg_data & 0xff;

    CS_SNPRINTF((buffer, len, "%6x,%4x", numerator, divisor));

    return buffer;
}

/**
 * This is an internal method to display the polarity inversion configuration
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_polarity_inversion(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint16 reg_data;
    int offset = 0;
    cs_boolean analog_tx;
    cs_boolean digital_tx;
    cs_boolean digital_rx;

    if(interface == CS4224_CFG_HOST_SIDE) 
    {
        offset = 0x800;
    }

    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, &reg_data);
    analog_tx = (reg_data >> 11) & 0x1;

    if(interface == CS4224_CFG_LINE_SIDE)
    {
        cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config, &reg_data);
    }
    else
    {
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config, &reg_data);
    }

    digital_tx = (reg_data >> 2) & 0x1; 
    
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config + offset, &reg_data);
    digital_rx = (reg_data >> 2) & 0x1; 

    CS_SNPRINTF((buffer, len, "%s%s%s",
            analog_tx  == 1 ? "+AlgTX" : " ",
            digital_tx == 1 ? "+DigTx" : " ",
            digital_rx == 1 ? "+DigRX" : " "));

    if(3 == CS_STRLEN(buffer)) /* 3 spaces */
    {
        CS_SNPRINTF((buffer, len, "Off"));
    } 

    return buffer;
}

/**
 * This is an internal method to display the RX lock status
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_rxlock(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint16 reg_data;
    int offset = 0;

    if(interface == CS4224_CFG_HOST_SIDE) 
    {
        offset = 0x800;
    }

    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS + offset, &reg_data);

    CS_SNPRINTF((buffer, len, "%s", (reg_data & 0x40) == 0x40 ? "Yes" : "No"));

    return buffer;
}

/**
 * This method is called to query the status of each of the line
 * side PCSes and display it.
 *
 * @param slice     [I] - The slice of the device to read
 * @param interface [I] - The interface being accessed (CS_STATUS_INTF_LINE
 *                        or CS_STATUS_INTF_HOST
 * @param buffer    [I] - The buffer to write data to.
 * @param len       [I] - The length of the buffer to write to.
 *
 * @return The formatted buffer
 *
 * @private
 */
const char* cs4224_diags_format_pcs_status(
    cs_uint32 slice,
    int       interface,
    char*     buffer,
    int       len)
{
    cs_uint16 data;
    cs_uint16 pcs_data;
    cs_status status = CS_OK;
    cs_boolean xgpcs_enabled = FALSE;
    cs_boolean xgpcs_synced  = FALSE;
    cs_boolean xgpcs_high_ber = FALSE;
    cs_boolean egpcs_enabled = FALSE;
    cs_boolean egpcs_synced  = FALSE;
    cs_boolean gigepcs_enabled = FALSE;
    cs_boolean gigepcs_synced  = FALSE;

    if(interface == CS4224_CFG_HOST_SIDE)
    {
        return "";
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, &data);

    /* If the XGPCS is enabled then query it's status */
    if(CS_BIT2 == (data & CS_BIT2))
    {
        /* Ensure the XGPCS is out of reset */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXCNTRL, &pcs_data);
        if(!(CS_BIT15 == (pcs_data & CS_BIT15)))
        {
            xgpcs_enabled = TRUE;
            xgpcs_synced = TRUE;
            xgpcs_high_ber = FALSE;

            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXSTATUS, &pcs_data);

            /* If the 10G PCS is enable but synced then the link is not ready */
            if(!(CS_BIT8 == (pcs_data & CS_BIT8)))
            {
                xgpcs_synced = FALSE;
            }                        

            /* If the 10G PCS is showing bit errors then the link is not ready */
            if(CS_BIT9 == (pcs_data & CS_BIT9))
            {
                xgpcs_high_ber = TRUE;
            }
        }
    } 
    /* Else if the 8G PCS is enabled then check it's PCS sync status */
    else if(CS_BIT1 == (data & CS_BIT1))
    {
        /* Ensure the 8G PCS is out of reset */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_EGPCS_RX_MODE, &pcs_data);
        if(!(CS_BIT15 == (pcs_data & CS_BIT15)))
        {
            egpcs_enabled = TRUE;
            egpcs_synced = TRUE;

            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_EGPCS_RX_INTSTATUS, &pcs_data);

            /* If the EGPCS is not synced then the link is not ready */
            if(!(CS_BIT0 == (pcs_data & CS_BIT0)))
            {
                egpcs_synced = FALSE;
            }
        }
    }
    /* Else if the 1G PCS is enabled then check it's PCS sync status */
    else if(CS_BIT0 == (data & CS_BIT0))
    {
        /* Ensure the 1G PCS is out of reset */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_GIGEPCS_LINE_CONTROL, &pcs_data);
        if(!(CS_BIT15 == (pcs_data & CS_BIT15)))
        {
            gigepcs_enabled = TRUE;
            gigepcs_synced = TRUE;

            /* If the 1G PCS is not showing sync then the link isn't ready */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_GIGEPCS_LINE_STATUS, &pcs_data);
            if(!(CS_BIT2 == (pcs_data & CS_BIT2)))
            {
                gigepcs_synced = FALSE;
            }
        }
    }
    
    CS_SNPRINTF((buffer, len, "%6s|%6s|%6s",
                xgpcs_enabled ? (xgpcs_synced ? (xgpcs_high_ber ? "Y+BER" : "Y") : "N") : "-",
                egpcs_enabled ? (egpcs_synced ? "Y" : "N") : "-",
                gigepcs_enabled ? (gigepcs_synced ? "Y" : "N") : "-"));

    return buffer;
}

/**
 * This structure is used by the diagnostics status in order to
 * know how to format a field in the summary report.
 *
 * @private
 */
typedef struct cs_edc_field_s
{
    /** the register address (if applicable) */
    cs_uint32   reg_addr;

    /** A label to associate with a field in the report */
    const char* field_label;

    /**
     * The format of the field, currently only 'x' or 's'
     * are supported
     */
    const char* field_format;

    /** The width of the field */
    int         field_width;

    /** An optional callback used to format the field */
    const char* (*callback)(cs_uint32 slice, int interface, char* buffer, int len);
}cs_edc_field_t;

/**
 * This structure is used to define an entry in
 * each section of the status summary
 *
 * @private
 */
typedef struct cs_edc_row_s
{
    /** This is a label to associate with a row of the report */
    const char* label;

    /** The number of instances of the section */
    int instances;

    /** The number of columns in this section */
    int cols;

    /**
     * This is an include mask that is used to define whether or
     * not the row should be displayed
     */
    cs_uint16   include_mask;

    /**
     * This is the list of fields in that row or section of
     * the report. This must be changed if more fields
     * are displayed
     */
    cs_edc_field_t fields[14];
}cs_edc_row_t;

/**
 * This array defines the rows that are part of the status report
 *
 * @private
 */
cs_edc_row_t g_edc_fields[] = 
{
    /* Global status */
    {
        "Global Status",
        1,  /* Only one global instance, no port pair registers */
        14, /* The number of columns in the array below */
        CS4224_STATUS_GLOBAL,
        {
            {0,                                              "SKU",      "s", 10, cs4224_diags_format_sku},
            {CS4224_EFUSE_PDF_MON_CAL_DATA,                  "EFCAL",    "x", 5, NULL},
            {CS4224_EFUSE_PDF_MON_GAIN_DATA,                 "EFGAI",    "x", 5, NULL},
            {CS4224_GLOBAL_UCODE_TIMESTAMP0,                 "TIME0",    "x", 5, NULL},
            {CS4224_GLOBAL_UCODE_TIMESTAMP1,                 "TIME1",    "x", 5, NULL},
            {CS4224_GLOBAL_UCODE_TIMESTAMP2,                 "TIME2",    "x", 5, NULL},
            {CS4224_GLOBAL_DWNLD_CHECKSUM_HW,                "CHKHW",    "x", 5, NULL},
            {CS4224_GLOBAL_DWNLD_CHECKSUM_SW,                "CHKSW",    "x", 5, NULL},
            {CS4224_GLOBAL_PIN_STATUS,                       "PINST",    "x", 5, NULL},
            {CS4224_EEPROM_LOADER_STATUS,                    "EPSTS",    "x", 5, NULL},
            {CS4224_GLOBAL_SCRATCH7,                         "APIVER",   "x", 6, NULL},
            {0,                                              "Temp",     "s", 5, cs4224_diags_format_temperature},
            {0,                                              "1.8V",     "s", 5, cs4224_diags_format_voltage_1p8},
            {0,                                              "0.9V",     "s", 5, cs4224_diags_format_voltage_0p9},
        }
    },
    /* SERDES status like locks and transmit coefficients */
    {
        "Serdes Status",
        2,  /* 2 instances = Line + host */
        9, /* The number of columns in the array below */
        CS4224_STATUS_SERDES,
        {
            {0,                                              "Lock",    "s", 4, cs4224_diags_format_rxlock}, 
            {CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT,   "LockI",   "x", 5, NULL},
            {CS4224_PP_LINE_SDS_COMMON_RXVCO0_STATUS,        "Freq",    "x", 4, NULL}, 
            {0,                                              "EDC MD",  "s", 6, cs4224_diags_format_edc_mode}, 
            {CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, "CTLA",    "x", 4, NULL},
            {CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, "CTLB",    "x", 4, NULL},
            {CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH,         "Sqlch",   "x", 5, NULL},
            {CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA,          "RX_CPA",  "x", 6, NULL},
            {CS4224_PP_LINE_SDS_COMMON_RXVCO0_STATUS,        "VCOSTAT", "x", 7, NULL},
            
        }
    },

    /* Clocking Dividers and Lane Mappings */
    {
        "Receive Clocking/Polarity Inversion",
        2, /* 2 instances = Line + host */
        3, /* The number of columns in the array below */
        CS4224_STATUS_CLOCKING,
        {
            {0,                               "RDIV,DDIV,FDIV",     "s", 14, cs4224_diags_format_dividers},
            {0,                               "Numrtr,Div ",        "s", 11, cs4224_diags_format_fracn},
            {0,                               "Polarity Inversion", "s", 18, cs4224_diags_format_polarity_inversion},
        }
    },

    /* Microsequencer status */
    {
        "Microsequencer Status",
        2,  /* 2 instances = Line + host */
        10,  /* The number of columns in the array below */
        CS4224_STATUS_MSEQ,
        {
            {CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS,           "MSQ_STA",  "x", 7, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE,           "MSQ_ENB",  "x", 7, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW,   "OPTIONS",  "x", 7, NULL},
            {0,                                            "RSTCNT",   "s", 8, cs4224_diags_format_reset_count},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1,    "EQAD1",    "x", 5, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2,    "EQAD2",    "x", 5, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL,     "PHSEL",    "x", 6, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_AGC_GAIN,  "AGC_GN",   "x", 6, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_MSB,   "PWRDN_M",  "x", 7, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB,   "PWRDN_L",  "x", 7, NULL},
        }
    },

    /* Microsequencer spare registers */
    {
        "Microsequencer Spares",
        2,  /* 2 instances = Line + host */
        9,  /* The number of columns in the array below */
        CS4224_STATUS_MSEQ,
        {
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE1_LSB,       "SP1_LSB",  "x", 7, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE1_MSB,       "SP1_MSB",  "x", 7, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE3_LSB,       "SP3_LSB",  "x", 7, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE3_MSB,       "SP3_MSB",  "x", 7, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE10_LSB,      "SP10_LSB", "x", 8, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE10_MSB,      "SP10_MSB", "x", 8, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB,      "SP12_LSB", "x", 8, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE16_LSB,      "SP16_LSB", "x", 8, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE19_LSB,      "SP19_LSB", "x", 8, NULL},
        }
    },
    
    /* Line Interrupt status, two of them since there are a lot of line registers */
    {
        "Line Interrupts",
        1,  /* 2 instances = Line + host */
        9,  /* The number of columns in the array below */
        CS4224_STATUS_LINE_INTERRUPT,
        {
            {0x1051,                                           "RXVCO0",       "x", 6,  NULL},
            {CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT,     "RXLOCKD0",     "x", 8,  NULL}, 
            {CS4224_PP_LINE_SDS_COMMON_PRBSCHK0_INTERRUPT,     "PRBSCHK0",     "x", 8,  NULL}, 
            {CS4224_PP_LINE_SDS_DSP_COEF_SATURATED_INT,        "DSP_SAT",      "x", 7,  NULL}, 
            {0x1439,                                           "EMDS",         "x", 4,  NULL},
            {CS4224_PP_LINE_GIGEPCS_INT_LINE_PCS1GE_INTERRUPT, "PCS1GE",       "x", 6,  NULL},
            {CS4224_PP_LINE_EGPCS_RX_INTERRUPT,                "EGPCS_RX",     "x", 8,  NULL},
            {CS4224_PP_LINE_EGPCS_TX_INTERRUPT,                "EGPCS_TX",     "x", 8,  NULL},
            {CS4224_PP_LINE_XGPCS_RX_RXINT,                    "XGPCS_RX",     "x", 8,  NULL},
        }
    },
    {
        "Line Protocol Interrupts",
        1,  /* 2 instances = Line + host */
        9,  /* The number of columns in the array below */
        CS4224_STATUS_LINE_INTERRUPT,
        {
            {CS4224_PP_LINE_AN_TX_AN_COMPLETE_STATUS_INT,      "AN_COMP",      "x", 7,  NULL},
            {CS4224_PP_LINE_AN_TX_MAIN_INT,                    "AN_TX_MAIN",   "x", 10, NULL},
            {CS4224_PP_LINE_AN_TX_TX_AFIFO_INT,                "AN_TX_AFIFO",  "x", 11, NULL},
            {CS4224_PP_LINE_AN_RX_MAIN_INT,                    "AN_RX_MAIN",   "x", 10, NULL},
            {CS4224_PP_LINE_AN_RX_RX_AFIFO_INT,                "AN_RX_AFIFO",  "x", 11, NULL},
            {CS4224_PP_LINE_TP_TX_TRAINING_INT,                "TP_TX_TRAIN",  "x", 11, NULL},
            {CS4224_PP_LINE_TP_RX_FRAME_LOCK_INT,              "TP_RX_FL",     "x", 8,  NULL},
            {CS4224_PP_LINE_KR_FEC_TX_INT,                     "KR_FEC_TX",    "x", 9,  NULL},
            {CS4224_PP_LINE_KR_FEC_RX_INT,                     "KR_FEC_RX",    "x", 9,  NULL},
        }
    },
    
    /* Host Interrupt Status */
    {
        "Host Interrupts",
        1,  /* 2 instances = Line + host */
        6,  /* The number of columns in the array below */
        CS4224_STATUS_HOST_INTERRUPT,
        {
            {0x1851,                                           "RXVCO0",   "x", 6, NULL},
            {CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT,     "RXLOCKD0", "x", 8, NULL},
            {CS4224_PP_HOST_SDS_COMMON_PRBSCHK0_INTERRUPT,     "PRBSCHK0", "x", 8, NULL},
            {CS4224_PP_HOST_SDS_DSP_COEF_SATURATED_INT,        "DSP_SAT",  "x", 7, NULL},
            {0x1c39,                                           "EMDS",     "x", 4, NULL},
            {CS4224_PP_HOST_GIGEPCS_INT_HOST_PCS1GE_INTERRUPT, "PCS1GE",   "x", 6, NULL},
        }
    },

    /* Link Status */
    {
        "Link Status",
        1,  /* One instance showing line + host */
        5,
        CS4224_STATUS_LINK,
        {
            {CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS, "Line", "x", 4, NULL},
            {CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS,           "MSEQ", "x", 4, NULL},
            {0,                                            "10GPCS| 8GPCS| 1GPCS",  "s", 21, cs4224_diags_format_pcs_status},

            {CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS, "Host", "x", 4, NULL},
            {CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS,           "MSEQ", "x", 4, NULL},
        }
    }
};

/**
 * This method is called to show the overall status of the device
 * for a particular set of slices. This method will not work properly
 * on simplex devices right now. This will be added in the future.
 *
 * This method is only defined if CS_DONT_USE_STDLIB is not defined
 * implying that the C standard library is available. It uses sprintf()
 * and the CS_PRINTF() macro to display output which may not be
 * possible on systems that do not have a console.
 *
 * The following tables describe the format of each of these
 * sections:
 *
 * @{table,
 * -t Global Status (STATUS_GLOBAL)
 * -h Column | Description
 * - Sl      | The slice/channel number
 * - SKU     | The SKU identifying the device
 * - EFCAL   | Calibration constants programmed on the device
 * - EFGAI   | Calibration constants programmed on the device
 * - TIME0   | The microcode timestamp (MM/DD)
 * - TIME1   | The microcode timestamp (YYYY)
 * - TIME2   | The microcode timestamp (HH/MM)
 * - CHKHW   | The calculated hardware checksum
 * - CHKSW   | The calculated software checksum
 * - PIN_ST  | The value of the pin status register
 * - EP_STS  | The value of the EEPROM status register
 * - API_VER | The verion of the API used to program the ASIC.
 * }
 *
 * @{table,
 * -t SERDES Status (STATUS_SERDES)
 * -h Column  | Description
 * - Sl       | The slice/channel number
 * - Lock     | Whether or not the lock detector is locked
 * - LockI    | The current value of the lock detect interrupt register
 * - Freq     | The VCO frequency slot
 * - EDC MD   | The configured EDC mode such as CX1, SR, etc.
 * - CTRLA    | The main cursor
 * - CTRLB    | The pre and post cursors
 * - Squelch  | 1 if the TX is squelched, 0 if not
 * - Temp     | The measured temperature from the die
 * - 1.8V     | The measured voltage of the die
 * - 0.9V     | The measured voltage of the die
 * }
 *
 * @{table,
 * -t Receive Clocking (STATUS_CLOCKING)
 * -h Column            | Description
 * - Sl                 | The slice/channel number
 * - RDIV,DDIV,FDIV     | The configuration of the three clock dividers RDIV, DDIV and FASTDIV.
 * - Nmrtr,Div          | The configuration of the fractional divider (Numerator, Divisor)
 * - Polarity Inversion | The configuration of any polarity inversions (Blank if none are enabled)
 * }
 *
 * @{table,
 * -t Microsequencer Status (STATUS_MSEQ)
 * -h Column | Description
 * - Sl      | The slice/channel number
 * - MSEQ_STA | The current value of the MSEQ_STATUS register showing info like EDC convergence
 * - RSTCNT   | Microsequencer reset count (increments if RX lock is lost)
 * - EQADJ1   | Microsequencer calibration information
 * - EQADJ2   | Microsequencer calibration information
 * - PHSEL    | Microsequencer calibration information
 * - AGC_GN   | Microsequencer calibration information
 * - PWRDN_M  | Microsequencer status information
 * - PWRDN_L  | Microsequencer status information
 * }
 *
 * @param slice_start         [I] - The slice to start the dump from
 * @param slice_end           [I] - The slice to end the dump at.
 * @param sections_to_display [I] - A mask defining the sections of the report
 *                                  to display, use e_cs4224_status_mask
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @example
 *
 *     // Print the full status for slices 0-7
 *     cs4224_diags_show_status(0, 7, CS4224_STATUS_ALL);
 *
 *     // Only print the global and serdes information for slices 0-3
 *     cs4224_diags_show_status(0, 3, CS4224_STATUS_GLOBAL | CS4224_STATUS_SERDES);
 */
cs_status cs4224_diags_show_status(
    cs_uint32 slice_start,
    cs_uint32 slice_end,
    cs_uint16 sections_to_display)
{
    int i,j;
    cs_uint32 k,slice;
    cs_uint32 row;
    cs_status status = CS_OK;
    int instance;
    cs_boolean is_simplex = FALSE;

    if(cs4224_is_hw_simplex(slice_start))
    {
        is_simplex = TRUE;
    }

    /* slice printed below will have the EDC address removed, so print it at least once */
    CS_PRINTF(( "\nStatus of EDC %08x\n\n", (cs_uint32)(slice_start & 0xFFFFFF00) ));

    for(instance = 0; instance < 2; instance++)
    {
        for(row = 0; row < sizeof(g_edc_fields)/sizeof(cs_edc_row_t); row++)
        {
            /* If this section is not selected then skip it */
            if((sections_to_display & g_edc_fields[row].include_mask) != g_edc_fields[row].include_mask)
            {
                continue;
            }

            if(g_edc_fields[row].instances == 1 && instance > 0)
            {
                continue;
            } 
            
            if(is_simplex && instance > 0)
            {
                continue;
            }
        
            if(is_simplex || g_edc_fields[row].instances == 1)
            {
                CS_PRINTF(("%s\n", g_edc_fields[row].label));
            }
            else
            {
                if(instance == 0)
                {
                    CS_PRINTF(("Line %s\n", g_edc_fields[row].label));
                }
                else
                {
                    CS_PRINTF(("Host %s\n", g_edc_fields[row].label));
                }
            }
        
            /* Print the top of the header */
            CS_PRINTF(("---+"));
            for(i = 0; i < g_edc_fields[row].cols; i++)
            {
                cs_uint16 field_width = g_edc_fields[row].fields[i].field_width;

                /* Only display the field header if the width > 0 */
                for(k = 0; k < field_width; k++)
                {
                    CS_PRINTF(("-"));
                }

                if(field_width > 0)
                {
                    CS_PRINTF(("+"));
                }
            }
            CS_PRINTF(("\n"));
        
            /* Print the row header */
            CS_PRINTF(("Sl#|"));
            for(i = 0; i < g_edc_fields[row].cols; i++)
            {
                cs_uint16 field_width = g_edc_fields[row].fields[i].field_width;
                const char* field_label = g_edc_fields[row].fields[i].field_label;

                /* Only display the field header if the width > 0 */
                if(field_width > 0)
                {
                    CS_PRINTF(("%*s|", field_width, field_label));
                }
            }
            CS_PRINTF(("\n"));
        
            /* Print the bottom of the row header */
            CS_PRINTF(("---+"));
            for(i = 0; i < g_edc_fields[row].cols; i++)
            {
                cs_uint16 field_width = g_edc_fields[row].fields[i].field_width;

                /* Only display the field header if the width > 0 */
                for(k = 0; k < field_width; k++)
                {
                    CS_PRINTF(("-"));
                }

                if(field_width > 0)
                {
                    CS_PRINTF(("+"));
                }
            }
            CS_PRINTF(("\n"));
            
            
            /* Print the status for each slice of the device for this section
             * of the report. */
            for(slice = slice_start; slice <= slice_end; slice++)
            {
                CS_PRINTF(( "%3d|", (slice&0xFF) ));
                for(j = 0; j < g_edc_fields[row].cols; j++)
                {
                    cs_uint16 field_width = g_edc_fields[row].fields[j].field_width;
                    int interface;
                    
                    /* For simplex SKUs we need to override the interface based on whether
                     * or not it is line vs. host */
                    if(cs4224_is_hw_simplex(slice))
                    {
                        if(cs4224_line_rx_to_host_tx_dir(slice))
                        {
                            interface = CS4224_CFG_LINE_SIDE; 
                        }
                        else
                        {
                            interface = CS4224_CFG_HOST_SIDE; 
                        }
                    }
                    else
                    {
                        if(instance == 0)
                        {
                            interface = CS4224_CFG_LINE_SIDE;
                        }
                        else
                        {
                            interface = CS4224_CFG_HOST_SIDE;
                        }
                    }

                    /* Only display the field if the width > 0 */
                    if(field_width > 0)
                    { 
                        /* If the field has a display callback then call it instead of
                         * grabbing the register data. */
                        if(g_edc_fields[row].fields[j].callback != NULL)
                        {
                            char format_buffer[32];
                            int len = g_edc_fields[row].fields[j].field_width;
                            CS_PRINTF(("%*s|", field_width, g_edc_fields[row].fields[j].callback(slice, interface, format_buffer, len)));
                        }
                        else
                        {
                            cs_uint16 reg_data;
                            cs_uint32 addr = g_edc_fields[row].fields[j].reg_addr;

                            if(instance == 1)
                            {
                                addr += 0x800;
                            }
                            
                            if(addr != 0)
                            {
                                status |= cs4224_reg_get_channel(slice, addr, &reg_data);
                                CS_PRINTF(("%*x|", field_width, reg_data));
                            }
                            else
                            {
                                status |= cs4224_reg_get_channel(slice, addr, &reg_data);
                                CS_PRINTF(("%*s|", field_width, "--"));
                            }
                        }
                    }
                }
                CS_PRINTF(("\n"));
            }
            
            
            /* Print the footer of the row */
            CS_PRINTF(("---+"));
            for(i = 0; i < g_edc_fields[row].cols; i++)
            {
                cs_uint16 field_width = g_edc_fields[row].fields[i].field_width;

                /* Only display the field header if the width > 0 */
                for(k = 0; k < field_width; k++)
                {
                    CS_PRINTF(("-"));
                }

                if(field_width > 0)
                {
                    CS_PRINTF(("+"));
                }
            }
            CS_PRINTF(("\n\n"));
        }
    }

    return status;
}

/** This method dumps out current interrupt stats on all slices of a device,
 *   then resets the state of those interrupts so testing can continue. Similar
 *   to a PRBS check but for non-PRBS status information
 * 
 * @param die  [I] - Uses the upper bits to determine which device to get stats from
 *
 * @return CS_OK on a pass, CS_ERROR otherwise
 * 
 */
cs_status cs4224_diags_show_and_clear_stats(
    cs_uint32 die)
{
    cs_status status = CS_OK;
    cs_uint32 i = 0;
    cs4224_fec_stats_t fec_stats;
    cs_uint16 sections = CS4224_STATUS_GLOBAL | CS4224_STATUS_SERDES | CS4224_STATUS_HOST_INTERRUPT | \
                         CS4224_STATUS_LINE_INTERRUPT | CS4224_STATUS_MSEQ;
    cs_uint32 upper_bits = (die & 0xFFFFFF00);
    cs_uint32 min = upper_bits; /* slice 0 */
    cs_uint32 max = upper_bits | (CS4224_MAX_NUM_SLICES(die)-1); /* slice 7 or 15 */

    CS_PRINTF(("\nCS4224: Stats for die 0x%08x\n\n",upper_bits));

    /* Dump out interrupt information */
    status |= cs4224_diags_show_status(min, max, sections);

    if(!cs4224_is_hw_simplex(die))
    {
        /* FEC is only valid in duplex + KR-AN */
        /* Dump out FEC information */
        CS_PRINTF(("FEC Stats:\n"));
        CS_PRINTF(("sl# | tx_blk_total | rx_blk_total | rx_blk_corr | rx_blk_uncorr | rx_zero_errs | rx_one_errs\n"));
        for(i = 0; i < CS4224_MAX_NUM_SLICES(die); i++)
        {
            status |= cs4224_get_fec_stats( (upper_bits | i), &fec_stats );
            CS_PRINTF(( "%3d | %12x | %12x | %11x | %13x | %12x | %11x",
                        i,
                        fec_stats.tx_blk_total,
                        fec_stats.rx_blk_total,
                        fec_stats.rx_blk_corr,
                        fec_stats.rx_blk_uncorr,
                        fec_stats.rx_zero_errs,
                        fec_stats.rx_one_errs
                        ));
            /*check for any errors in the FEC stats */
            if( (0 != fec_stats.rx_blk_corr) || (0 != fec_stats.rx_blk_uncorr) )
            {
                CS_PRINTF(("  ***  ERRORS"));
            }
            CS_PRINTF(("\n"));
        }
    }

    /* Clear all the interrupts */
    for(i = 0; i < CS4224_MAX_NUM_SLICES(die); i++)
    {
        status |= cs4224_diags_clear_interrupts( upper_bits | i );
    }
    
    return status;
}

#endif /* CS_HAS_DEBUG_STATUS_DUMPS == 1 */

#if (CS_HAS_DEBUG_REGISTER_DUMPS == 1)

/**
 * Some registers cannot be read or else you risk breaking the operation of the
 * mseq. This function will return TRUE if you can read from the register address
 * or FALSE if reading will cause errors.
 * 
 * @param addr     [I] - Register address you wish to read from
 * 
 * @return TRUE if register can be read, FALSE otherwise
 * 
 * @private
 */
cs_boolean cs4224_diags_register_can_read(
        cs_uint16 addr)
{
    /* don't read from select register ranges */
    if( (addr >= CS4224_PP_LINE_SDS_DSP_MSEQ_IX && addr <= CS4224_PP_LINE_SDS_DSP_MSEQ_BASE3_INST) ||
        (addr >= CS4224_PP_HOST_SDS_DSP_MSEQ_IX && addr <= CS4224_PP_HOST_SDS_DSP_MSEQ_BASE3_INST) )
    {
        return FALSE;
    }
    return TRUE;
    
}

/**
 * This method is called to dump a range of registers on the device.
 *
 * @param die        [I] - The die of the device to dump registers on
 * @param start_addr [I] - The start address of the range to dump
 * @param end_addr   [I] - The end address of the range to dump. This
 *                         address is included in the register dump.
 * @param registers  [O] - The array to store register values. This must
 *                         be at least as big as (end_addr - start_addr + 1)
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 *    cs_uint16 registers[8];
 *    cs_uint32 die = 0;
 *    int i;
 *
 *    // Read the 8 scratch registers (addresses 0x1d - 0x24)
 *    cs4224_diags_register_dump_range(die, 0x1d, 0x1d + 8, registers); 
 *
 *    for(i = 0; i < 8; i++)
 *    {
 *        CS_PRINTF(("%d: %x = %x\\n", i, 0x1d + i, registers[i]));
 *    }
 */
cs_status cs4224_diags_register_dump_range(
        cs_uint32 die,
        cs_uint32 start_addr,
        cs_uint32 end_addr,
        cs_uint16 registers[])
{
    cs_status status = CS_OK;
    cs_uint32 addr;
    
    status |= cs4224_lock(die);

    /* Ensure a valid address was entered */
    if((start_addr > end_addr) || (end_addr > 0x5011))
    {
        return CS_ERROR;
    }

    for(addr = start_addr; addr <= end_addr; addr++)
    {
        if(cs4224_diags_register_can_read(addr))
        {
            status |= cs4224_reg_get(die, addr, &(registers[addr-start_addr]));
        }
        else
        {
            registers[addr-start_addr] = 0xbeef;
        }
    }
    
    status |= cs4224_unlock(die);

    return status;
}

/**
 * This is an internal array that is used to determine
 * the valid sections of the address map to read when
 * dumping registers. This array consists of:
 *
 *    start_addr, end_addr
 *
 * for each block of registers in the address map.
 */
cs_uint32 g_register_ranges[][2] = 
{
    {0x0,    0xfe},   /* GLOBAL         */
    {0x100,  0x14d},  /* GPIO           */
    {0x180,  0x1d6},  /* EFUSE          */
    {0x200,  0x2a6},  /* MONITOR        */
    {0x2e0,  0x2e9},  /* CLKMON_GBL     */
    {0x300,  0x30e},  /* MSEQ_PS[0]     */
    {0x400,  0x40e},  /* MSEQ_PS[1]     */

    {0x1000, 0x1012}, /* PP[0].LINEMISC */
    {0x1020, 0x10CA}, /* PP[0].LINE_SDS_COMMON */
    {0x1220, 0x1228}, /* PP[0].LINE_SDS_DSP_MSEQ */
                      /* skip _IX...BASE3_INST */
    {0x1234, 0x12B9}, /* PP[0].LINE_SDS_DSP_MSEQ */
    {0x1320, 0x135D}, /* PP[0].LINE_SDS_DSP */
    {0x1420, 0x1442}, /* PP[0].LINE_EMDS */
    {0x1460, 0x1483}, /* PP[0].LINE_GIGEPCS */
    {0x14a0, 0x14b9}, /* PP[0].LINE_EGPCS */
    {0x14C0, 0x14EF}, /* PP[0].LINE_XGPCS */
    {0x1500, 0x1565}, /* PP[0].LINE_KR_AN */
    {0x1580, 0x15CC}, /* PP[0].LINE_KR_TP */
    {0x1600, 0x1664}, /* PP[0].LINE_KR_FEC */
    {0x1680, 0x168C}, /* PP[0].LINE_MCAN */
    {0x1800, 0x1812}, /* PP[0].HOSTMISC */
    {0x1820, 0x18CA}, /* PP[0].HOST_SDS_COMMON */
    {0x1A20, 0x1AB9}, /* PP[0].HOST_SDS_DSP_MSEQ */
    {0x1B20, 0x1B5D}, /* PP[0].HOST_SDS_DSP */
    {0x1C20, 0x1C42}, /* PP[0].HOST_EMDS */
    {0x1C60, 0x1C83}, /* PP[0].HOST_GIGEPCS */

    {0x5000, 0x5011}, /* EEPROM     */
};

/**
 * This method is called to dump the entire register map for a
 * single die of the device.
 *
 * @param die [I] - The die of the device to dump registers for 
 *
 */
void cs4224_diags_register_dump_die(cs_uint32 die)
{
    cs_uint32 range;
    CS_PRINTF(("DIE %d\n-----------\n", die));
    
    cs4224_lock(die);

    for(range = 0; range < (sizeof(g_register_ranges)/sizeof(g_register_ranges[0])); range++)
    {
        cs_uint32 start = g_register_ranges[range][0];
        cs_uint32 end   = g_register_ranges[range][1];
        cs_uint32 addr;
        cs_uint16 reg_data = 0;

        /* Expand the port-pair registers to handle all instances */
        if(start >= 0x1000 && start < 0x5000)
        {
            int instance = 0;

            for(instance = 0; instance < 4; instance++)
            {
                for(addr = start; addr < end+1; addr++)
                {
                    if(cs4224_diags_register_can_read(addr))
                    {
                        cs4224_reg_get(die, addr + (instance * 0x1000), &reg_data);
                    }
                    else
                    {
                        reg_data = 0xbeef;
                    }
                    CS_PRINTF(("0x%04x = 0x%04x\n", addr + (instance * 0x1000), reg_data));
                }
            }
        }
        else
        {
            for(addr = start; addr < end+1; addr++)
            {
                if(cs4224_diags_register_can_read(addr))
                {
                    cs4224_reg_get(die, addr, &reg_data);
                }
                else
                {
                    reg_data = 0xbeef;
                }
                CS_PRINTF(("0x%04x = 0x%04x\n", addr, reg_data));
            }
        }
    }
    
    cs4224_unlock(die);
}

e_cs4224_hardware_id cs4224_hw_id(cs_uint32 slice);

/**
 * This method is called to dump the entire register map for all
 * dies in the device.
 *
 * @deprecated
 *   This method has been deprecated, use cs4224_diags_register_dump_asic 
 *   instead.
 */
void cs4224_diags_register_dump(void)
{
    int max_dies = 2;
    int die;

    if(CS4224_HW_CS4223 == cs4224_hw_id(0))
    {
        max_dies = 1;
    }

    for(die = 0; die < max_dies; die++)
    {
        cs4224_diags_register_dump_die(die);
    }
}

/**
 * This method is called to dump the entire register map for all
 * dies in the selected device.
 *
 * @param slice [I] - The slice parameter is only used to select
 *                    the ASIC to dump the registers for. It can
 *                    be any slice on that particular device.
 */
void cs4224_diags_register_dump_asic(
    cs_uint32 slice)
{
    cs_uint8  max_dies = CS4224_MAX_NUM_DIES(slice);
    cs_uint8  die;
    cs_uint32 asic_die;

    for(die = 0; die < max_dies; die++)
    {
        asic_die = (slice & 0xffffff00) | die;

        cs4224_diags_register_dump_die(asic_die);
    }
}

#endif /* CS_HAS_DEBUG_REGISTER_DUMPS == 1 */

/**
* This method runs a BIST test on internal memories
* inside the ASIC. This must be followed by a physical
* reset of the ASIC to return it to an operational state.
*
* This method can be called on multiple slices before
* resetting the ASIC to put it back into operational mode.
*
* @param slice [I] - The slice of the device to run
*                    a BIST test on.
*
* @return CS_OK if the BIST test was successful and
*         CS_ERROR on failure.
*/
cs_status cs4224_diags_mbist_run(cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data1 = 0;
    cs_uint16 reg_data2 = 0;
    cs_int8 attempts = 50;

    /* Trigger the BIST test on both addresses*/
    status |= cs4224_reg_set_channel(slice, CS4224_MSEQ_PS_MBIST_CTRL, 0x3);
    status |= cs4224_reg_set_channel(slice, CS4224_MSEQ_PS_MBIST_CTRL + 0x100, 0x3);

    /* poll first test */
    while(attempts > 0)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_MSEQ_PS_MBIST_STATUS, &reg_data1);

        if( (reg_data1 & CS_BIT0) == 0 )
        {
            CS_MDELAY(1);
            attempts--;
            continue;
        }
        break;
    }
    if(attempts <= 0)
    {
        CS_TRACE(("ERROR: BIST test 1 timed out (register read issue?)\n"));
        status |= CS_ERROR;
    }

    /* poll second test - slightly faster to have two loops (less reg_get calls) */
    attempts = 50;
    while(attempts > 0)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_MSEQ_PS_MBIST_STATUS + 0x100, &reg_data2);

        if( (reg_data2 & CS_BIT0) == 0)
        {
            CS_MDELAY(1);
            attempts--;
            continue;
        }
        break;
    }
    if(attempts <= 0)
    {
        CS_TRACE(("ERROR: BIST test 2 timed out (register read issue?)\n"));
        status |= CS_ERROR;
    }

    /* BIST failed */
    if(reg_data1 & CS_BIT1)
    {
        CS_PRINTF(("\nBIST read error in test 1\n"));
        status |= CS_ERROR;
    }
    if(reg_data2 & CS_BIT1)
    {
        CS_PRINTF(("\nBIST read error in test 2\n"));
        status |= CS_ERROR;
    }

    return status;
}

/** This method will return an error if there are uncorrected FEC blocks on any
 *  slice on the entire device.
 * 
 *  Useful for KR-AN debugging.
 *
 * @param die  [I] - Uses the upper bits to determine which device to get stats from
 *
 * @return CS_OK on a pass, CS_ERROR otherwise
 * 
 * @private
 */
cs_status cs4224_diags_get_fec_errors(
        cs_uint32 die)
{
    cs_status status = CS_OK;
    cs_uint32 upper_bits = die & 0xFFFFFF00;
    cs4224_fec_stats_t fec_stats;
    cs_uint16 i = 0;

    for(i = 0; i < CS4224_MAX_NUM_SLICES(die); i++)
    {
        status |= cs4224_get_fec_stats( (upper_bits | i), &fec_stats );
        /*check for any errors in the FEC stats */
        if( (0 != fec_stats.rx_blk_corr) || (0 != fec_stats.rx_blk_uncorr) )
        {
            CS_PRINTF(( "\nERROR: FEC errors on slice %x. rx_blk_corr = %x    rx_blk_uncorr = %x\n", (upper_bits|i), fec_stats.rx_blk_corr, fec_stats.rx_blk_uncorr ));
            status |= CS_ERROR;
        }
    }

    return status;
}

/** This method will return an error if there are uncorrected FEC blocks on the
 *  particular slice in question.
 *
 * @param slice  [I] - Slice to check the FEC stats on
 *
 * @return CS_OK on a pass, CS_ERROR otherwise
 *
 */
cs_status cs4224_diags_query_fec_status(
        cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs4224_fec_stats_t fec_stats;

    status |= cs4224_get_fec_stats(slice, &fec_stats);
    /*check for any errors in the FEC stats */
    if( (0 != fec_stats.rx_blk_corr) || (0 != fec_stats.rx_blk_uncorr) )
    {
        CS_PRINTF(( "\nERROR: FEC errors on slice %x. rx_blk_corr = %x    rx_blk_uncorr = %x\n", slice, fec_stats.rx_blk_corr, fec_stats.rx_blk_uncorr ));
        status |= CS_ERROR;
    }

    return status;
}

/** This method will clear all the known interrupts.
 *
 *  NOTE: For simplex devices this will only reset either host or line side, even
 *  if there are interrupts on the host side that may have to do with line side
 *  behaviour.
 *
 *  The implementation of this method is not ideal since the list of interrupts is manually maintained.
 *
 *  @param slice [I]  - Slice to reset the interrupts on
 *
 *  @return CS_OK on pass, CS_ERROR otherwise
 * 
 *  @private
 */
cs_status cs4224_diags_clear_interrupts(
    cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs_uint16 interrupts = 0;
    cs_uint16 i = 0, j = 0;

    if(cs4224_is_hw_simplex(slice))
    {
        if(cs4224_line_rx_to_host_tx_dir(slice))
        {
            interrupts = CS4224_STATUS_LINE_INTERRUPT;
        }
        else
        {
            interrupts = CS4224_STATUS_HOST_INTERRUPT;
        }
    }
    else /* duplex */
    {
        interrupts = CS4224_STATUS_LINE_INTERRUPT | CS4224_STATUS_HOST_INTERRUPT;
    }

    /* ideally this should actually just use the irq stuff, but we need a method
     * that can be used even if interrupts are disabled
     */

    /* step through g_edc_fields... */
    for(i = 0; i < sizeof(g_edc_fields)/sizeof(*g_edc_fields); i++)
    {
        /* ignore all non-interrupt rows */
        if(!(interrupts & g_edc_fields[i].include_mask))
        {
            continue;
        }
        /* step through each field in the interrupt row... */
        for(j = 0; j < g_edc_fields[i].cols; j++)
        {
            /* reset the interrupt on this slice */
            /* CS_PRINTF(("addr %x to 0xffff\n", g_edc_fields[i].fields[j].reg_addr)); */
            status |= cs4224_reg_set_channel( slice, g_edc_fields[i].fields[j].reg_addr, 0xFFFF);
        }
    }

    return status;
}

/**
 * This is method used to resync the digital elastic stores of a duplex slice. 
 * 
 * @param slice [I] - The slice to apply the elastic store resync.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_diags_resync_digital_elsto(
    cs_uint32         slice) 
{
    cs_status status = CS_OK;

    status |= cs4224_resync_elsto(slice, CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
    status |= cs4224_resync_elsto(slice, CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);
    status |= cs4224_resync_elsto(slice, CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);
    status |= cs4224_resync_elsto(slice, CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);

    return status;
}

/**
 * This method is a diagnostics method used to disable some portions of the cal
 * 
 * @{warning,
 * There is no going back from this, you need to reconfig the device to reset
 * the config.
 * 
 * This method is not for general usage. It rarely will make sense
 * to do this in a production environment.
 * }
 * 
 * @param slice [I] - The slice
 * @param intf  [I] - The microsequencer to change.
 * @param phsel [I] - The fixed phsel value to use
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_diags_set_phsel_mseq(
    cs_uint32        slice,
    e_cs4224_mseq_id mseq,
    cs_uint16        phsel)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;
    cs_uint16 reg_data = 0;
    e_cs4224_edc_mode edc_mode = CS_HSIO_EDC_MODE_DISABLED;
    
    offset = cs4224_mseq_get_addr_offset(slice, mseq);
    
    status |= cs4224_query_edc_mode(slice, mseq, &edc_mode);
    if(CS_OK != status)
    {
        return status;
    }
    if(CS_HSIO_EDC_MODE_SR == edc_mode)
    {
        CS_TRACE(("WARNING: Doesn't make sense to set phsel in SR mode, not setting. slice: %x mseq: %d des phsel: 0x%x\n", slice, mseq, phsel));
        return status;
    }
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL+offset, &reg_data);
    /*CS_PRINTF(("Previous phsel: 0x%x\n",reg_data));*/

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB+offset, &reg_data);
    reg_data |= CS_BIT7;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB+offset, reg_data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB+offset, &reg_data);
    reg_data |= CS_BIT13;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB+offset, reg_data);
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE15_MSB+offset, &reg_data);
    reg_data |= CS_MSB_BIT31;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE15_MSB+offset, reg_data);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB+offset, 0xFF);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE1_LSB+offset, 0x0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE1_MSB+offset, 0xFF);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_LSB+offset, 0x0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_MSB+offset, 0xFF);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB+offset, 0x10);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL+offset, phsel);
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL+offset, &reg_data);
    /*CS_PRINTF(("New phsel: 0x%x\n", reg_data));*/
    if(reg_data != phsel)
    {
        CS_TRACE(("ERROR: phsel not set to desired value, limit reached. Act: %x  des: %x\n",reg_data,phsel));
        return CS_ERROR;
    }
    
    return status;
}

/**
 * This method dumps the microsequencer data-store variables
 * 
 * @param slice  [I] - The slice or port of the device(s) being initialized
 * @param side   [I] - Identifies the microsequencer, line or host
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_diags_dump_data_store(
    cs_uint32 slice, 
    e_cs4224_mseq_id side)
{
    cs_status  status = CS_OK;
    cs_uint16  offset = 0x0000;
    cs_uint16  stall, addr, data0, data1;
    cs_boolean need_to_unstall = FALSE;

    if (side == CS4224_DPLX_HOST_MSEQ)
    {
        CS_PRINTF(("Dumping the HOST side data store of slice %x\n", slice));
        offset = 0x0800;
    }
    else
    {
        CS_PRINTF(("Dumping the LINE side data store of slice %x\n", slice));
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW + offset, &stall);
    if ((stall & 0x0008) == 0)
    {
        CS_PRINTF(("  Microsequencer is running, stalling it!\n"));

        if (side == CS4224_DPLX_HOST_MSEQ)
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, TRUE);
        }
        else
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, TRUE);
        }
        need_to_unstall = TRUE;
    }

    for (addr = 0; addr < 64; addr++)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR + offset, 0x8800 | addr);
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1 + offset, &data1);
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0 + offset, &data0);
        CS_PRINTF(("  addr:%02d, msb:0x%04x, lsb:0x%04x\n", addr, data1, data0));
    }  

    if (need_to_unstall == TRUE) 
    {
        CS_PRINTF(("  Microsequencer was running, un-stalling it!\n"));

        if (side == CS4224_DPLX_HOST_MSEQ)
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, FALSE);
        }
        else
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
        }
    }

    return status;
}

/**
 * This method dumps the microsequencer program-store variables
 * 
 * @param slice  [I] - The slice or port of the device(s) being initialized
 * @param side   [I] - Identifies the microsequencer, line or host
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_diags_dump_pgrm_store(
    cs_uint32 slice, 
    e_cs4224_mseq_id side)
{
    cs_status  status = CS_OK;
    cs_uint16  offset = 0x0000;
    cs_uint16  stall, addr, data0, data1;
    cs_boolean need_to_unstall = FALSE;
    cs_uint32  die = 0;

    die = cs4224_get_die_from_slice(slice);

    if (side == CS4224_DPLX_HOST_MSEQ)
    {
        CS_PRINTF(("Dumping the HOST side program store of die %x\n", die));
        offset = 0x0800;
    }
    else
    {
        CS_PRINTF(("Dumping the LINE side program store of die %x\n", die));
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW + offset, &stall);
    if ((stall & 0x0008) == 0)
    {
        CS_PRINTF(("  Microsequencer is running, stalling it!\n"));

        if (side == CS4224_DPLX_HOST_MSEQ)
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, TRUE);
        }
        else
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, TRUE);
        }
        need_to_unstall = TRUE;
    }

    for (addr = 3584; addr < 4096; addr++)
    {
        status |= cs4224_reg_set(die, CS4224_MSEQ_PS_RAM_CONTROL + offset, 0xa000 | addr);
        status |= cs4224_reg_get(die, CS4224_MSEQ_PS_RAM_DATA1   + offset, &data1);
        status |= cs4224_reg_get(die, CS4224_MSEQ_PS_RAM_DATA0   + offset, &data0);
        CS_PRINTF(("  addr:%02d, data:0x%02x%04x\n", addr, data1, data0));
    }  

    if (need_to_unstall == TRUE) 
    {
        CS_PRINTF(("  Microsequencer was running, un-stalling it!\n"));

        if (side == CS4224_DPLX_HOST_MSEQ)
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, FALSE);
        }
        else
        {
            cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
        }
    }

    return status;
}

/** @file cs4224_fcan.c
 ****************************************************************************
 *
 * @brief
 *    This module contains methods for configuring the FC-AN feature.
 *
 ****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ***************************************************************************/

extern cs_uint32 cs4224_max_num_dies;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :1;
    cs_uint16 prev4          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev4          :3;
    cs_uint16 rsrvd1         :1;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_FCAN_HIDDEN_PP_LINE_TP_TX_TRAINING_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :1;
    cs_uint16 prev4          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev4          :3;
    cs_uint16 rsrvd1         :1;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_FCAN_HIDDEN_PP_LINE_TP_TX_ENCODER_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :1;
    cs_uint16 prev4          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev4          :3;
    cs_uint16 rsrvd1         :1;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_FCAN_HIDDEN_PP_LINE_TP_RX_FRAME_LOCK_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :4;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 rsrvd1         :4;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_FCAN_HIDDEN_PP_LINE_TP_RX_FM_DETECT_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :13;
    cs_uint16 rtune_override :1;
    cs_uint16 itune_override :1;
    cs_uint16 tx_eq_override :1;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 tx_eq_override :1;
    cs_uint16 itune_override :1;
    cs_uint16 rtune_override :1;
    cs_uint16 rsrvd1         :13;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_FCAN_HIDDEN_PP_LINE_LINEMISC_OVERRIDE_EN_t;

extern cs_status cs4224_init_ro_vco_tmp_thresh( cs_uint32 slice, e_cs4224_cfg_sides_t intf);
extern cs_status cs4224_init_lc_vco_tmp_thresh( cs_uint32 slice, e_cs4224_cfg_sides_t intf);

/* forward declaration, defined in cs4224.c but not declared in cs4224.h */
cs_status cs4224_pgm_reg_from_efuse(cs_uint32 slice, e_cs4224_cfg_sides_t dir);
cs_status cs4224_update_clkdiv_ctrl(cs_uint32 slice, cs4224_rules_t* rules);
cs_status cs4224_update_cdr_fracn(cs_uint32 slice, cs4224_rules_t* rules);

/**
 * This method will verify that the specified rates are correct
 * 
 * @param rates [I] - The rates supported, from rules.fcan.data_rates
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 */
cs_status cs4224_fcan_check_rates(
    cs4224_fcan_data_rates_t rates)
{
    cs_status status = CS_OK;
    /* mask to sweep to make this method somewhat clever
     * This must have the MAX value of data_rates_t */
    cs_uint16 mask = 0;
    cs_uint8 count = 0;

    /* Can only have a maximum of 4 sequencial rates */
    for(mask = CS4224_FCAN_DATA_RATE_16G; mask > 0; mask >>= 1)
    {
        if(rates & mask)
        {
            /* rates contains the current mask */
            count++;
            if(count >= 4)
            {
                status |= CS_ERROR;
            }
        }
        else if (count != 0)
        {
            /* rates doesn't contain current mask, and count has already been incremented 
             * setting count = 4 is a flag saying no other rates should be set */
            count = 4;
        }
    }
    if (count == 0)
    {
        status |= CS_ERROR;
    }
    if (status != CS_OK)
    {
        CS_TRACE(("ERROR: rules.fcan.data_rates must contain between 1 and 4 sequencial rates. rates = 0x%04x\n", rates));
    }
    return status;
}

/**
 * This method will initialize FC-AN rate settings for the interface.
 * 
 * @param slice  [I] - The slice or port of the device(s) being initialized
 * @param rules  [I] - The rules struct containing FC-AN configurations
 * @param intf   [I] - Interface being configured on the slice
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_fcan_init_rate(
    cs_uint32 slice,
    cs4224_rules_t* rules,
    e_cs4224_cfg_sides_t intf)
{

    cs_status status = CS_OK;
    cs_uint16 offset = 0;
    /* max supported rate, basically a check for 16G */
    e_cs4224_fcan_data_rate_t max_rate = CS4224_FCAN_DATA_RATE_1G;
    e_cs4224_edc_mode edc_mode;
    cs_uint16 data;
 
    if (intf == CS4224_CFG_HOST_SIDE)
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
        edc_mode = rules->rx_if.dplx_host_edc_mode;
    }
    else if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x000;
        edc_mode = rules->rx_if.dplx_line_edc_mode;
    }
    else
    {
        CS_TRACE(("ERROR: Invalid intf: 0x%04x\n",intf));
        status |= CS_ERROR;
        return status;
    }

    /* find the max supported rate */
    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_16G)
    {
        max_rate = CS4224_FCAN_DATA_RATE_16G;
    }
    else if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_8G)
    {
        max_rate = CS4224_FCAN_DATA_RATE_8G;
    }
    else if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_4G)
    {
        max_rate = CS4224_FCAN_DATA_RATE_4G;
    }
    else if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_2G)
    {
        max_rate = CS4224_FCAN_DATA_RATE_2G;
    }
    else if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_1G)
    {
        max_rate = CS4224_FCAN_DATA_RATE_1G;
    }
    else
    {
        CS_TRACE(("ERROR: rules.fcan.data_rates has invalid value: 0x%04x\n",rules->fcan.data_rates));
        status |= CS_ERROR;
        return status;
    }

    /* force line side EDC mode to SR if max FC rate < 8G */
    if (intf == CS4224_CFG_LINE_SIDE)
    {
        if (max_rate < CS4224_FCAN_DATA_RATE_8G)
        {
            edc_mode = CS_HSIO_EDC_MODE_SR;
        }
    }

    status |= cs4224_lock(slice);

    /* -- Common -- */

    /* Unsquelch Lineside */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH + offset,  0x0000);

    /* Bitswap */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config + offset,    0x0010); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config + offset,    0x0010);

    /* FC SPARE Setup */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB  + offset, 0x001F); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_MSB  + offset, 0x000F); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_LSB  + offset, 0x3650); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_MSB  + offset, 0x2b50); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE3_LSB  + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE3_MSB  + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB  + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_MSB  + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE5_LSB  + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE5_MSB  + offset, 0x0000);
    /*
    # SPARE6 EQADJ Setup
    #CX1: EQADJ1_SWR[3:0]          = SPARE6LSB[3:0]
    #     EQADJ1_SWC[11:8]         = SPARE6LSB[11:8]
    #     EQADJ2_COARSE[3:0]       = SPARE6MSB[3:0]
    #     EQADJ2_COARSE_RSEL[10:8] = SPARE6MSB[10:8]
    #SR:  EQADJ1_SWR[3:0]          = SPARE6LSB[7:4]
    #     EQADJ1_SWC[11:8]         = SPARE6LSB[15:12]
    #     EQADJ2_COARSE[3:0]       = SPARE6MSB[7:4]
    #     EQADJ2_COARSE_RSEL[10:8] = SPARE6MSB[14:12]        
    */

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_LSB  + offset, 0x0078); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB  + offset, 0x70FB);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_LSB  + offset, 0x0010);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_MSB  + offset, 0x0030);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE8_LSB  + offset, 0x0FFF);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE8_MSB  + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_LSB  + offset, 0x0000); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_MSB  + offset, 0x0030); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE10_LSB + offset, 0x0B08);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE10_MSB + offset, 0x0708);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_LSB + offset, 0xFFFE);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_MSB + offset, 0x007F);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE13_LSB + offset, 0x0008);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE13_MSB + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_LSB + offset, 0x0000); /* Bank Jmp */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_MSB + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_LSB + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_MSB + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_MSB + offset, 0x0000);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE23_LSB + offset, 0x00C0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE23_MSB + offset, 0x0000); /*R_T_TOV */

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_MSB + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_MSB + offset, 0x0000); /*FC Start */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB + offset, 0x0000);

    if(intf == CS4224_CFG_HOST_SIDE)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB + offset, 0x0366);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_MSB + offset, 0x0001); /*2ms timer */
        /* Host incoming rate, needs to be set for max rate initially */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_LSB + offset, max_rate);

        if (edc_mode != CS_HSIO_EDC_MODE_SR)
        {
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_LSB + offset, &data);
            if (max_rate == CS4224_FCAN_DATA_RATE_16G)
            {
                data |= CS_BIT4;
            }
            else
            {
                data |= CS_BIT3;
            }
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_LSB + offset, data);
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_MSB + offset, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE25_LSB + offset, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE25_MSB + offset, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB + offset, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB + offset, 0x0000);
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB, 0x87FA);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_MSB, 0x0028); /*R_T_TOV */
        /* Line advertized rates */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE25_LSB, rules->fcan.data_rates);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE25_MSB, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, 0x0001);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, 0x0000);
    }

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + offset, 0x0024); /* Ref Level offset */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + offset, 0x0000); 

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES + offset,      0x0030);

    if (edc_mode == CS_HSIO_EDC_MODE_SR)
    {
        /* SR Mode */
        if (intf == CS4224_CFG_LINE_SIDE)
        {
            status |= cs4224_save_edc_mode(slice, 0, CS_HSIO_EDC_MODE_SR); 
        }

        if (max_rate == CS4224_FCAN_DATA_RATE_16G)
        {
            /* rate = FC 16G, SR */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset,      0x0004);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + offset,         0x00DD);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL + offset,      0x001E);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + offset,    0x0004);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2 + offset,    0x0040);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + offset,     0x0441);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + offset,    0xDFFF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + offset,    0x000D);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + offset,     0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + offset,     0x070F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_RESOLUTION + offset, 0x0001);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_FLOAT + offset,    0x8001);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN + offset,           0x0006);

          /*status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       0x0BBC); */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       &data); 
            data &= 0x0004; /* preserve only squelch bit [2] */
            data |= 0x0BB8;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       data); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + offset,       0x0009); 

            /*TX CNTRL */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA + offset,0x4820);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB + offset,0x0012);
        }
        else
        {
            /* rate < FC 16G, SR */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset,      0x0084);
         /* status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       0x0B39); */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       &data); 
            data &= 0x0004; /* preserve only squelch bit [2] */
            data |= 0x0B39;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       data); 

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + offset,       0x0009); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + offset,         0x0044);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL + offset,      0x001E);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + offset,    0x0004);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + offset,     0x0441);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + offset,    0xDFFF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + offset,    0x000d);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + offset,     0x0001);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + offset,     0x070F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL + offset,      0x001E);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN + offset,           0x0006);

            /*TX CNTRL */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA + offset,0x4818);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB + offset,0x000B);
        }
    }
    else /* DFE mode, valid for FC 8G or 16G rates only */
    {
        /* FC 8/16G DFE mode */

        if (intf == CS4224_CFG_LINE_SIDE)
        {
            status |= cs4224_save_edc_mode(slice, 0, CS_HSIO_EDC_MODE_FCAN); 
        }

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_INIT_SEL + offset, 0x0001);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_ENABLE + offset,                 0x0006);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_DFE_GAIN0 + offset,  0x007f);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_DFE_GAIN1 + offset,  0x007f);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_DFE_GAIN2 + offset,  0x007f);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_LEAK_INTVL_DFE + offset,    0x8100);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_LEAK_INTVL_AGC + offset,    0x8010);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_AGC_MISC + offset,   0x0002);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MU_VALUE + offset,          0x8C0f);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_BIAS1 + offset,      0xff5d); /* reduce DFE bias */

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset,      0x0004);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + offset,         0x0099);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL + offset,      0x001E);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + offset,    0x0005);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2 + offset,    0x0070);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + offset,     0x1F70);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + offset,    0x8F00);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + offset,    0x000c);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + offset,     0x0008);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + offset,     0x000B);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_RESOLUTION + offset, 0x0001);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_FLOAT + offset,    0x8001);

        /* DFE Tap Delays for 14G operation  SRX_DFE_DLY_SEL = 1 (for 14G-mode) */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL2 + offset,  0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL1 + offset,  0x0000);

        /* the following sets the data slicer offset. 0x90 for ZR. DWDM TBD */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + offset,     0x0080);

        /*8G Initial Conditions */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE0_1 + offset,              0x0008);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE1_1 + offset,              0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE2_1 + offset,              0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE3_1 + offset,              0x00FD);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE4_1 + offset,              0x0000);

        /*16G Initial Conditions */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE0_0 + offset,              0x00E0);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE1_0 + offset,              0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE2_0 + offset,              0x0003);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE3_0 + offset,              0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE4_0 + offset,              0x0000);

      /*status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       0x0BFC);*//*78 without Power Savings */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       &data); 
        data &= 0x0004; /* preserve only squelch bit [2] */
        data |= 0x0BF8;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset,       data); 

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + offset,       0x0009);

        /*TX CNTRL */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA + offset,0x4820);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB + offset,0x0000);

        if (max_rate == CS4224_FCAN_DATA_RATE_8G)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset,      0x0084);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + offset,         0x0044);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL + offset, 0x3006);   

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + offset,     0x1B30); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE + offset,  0x0020);
        }
    }

    if (rules->fcan.advanced.enable_no_loss)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB + offset,0x0000);
    }

    /* override from efuse */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE + offset, 0x0000);

    /*The default is 4096 decimal so with 106MHz ref this is 4096 X 9ns=36us. */
    /*With 127 steps this is ~4.7ms for coarse tune. */
    /*We should be able to drop VCOMAX by 2 or even 4+ to speed things.  (We settle in ~10ns so 36us averaging is overkill.) */
    /*If this is not set, the ucode does not wait long enough after coarse tune */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_VCOMAX + offset,       0x07FF);

    status |= cs4224_unlock(slice);
    
    return status;
}

/**
 * This method will start the FC-AN protocol, and check that it's started.
 * 
 * @param slice  [I] - The slice or port of the device(s) being initialized
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 */
cs_status cs4224_fcan_start_an(
    cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data = 0;

    cs_uint16 yyyy, mmdd, hhmm;

    status |= cs4224_lock(slice);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB, 0x0001);

    /* delay for a tiny bit for the AN to start */
    CS_UDELAY(100);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB, &reg_data);

    if(reg_data & CS_BIT0)
    {
        /* Get the timestamp of the loaded microcode */
        status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP1, &yyyy);
        status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP0, &mmdd);
        status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP2, &hhmm);

        CS_TRACE(("ERROR: FC-AN did not successfully start. Possible configuration error or incorrect micro-sequencer code on slice %x\n", slice));
        CS_TRACE(("Micro-sequencer image built on (yyyy/mmdd/hhmm) = %04x/%04x/%04x\n", yyyy, mmdd, hhmm));

        status |= CS_ERROR;
    }

    status |= cs4224_unlock(slice);

    return status;
}

/**
 * Initialize the FC-AN protocol.
 * 
 * Notes:
 *   - This is only meant for duplex parts, see user guide for details
 *
 * @param slice  [I] - The slice or port of the device(s) being initialized
 * @param rules  [I] - The rules struct containing FC-AN configurations
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_fcan_init_fc_pre_an(
    cs_uint32 slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    /* 16G needs PD mode, everything else is PFD */
    e_cs4224_fcan_vco_mode_t vco_mode = CS4224_FCAN_VCO_PFD_MODE;
    cs_uint16 reg_data = 0;

    status |= cs4224_lock(slice);

    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_16G)
    {
        vco_mode = CS4224_FCAN_VCO_PD_MODE;
    }

    /* -------------------------------------------------------------------------- */
    /* start of line_datastore_init script method */
    /* -------------------------------------------------------------------------- */

    /* TP_Mode Settings */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x5000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8001);

    /* 4/2/1G Driver Settings */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0000); /* ctrlb */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x4818); /* ctrla */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8003);

    if ((rules->rx_if.dplx_line_edc_mode == CS_HSIO_EDC_MODE_SR) || (rules->fcan.advanced.enable_no_loss))
    {
        /* SR EDC mode or no-loss channel */

        /* 16G Driver Settings */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0000); /* ctrlb */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x4820); /* ctrla */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8005);

        /* 8G Driver Settings */
        if (rules->fcan.advanced.enable_no_loss)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0000); /* ctrlb */
        }
        else  
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x000B); /* ctrlb */
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x4818); /* ctrla */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8004);
    }
    else 
    {
        /* DFE EDC modes or lossy channel */

        /* 16G Driver Settings */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0017); /* ctrlb */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x4820); /* ctrla */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8005);

        /* 8G Driver Settings */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0000); /* ctrlb */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x4820); /* ctrla */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8004);
    }

    /* function_number cleared for FC-AN */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x800e);

    /* end of line_datastore_init */

    /* -------------------------------------------------------------------------- */
    /* start of fc_init script method */
    /* -------------------------------------------------------------------------- */

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_LSB, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_MSB, 0x0000);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);

    CS_MDELAY(10);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_PC,             0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_PC,             0x0000);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR,  0x0004);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR,  0x0007);

    if(vco_mode == CS4224_FCAN_VCO_PFD_MODE)
    {
        /* PFD Mode */
        cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE, 0x0003);
        cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE, 0x0002); /* host side PFD mode */
    }
    else
    {
        /* PD Mode */
        cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE, 0x0003);
        cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE, 0x0003);
    }

    cs4224_fcan_init_rate(slice, rules, CS4224_CFG_LINE_SIDE);
    cs4224_fcan_init_rate(slice, rules, CS4224_CFG_HOST_SIDE);

    /* -------------------------------------------------------------------------- */
    /* from digital_dp_setup */
    /* -------------------------------------------------------------------------- */
    /* XGPCS */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,              0x0404);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,             0x0404);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXCNTRL,            0x5000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_XGPCS_TX_TXCNTRL,            0x0002);

    /* EGPCS */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,              0x0202);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,             0x0202);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_EGPCS_TX_MODE,               0x0001);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_EGPCS_RX_MODE,               0x0003);

    /* TP */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,              0x0808);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,             0x0808);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_BITSWAP,               0x0001);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_RX_BITSWAP,               0x0001);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_TX_RX_RESET,           0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_FC_OPTIONS,            0x073F);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_ENABLE,                0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAX_WAIT_TIMEOUT1,     0x2500);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_WAIT_TIMEOUT,          0x0064);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRESET_COEFF_OVERRIDE, 0x0001);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_RX_REMOTE_RX_READY,       0x0013);

    /*Set up Training Limits */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_MAX_LIMIT,   0x001F);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_MAX_LIMIT,  0x0030);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_MAX_LIMIT,  0x003E);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_MIN_LIMIT,   0x0011);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_MIN_LIMIT,  0x0020);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_MIN_LIMIT,  0x001C);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_PRESET,      0x001F);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_PRESET,     0x0030);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_PRESET,     0x003E); 

    /* for lab use only, no loss on cable */
    if (rules->fcan.advanced.enable_no_loss)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_INIT,        0x001B);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_INIT,       0x0020);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_INIT,       0x003f);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_START,       0x001B);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_START,      0x0020);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_START,      0x003f);
    }
    else  
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_INIT,        0x001B);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_INIT,       0x0020);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_INIT,       0x0028);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_START,       0x001B);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_START,      0x0020);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_START,      0x0028);
    }

    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_16G)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,          0x404);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,         0x404);

        /* setup the temperature thresholds for the LC VCO */
        status |= cs4224_init_lc_vco_tmp_thresh(slice, CS4224_CFG_LINE_SIDE);
        status |= cs4224_init_lc_vco_tmp_thresh(slice, CS4224_CFG_HOST_SIDE);

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE,  0x0047);    
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_RBIAS_TUNE,  0x0047);    

    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,          0x202);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,         0x202); 

        /* setup the temperature thresholds for the Ring Oscillator VCO */
        status |= cs4224_init_ro_vco_tmp_thresh(slice, CS4224_CFG_LINE_SIDE);
        status |= cs4224_init_ro_vco_tmp_thresh(slice, CS4224_CFG_HOST_SIDE);

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE,  0x0020);    
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_RBIAS_TUNE,  0x0020);    

    }

    /* digital_dp_setup */

    /* define what we are advertizing */
    reg_data = 0;
    reg_data |= (rules->fcan.speed_negotiation_support           ? CS_BIT0      : 0) |   
                (rules->fcan.training_protocol_support           ? CS_BIT1      : 0) |
                (rules->fcan.fec_capable                         ? CS_BIT2      : 0) |
                (rules->fcan.fec_request                         ? CS_BIT3      : 0) |
                (rules->fcan.transmitter_fixed                   ? CS_BIT4      : 0) |
                (rules->fcan.transmitter_fixed                   ? CS_BIT8      : 0) | /* copy */
                (rules->fcan.fec_capable                         ? CS_BIT9      : 0) | /* copy */
                (rules->fcan.speed_negotiation_support           ? CS_BIT10     : 0) | /* copy */
                (rules->fcan.fec_request                         ? CS_BIT11     : 0);  /* copy */

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, reg_data);

    reg_data = 0;
    reg_data |= (rules->fcan.advanced.enable_tp_main_tap_to_max  ? CS_MSB_BIT16 : 0) |
                (rules->fcan.advanced.enable_tp_adaptive_post    ? CS_MSB_BIT17 : 0) |
                (rules->fcan.advanced.enable_tp_send_preset      ? CS_MSB_BIT18 : 0) |
                (rules->fcan.advanced.enable_tp_send_init        ? CS_MSB_BIT19 : 0) |
                (rules->fcan.advanced.enable_tp_frc_lcl_rx_ready ? CS_MSB_BIT20 : 0) |
                (rules->fcan.advanced.enable_tp_lp_status        ? CS_MSB_BIT21 : 0) |
                (rules->fcan.advanced.enable_tp_send_hold        ? CS_MSB_BIT22 : 0) |
                (rules->fcan.advanced.enable_tp_swc_in_limits    ? CS_MSB_BIT23 : 0) |
                (rules->fcan.advanced.enable_jmp_to_caldotasm    ? CS_MSB_BIT28 : 0) |
                (rules->fcan.advanced.disable_fc_power_savings   ? CS_MSB_BIT29 : 0) |
                (rules->fcan.advanced.disable_pcs_checks         ? CS_MSB_BIT30 : 0);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, reg_data);

    /* re-coarse tune the VCOs */
    status |= cs4224_init_vco(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_CONTROL);
    status |= cs4224_init_vco(slice, CS4224_PP_HOST_SDS_COMMON_RXVCO0_CONTROL);

    if(vco_mode == CS4224_FCAN_VCO_PFD_MODE)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE, 0x0002);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE, 0x0003);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE, 0x0002);
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE, 0x0002);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE, 0x0002);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE, 0x0003);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE, 0x0003);
    }

    CS_MDELAY(50);

    /* clear the out mail box queue in case it has an event request in it */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_LSB,   0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_LSB+1, 0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_LSB,   0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_LSB+1, 0);
    /* clear the in mail box queue request */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_IN_LSB,    0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_IN_LSB+1,  0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_LSB,    0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_LSB+1,  0);

    /* unstall the mseq */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL, 0x0004);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS, 0x0007);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_MSEQCLKCTRL, 0x0004);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS, 0x0007);

    status |= cs4224_unlock(slice);

    if (rules->fcan.advanced.start_an)
    {
        status |= cs4224_fcan_start_an(slice);
        CS_MDELAY(1);
        /* CS_PRINTF(("*** Starting FC-AN on slice %x ***\n", slice));*/
    }
    else
    {
        /* CS_PRINTF(("*** Skipping Starting FC-AN on slice %x ***\n", slice));*/
    }

    return status;
}

/**
 * Poll the FC-AN registers for an indication that the FC data rate negotiation
 * is complete.
 *
 * @param slice            [I] - The slice or port of the device(s) being polled
 * @param max_secs_to_poll [I] - The maximum number of seconds to wait before exiting
 * @param negotiated_rate  [O] - Pointer to the FC-AN negotiated rate
 *
 * @return CS4224_FCAN_DONE on success, CS4224_FCAN_AN_NOT_DONE on failure.
 */
e_cs4224_fcan_an_status_t cs4224_fcan_wait_for_an(
    cs_uint32 slice,
    e_cs4224_fcan_data_rate_t *negotiated_rate) 
{
    e_cs4224_fcan_an_status_t status = CS4224_FCAN_AN_NOT_DONE;
    cs_uint16 done_flag = 0;
    cs_uint16 ucode_rate = 0;

    *negotiated_rate = CS4224_FCAN_DATA_RATE_DISABLED;

    cs4224_lock(slice);

    /* wait for FC-AN to complete its negotiating */
    do
    {
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB, &done_flag);

        CS_MDELAY(1);

    } while ( !(done_flag & CS_BIT1) );

    /* get the FC-AN negotiated rate */
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &ucode_rate);

    /* check to make sure Rx and Tx are the same rate */
    if ( ((ucode_rate & 0xFF00) >> 8) != (ucode_rate & 0x00FF) )
    {
        CS_TRACE(("ERROR: Negotiated Rx and Tx rates do not match, most likely a ucode error. ucode_rate = 0x%04x\n",ucode_rate));
        goto EXIT;
    }

    if (cs4224_fcan_check_rates(ucode_rate & 0x00FF) != CS_OK)
    {
        CS_TRACE(("ERROR: Negotiated rate unknown, possible ucode error. ucode_rate = 0x%04x\n", ucode_rate));
        goto EXIT;
    }

    *negotiated_rate = (e_cs4224_fcan_data_rate_t)(ucode_rate & 0x00FF);

    /* if we got here, everything is fine */
    status = CS4224_FCAN_AN_DONE;

EXIT:
    cs4224_unlock(slice);

    return status;

}

/**
 * Poll the FC-AN registers for an indication that the FC data rate negotiation
 * is complete. A timeout is specified (in seconds) to abort waiting.
 *
 * @param slice            [I] - The slice or port of the device(s) being polled
 * @param max_secs_to_poll [I] - The maximum number of seconds to wait before exiting
 * @param negotiated_rate  [O] - Pointer to the FC-AN negotiated rate
 *
 * @return CS4224_FCAN_DONE on success, CS4224_FCAN_AN_NOT_DONE on failure.
 */
e_cs4224_fcan_an_status_t cs4224_fcan_wait_for_an_with_timeout(
    cs_uint32 slice,
    cs_uint16 max_secs_to_poll,
    e_cs4224_fcan_data_rate_t *negotiated_rate) 
{
    e_cs4224_fcan_an_status_t status = CS4224_FCAN_AN_NOT_DONE;
    cs_uint16 done_flag   = 0;
    cs_uint16 done_state  = 0;
    cs_uint16 ucode_rate  = 0;
    cs_uint32 loop_count  = 0; 
    cs_uint16 reneg_count_before, reneg_count_after = 0; 
    cs_uint32 max_iterations;

    *negotiated_rate = CS4224_FCAN_DATA_RATE_DISABLED;

    /* convert to milliseconds, timer resolution is 1 millisecs */
    max_iterations = (max_secs_to_poll * 1000);

    cs4224_lock(slice);

    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_LSB, &reneg_count_before);

    /* wait for FC-AN to complete its negotiating */
    for(loop_count = 0; loop_count < max_iterations; loop_count++)
    {
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB, &done_flag);
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_LSB, &done_state);

        if(CS_IF_SET(done_flag,CS_BIT1) && (done_state == 0x0060))
        {
            break;
        }
        /* arg of 1 delays 1 millisecond */
        CS_MDELAY(1);
    }
    if (loop_count >= max_iterations)
    {
        CS_TRACE(("ERROR: FC-AN timeout, result is NOT_DONE for PHY %x\n", slice));
        goto EXIT;
    }
    
    /* get the FC-AN negotiated rate */
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &ucode_rate);

    /* check to make sure Rx and Tx are the same rate */
    if ( ((ucode_rate & 0xFF00) >> 8) != (ucode_rate & 0x00FF) )
    {
        CS_TRACE(("ERROR: Negotiated Rx and Tx rates do not match, most likely a ucode error. ucode_rate = 0x%04x\n",ucode_rate));
        goto EXIT;
    }

    if (cs4224_fcan_check_rates(ucode_rate & 0x00FF) != CS_OK)
    {
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_LSB, &reneg_count_after);
        
        CS_TRACE(("ERROR: Negotiated rate unknown, possible ucode error.\n"
                   "ucode_rate=0x%04x, done_state=0x%04x, done_flag=0x%04x, reneg_before=%d, reneg_after=%d, reneg(delta)=%d\n", 
                      ucode_rate, 
                      done_state, 
                      done_flag,
                      reneg_count_before,
                      reneg_count_after,
                      (reneg_count_after-reneg_count_before)));
        goto EXIT;
    }

    *negotiated_rate = (e_cs4224_fcan_data_rate_t)(ucode_rate & 0x00FF);

    /* if we got here, everything is fine */
    status = CS4224_FCAN_AN_DONE;

EXIT:
    cs4224_unlock(slice);

    return status;

}

/**
 * Configure the host side for SR EDC mode.
 *
 * @param slice  [I] - The slice or port of the device(s) being initialized
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_fcan_set_host_sr(
    cs_uint32 slice) 
{
    cs_status status = CS_OK;

    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA,      0x0044);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG,  0x0441);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, 0x0004);

    return status;
}

/**
 * Configure the host side (post AN) to the negotiated data rate.
 *
 * @param slice  [I] - The slice or port of the device(s) being initialized
 * @param rules  [I] - The rules struct containing FC-AN configurations
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_fcan_init_fc_post_an(
    cs_uint32 slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint16 fec_enabled, mate_sel_0, mate_sel_1;

    /* if host side configured for DFE mode */
    if (rules->rx_if.dplx_host_edc_mode != CS_HSIO_EDC_MODE_SR)
    {
        /* if max advertised rate = 16G */
        if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_16G)
        {
            /* if negotiated rate < 16G */
            if (rules->fcan.negotiated_rate != CS4224_FCAN_DATA_RATE_16G)
            {
                /* set host side to SR EDC mode */
                cs4224_fcan_set_host_sr(slice);
            }
        }
        /* else if max advertised rate = 8G */
        else if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_8G)
        {
            /* if negotiated rate < 8G */
            if (rules->fcan.negotiated_rate != CS4224_FCAN_DATA_RATE_8G)
            {
                /* set host side to SR EDC mode */
                cs4224_fcan_set_host_sr(slice);
            }
        }
    }

    if (rules->fcan.negotiated_rate != CS4224_FCAN_DATA_RATE_16G)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE,  0x0003);
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &fec_enabled);
    status |= cs4224_reg_get_channel(slice & 0xFFFFFFFE, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, &mate_sel_0); 
    status |= cs4224_reg_get_channel(slice | 0x00000001, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, &mate_sel_1); 

    /* if FEC or digital protection switch applied */
    if ((fec_enabled & 0x8000) || (mate_sel_0 != 0) || (mate_sel_1 != 0))
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x0022);

        /* turn off the line and host sides PCS Tx */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,      &data);
        data &= 0x20ff; /* clear the Tx PCSs */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,      data);
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,       &data);
        data &= 0x20ff; /* clear the Tx PCSs */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,       data);

        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_HOSTMISC_FUNCEN,      &data);
        data &= 0x20ff; /* clear the Tx PCSs */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_FUNCEN,      data);
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_HOSTMISC_CLKEN,       &data);
        data &= 0x20ff; /* clear the Tx PCSs */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_CLKEN,       data);
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, 0x0033);
    }

    return status;

}

/**
 * This method will set the default clkdiv/fracdiv settings in rules given the
 * provided FC-AN data-rate.
 * 
 * @param rules [O] - The rules struct to be modified. No modifications are made
 *                    if CS_ERROR is returned.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 */
cs_status cs4224_fcan_rules_set_rate(
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 rate = 0;

    /* setup clkdiv based on given FCAN rate */
    if(rules->ref_clk_rate != CS4224_REF_CLK_106p25)
    {
        /* If ref_clk_rate is not 106.25MHz (or 106250kHz), the clkdiv/fracdiv rules must be set manually.
         * For custom clkdiv/fracdiv based on your ref clock, please contact your Cortina AE.
         */
        CS_TRACE(("WARNING: rules.ref_clk_rate is not set to 106.25MHz, clkdiv/fracdiv must be setup manually\n"));
        status |= CS_ERROR;
        return status;
    }

    /* find the highest advertized data-rate */
    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_1G)
    {
        rate = CS4224_FCAN_DATA_RATE_1G;
    }
    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_2G)
    {
        rate = CS4224_FCAN_DATA_RATE_2G;
    }
    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_4G)
    {
        rate = CS4224_FCAN_DATA_RATE_4G;
    }
    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_8G)
    {
        rate = CS4224_FCAN_DATA_RATE_8G;
    }
    if (rules->fcan.data_rates & CS4224_FCAN_DATA_RATE_16G)
    {
        rate = CS4224_FCAN_DATA_RATE_16G;
    }
    if (rate == 0)
    {
        CS_TRACE(("ERROR: Invalid FC-AN data rate=0x%04x\n", rules->fcan.data_rates));
        return CS_ERROR;
    }

    switch(rate)
    {
        case CS4224_FCAN_DATA_RATE_16G:
        {
            rules->fracdiv.enable    = TRUE;
            rules->fracdiv.divisor   = 0x10;
            rules->fracdiv.numerator = 0x7FFFFF;
            break;
        }
        case CS4224_FCAN_DATA_RATE_8G:
        {
            rules->fracdiv.enable = FALSE;
            rules->clkdiv.enable  = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV1;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;
            break;
        }
        case CS4224_FCAN_DATA_RATE_4G:
        {
            rules->fracdiv.enable = FALSE;
            rules->clkdiv.enable  = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV2;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;
            break;
        }
        case CS4224_FCAN_DATA_RATE_2G:
        {
            rules->fracdiv.enable = FALSE;
            rules->clkdiv.enable  = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV4;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;
            break;
        }
        case CS4224_FCAN_DATA_RATE_1G:
        {
            rules->fracdiv.enable = FALSE;
            rules->clkdiv.enable  = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV8;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Unknown FC-AN rate. rate = 0x%04x\n",rate));
            status |= CS_ERROR;
            return status;
        }
    }

    return status;
}

const char* cs4224_fcan_get_tp_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "      INIT"; break;
        case 1: return  "SEND_TRAIN"; break;
        case 2: return  "TRAIN_LOCL"; break;
        case 3: return  "TRAIN_FAIL"; break;
        case 4: return  "TRAIN_REMO"; break;
        case 5: return  "LINK_READY"; break;
        case 6: return  " SEND_DATA"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

const char* cs4224_fcan_get_tp_fm_detect_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "OUT_OF_SYN"; break;
        case 1: return  "   DO_SLIP"; break;
        case 2: return  "NEW_MARKER"; break;
        case 3: return  "MRKR_FOUND"; break;
        case 4: return  "COEF_UPDAT"; break;
        case 5: return  "STATUS_REP"; break;
        case 6: return  "TRAIN_PATT"; break;
        case 7: return  "FRAME_MARK"; break;
        case 8: return  "BAD_MARKER"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

const char* cs4224_fcan_get_tp_fm_lock_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "OUT_OF_FRM"; break;
        case 1: return  "RESET_COUN"; break;
        case 2: return  "GET_NEW_MA"; break;
        case 3: return  "TEST_MARKR"; break;
        case 4: return  "VALID_MARK"; break;
        case 5: return  "INVALID_MA"; break;
        case 6: return  "  IN_FRAME"; break;
        case 7: return  "      SLIP"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

const char* cs4224_fcan_get_tp_encoder_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "      IDLE"; break;
        case 1: return  "FRAME_MARK"; break;
        case 2: return  "COEFF_UPDA"; break;
        case 3: return  "STATUS_REP"; break;
        case 4: return  "        TP"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

/**
 * Dump out the FC-AN status summary for all slices
 *
 * @param slice       [I] - The slice of the FC-AN session
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_fcan_status_summary(
    cs_uint32 slice) 
{
    cs_status          status = CS_OK;
    cs_uint16          i, data, yyyy, mmdd, hhmm;
    cs_uint32          upper_bits = slice & 0xFFFFFF00;
    cs4224_fec_stats_t fec_stats;
    cs_uint32          temp;

    /* Convert the fetched data into bitfields (if necessary) */
    CS4224_PP_LINE_XGPCS_RX_RXSTATUS_t                      xgpcs_rx_status;
    CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS_t          rxlockd_status;
    CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR_t             bankselect;
    CS4224_PP_LINE_SDS_DSP_MSEQ_PC_SHADOW_t                 pc_shadow;
    CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW_t            options_shadow;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA_t        ctrla;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB_t        ctrlb;
#if 0
    CS4224_PP_LINE_TP_TX_TRAINING_INTS_t                    trn_ints;
    CS4224_PP_LINE_TP_RX_FRAME_LOCK_INTS_t                  frm_lck;
    CS4224_FCAN_HIDDEN_PP_LINE_TP_TX_TRAINING_STATE_t       trn_state;
    CS4224_FCAN_HIDDEN_PP_LINE_TP_TX_ENCODER_STATE_t        trn_encoder_state;
    CS4224_FCAN_HIDDEN_PP_LINE_TP_RX_FM_DETECT_STATE_t      trn_fm_detect_state;
    CS4224_FCAN_HIDDEN_PP_LINE_TP_RX_FRAME_LOCK_STATE_t     trn_fm_lock_state;
#endif
    /* keep only the asic portion of the slice arg */

    CS_PRINTF(("\nFC-AN Status"));
    CS_PRINTF(("\n============"));
    CS_PRINTF(("\nASIC Status"));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_PIN_STATUS, &data);
    CS_PRINTF(("\n  Pin Status:    0x%04x", data));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_CHIP_ID_MSB, &data);
    CS_PRINTF(("\n  Asic Rev:      0x%04x", data));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_SCRATCH7, &data);
    CS_PRINTF(("\n  Api Version:   0x%04x", data));

    status |= cs4224_mon_temp_read_fixp(upper_bits + CS4224_MAX_NUM_SLICES(slice), &temp);
    CS_PRINTF(("\n  Die 0 Temp:    %05d milli-degrees C", temp));
    if (2 == cs4224_max_num_dies)
    {
        status |= cs4224_mon_temp_read_fixp(upper_bits, &temp);
        CS_PRINTF(("\n  Die 1 Temp:    %05d milli-degrees C", temp));
    }
    /* Get the timestamp of the loaded microcode */
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP1, &yyyy);
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP0, &mmdd);
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP2, &hhmm);
    CS_PRINTF(("\n  ucode Version: (yyyy/mmdd/hhmm)%04x/%04x/%04x", yyyy, mmdd, hhmm));

    if (2 == CS4224_MAX_NUM_SLICES(slice))
    {
        CS_PRINTF(("\nSlices                         0          1"));
    }
    else if (4 == CS4224_MAX_NUM_SLICES(slice))
    {
        CS_PRINTF(("\nSlices                         0          1          2          3"));
    }
    else if (8 == CS4224_MAX_NUM_SLICES(slice))
    {
        CS_PRINTF(("\nSlices                         0          1          2          3          4          5          6          7"));
    }

    CS_PRINTF(("\nNegotiated Results"));
    CS_PRINTF(("\n  AN Complete:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB, &data);
        CS_PRINTF((" %s", (data & 0x0002) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  AN Retries:        " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_LSB, &data);
        CS_PRINTF(("        %03d" ,  data));
    }
    CS_PRINTF(("\n  FEC:               " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_RESET, &data);
        CS_PRINTF((" %s", (data == 0xbada) || (data & CS_BIT0) ?  "     False" : "      True"));
    }
    CS_PRINTF(("\n  Rx Rate:           " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &data);
        if (data & CS4224_FCAN_DATA_RATE_1G)
        {
            CS_PRINTF((" %s" ,  "        1G"));
        }
        else if (data & CS4224_FCAN_DATA_RATE_2G)
        {
            CS_PRINTF((" %s" ,  "        2G"));
        }
        else if (data & CS4224_FCAN_DATA_RATE_4G)
        {
            CS_PRINTF((" %s" ,  "        4G"));
        }
        else if (data & CS4224_FCAN_DATA_RATE_8G)
        {
            CS_PRINTF((" %s" ,  "        8G"));
        }
        else if (data & CS4224_FCAN_DATA_RATE_16G)
        {
            CS_PRINTF((" %s" ,  "       16G"));
        }
        else
        {
            CS_PRINTF((" %s" ,  "      none"));
        }
    }
    CS_PRINTF(("\n  Tx Rate:           " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &data);
        if ((data >> 8) & CS4224_FCAN_DATA_RATE_1G)
        {
            CS_PRINTF((" %s" ,  "        1G"));
        }
        else if ((data >> 8) & CS4224_FCAN_DATA_RATE_2G)
        {
            CS_PRINTF((" %s" ,  "        2G"));
        }
        else if ((data >> 8) & CS4224_FCAN_DATA_RATE_4G)
        {
            CS_PRINTF((" %s" ,  "        4G"));
        }
        else if ((data >> 8) & CS4224_FCAN_DATA_RATE_8G)
        {
            CS_PRINTF((" %s" ,  "        8G"));
        }
        else if ((data >> 8) & CS4224_FCAN_DATA_RATE_16G)
        {
            CS_PRINTF((" %s" ,  "       16G"));
        }
        else
        {
            CS_PRINTF((" %s" ,  "      none"));
        }
    }

    CS_PRINTF(("\nAdvertized"));
    CS_PRINTF(("\n  Rate(s):           " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE25_LSB, &data);
        CS_PRINTF(("     0x%04x" ,  data));
    }
    CS_PRINTF(("\n  Speed Negotiation: " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, &data);
        CS_PRINTF((" %s", (data & CS_BIT0) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  Training Protocol: " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, &data);
        CS_PRINTF((" %s", (data & CS_BIT1) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  FEC Capable:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, &data);
        CS_PRINTF((" %s", (data & CS_BIT2) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  FEC Request:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, &data);
        CS_PRINTF((" %s", (data & CS_BIT3) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  Tx Fixed Settings: " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, &data);
        CS_PRINTF((" %s", (data & CS_BIT4) ?  "      True" : "     False"));
    }

    CS_PRINTF(("\nInternal Advanced Settings"));
    CS_PRINTF(("\n  TP Main Tap to Max:" ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT16) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP Adaptive Post:  " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT17) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP Send Preset:    " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT18) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP Send Init:      " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT19) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP Force Lcl Rx Rd:" ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT20) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP LP Status: :    " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT21) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP Send Hold:      " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT22) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP SWC in Limits:  " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT23) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  Jump to cal.asm:   " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT28) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  Enable API SNR mon:" ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT29) ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  Disable PCS Checks:" ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, &data);
        CS_PRINTF((" %s", (data & CS_MSB_BIT30) ?  "      True" : "     False"));
    }

#if 0
    CS_PRINTF(("\nClause 72 Startup/Training Protocol"));
    CS_PRINTF(("\n  TP Failure:        "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_INTS              , &(trn_ints.wrd         ));
        if (trn_ints.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", trn_ints.bf.training_failureS ?  "      True" : "     False"));
        }
    }
    CS_PRINTF(("\n  TP Complete:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_INTS              , &(trn_ints.wrd         ));
        if (trn_ints.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", trn_ints.bf.training_completeS ? "      True" : "     False"));
        }
    }
    CS_PRINTF(("\n  TP FRAME Lock:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_INTS            , &(frm_lck.wrd          ));
        if (frm_lck.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", frm_lck.bf.frame_lockS ?         "      True" : "     False"));
        }
    }
    CS_PRINTF(("\n  TP Enabled:        "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENABLE            , &data);
        if (data == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", ((data & 1) == 1) ?         "      True" : "     False"));
        }
    }
    CS_PRINTF(("\n  TP In Progress:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_RX_PAGE_RECEIVED            , &data);
        if (data == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", ((data & 1) == 1) ?         "      True" : "     False"));
        }
    }

    CS_PRINTF(("\nTraining Tx State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        if (trn_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_state_str(trn_state.bf.current)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        if (trn_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_state_str(trn_state.bf.prev1)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        if (trn_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_state_str(trn_state.bf.prev2)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        if (trn_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_state_str(trn_state.bf.prev3)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 4:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        if (trn_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_state_str(trn_state.bf.prev4)));
        }
    }

    CS_PRINTF(("\nTraining Tx Encoder State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        if (trn_encoder_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_encoder_state_str(trn_encoder_state.bf.current)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        if (trn_encoder_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_encoder_state_str(trn_encoder_state.bf.prev1)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        if (trn_encoder_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_encoder_state_str(trn_encoder_state.bf.prev2)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        if (trn_encoder_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_encoder_state_str(trn_encoder_state.bf.prev3)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 4:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        if (trn_encoder_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_encoder_state_str(trn_encoder_state.bf.prev4)));
        }
    }

    CS_PRINTF(("\nTraining Rx Frame Marker Detect State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        if (trn_fm_detect_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.current)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        if (trn_fm_detect_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.prev1)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        if (trn_fm_detect_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.prev2)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        if (trn_fm_detect_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.prev3)));
        }
    }

    CS_PRINTF(("\nTraining Rx Frame Lock State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        if (trn_fm_lock_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.current)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        if (trn_fm_lock_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev1)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        if (trn_fm_lock_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev2)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        if (trn_fm_lock_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev3)));
        }
    }
    CS_PRINTF(("\n  TP SM Prev 4:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        if (trn_fm_lock_state.wrd == 0xbada)
        {
            CS_PRINTF((" %s", "       n/a"));
        }
        else
        {
            CS_PRINTF((" %s", cs4224_fcan_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev4)));
        }
    }
#endif

    CS_PRINTF(("\nTap Values"));
    CS_PRINTF(("\n  Pre:               "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB  , &(ctrlb.wrd            ));
        CS_PRINTF(("         %02d", ctrlb.bf.STX_PRE_PEAK));
    }
    CS_PRINTF(("\n  Main:              "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA  , &(ctrla.wrd            ));
        CS_PRINTF(("         %02d", ctrla.bf.STX_LEVEL));
    }
    CS_PRINTF(("\n  Post:              "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB  , &(ctrlb.wrd            ));
        CS_PRINTF(("         %02d", ctrlb.bf.STX_POST_PEAK));
    }
    CS_PRINTF(("\nPCS Values"));
    CS_PRINTF(("\n  10G PCS Rx Sync:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_XGPCS_RX_RXSTATUS                , &(xgpcs_rx_status.wrd  ));
        CS_PRINTF((" %s", xgpcs_rx_status.bf.syncdetS  ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  10G PCS Rx BER:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_XGPCS_RX_RXSTATUS                , &(xgpcs_rx_status.wrd  ));
        CS_PRINTF((" %s", xgpcs_rx_status.bf.berhighS  ? "      True" : "     False"));
    }

    CS_PRINTF(("\nFEC Statistics"));
    CS_PRINTF(("\n  Tx Total Blocks:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_RESET             , &(data));
        if ((data != 0))
        {
            CS_PRINTF(("        n/a"));
        }
        else
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.tx_blk_total));;
        }
    }
    CS_PRINTF(("\n  Rx Total Blocks:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_RESET             , &(data));
        if ((data != 0))
        {
            CS_PRINTF(("        n/a"));
        }
        else
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_blk_total));;
        }
    }
    CS_PRINTF(("\n  Rx Corr. Blocks:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_RESET             , &(data));
        if ((data != 0))
        {
            CS_PRINTF(("        n/a"));
        }
        else
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_blk_corr));;
        }
    }
    CS_PRINTF(("\n  Rx Uncorr. Blocks: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_RESET             , &(data));
        if ((data != 0))
        {
            CS_PRINTF(("        n/a"));
        }
        else
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_blk_uncorr));;
        }
    }
    CS_PRINTF(("\n  Rx Zero Bit Er Bks:"));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_RESET             , &(data));
        if ((data != 0))
        {
            CS_PRINTF(("        n/a"));
        }
        else
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_zero_errs));;
        }
    }
    CS_PRINTF(("\n  Rx One Bit Er Bks: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_RESET             , &(data));
        if ((data != 0))
        {
            CS_PRINTF(("        n/a"));
        }
        else
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_one_errs));;
        }
    }

    CS_PRINTF(("\nLine Device Status"));
    CS_PRINTF(("\n  CDR Lock:          "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS    , &(rxlockd_status.wrd   ));
        CS_PRINTF((" %s", ((rxlockd_status.wrd & 0x0041) == 0x0041) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  MSEQ Bank:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR       , &(bankselect.wrd       ));
        CS_PRINTF(("          %01d", bankselect.bf.bank_select_reg));
    }
    CS_PRINTF(("\n  MSEQ PC:           "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_PC_SHADOW           , &(pc_shadow.wrd        ));
        CS_PRINTF(("      0x%03x", pc_shadow.bf.PC_state));
    }
    CS_PRINTF(("\n  MSEQ Stalled:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW      , &(options_shadow.wrd   ));
        CS_PRINTF((" %s", (options_shadow.bf.OPTIONS_state & 0x0008) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched Enabled: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 4) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH      , &data  );
        CS_PRINTF((" %s", (data & 1) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Power Saving Enab: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 2) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  POWER_DOWN_LSB:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  RX_CPA:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  FUNCEN:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_LINEMISC_FUNCEN      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  CLKEN:             "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_LINEMISC_CLKEN      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  MSEQ_SERDES:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  CLKDIV_CTRL:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  SPARE19_LSB:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE19_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  SPARE20_LSB:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  SPARE24_LSB:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  SPARE26_LSB:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  SPARE27_LSB:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  SPARE28_LSB:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  SPARE28_MSB:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }

    CS_PRINTF(("\nHost Device Status"));
    CS_PRINTF(("\n  CDR Lock:          "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS    , &(rxlockd_status.wrd   ));
        CS_PRINTF((" %s", ((rxlockd_status.wrd & 0x0041) == 0x0041) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  MSEQ Bank:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR       , &(bankselect.wrd       ));
        CS_PRINTF(("          %01d", bankselect.bf.bank_select_reg));
    }
    CS_PRINTF(("\n  MSEQ PC:           "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_PC_SHADOW           , &(pc_shadow.wrd        ));
        CS_PRINTF(("      0x%03x", pc_shadow.bf.PC_state));
    }
    CS_PRINTF(("\n  MSEQ Stalled:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW      , &(options_shadow.wrd   ));
        CS_PRINTF((" %s", (options_shadow.bf.OPTIONS_state & 0x0008) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched Enabled: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 4) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH      , &data  );
        CS_PRINTF((" %s", (data & 1) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Power Saving Enab: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 2) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  POWER_DOWN_LSB:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  RX_CPA:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  FUNCEN:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_HOSTMISC_FUNCEN      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  CLKEN:             "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_HOSTMISC_CLKEN      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  MSEQ_SERDES:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_SERDES      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  CLKDIV_CTRL:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL , &data);
        CS_PRINTF(("     0x%04x", data));
    }

    CS_PRINTF(("\n"));

    return status;
}

/** @file cs4224_kr_ucode_image.c
 ****************************************************************************
 *
 * @brief
 *    This module contains the microcode to the downloaded to the
 *    device.
 *
 *****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ****************************************************************************/
  
#if !defined(CS_SKIP_UCODE_DOWNLOAD)
/* The following array contains the microcode image to download
 * to the device. It consists of a series of register writes
 * in the format:
 *    address, data
 */
unsigned short cs4224_kr_ucode_image[] = {
    /* Addr, Data */
    0x0011, 0x0001,
    0x0017, 0x8080,
    0x1091, 0x0001,
    0x1007, 0x8004,
    0x1225, 0x0008,
    0x1238, 0x0000,
    0x0301, 0x9000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7c0d,
    0x0302, 0x0084,
    0x0303, 0x7c02,
    0x0302, 0x0088,
    0x0303, 0x010d,
    0x0302, 0x0060,
    0x0303, 0x7c02,
    0x0302, 0x0009,
    0x0303, 0x019f,
    0x0302, 0x00e0,
    0x0303, 0x7c02,
    0x0302, 0x008d,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x7c02,
    0x0302, 0x00af,
    0x0303, 0x01ea,
    0x0302, 0x0060,
    0x0303, 0x7c02,
    0x0302, 0x002e,
    0x0303, 0x016d,
    0x0302, 0x0060,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x0180,
    0x0302, 0x0060,
    0x0303, 0x016d,
    0x0302, 0x0060,
    0x0303, 0xe805,
    0x0302, 0x008d,
    0x0303, 0x4804,
    0x0302, 0x008c,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0x001b,
    0x0302, 0x0000,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x6893,
    0x0302, 0x0083,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x9002,
    0x0302, 0x008c,
    0x0303, 0x000f,
    0x0302, 0x003a,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x9002,
    0x0302, 0x008a,
    0x0303, 0x6793,
    0x0302, 0x0083,
    0x0303, 0x9006,
    0x0302, 0x0009,
    0x0303, 0x0708,
    0x0302, 0x003a,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x050b,
    0x0302, 0x00ba,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x002d,
    0x0302, 0x0000,
    0x0303, 0x9003,
    0x0302, 0x0028,
    0x0303, 0xe2f5,
    0x0302, 0x0003,
    0x0303, 0x002d,
    0x0302, 0x0000,
    0x0303, 0xc8f5,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xe605,
    0x0302, 0x002f,
    0x0303, 0xe6f5,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xe643,
    0x0302, 0x009f,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0xe7f9,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x037a,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x003c,
    0x0302, 0x0041,
    0x0303, 0x7a5f,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0045,
    0x0302, 0x0080,
    0x0303, 0x7b75,
    0x0302, 0x0097,
    0x0303, 0x004e,
    0x0302, 0x0041,
    0x0303, 0xf970,
    0x0302, 0x001c,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x757b,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x7b5f,
    0x0302, 0x0099,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x003c,
    0x0302, 0x0000,
    0x0303, 0x7b75,
    0x0302, 0x0097,
    0x0303, 0x004e,
    0x0302, 0x0041,
    0x0303, 0xf970,
    0x0302, 0x009d,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x757b,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x5f7b,
    0x0302, 0x001e,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x0045,
    0x0302, 0x0080,
    0x0303, 0xcc60,
    0x0302, 0x0003,
    0x0303, 0xdb68,
    0x0302, 0x0083,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x03db,
    0x0302, 0x0011,
    0x0303, 0x03db,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x000f,
    0x0302, 0x005a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0xc375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf467,
    0x0302, 0x0003,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x0056,
    0x0302, 0x0041,
    0x0303, 0x0017,
    0x0302, 0x009a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf40f,
    0x0302, 0x001f,
    0x0303, 0x2267,
    0x0302, 0x0002,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x005b,
    0x0302, 0x00c1,
    0x0303, 0x002b,
    0x0302, 0x009a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf472,
    0x0302, 0x0083,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x0062,
    0x0302, 0x00c1,
    0x0303, 0x003f,
    0x0302, 0x009a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf40f,
    0x0302, 0x001f,
    0x0303, 0x2272,
    0x0302, 0x0082,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x0068,
    0x0302, 0x00c1,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x4f75,
    0x0302, 0x0082,
    0x0303, 0x7567,
    0x0302, 0x0011,
    0x0303, 0x03ec,
    0x0302, 0x0083,
    0x0303, 0x68db,
    0x0302, 0x0083,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0x00e6,
    0x0302, 0x00ba,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0xcffe,
    0x0302, 0x0083,
    0x0303, 0xc2fd,
    0x0302, 0x0003,
    0x0303, 0x9015,
    0x0302, 0x000b,
    0x0303, 0x780f,
    0x0302, 0x009f,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0x0083,
    0x0302, 0x0080,
    0x0303, 0xfd03,
    0x0302, 0x0004,
    0x0303, 0xc0fd,
    0x0302, 0x0083,
    0x0303, 0x0083,
    0x0302, 0x0080,
    0x0303, 0xfe70,
    0x0302, 0x001d,
    0x0303, 0x03fe,
    0x0302, 0x0083,
    0x0303, 0xc1ae,
    0x0302, 0x0003,
    0x0303, 0xc2ae,
    0x0302, 0x0003,
    0x0303, 0x6f0f,
    0x0302, 0x009f,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0xc0ae,
    0x0302, 0x0083,
    0x0303, 0xb100,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01f4,
    0x0302, 0x003a,
    0x0303, 0xb003,
    0x0302, 0x0097,
    0x0303, 0xfe02,
    0x0302, 0x0009,
    0x0303, 0x007e,
    0x0302, 0x0041,
    0x0303, 0x00c0,
    0x0302, 0x003a,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0xc0ea,
    0x0302, 0x0083,
    0x0303, 0x8403,
    0x0302, 0x008d,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x01ea,
    0x0302, 0x0060,
    0x0303, 0xe805,
    0x0302, 0x000a,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x9000,
    0x0302, 0x005a,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0x9000,
    0x0302, 0x0018,
    0x0303, 0x0390,
    0x0302, 0x0003,
    0x0303, 0xe812,
    0x0302, 0x0024,
    0x0303, 0xe811,
    0x0302, 0x00aa,
    0x0303, 0xe809,
    0x0302, 0x0009,
    0x0303, 0x810f,
    0x0302, 0x009f,
    0x0303, 0x037d,
    0x0302, 0x001b,
    0x0303, 0x0370,
    0x0302, 0x001c,
    0x0303, 0x0370,
    0x0302, 0x0019,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x7d81,
    0x0302, 0x001b,
    0x0303, 0x037d,
    0x0302, 0x0017,
    0x0303, 0x009f,
    0x0302, 0x0021,
    0x0303, 0x800f,
    0x0302, 0x00da,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0x810f,
    0x0302, 0x009f,
    0x0303, 0x037d,
    0x0302, 0x001b,
    0x0303, 0x0370,
    0x0302, 0x009d,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x8184,
    0x0302, 0x0028,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x07d0,
    0x0302, 0x003a,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0x9c40,
    0x0302, 0x00ba,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x00c0,
    0x0302, 0x009a,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0xd294,
    0x0302, 0x0083,
    0x0303, 0xd295,
    0x0302, 0x0003,
    0x0303, 0xb2ef,
    0x0302, 0x0083,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x01ea,
    0x0302, 0x0060,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xc0e1,
    0x0302, 0x0003,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xc3df,
    0x0302, 0x0083,
    0x0303, 0xe803,
    0x0302, 0x0003,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0xc04c,
    0x0302, 0x0083,
    0x0303, 0x0053,
    0x0302, 0x003a,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x00d6,
    0x0302, 0x00c1,
    0x0303, 0x7572,
    0x0302, 0x0019,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xdf00,
    0x0302, 0x0098,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0x00ce,
    0x0302, 0x0080,
    0x0303, 0xe803,
    0x0302, 0x0003,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03cc,
    0x0302, 0x001b,
    0x0303, 0x03df,
    0x0302, 0x0097,
    0x0303, 0x00dc,
    0x0302, 0x00c1,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0xe50f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0xdf03,
    0x0302, 0x009e,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0xe802,
    0x0302, 0x008f,
    0x0303, 0x00e8,
    0x0302, 0x0000,
    0x0303, 0x9003,
    0x0302, 0x008b,
    0x0303, 0xdc0f,
    0x0302, 0x001f,
    0x0303, 0x00e7,
    0x0302, 0x0000,
    0x0303, 0x0021,
    0x0302, 0x003a,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0xe36e,
    0x0302, 0x001b,
    0x0303, 0x03c5,
    0x0302, 0x009c,
    0x0303, 0x035d,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf663,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf501,
    0x0302, 0x001f,
    0x0303, 0x0375,
    0x0302, 0x0019,
    0x0303, 0x757f,
    0x0302, 0x0003,
    0x0303, 0xc0eb,
    0x0302, 0x0003,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x0180,
    0x0302, 0x0060,
    0x0303, 0xcbf4,
    0x0302, 0x0003,
    0x0303, 0x7580,
    0x0302, 0x0003,
    0x0303, 0xf400,
    0x0302, 0x0098,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x4dd1,
    0x0302, 0x0011,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x8003,
    0x0302, 0x00a4,
    0x0303, 0x838a,
    0x0302, 0x002b,
    0x0303, 0x0105,
    0x0302, 0x0080,
    0x0303, 0x838c,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xe821,
    0x0302, 0x009f,
    0x0303, 0x030c,
    0x0302, 0x008b,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x4c00,
    0x0302, 0x00ba,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x011a,
    0x0302, 0x0041,
    0x0303, 0x4e00,
    0x0302, 0x003a,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x011b,
    0x0302, 0x00c1,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x03e6,
    0x0302, 0x0083,
    0x0303, 0x011b,
    0x0302, 0x0080,
    0x0303, 0xc0e6,
    0x0302, 0x0083,
    0x0303, 0xc071,
    0x0302, 0x0003,
    0x0303, 0xc06a,
    0x0302, 0x0003,
    0x0303, 0xc06b,
    0x0302, 0x0083,
    0x0303, 0xc07f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xe977,
    0x0302, 0x0083,
    0x0303, 0xc16a,
    0x0302, 0x0083,
    0x0303, 0xc17f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc26a,
    0x0302, 0x0083,
    0x0303, 0xc27f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc36a,
    0x0302, 0x0003,
    0x0303, 0xc37f,
    0x0302, 0x0097,
    0x0303, 0xc0e6,
    0x0302, 0x0083,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc16b,
    0x0302, 0x0003,
    0x0303, 0xc171,
    0x0302, 0x0083,
    0x0303, 0xc47f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc46a,
    0x0302, 0x0083,
    0x0303, 0xc57f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc26b,
    0x0302, 0x0003,
    0x0303, 0xc67f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc56a,
    0x0302, 0x0003,
    0x0303, 0xc77f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc36b,
    0x0302, 0x0083,
    0x0303, 0xc87f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc66a,
    0x0302, 0x0003,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc46b,
    0x0302, 0x0003,
    0x0303, 0x000a,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc76a,
    0x0302, 0x0083,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc56b,
    0x0302, 0x0083,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc86a,
    0x0302, 0x0083,
    0x0303, 0x000d,
    0x0302, 0x00ba,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc66b,
    0x0302, 0x0083,
    0x0303, 0x000e,
    0x0302, 0x00ba,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x000f,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc76b,
    0x0302, 0x0003,
    0x0303, 0xc97f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0x000a,
    0x0302, 0x003a,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x0011,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x6ac8,
    0x0302, 0x001c,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x778b,
    0x0302, 0x0011,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x6bc8,
    0x0302, 0x009c,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0xcc0f,
    0x0302, 0x009f,
    0x0303, 0x03f6,
    0x0302, 0x001b,
    0x0303, 0x038b,
    0x0302, 0x0011,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xb612,
    0x0302, 0x002c,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0xb60f,
    0x0302, 0x001f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0302,
    0x0302, 0x002f,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x0055,
    0x0302, 0x003a,
    0x0303, 0x03b8,
    0x0302, 0x001b,
    0x0303, 0x0178,
    0x0302, 0x0020,
    0x0303, 0x1891,
    0x0302, 0x001a,
    0x0303, 0x0179,
    0x0302, 0x0000,
    0x0303, 0x1091,
    0x0302, 0x009a,
    0x0303, 0x68b5,
    0x0302, 0x0003,
    0x0303, 0x03b4,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb591,
    0x0302, 0x00aa,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0007,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0027,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0067,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x00e7,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x01e7,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x7e86,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x00e7,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0067,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0027,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0xc781,
    0x0302, 0x0083,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xac0a,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb211,
    0x0302, 0x0084,
    0x0303, 0x6eac,
    0x0302, 0x009b,
    0x0303, 0xc803,
    0x0302, 0x0097,
    0x0303, 0x01b2,
    0x0302, 0x00c1,
    0x0303, 0xb20f,
    0x0302, 0x009f,
    0x0303, 0x0372,
    0x0302, 0x001e,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01b1,
    0x0302, 0x0080,
    0x0303, 0xb20f,
    0x0302, 0x009f,
    0x0303, 0x03cf,
    0x0302, 0x0017,
    0x0303, 0x01b2,
    0x0302, 0x0020,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x03ac,
    0x0302, 0x0017,
    0x0303, 0x01b2,
    0x0302, 0x00c1,
    0x0303, 0xb200,
    0x0302, 0x0018,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x6d95,
    0x0302, 0x0083,
    0x0303, 0xb275,
    0x0302, 0x0083,
    0x0303, 0x73b2,
    0x0302, 0x0097,
    0x0303, 0x01c7,
    0x0302, 0x0041,
    0x0303, 0xfe09,
    0x0302, 0x000e,
    0x0303, 0xfd04,
    0x0302, 0x0084,
    0x0303, 0xcc60,
    0x0302, 0x0017,
    0x0303, 0x01c3,
    0x0302, 0x00c1,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xc2fd,
    0x0302, 0x0003,
    0x0303, 0x75cb,
    0x0302, 0x001e,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xfe70,
    0x0302, 0x009c,
    0x0303, 0x03fe,
    0x0302, 0x0083,
    0x0303, 0x75c8,
    0x0302, 0x001e,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0x6000,
    0x0302, 0x0018,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0360,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xcb75,
    0x0302, 0x0017,
    0x0303, 0x01dd,
    0x0302, 0x00c1,
    0x0303, 0x740f,
    0x0302, 0x009f,
    0x0303, 0xfe02,
    0x0302, 0x008e,
    0x0303, 0x03c9,
    0x0302, 0x001e,
    0x0303, 0xb203,
    0x0302, 0x0017,
    0x0303, 0x01e8,
    0x0302, 0x00c1,
    0x0303, 0x6005,
    0x0302, 0x0084,
    0x0303, 0x60c1,
    0x0302, 0x009e,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0360,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xfd05,
    0x0302, 0x0089,
    0x0303, 0xc0fd,
    0x0302, 0x0083,
    0x0303, 0xcb75,
    0x0302, 0x0099,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xfe10,
    0x0302, 0x0009,
    0x0303, 0xfe70,
    0x0302, 0x001d,
    0x0303, 0x03fe,
    0x0302, 0x0083,
    0x0303, 0x75c8,
    0x0302, 0x0099,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x000e,
    0x0302, 0x001a,
    0x0303, 0x03b2,
    0x0302, 0x0017,
    0x0303, 0x01e2,
    0x0302, 0x00c1,
    0x0303, 0x6008,
    0x0302, 0x0004,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0x75c5,
    0x0302, 0x0097,
    0x0303, 0x01e8,
    0x0302, 0x00c1,
    0x0303, 0x00d0,
    0x0302, 0x001a,
    0x0303, 0x6003,
    0x0302, 0x0017,
    0x0303, 0x01cf,
    0x0302, 0x00c1,
    0x0303, 0x6098,
    0x0302, 0x0004,
    0x0303, 0xb2ef,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x01ec,
    0x0302, 0x0021,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7c02,
    0x0302, 0x0088,
    0x0303, 0x0085,
    0x0302, 0x0080,
    0x0303, 0x7c02,
    0x0302, 0x0009,
    0x0303, 0x005d,
    0x0302, 0x0080,
    0x0303, 0x7c02,
    0x0302, 0x008d,
    0x0303, 0x004d,
    0x0302, 0x0000,
    0x0303, 0x7c02,
    0x0302, 0x00af,
    0x0303, 0x01a6,
    0x0302, 0x0080,
    0x0303, 0x7c02,
    0x0302, 0x002e,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0xb606,
    0x0302, 0x002f,
    0x0303, 0x4000,
    0x0302, 0x007a,
    0x0303, 0x037c,
    0x0302, 0x0083,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xea19,
    0x0302, 0x0088,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec01,
    0x0302, 0x009f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x009e,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec61,
    0x0302, 0x009f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x0017,
    0x0302, 0x003a,
    0x0303, 0x0380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x0019,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0008,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0x0047,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec41,
    0x0302, 0x001f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x002b,
    0x0302, 0x003a,
    0x0303, 0x0380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x0019,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec21,
    0x0302, 0x001f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x009e,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0008,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0xeb07,
    0x0302, 0x002f,
    0x0303, 0x8306,
    0x0302, 0x000d,
    0x0303, 0xe805,
    0x0302, 0x0009,
    0x0303, 0xcb7c,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0x8306,
    0x0302, 0x00a4,
    0x0303, 0xea6d,
    0x0302, 0x0017,
    0x0303, 0x0055,
    0x0302, 0x0041,
    0x0303, 0xc075,
    0x0302, 0x0083,
    0x0303, 0xc872,
    0x0302, 0x0083,
    0x0303, 0x0058,
    0x0302, 0x0080,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xc172,
    0x0302, 0x0083,
    0x0303, 0x75ea,
    0x0302, 0x001b,
    0x0303, 0x005d,
    0x0302, 0x00a1,
    0x0303, 0xc27c,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x007a,
    0x0302, 0x00a1,
    0x0303, 0xd16e,
    0x0302, 0x0091,
    0x0303, 0xeb03,
    0x0302, 0x001b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x035f,
    0x0302, 0x001e,
    0x0303, 0x0072,
    0x0302, 0x0041,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x5f03,
    0x0302, 0x001e,
    0x0303, 0x7b03,
    0x0302, 0x0017,
    0x0303, 0x007a,
    0x0302, 0x00c1,
    0x0303, 0xf970,
    0x0302, 0x009d,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x5f7b,
    0x0302, 0x001e,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x01ef,
    0x0302, 0x0060,
    0x0303, 0x75eb,
    0x0302, 0x0083,
    0x0303, 0x007a,
    0x0302, 0x0080,
    0x0303, 0x7b03,
    0x0302, 0x0017,
    0x0303, 0x007a,
    0x0302, 0x00c1,
    0x0303, 0xf970,
    0x0302, 0x001c,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x7b5f,
    0x0302, 0x0099,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x01ef,
    0x0302, 0x0060,
    0x0303, 0x75eb,
    0x0302, 0x0083,
    0x0303, 0xe651,
    0x0302, 0x002b,
    0x0303, 0x00ff,
    0x0302, 0x003a,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x0101,
    0x0302, 0x0021,
    0x0303, 0xc071,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf501,
    0x0302, 0x001f,
    0x0303, 0x0377,
    0x0302, 0x0003,
    0x0303, 0xc17c,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf601,
    0x0302, 0x001f,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdc43,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xa96e,
    0x0302, 0x009b,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x009c,
    0x0302, 0x0041,
    0x0303, 0xa908,
    0x0302, 0x00ab,
    0x0303, 0x8b0c,
    0x0302, 0x0084,
    0x0303, 0x0006,
    0x0302, 0x009a,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x009c,
    0x0302, 0x0041,
    0x0303, 0xf670,
    0x0302, 0x009e,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x009c,
    0x0302, 0x0000,
    0x0303, 0x8b0f,
    0x0302, 0x009f,
    0x0303, 0xcc03,
    0x0302, 0x0017,
    0x0303, 0x009c,
    0x0302, 0x00a0,
    0x0303, 0xf600,
    0x0302, 0x0018,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0xcb0f,
    0x0302, 0x001f,
    0x0303, 0x03ef,
    0x0302, 0x0097,
    0x0303, 0x00a5,
    0x0302, 0x0041,
    0x0303, 0x0008,
    0x0302, 0x001a,
    0x0303, 0x03e9,
    0x0302, 0x0097,
    0x0303, 0x00af,
    0x0302, 0x0041,
    0x0303, 0xe970,
    0x0302, 0x001e,
    0x0303, 0x03e9,
    0x0302, 0x0083,
    0x0303, 0x00af,
    0x0302, 0x0000,
    0x0303, 0xc90f,
    0x0302, 0x009f,
    0x0303, 0xef03,
    0x0302, 0x0097,
    0x0303, 0x00af,
    0x0302, 0x0041,
    0x0303, 0x000f,
    0x0302, 0x009a,
    0x0303, 0x03e2,
    0x0302, 0x001b,
    0x0303, 0xe903,
    0x0302, 0x0097,
    0x0303, 0x00af,
    0x0302, 0x0041,
    0x0303, 0xe900,
    0x0302, 0x0098,
    0x0303, 0x03e9,
    0x0302, 0x0083,
    0x0303, 0x00c5,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf563,
    0x0302, 0x009f,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xed07,
    0x0302, 0x0004,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde03,
    0x0302, 0x0006,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0097,
    0x0303, 0x00be,
    0x0302, 0x0041,
    0x0303, 0xe977,
    0x0302, 0x0097,
    0x0303, 0x00cb,
    0x0302, 0x0020,
    0x0303, 0xf570,
    0x0302, 0x009e,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x00cb,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde43,
    0x0302, 0x001f,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x6103,
    0x0302, 0x0097,
    0x0303, 0x00cb,
    0x0302, 0x00c1,
    0x0303, 0x6807,
    0x0302, 0x0005,
    0x0303, 0xe20f,
    0x0302, 0x009f,
    0x0303, 0x03cc,
    0x0302, 0x001b,
    0x0303, 0x0377,
    0x0302, 0x0017,
    0x0303, 0x00cb,
    0x0302, 0x0020,
    0x0303, 0xf500,
    0x0302, 0x0018,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf141,
    0x0302, 0x001f,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0xeb33,
    0x0302, 0x00af,
    0x0303, 0x8332,
    0x0302, 0x008d,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xe802,
    0x0302, 0x00ad,
    0x0303, 0x00e0,
    0x0302, 0x0080,
    0x0303, 0x7971,
    0x0302, 0x009e,
    0x0303, 0x4c03,
    0x0302, 0x0019,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x7275,
    0x0302, 0x0097,
    0x0303, 0x00da,
    0x0302, 0x00c1,
    0x0303, 0x72fa,
    0x0302, 0x0003,
    0x0303, 0x00e0,
    0x0302, 0x0080,
    0x0303, 0xdc6e,
    0x0302, 0x001b,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x00df,
    0x0302, 0x00c1,
    0x0303, 0xdcfa,
    0x0302, 0x0083,
    0x0303, 0x00e0,
    0x0302, 0x0080,
    0x0303, 0x75fa,
    0x0302, 0x0083,
    0x0303, 0xeb01,
    0x0302, 0x00ae,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd75,
    0x0302, 0x0086,
    0x0303, 0xed75,
    0x0302, 0x0097,
    0x0303, 0x00f1,
    0x0302, 0x00c1,
    0x0303, 0x68c3,
    0x0302, 0x0097,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0x6eeb,
    0x0302, 0x009b,
    0x0303, 0x03c3,
    0x0302, 0x0099,
    0x0303, 0xfa03,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xfa4d,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xfa00,
    0x0302, 0x0018,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x0379,
    0x0302, 0x0083,
    0x0303, 0x0101,
    0x0302, 0x0000,
    0x0303, 0x4c10,
    0x0302, 0x0005,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd43,
    0x0302, 0x001f,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x75ed,
    0x0302, 0x0097,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0x6eeb,
    0x0302, 0x009b,
    0x0303, 0x03c2,
    0x0302, 0x009e,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xdc6e,
    0x0302, 0x001b,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xfa70,
    0x0302, 0x009e,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x0379,
    0x0302, 0x0083,
    0x0303, 0x00ff,
    0x0302, 0x003a,
    0x0303, 0x8302,
    0x0302, 0x0024,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x0116,
    0x0302, 0x0021,
    0x0303, 0xa06e,
    0x0302, 0x009b,
    0x0303, 0xa002,
    0x0302, 0x00ab,
    0x0303, 0xc003,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0xa16e,
    0x0302, 0x001b,
    0x0303, 0xa102,
    0x0302, 0x002b,
    0x0303, 0xc003,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0019,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x0303,
    0x0302, 0x002b,
    0x0303, 0x675d,
    0x0302, 0x0099,
    0x0303, 0x035d,
    0x0302, 0x0083,
    0x0303, 0x5dc5,
    0x0302, 0x009d,
    0x0303, 0x03ed,
    0x0302, 0x0003,
    0x0303, 0x5d03,
    0x0302, 0x009e,
    0x0303, 0x035d,
    0x0302, 0x0083,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x3e00,
    0x0302, 0x00ba,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x0120,
    0x0302, 0x0041,
    0x0303, 0x4400,
    0x0302, 0x003a,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x0125,
    0x0302, 0x0041,
    0x0303, 0xc0e1,
    0x0302, 0x0003,
    0x0303, 0x0125,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf663,
    0x0302, 0x009f,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x0600,
    0x0302, 0x003a,
    0x0303, 0x03e1,
    0x0302, 0x0003,
    0x0303, 0x8311,
    0x0302, 0x000d,
    0x0303, 0xe821,
    0x0302, 0x009f,
    0x0303, 0x030f,
    0x0302, 0x000a,
    0x0303, 0xec01,
    0x0302, 0x009f,
    0x0303, 0x03cb,
    0x0302, 0x009e,
    0x0303, 0x03c4,
    0x0302, 0x0019,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x780f,
    0x0302, 0x009f,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0xc1ae,
    0x0302, 0x0003,
    0x0303, 0xc2ae,
    0x0302, 0x0003,
    0x0303, 0x6dd1,
    0x0302, 0x0091,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0xc0ae,
    0x0302, 0x0083,
    0x0303, 0xb100,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xa26e,
    0x0302, 0x001b,
    0x0303, 0xa206,
    0x0302, 0x00ab,
    0x0303, 0x03c6,
    0x0302, 0x0099,
    0x0303, 0x03c4,
    0x0302, 0x001c,
    0x0303, 0x6103,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x0080,
    0x0303, 0xc603,
    0x0302, 0x001e,
    0x0303, 0x0140,
    0x0302, 0x0041,
    0x0303, 0x0144,
    0x0302, 0x0080,
    0x0303, 0x03c4,
    0x0302, 0x001c,
    0x0303, 0x6103,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x0080,
    0x0303, 0x61c6,
    0x0302, 0x009d,
    0x0303, 0x6103,
    0x0302, 0x009e,
    0x0303, 0x0361,
    0x0302, 0x0083,
    0x0303, 0x06ff,
    0x0302, 0x003a,
    0x0303, 0x8302,
    0x0302, 0x0024,
    0x0303, 0x01ff,
    0x0302, 0x00ba,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x0163,
    0x0302, 0x00a1,
    0x0303, 0x8302,
    0x0302, 0x0024,
    0x0303, 0xed07,
    0x0302, 0x0004,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde03,
    0x0302, 0x0006,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0097,
    0x0303, 0x015a,
    0x0302, 0x00c1,
    0x0303, 0x0012,
    0x0302, 0x003a,
    0x0303, 0x7f03,
    0x0302, 0x0097,
    0x0303, 0x0163,
    0x0302, 0x00c1,
    0x0303, 0x7f00,
    0x0302, 0x0098,
    0x0303, 0x037f,
    0x0302, 0x0083,
    0x0303, 0x0163,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde43,
    0x0302, 0x001f,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x6103,
    0x0302, 0x0097,
    0x0303, 0x0163,
    0x0302, 0x00c1,
    0x0303, 0x7f03,
    0x0302, 0x0004,
    0x0303, 0x7f70,
    0x0302, 0x001e,
    0x0303, 0x037f,
    0x0302, 0x0083,
    0x0303, 0xea00,
    0x0302, 0x0098,
    0x0303, 0x03ea,
    0x0302, 0x0083,
    0x0303, 0xe075,
    0x0302, 0x0006,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x019b,
    0x0302, 0x0041,
    0x0303, 0xe803,
    0x0302, 0x000f,
    0x0303, 0xd1eb,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0000,
    0x0303, 0xeb30,
    0x0302, 0x002b,
    0x0303, 0x7dea,
    0x0302, 0x009b,
    0x0303, 0x0170,
    0x0302, 0x0021,
    0x0303, 0xfa00,
    0x0302, 0x0018,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x8305,
    0x0302, 0x000b,
    0x0303, 0x002e,
    0x0302, 0x003a,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0175,
    0x0302, 0x00a0,
    0x0303, 0x0010,
    0x0302, 0x0080,
    0x0303, 0x7dea,
    0x0302, 0x0097,
    0x0303, 0x01cf,
    0x0302, 0x00c1,
    0x0303, 0xc90f,
    0x0302, 0x009f,
    0x0303, 0xfa03,
    0x0302, 0x009c,
    0x0303, 0x03df,
    0x0302, 0x0091,
    0x0303, 0xfd02,
    0x0302, 0x0084,
    0x0303, 0x03c1,
    0x0302, 0x009e,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0xc0ea,
    0x0302, 0x0083,
    0x0303, 0xd170,
    0x0302, 0x009d,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0xdf6e,
    0x0302, 0x001b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdf43,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x009e,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0xdc6e,
    0x0302, 0x001b,
    0x0303, 0xfa03,
    0x0302, 0x0017,
    0x0303, 0x018b,
    0x0302, 0x00c1,
    0x0303, 0xdcfa,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf141,
    0x0302, 0x001f,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0191,
    0x0302, 0x0041,
    0x0303, 0x72fa,
    0x0302, 0x0003,
    0x0303, 0xfa0f,
    0x0302, 0x009f,
    0x0303, 0x0379,
    0x0302, 0x0083,
    0x0303, 0x03eb,
    0x0302, 0x0011,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0xd294,
    0x0302, 0x0083,
    0x0303, 0xd295,
    0x0302, 0x0003,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x8001,
    0x0302, 0x005a,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x0010,
    0x0302, 0x0080,
    0x0303, 0x8334,
    0x0302, 0x008b,
    0x0303, 0x3000,
    0x0302, 0x003a,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0xe243,
    0x0302, 0x001f,
    0x0303, 0x03ea,
    0x0302, 0x0097,
    0x0303, 0x01cb,
    0x0302, 0x0041,
    0x0303, 0x8325,
    0x0302, 0x0024,
    0x0303, 0xd17c,
    0x0302, 0x0083,
    0x0303, 0xcb67,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xe3dd,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd75,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd43,
    0x0302, 0x001f,
    0x0303, 0x0375,
    0x0302, 0x0019,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x0370,
    0x0302, 0x009d,
    0x0303, 0x036e,
    0x0302, 0x009b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x03ed,
    0x0302, 0x0017,
    0x0303, 0x01c6,
    0x0302, 0x00c1,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xe543,
    0x0302, 0x009f,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6775,
    0x0302, 0x0099,
    0x0303, 0x03ed,
    0x0302, 0x0017,
    0x0303, 0x01bf,
    0x0302, 0x0041,
    0x0303, 0x67dd,
    0x0302, 0x0019,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0x67c9,
    0x0302, 0x001c,
    0x0303, 0x03dd,
    0x0302, 0x0099,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0x01c6,
    0x0302, 0x00c1,
    0x0303, 0xed75,
    0x0302, 0x009e,
    0x0303, 0x03dd,
    0x0302, 0x0099,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0xed75,
    0x0302, 0x009e,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03dd,
    0x0302, 0x0099,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0xe805,
    0x0302, 0x000a,
    0x0303, 0xe804,
    0x0302, 0x00ab,
    0x0303, 0x9000,
    0x0302, 0x00fa,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0xe804,
    0x0302, 0x002a,
    0x0303, 0xe803,
    0x0302, 0x0024,
    0x0303, 0x0010,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0x0391,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7886,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7695,
    0x0302, 0x0083,
    0x0303, 0x0394,
    0x0302, 0x0083,
    0x0303, 0x6f86,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xc094,
    0x0302, 0x0083,
    0x0303, 0xc095,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0xc04c,
    0x0302, 0x0083,
    0x0303, 0x3213,
    0x0302, 0x003a,
    0x0303, 0x8b03,
    0x0302, 0x0017,
    0x0303, 0x01f7,
    0x0302, 0x0041,
    0x0303, 0xc24c,
    0x0302, 0x0003,
    0x0303, 0x01fb,
    0x0302, 0x0000,
    0x0303, 0x3d00,
    0x0302, 0x00ba,
    0x0303, 0x8b03,
    0x0302, 0x0017,
    0x0303, 0x01fb,
    0x0302, 0x0041,
    0x0303, 0xc14c,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xcd03,
    0x0302, 0x0019,
    0x0303, 0x0360,
    0x0302, 0x001e,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6204,
    0x0302, 0x0084,
    0x0303, 0x6207,
    0x0302, 0x0003,
    0x0303, 0xc062,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x100e,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5383,
    0x0302, 0x0085,
    0x0303, 0x0001,
    0x0302, 0x00ba,
    0x0303, 0x9a4c,
    0x0302, 0x001f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x9b83,
    0x0302, 0x0088,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0xc064,
    0x0302, 0x0083,
    0x0303, 0x0065,
    0x0302, 0x003a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0010,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x1092,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x3d3d,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xf00f,
    0x0302, 0x009f,
    0x0303, 0xfa44,
    0x0302, 0x009f,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0x001e,
    0x0302, 0x003a,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0xe000,
    0x0302, 0x007a,
    0x0303, 0x039b,
    0x0302, 0x009b,
    0x0303, 0x9b41,
    0x0302, 0x001f,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x9b00,
    0x0302, 0x0010,
    0x0303, 0x0307,
    0x0302, 0x008a,
    0x0303, 0xc040,
    0x0302, 0x0083,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0x0036,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1526,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1501,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1600,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1640,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xfdff,
    0x0302, 0x00ba,
    0x0303, 0x0382,
    0x0302, 0x001b,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0xc200,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x1538,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1537,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x53c2,
    0x0302, 0x009b,
    0x0303, 0x0058,
    0x0302, 0x0020,
    0x0303, 0x53c1,
    0x0302, 0x009b,
    0x0303, 0x00aa,
    0x0302, 0x00a0,
    0x0303, 0xc165,
    0x0302, 0x0083,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x3034,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x3039,
    0x0302, 0x003a,
    0x0303, 0x000b,
    0x0302, 0x00da,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xc3c3,
    0x0302, 0x003a,
    0x0303, 0x00c3,
    0x0302, 0x005a,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x0068,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0xc569,
    0x0302, 0x0003,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x00dd,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x1011,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x4a0f,
    0x0302, 0x001f,
    0x0303, 0x01dc,
    0x0302, 0x0060,
    0x0303, 0x9b24,
    0x0302, 0x0029,
    0x0303, 0x1500,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x9b2d,
    0x0302, 0x0008,
    0x0303, 0x992c,
    0x0302, 0x00a8,
    0x0303, 0x0081,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0123,
    0x0302, 0x0000,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x03d6,
    0x0302, 0x009b,
    0x0303, 0x0306,
    0x0302, 0x0005,
    0x0303, 0x00d0,
    0x0302, 0x00ba,
    0x0303, 0x03d6,
    0x0302, 0x009b,
    0x0303, 0x038c,
    0x0302, 0x0004,
    0x0303, 0xc575,
    0x0302, 0x0083,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0xd661,
    0x0302, 0x009f,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x151b,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x5303,
    0x0302, 0x001d,
    0x0303, 0x0304,
    0x0302, 0x0089,
    0x0303, 0x0020,
    0x0302, 0x00ba,
    0x0303, 0x9d03,
    0x0302, 0x0091,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x0017,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0308,
    0x0302, 0x0004,
    0x0303, 0xc366,
    0x0302, 0x0003,
    0x0303, 0xc164,
    0x0302, 0x0003,
    0x0303, 0x00a2,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0xc569,
    0x0302, 0x0003,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x0305,
    0x0302, 0x002e,
    0x0303, 0x1538,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x00b8,
    0x0302, 0x0000,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0xc065,
    0x0302, 0x0003,
    0x0303, 0x1688,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5383,
    0x0302, 0x0004,
    0x0303, 0x1689,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0x5303,
    0x0302, 0x009f,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x0028,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x000e,
    0x0302, 0x00a1,
    0x0303, 0x9b13,
    0x0302, 0x008b,
    0x0303, 0x9c75,
    0x0302, 0x0083,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x00bf,
    0x0302, 0x0020,
    0x0303, 0x75c9,
    0x0302, 0x009d,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x1522,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x7553,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1523,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1526,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0020,
    0x0302, 0x00ba,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x00d1,
    0x0302, 0x00a0,
    0x0303, 0x0080,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x00f5,
    0x0302, 0x0000,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0099,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0010,
    0x0302, 0x00ba,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x00e2,
    0x0302, 0x0021,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf041,
    0x0302, 0x009f,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x2000,
    0x0302, 0x00ba,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0x0160,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1092,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0040,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x3026,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x3029,
    0x0302, 0x00ba,
    0x0303, 0x000e,
    0x0302, 0x00da,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xb4b4,
    0x0302, 0x003a,
    0x0303, 0x00b4,
    0x0302, 0x003a,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x00f5,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0xc569,
    0x0302, 0x0003,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0101,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x030d,
    0x0302, 0x002a,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0xd603,
    0x0302, 0x008f,
    0x0303, 0xc875,
    0x0302, 0x0003,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x1482,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5370,
    0x0302, 0x009b,
    0x0303, 0x0304,
    0x0302, 0x0085,
    0x0303, 0x00fc,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0123,
    0x0302, 0x0000,
    0x0303, 0x1480,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x7053,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc94e,
    0x0302, 0x0003,
    0x0303, 0x00dc,
    0x0302, 0x0080,
    0x0303, 0x168a,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x759a,
    0x0302, 0x0083,
    0x0303, 0xf200,
    0x0302, 0x0098,
    0x0303, 0x03f2,
    0x0302, 0x0083,
    0x0303, 0x0001,
    0x0302, 0x00ba,
    0x0303, 0x9926,
    0x0302, 0x001f,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0xc100,
    0x0302, 0x0010,
    0x0303, 0x9903,
    0x0302, 0x001b,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x9b04,
    0x0302, 0x0024,
    0x0303, 0x000e,
    0x0302, 0x00ba,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x9b84,
    0x0302, 0x00a8,
    0x0303, 0x000e,
    0x0302, 0x00ba,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0xc169,
    0x0302, 0x0083,
    0x0303, 0x9b6f,
    0x0302, 0x001f,
    0x0303, 0x0304,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc2ee,
    0x0302, 0x0083,
    0x0303, 0x6991,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4a0f,
    0x0302, 0x001f,
    0x0303, 0x01dc,
    0x0302, 0x0060,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x9bab,
    0x0302, 0x0088,
    0x0303, 0x99ac,
    0x0302, 0x0028,
    0x0303, 0x6409,
    0x0302, 0x0004,
    0x0303, 0x6508,
    0x0302, 0x0004,
    0x0303, 0x1681,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0102,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5381,
    0x0302, 0x000a,
    0x0303, 0x4d75,
    0x0302, 0x0083,
    0x0303, 0x83b7,
    0x0302, 0x000b,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x0306,
    0x0302, 0x00aa,
    0x0303, 0x1480,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x7d75,
    0x0302, 0x0083,
    0x0303, 0x53be,
    0x0302, 0x0028,
    0x0303, 0x650d,
    0x0302, 0x0004,
    0x0303, 0x640c,
    0x0302, 0x0004,
    0x0303, 0x1685,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6667,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5275,
    0x0302, 0x0003,
    0x0303, 0x53c6,
    0x0302, 0x0009,
    0x0303, 0x5270,
    0x0302, 0x0099,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6787,
    0x0302, 0x0085,
    0x0303, 0x0040,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x0136,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0123,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x1526,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1546,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x1523,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x9a75,
    0x0302, 0x0083,
    0x0303, 0x68db,
    0x0302, 0x00a8,
    0x0303, 0x68dc,
    0x0302, 0x00a9,
    0x0303, 0x168a,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0010,
    0x0302, 0x00ba,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x017a,
    0x0302, 0x00a0,
    0x0303, 0x1538,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0136,
    0x0302, 0x00a1,
    0x0303, 0x4a0f,
    0x0302, 0x001f,
    0x0303, 0x01dc,
    0x0302, 0x0060,
    0x0303, 0x9b00,
    0x0302, 0x0010,
    0x0303, 0x030a,
    0x0302, 0x000c,
    0x0303, 0x4b09,
    0x0302, 0x0028,
    0x0303, 0x2000,
    0x0302, 0x007a,
    0x0303, 0x03d5,
    0x0302, 0x0091,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03eb,
    0x0302, 0x001b,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0x018d,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0x0004,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x9d02,
    0x0302, 0x008e,
    0x0303, 0x0197,
    0x0302, 0x0000,
    0x0303, 0x9b02,
    0x0302, 0x008e,
    0x0303, 0x0197,
    0x0302, 0x0000,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0xe803,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x0199,
    0x0302, 0x0080,
    0x0303, 0x010e,
    0x0302, 0x0000,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x9b82,
    0x0302, 0x0008,
    0x0303, 0x9983,
    0x0302, 0x00a8,
    0x0303, 0xe802,
    0x0302, 0x0029,
    0x0303, 0x01a1,
    0x0302, 0x0000,
    0x0303, 0xfdff,
    0x0302, 0x00ba,
    0x0303, 0x0382,
    0x0302, 0x001b,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x6409,
    0x0302, 0x0004,
    0x0303, 0x6508,
    0x0302, 0x0004,
    0x0303, 0x1681,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0102,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5381,
    0x0302, 0x000a,
    0x0303, 0x4d75,
    0x0302, 0x0083,
    0x0303, 0x8393,
    0x0302, 0x000b,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x0314,
    0x0302, 0x00aa,
    0x0303, 0x9b0f,
    0x0302, 0x001f,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x03cc,
    0x0302, 0x001b,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6507,
    0x0302, 0x0004,
    0x0303, 0xd70d,
    0x0302, 0x00ab,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6783,
    0x0302, 0x0005,
    0x0303, 0x7d75,
    0x0302, 0x0083,
    0x0303, 0x010e,
    0x0302, 0x0000,
    0x0303, 0xd902,
    0x0302, 0x000a,
    0x0303, 0x01c1,
    0x0302, 0x0000,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6784,
    0x0302, 0x0085,
    0x0303, 0x7b75,
    0x0302, 0x0083,
    0x0303, 0x010e,
    0x0302, 0x0000,
    0x0303, 0xe804,
    0x0302, 0x0089,
    0x0303, 0x0200,
    0x0302, 0x00ba,
    0x0303, 0x0382,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x4b05,
    0x0302, 0x0028,
    0x0303, 0x4b04,
    0x0302, 0x0089,
    0x0303, 0xc34b,
    0x0302, 0x0003,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x0040,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x3000,
    0x0302, 0x003a,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x0199,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x00ae,
    0x0303, 0xc000,
    0x0302, 0x00fa,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x009b,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x01ec,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x01f3,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01ec,
    0x0302, 0x0000,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x030e,
    0x0302, 0x00a8,
    0x0303, 0x0328,
    0x0302, 0x00a9,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0358,
    0x0302, 0x00a8,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x6304,
    0x0302, 0x0004,
    0x0303, 0x6307,
    0x0302, 0x0083,
    0x0303, 0xc063,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x00cb,
    0x0302, 0x0080,
    0x0303, 0x0006,
    0x0302, 0x0000,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x018c,
    0x0302, 0x0000,
    0x0303, 0xc0ea,
    0x0302, 0x0083,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0x8403,
    0x0302, 0x008d,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x004e,
    0x0302, 0x0060,
    0x0303, 0xe805,
    0x0302, 0x000a,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x9000,
    0x0302, 0x005a,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0x9000,
    0x0302, 0x0018,
    0x0303, 0x0390,
    0x0302, 0x0003,
    0x0303, 0xe806,
    0x0302, 0x0024,
    0x0303, 0xe805,
    0x0302, 0x00aa,
    0x0303, 0xdd04,
    0x0302, 0x00a8,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0x800f,
    0x0302, 0x00da,
    0x0303, 0x005a,
    0x0302, 0x0060,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x07d0,
    0x0302, 0x003a,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x005a,
    0x0302, 0x0060,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0x9c40,
    0x0302, 0x00ba,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x005a,
    0x0302, 0x0060,
    0x0303, 0xe814,
    0x0302, 0x00aa,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0xe804,
    0x0302, 0x00a4,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0x8002,
    0x0302, 0x0088,
    0x0303, 0x839f,
    0x0302, 0x000b,
    0x0303, 0xea00,
    0x0302, 0x0098,
    0x0303, 0x03ea,
    0x0302, 0x0083,
    0x0303, 0x7d03,
    0x0302, 0x0017,
    0x0303, 0x0040,
    0x0302, 0x00c1,
    0x0303, 0x8303,
    0x0302, 0x00a4,
    0x0303, 0xcb67,
    0x0302, 0x0003,
    0x0303, 0x004e,
    0x0302, 0x0060,
    0x0303, 0xe804,
    0x0302, 0x008a,
    0x0303, 0x9000,
    0x0302, 0x00fa,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0xe803,
    0x0302, 0x0024,
    0x0303, 0xe802,
    0x0302, 0x002a,
    0x0303, 0x0030,
    0x0302, 0x0000,
    0x0303, 0xee67,
    0x0302, 0x0086,
    0x0303, 0x0046,
    0x0302, 0x0080,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x0050,
    0x0302, 0x0021,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x0808,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x159d,
    0x0302, 0x003a,
    0x0303, 0x4102,
    0x0302, 0x00ad,
    0x0303, 0x1596,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x001f,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x009b,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x159e,
    0x0302, 0x003a,
    0x0303, 0x4102,
    0x0302, 0x00ad,
    0x0303, 0x1597,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x536a,
    0x0302, 0x0003,
    0x0303, 0x159f,
    0x0302, 0x00ba,
    0x0303, 0x4102,
    0x0302, 0x00ad,
    0x0303, 0x1598,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x1090,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0xe0c0,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x67c8,
    0x0302, 0x009c,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0369,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0xc045,
    0x0302, 0x0083,
    0x0303, 0x5345,
    0x0302, 0x0091,
    0x0303, 0x0345,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x108f,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6769,
    0x0302, 0x0019,
    0x0303, 0x0f6b,
    0x0302, 0x0002,
    0x0303, 0x03c2,
    0x0302, 0x001c,
    0x0303, 0x036b,
    0x0302, 0x0019,
    0x0303, 0x0f6b,
    0x0302, 0x0002,
    0x0303, 0x6ac3,
    0x0302, 0x009c,
    0x0303, 0x036b,
    0x0302, 0x0019,
    0x0303, 0x0f6b,
    0x0302, 0x0002,
    0x0303, 0x01db,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x0194,
    0x0302, 0x003a,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x00a8,
    0x0302, 0x00c1,
    0x0303, 0xc767,
    0x0302, 0x0003,
    0x0303, 0x00b7,
    0x0302, 0x0000,
    0x0303, 0x01ae,
    0x0302, 0x003a,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x015c,
    0x0302, 0x00ba,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x00af,
    0x0302, 0x0041,
    0x0303, 0xc667,
    0x0302, 0x0083,
    0x0303, 0x00b7,
    0x0302, 0x0000,
    0x0303, 0x0181,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x013c,
    0x0302, 0x00ba,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x00b6,
    0x0302, 0x00c1,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0x00b7,
    0x0302, 0x0000,
    0x0303, 0xc467,
    0x0302, 0x0003,
    0x0303, 0x67c4,
    0x0302, 0x009c,
    0x0303, 0x03c8,
    0x0302, 0x0091,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x036a,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0345,
    0x0302, 0x0091,
    0x0303, 0x0345,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x0043,
    0x0302, 0x0080,
    0x0303, 0x0046,
    0x0302, 0x0080,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc3ee,
    0x0302, 0x0003,
    0x0303, 0x9b6f,
    0x0302, 0x001f,
    0x0303, 0x0386,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x0003,
    0x0302, 0x003a,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x1091,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x7053,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xc875,
    0x0302, 0x0003,
    0x0303, 0x9d02,
    0x0302, 0x008e,
    0x0303, 0xc475,
    0x0302, 0x0003,
    0x0303, 0x4bc2,
    0x0302, 0x0097,
    0x0303, 0x00d8,
    0x0302, 0x0021,
    0x0303, 0xcb75,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0xb602,
    0x0302, 0x000a,
    0x0303, 0x00df,
    0x0302, 0x0080,
    0x0303, 0x1091,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x3810,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1600,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1640,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1581,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1580,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xffff,
    0x0302, 0x00fa,
    0x0303, 0x03e2,
    0x0302, 0x001b,
    0x0303, 0x0101,
    0x0302, 0x0021,
    0x0303, 0x0900,
    0x0302, 0x00fa,
    0x0303, 0x03e2,
    0x0302, 0x0011,
    0x0303, 0x03e2,
    0x0302, 0x0003,
    0x0303, 0x9b16,
    0x0302, 0x00ac,
    0x0303, 0x1023,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x3009,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1082,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1079,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xe1e1,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x107a,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0021,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x011c,
    0x0302, 0x0000,
    0x0303, 0x1023,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x3005,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x1033,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x5853,
    0x0302, 0x009b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x005a,
    0x0302, 0x0060,
    0x0303, 0x9b0f,
    0x0302, 0x001f,
    0x0303, 0x03c7,
    0x0302, 0x009d,
    0x0303, 0x030d,
    0x0302, 0x00a8,
    0x0303, 0x10ae,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0xfffe,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x10a1,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0005,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0080,
    0x0302, 0x00ba,
    0x0303, 0x2000,
    0x0302, 0x00da,
    0x0303, 0x03e8,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x0140,
    0x0302, 0x003a,
    0x0303, 0x0363,
    0x0302, 0x0003,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x00c5,
    0x0302, 0x0000,
    0x0303, 0x4789,
    0x0302, 0x0083,
    0x0303, 0x01aa,
    0x0302, 0x00e0,
    0x0303, 0x490f,
    0x0302, 0x001f,
    0x0303, 0x005a,
    0x0302, 0x0060,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x0148,
    0x0302, 0x00ba,
    0x0303, 0x0363,
    0x0302, 0x0003,
    0x0303, 0x00c5,
    0x0302, 0x0000,
    0x0303, 0xd603,
    0x0302, 0x00ab,
    0x0303, 0x8391,
    0x0302, 0x008b,
    0x0303, 0x8488,
    0x0302, 0x002d,
    0x0303, 0x105b,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xce53,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x9b00,
    0x0302, 0x0010,
    0x0303, 0x030f,
    0x0302, 0x000a,
    0x0303, 0x4889,
    0x0302, 0x0083,
    0x0303, 0x0258,
    0x0302, 0x003a,
    0x0303, 0x038a,
    0x0302, 0x0083,
    0x0303, 0xc05e,
    0x0302, 0x0083,
    0x0303, 0xc3ee,
    0x0302, 0x0003,
    0x0303, 0x015b,
    0x0302, 0x003a,
    0x0303, 0x0363,
    0x0302, 0x0003,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0xc667,
    0x0302, 0x0083,
    0x0303, 0x0046,
    0x0302, 0x0080,
    0x0303, 0xd704,
    0x0302, 0x00ae,
    0x0303, 0xc99a,
    0x0302, 0x0003,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x0045,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x14e0,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5000,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x9d00,
    0x0302, 0x0010,
    0x0303, 0x0305,
    0x0302, 0x008e,
    0x0303, 0x1092,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5153,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x0004,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x9d03,
    0x0302, 0x000e,
    0x0303, 0x2024,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x4bc2,
    0x0302, 0x0097,
    0x0303, 0x0176,
    0x0302, 0x0021,
    0x0303, 0x0400,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x017b,
    0x0302, 0x0080,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x0304,
    0x0302, 0x002f,
    0x0303, 0x0004,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x030d,
    0x0302, 0x002a,
    0x0303, 0xd604,
    0x0302, 0x000f,
    0x0303, 0xcb9a,
    0x0302, 0x0083,
    0x0303, 0xc268,
    0x0302, 0x0003,
    0x0303, 0x0045,
    0x0302, 0x0080,
    0x0303, 0x0187,
    0x0302, 0x00ba,
    0x0303, 0x0363,
    0x0302, 0x0003,
    0x0303, 0x00c2,
    0x0302, 0x0080,
    0x0303, 0x14e1,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x536d,
    0x0302, 0x009b,
    0x0303, 0x038b,
    0x0302, 0x0084,
    0x0303, 0x6503,
    0x0302, 0x0084,
    0x0303, 0x6402,
    0x0302, 0x0084,
    0x0303, 0x0192,
    0x0302, 0x0000,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0x0046,
    0x0302, 0x0080,
    0x0303, 0x6667,
    0x0302, 0x0083,
    0x0303, 0x1681,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc40f,
    0x0302, 0x001f,
    0x0303, 0x6703,
    0x0302, 0x001c,
    0x0303, 0x03c3,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xd604,
    0x0302, 0x000f,
    0x0303, 0xcf9a,
    0x0302, 0x0003,
    0x0303, 0xc668,
    0x0302, 0x0083,
    0x0303, 0x0045,
    0x0302, 0x0080,
    0x0303, 0x1681,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x5387,
    0x0302, 0x000a,
    0x0303, 0x1683,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01d3,
    0x0302, 0x0060,
    0x0303, 0x5392,
    0x0302, 0x0089,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6795,
    0x0302, 0x0085,
    0x0303, 0x018f,
    0x0302, 0x0000,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xd568,
    0x0302, 0x0003,
    0x0303, 0x01af,
    0x0302, 0x0080,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x6d68,
    0x0302, 0x0003,
    0x0303, 0x6700,
    0x0302, 0x0010,
    0x0303, 0x0387,
    0x0302, 0x001b,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0384,
    0x0302, 0x0011,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0010,
    0x0303, 0x0375,
    0x0302, 0x009b,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x01b4,
    0x0302, 0x00a1,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0387,
    0x0302, 0x0011,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x75d1,
    0x0302, 0x0091,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x00ae,
    0x0303, 0xc000,
    0x0302, 0x00fa,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x009b,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x01dd,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xb611,
    0x0302, 0x002c,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0xb60f,
    0x0302, 0x001f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0302,
    0x0302, 0x002f,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x0055,
    0x0302, 0x003a,
    0x0303, 0x03b8,
    0x0302, 0x001b,
    0x0303, 0x01ea,
    0x0302, 0x00a0,
    0x0303, 0x1891,
    0x0302, 0x001a,
    0x0303, 0x01eb,
    0x0302, 0x0080,
    0x0303, 0x1091,
    0x0302, 0x009a,
    0x0303, 0x68b5,
    0x0302, 0x0003,
    0x0303, 0x03b4,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb590,
    0x0302, 0x002a,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x030d,
    0x0302, 0x00a8,
    0x0303, 0x4e00,
    0x0302, 0x0014,
    0x0303, 0x03cb,
    0x0302, 0x0097,
    0x0303, 0x0012,
    0x0302, 0x00a0,
    0x0303, 0x4f07,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xf002,
    0x0302, 0x00ab,
    0x0303, 0x000e,
    0x0302, 0x0080,
    0x0303, 0xc0f0,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x9c81,
    0x0302, 0x0088,
    0x0303, 0xc868,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0060,
    0x0303, 0x1092,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0022,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0xd50f,
    0x0302, 0x001f,
    0x0303, 0x03e8,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xdcfa,
    0x0302, 0x0083,
    0x0303, 0xc079,
    0x0302, 0x0083,
    0x0303, 0xc200,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xc092,
    0x0302, 0x0083,
    0x0303, 0xc080,
    0x0302, 0x0083,
    0x0303, 0x0028,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01ed,
    0x0302, 0x00e0,
    0x0303, 0x9d0b,
    0x0302, 0x0009,
    0x0303, 0x2000,
    0x0302, 0x007a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0033,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f7,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x9d02,
    0x0302, 0x0028,
    0x0303, 0x00e7,
    0x0302, 0x0000,
    0x0303, 0xf000,
    0x0302, 0x0018,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0xc09c,
    0x0302, 0x0003,
    0x0303, 0x6b01,
    0x0302, 0x003a,
    0x0303, 0x003e,
    0x0302, 0x00da,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x9ad2,
    0x0302, 0x003a,
    0x0303, 0x0290,
    0x0302, 0x00da,
    0x0303, 0x038a,
    0x0302, 0x0083,
    0x0303, 0x9a46,
    0x0302, 0x0083,
    0x0303, 0xc09b,
    0x0302, 0x0083,
    0x0303, 0x01bf,
    0x0302, 0x0060,
    0x0303, 0x0043,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f1,
    0x0302, 0x0060,
    0x0303, 0x0046,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e5,
    0x0302, 0x0060,
    0x0303, 0xc04a,
    0x0302, 0x0083,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0011,
    0x0302, 0x003a,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x004d,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x500a,
    0x0302, 0x0028,
    0x0303, 0x8405,
    0x0302, 0x002d,
    0x0303, 0x0052,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f3,
    0x0302, 0x00e0,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0056,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x0048,
    0x0302, 0x0000,
    0x0303, 0x484a,
    0x0302, 0x0083,
    0x0303, 0xc868,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0060,
    0x0303, 0x005d,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f1,
    0x0302, 0x0060,
    0x0303, 0x0060,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e5,
    0x0302, 0x0060,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0065,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x5008,
    0x0302, 0x00a8,
    0x0303, 0x8402,
    0x0302, 0x00ad,
    0x0303, 0x0078,
    0x0302, 0x0000,
    0x0303, 0x006c,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x4849,
    0x0302, 0x0083,
    0x0303, 0x0062,
    0x0302, 0x0080,
    0x0303, 0x4748,
    0x0302, 0x001e,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0320,
    0x0302, 0x00ab,
    0x0303, 0x4b48,
    0x0302, 0x0017,
    0x0303, 0x0091,
    0x0302, 0x0020,
    0x0303, 0x484a,
    0x0302, 0x0091,
    0x0303, 0x0f4a,
    0x0302, 0x0002,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x0067,
    0x0302, 0x0080,
    0x0303, 0x4748,
    0x0302, 0x0003,
    0x0303, 0x007c,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x007f,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x5011,
    0x0302, 0x0028,
    0x0303, 0xc968,
    0x0302, 0x0083,
    0x0303, 0x019b,
    0x0302, 0x0060,
    0x0303, 0xb60b,
    0x0302, 0x00aa,
    0x0303, 0x0029,
    0x0302, 0x00ba,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x0089,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f3,
    0x0302, 0x00e0,
    0x0303, 0x4948,
    0x0302, 0x0083,
    0x0303, 0x008d,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x0062,
    0x0302, 0x0080,
    0x0303, 0x4a46,
    0x0302, 0x0003,
    0x0303, 0x01bf,
    0x0302, 0x0060,
    0x0303, 0x0084,
    0x0302, 0x0000,
    0x0303, 0xf3de,
    0x0302, 0x003a,
    0x0303, 0x0057,
    0x0302, 0x00da,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x4847,
    0x0302, 0x001b,
    0x0303, 0x009a,
    0x0302, 0x0021,
    0x0303, 0x4847,
    0x0302, 0x0003,
    0x0303, 0x009a,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f5,
    0x0302, 0x00e0,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x480c,
    0x0302, 0x000c,
    0x0303, 0x9d06,
    0x0302, 0x0029,
    0x0303, 0x14e2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xce53,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x00ad,
    0x0302, 0x0080,
    0x0303, 0x15c2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x00ad,
    0x0302, 0x0080,
    0x0303, 0x14a4,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x0031,
    0x0302, 0x00ba,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x00b7,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x00b5,
    0x0302, 0x00a1,
    0x0303, 0xe802,
    0x0302, 0x000e,
    0x0303, 0x01da,
    0x0302, 0x0060,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0x848a,
    0x0302, 0x00ad,
    0x0303, 0x9b00,
    0x0302, 0x0098,
    0x0303, 0x039b,
    0x0302, 0x0083,
    0x0303, 0x8310,
    0x0302, 0x008b,
    0x0303, 0x00bc,
    0x0302, 0x0080,
    0x0303, 0x4806,
    0x0302, 0x000c,
    0x0303, 0x9d03,
    0x0302, 0x0089,
    0x0303, 0xd80c,
    0x0302, 0x000a,
    0x0303, 0x00c4,
    0x0302, 0x0080,
    0x0303, 0xd90a,
    0x0302, 0x008a,
    0x0303, 0x00c4,
    0x0302, 0x0080,
    0x0303, 0xda08,
    0x0302, 0x000a,
    0x0303, 0x00c4,
    0x0302, 0x0080,
    0x0303, 0x9d14,
    0x0302, 0x008f,
    0x0303, 0x018f,
    0x0302, 0x0060,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x030f,
    0x0302, 0x0088,
    0x0303, 0x9d04,
    0x0302, 0x008d,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x039b,
    0x0302, 0x009e,
    0x0303, 0x0371,
    0x0302, 0x002b,
    0x0303, 0x00d1,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x00d4,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x50c5,
    0x0302, 0x0028,
    0x0303, 0x00ca,
    0x0302, 0x0000,
    0x0303, 0x84ab,
    0x0302, 0x00ad,
    0x0303, 0xc29c,
    0x0302, 0x0083,
    0x0303, 0x47c9,
    0x0302, 0x0017,
    0x0303, 0x014b,
    0x0302, 0x00a1,
    0x0303, 0x48c9,
    0x0302, 0x0017,
    0x0303, 0x014b,
    0x0302, 0x00a1,
    0x0303, 0x9d6d,
    0x0302, 0x0009,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x018f,
    0x0302, 0x0060,
    0x0303, 0x3b00,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x00ea,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01ef,
    0x0302, 0x0060,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0xd70f,
    0x0302, 0x009f,
    0x0303, 0x03c7,
    0x0302, 0x001c,
    0x0303, 0x0386,
    0x0302, 0x00ab,
    0x0303, 0x7500,
    0x0302, 0x0098,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0389,
    0x0302, 0x000b,
    0x0303, 0x0051,
    0x0302, 0x00ba,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x1580,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc253,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x0001,
    0x0302, 0x007a,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x0140,
    0x0302, 0x003a,
    0x0303, 0x038a,
    0x0302, 0x0083,
    0x0303, 0xcf00,
    0x0302, 0x0090,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x9d41,
    0x0302, 0x001f,
    0x0303, 0x0341,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0xc040,
    0x0302, 0x0083,
    0x0303, 0xc05e,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x2000,
    0x0302, 0x00da,
    0x0303, 0x0341,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x010a,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f7,
    0x0302, 0x0060,
    0x0303, 0x010d,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01eb,
    0x0302, 0x00e0,
    0x0303, 0x5e9b,
    0x0302, 0x0003,
    0x0303, 0xd730,
    0x0302, 0x00aa,
    0x0303, 0x0110,
    0x0302, 0x0000,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x9d13,
    0x0302, 0x000a,
    0x0303, 0xd70f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0310,
    0x0302, 0x002f,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x0029,
    0x0303, 0x15c6,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x018f,
    0x0302, 0x0060,
    0x0303, 0x0800,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0126,
    0x0302, 0x00a0,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x2424,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0x0404,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6753,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x28cb,
    0x0302, 0x00ba,
    0x0303, 0x000c,
    0x0302, 0x005a,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x013b,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x00b5,
    0x0302, 0x00a1,
    0x0303, 0xe802,
    0x0302, 0x000e,
    0x0303, 0x01da,
    0x0302, 0x0060,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0x8488,
    0x0302, 0x002d,
    0x0303, 0xd902,
    0x0302, 0x000a,
    0x0303, 0x014b,
    0x0302, 0x0080,
    0x0303, 0xc49c,
    0x0302, 0x0083,
    0x0303, 0x4700,
    0x0302, 0x0090,
    0x0303, 0x039a,
    0x0302, 0x001b,
    0x0303, 0x0147,
    0x0302, 0x0020,
    0x0303, 0x0f9a,
    0x0302, 0x0082,
    0x0303, 0xc59c,
    0x0302, 0x0003,
    0x0303, 0x0014,
    0x0302, 0x0000,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x039c,
    0x0302, 0x0003,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x0392,
    0x0302, 0x0091,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x0189,
    0x0302, 0x0000,
    0x0303, 0xf289,
    0x0302, 0x0003,
    0x0303, 0x568a,
    0x0302, 0x0083,
    0x0303, 0x0060,
    0x0302, 0x003a,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0348,
    0x0302, 0x0011,
    0x0303, 0x039b,
    0x0302, 0x0083,
    0x0303, 0x4748,
    0x0302, 0x0017,
    0x0303, 0x0147,
    0x0302, 0x00a1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03eb,
    0x0302, 0x001b,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0xd500,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x9c2e,
    0x0302, 0x0028,
    0x0303, 0x8257,
    0x0302, 0x0083,
    0x0303, 0x9d09,
    0x0302, 0x00ab,
    0x0303, 0x9d02,
    0x0302, 0x002d,
    0x0303, 0x0166,
    0x0302, 0x0080,
    0x0303, 0xc20f,
    0x0302, 0x001f,
    0x0303, 0x03e8,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xff00,
    0x0302, 0x003a,
    0x0303, 0x0382,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x016e,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x016c,
    0x0302, 0x00a1,
    0x0303, 0xe802,
    0x0302, 0x000e,
    0x0303, 0x01da,
    0x0302, 0x0000,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x0080,
    0x0303, 0x5782,
    0x0302, 0x0083,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x4803,
    0x0302, 0x000c,
    0x0303, 0xd904,
    0x0302, 0x000a,
    0x0303, 0x015b,
    0x0302, 0x0000,
    0x0303, 0xda02,
    0x0302, 0x000a,
    0x0303, 0x015b,
    0x0302, 0x0000,
    0x0303, 0xc200,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x8488,
    0x0302, 0x002e,
    0x0303, 0xd5d9,
    0x0302, 0x0003,
    0x0303, 0xd5da,
    0x0302, 0x0003,
    0x0303, 0xc0d9,
    0x0302, 0x0083,
    0x0303, 0xc0da,
    0x0302, 0x0083,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0180,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x8498,
    0x0302, 0x00ad,
    0x0303, 0x9d05,
    0x0302, 0x002a,
    0x0303, 0x4703,
    0x0302, 0x000c,
    0x0303, 0xd9be,
    0x0302, 0x0089,
    0x0303, 0x0186,
    0x0302, 0x0000,
    0x0303, 0xdac0,
    0x0302, 0x0089,
    0x0303, 0x015b,
    0x0302, 0x0000,
    0x0303, 0x8402,
    0x0302, 0x002a,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0014,
    0x0302, 0x0000,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x0192,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x0199,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0192,
    0x0302, 0x0000,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x680f,
    0x0302, 0x001f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xd568,
    0x0302, 0x0003,
    0x0303, 0x01aa,
    0x0302, 0x0080,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x6d68,
    0x0302, 0x0003,
    0x0303, 0x6700,
    0x0302, 0x0010,
    0x0303, 0x0387,
    0x0302, 0x001b,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0384,
    0x0302, 0x0011,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0010,
    0x0303, 0x0375,
    0x0302, 0x009b,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x01af,
    0x0302, 0x00a1,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0387,
    0x0302, 0x0011,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0306,
    0x0302, 0x00a9,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x4608,
    0x0302, 0x00a9,
    0x0303, 0x4609,
    0x0302, 0x00a8,
    0x0303, 0xc94b,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc84b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc44b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc24b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc14b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc667,
    0x0302, 0x0083,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc767,
    0x0302, 0x0003,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc4ee,
    0x0302, 0x0083,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc94e,
    0x0302, 0x0003,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0x01d4,
    0x0302, 0x0080,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d4,
    0x0302, 0x0080,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x0080,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xee13,
    0x0302, 0x002f,
    0x0303, 0x4f0f,
    0x0302, 0x001f,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03c7,
    0x0302, 0x009b,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xee67,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x0308,
    0x0302, 0x00a8,
    0x0303, 0x0315,
    0x0302, 0x0029,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0303,
    0x0302, 0x0028,
    0x0303, 0x0303,
    0x0302, 0x00a9,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x00fc,
    0x0302, 0x0000,
    0x0303, 0x0130,
    0x0302, 0x0080,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0099,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0xc090,
    0x0302, 0x0003,
    0x0303, 0xf299,
    0x0302, 0x0008,
    0x0303, 0x002c,
    0x0302, 0x00ba,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0xc203,
    0x0302, 0x001f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x003e,
    0x0302, 0x0080,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x00dd,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0xc090,
    0x0302, 0x0003,
    0x0303, 0xf2a7,
    0x0302, 0x0088,
    0x0303, 0x003a,
    0x0302, 0x003a,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0xc103,
    0x0302, 0x001f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x0046,
    0x0302, 0x0080,
    0x0303, 0xf20f,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0327,
    0x0302, 0x0028,
    0x0303, 0x0305,
    0x0302, 0x00a9,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0365,
    0x0302, 0x0028,
    0x0303, 0x036a,
    0x0302, 0x00a9,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0xc0f0,
    0x0302, 0x0003,
    0x0303, 0x001e,
    0x0302, 0x003a,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x10ae,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0441,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a1,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc453,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a7,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xdfff,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a6,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x000d,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x102d,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0100,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x125f,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x070f,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x4000,
    0x0302, 0x007a,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x03db,
    0x0302, 0x0003,
    0x0303, 0x00ff,
    0x0302, 0x003a,
    0x0303, 0x0030,
    0x0302, 0x005a,
    0x0303, 0x03e5,
    0x0302, 0x0083,
    0x0303, 0x0010,
    0x0302, 0x00ba,
    0x0303, 0x0030,
    0x0302, 0x005a,
    0x0303, 0x03e3,
    0x0302, 0x0083,
    0x0303, 0x001c,
    0x0302, 0x00ba,
    0x0303, 0x000a,
    0x0302, 0x005a,
    0x0303, 0x03dc,
    0x0302, 0x0083,
    0x0303, 0x000a,
    0x0302, 0x003a,
    0x0303, 0xf10c,
    0x0302, 0x001f,
    0x0303, 0x03f1,
    0x0302, 0x0083,
    0x0303, 0xe80f,
    0x0302, 0x009f,
    0x0303, 0x03d5,
    0x0302, 0x009b,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03c6,
    0x0302, 0x009c,
    0x0303, 0x03e8,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x0008,
    0x0302, 0x00ba,
    0x0303, 0xe90c,
    0x0302, 0x001f,
    0x0303, 0x03e9,
    0x0302, 0x0083,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x10ae,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x1910,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a1,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc553,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a7,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x8f00,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a6,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a4,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x85f0,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x1266,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xd553,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x1266,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x008c,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x00b3,
    0x0302, 0x0080,
    0x0303, 0x1266,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0096,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x4000,
    0x0302, 0x007a,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x03db,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0005,
    0x0302, 0x005a,
    0x0303, 0x03e5,
    0x0302, 0x0083,
    0x0303, 0x0014,
    0x0302, 0x003a,
    0x0303, 0x0020,
    0x0302, 0x00da,
    0x0303, 0x03e3,
    0x0302, 0x0083,
    0x0303, 0x0024,
    0x0302, 0x003a,
    0x0303, 0x000a,
    0x0302, 0x005a,
    0x0303, 0x03dc,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0xf10c,
    0x0302, 0x001f,
    0x0303, 0x03f1,
    0x0302, 0x0083,
    0x0303, 0x2000,
    0x0302, 0x007a,
    0x0303, 0xe803,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x0008,
    0x0302, 0x00ba,
    0x0303, 0xe90c,
    0x0302, 0x001f,
    0x0303, 0x03e9,
    0x0302, 0x0083,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x10ae,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x1910,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc753,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0070,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x00bb,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a1,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc553,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a7,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x8f00,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a6,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a4,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x81f0,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x9b03,
    0x0302, 0x001f,
    0x0303, 0x00f9,
    0x0302, 0x00a0,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x53f5,
    0x0302, 0x0003,
    0x0303, 0x7207,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x10ae,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0149,
    0x0302, 0x0060,
    0x0303, 0xc153,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x10a1,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc453,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x1234,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0xc1f5,
    0x0302, 0x0083,
    0x0303, 0x070f,
    0x0302, 0x00ba,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x9b14,
    0x0302, 0x002c,
    0x0303, 0x1023,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6853,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x1082,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x684f,
    0x0302, 0x009f,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x1079,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6953,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x107a,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x694f,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x0125,
    0x0302, 0x0000,
    0x0303, 0x1023,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6753,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x1033,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0149,
    0x0302, 0x0060,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x5853,
    0x0302, 0x009b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x1682,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xffff,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x6667,
    0x0302, 0x0083,
    0x0303, 0x1681,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc40f,
    0x0302, 0x001f,
    0x0303, 0x6703,
    0x0302, 0x001c,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0144,
    0x0302, 0x00e0,
    0x0303, 0x0149,
    0x0302, 0x0060,
    0x0303, 0x5381,
    0x0302, 0x000a,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x678b,
    0x0302, 0x0085,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x014c,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x0153,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x014c,
    0x0302, 0x0000,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x6a0f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x4fc9,
    0x0302, 0x001c,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0x680f,
    0x0302, 0x001f,
    0x0303, 0x034f,
    0x0302, 0x0091,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03c5,
    0x0302, 0x0011,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x0011,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xee0a,
    0x0302, 0x00af,
    0x0303, 0x4f0f,
    0x0302, 0x001f,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03c7,
    0x0302, 0x009b,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x030e,
    0x0302, 0x00a8,
    0x0303, 0x0302,
    0x0302, 0x0029,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0x0183,
    0x0302, 0x0000,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0xee91,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x5e00,
    0x0302, 0x0098,
    0x0303, 0x035e,
    0x0302, 0x0083,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0x0026,
    0x0302, 0x00ba,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x00df,
    0x0302, 0x0080,
    0x0303, 0x4102,
    0x0302, 0x008c,
    0x0303, 0x0033,
    0x0302, 0x0000,
    0x0303, 0x01d5,
    0x0302, 0x0060,
    0x0303, 0xd72c,
    0x0302, 0x002a,
    0x0303, 0x002d,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x0056,
    0x0302, 0x0060,
    0x0303, 0x0031,
    0x0302, 0x00ba,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x4188,
    0x0302, 0x0024,
    0x0303, 0x8489,
    0x0302, 0x00ad,
    0x0303, 0xcd00,
    0x0302, 0x0010,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0039,
    0x0302, 0x003a,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x009a,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xd71b,
    0x0302, 0x00aa,
    0x0303, 0x003e,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x0056,
    0x0302, 0x0060,
    0x0303, 0x0042,
    0x0302, 0x003a,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x4248,
    0x0302, 0x009f,
    0x0303, 0x030a,
    0x0302, 0x002b,
    0x0303, 0x418a,
    0x0302, 0x000d,
    0x0303, 0xcd41,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x004a,
    0x0302, 0x00ba,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x009a,
    0x0302, 0x0000,
    0x0303, 0x4248,
    0x0302, 0x009f,
    0x0303, 0x0302,
    0x0302, 0x00ab,
    0x0303, 0x001f,
    0x0302, 0x0080,
    0x0303, 0x0050,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x0053,
    0x0302, 0x003a,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0xd702,
    0x0302, 0x002a,
    0x0303, 0xd787,
    0x0302, 0x002d,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xc36b,
    0x0302, 0x0083,
    0x0303, 0x4102,
    0x0302, 0x002f,
    0x0303, 0xc26b,
    0x0302, 0x0003,
    0x0303, 0x4041,
    0x0302, 0x001f,
    0x0303, 0x03c3,
    0x0302, 0x001b,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x0064,
    0x0302, 0x0020,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x0062,
    0x0302, 0x00a1,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x0065,
    0x0302, 0x0000,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x0065,
    0x0302, 0x0000,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0x4031,
    0x0302, 0x009f,
    0x0303, 0x03c3,
    0x0302, 0x001b,
    0x0303, 0x03c3,
    0x0302, 0x0017,
    0x0303, 0x0072,
    0x0302, 0x00a0,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x0070,
    0x0302, 0x00a1,
    0x0303, 0x4103,
    0x0302, 0x0088,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0x0073,
    0x0302, 0x0080,
    0x0303, 0xc268,
    0x0302, 0x0003,
    0x0303, 0x0073,
    0x0302, 0x0080,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x0073,
    0x0302, 0x0080,
    0x0303, 0xc368,
    0x0302, 0x0083,
    0x0303, 0x4041,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x03c3,
    0x0302, 0x001b,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x0080,
    0x0302, 0x0020,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x007d,
    0x0302, 0x0021,
    0x0303, 0xc069,
    0x0302, 0x0003,
    0x0303, 0x4108,
    0x0302, 0x0029,
    0x0303, 0x0088,
    0x0302, 0x0000,
    0x0303, 0xc169,
    0x0302, 0x0083,
    0x0303, 0x4105,
    0x0302, 0x00a9,
    0x0303, 0x0088,
    0x0302, 0x0000,
    0x0303, 0x4183,
    0x0302, 0x0029,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0x0088,
    0x0302, 0x0000,
    0x0303, 0x0064,
    0x0302, 0x00ba,
    0x0303, 0x035e,
    0x0302, 0x0097,
    0x0303, 0x0088,
    0x0302, 0x0041,
    0x0303, 0xc269,
    0x0302, 0x0091,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0368,
    0x0302, 0x0091,
    0x0303, 0x0369,
    0x0302, 0x0011,
    0x0303, 0x0304,
    0x0302, 0x0008,
    0x0303, 0xcb41,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0092,
    0x0302, 0x0080,
    0x0303, 0xcb00,
    0x0302, 0x0010,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0368,
    0x0302, 0x009b,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0302,
    0x0302, 0x0029,
    0x0303, 0x0099,
    0x0302, 0x0000,
    0x0303, 0xc941,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc042,
    0x0302, 0x0003,
    0x0303, 0x4104,
    0x0302, 0x008c,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x00d6,
    0x0302, 0x0080,
    0x0303, 0x4102,
    0x0302, 0x000e,
    0x0303, 0x00d6,
    0x0302, 0x0080,
    0x0303, 0xc142,
    0x0302, 0x0083,
    0x0303, 0x4102,
    0x0302, 0x002f,
    0x0303, 0xc242,
    0x0302, 0x0083,
    0x0303, 0x4103,
    0x0302, 0x0028,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x00a8,
    0x0302, 0x0080,
    0x0303, 0xc467,
    0x0302, 0x0003,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0342,
    0x0302, 0x001b,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0xcb68,
    0x0302, 0x0003,
    0x0303, 0xc969,
    0x0302, 0x0003,
    0x0303, 0x4103,
    0x0302, 0x00af,
    0x0303, 0xc968,
    0x0302, 0x0083,
    0x0303, 0xcb69,
    0x0302, 0x0083,
    0x0303, 0x4102,
    0x0302, 0x0029,
    0x0303, 0x00c6,
    0x0302, 0x0000,
    0x0303, 0x4104,
    0x0302, 0x008f,
    0x0303, 0x01ff,
    0x0302, 0x00ba,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x00be,
    0x0302, 0x0021,
    0x0303, 0xf561,
    0x0302, 0x001f,
    0x0303, 0x03c1,
    0x0302, 0x0097,
    0x0303, 0x00be,
    0x0302, 0x00a0,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x00c2,
    0x0302, 0x0020,
    0x0303, 0x00c6,
    0x0302, 0x0000,
    0x0303, 0xd541,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x00c7,
    0x0302, 0x0080,
    0x0303, 0xd541,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x6867,
    0x0302, 0x0003,
    0x0303, 0x00c7,
    0x0302, 0x0080,
    0x0303, 0x6967,
    0x0302, 0x0083,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0342,
    0x0302, 0x001b,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x4103,
    0x0302, 0x000a,
    0x0303, 0x2000,
    0x0302, 0x00ba,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x4103,
    0x0302, 0x008b,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0xcf00,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0342,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xd611,
    0x0302, 0x00ab,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0x15c7,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x5303,
    0x0302, 0x001d,
    0x0303, 0x03c1,
    0x0302, 0x009b,
    0x0303, 0x0367,
    0x0302, 0x0019,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0098,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x038a,
    0x0302, 0x000b,
    0x0303, 0x67c4,
    0x0302, 0x001e,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0303,
    0x0302, 0x002b,
    0x0303, 0xc941,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x4fc9,
    0x0302, 0x001c,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x034f,
    0x0302, 0x0091,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03c6,
    0x0302, 0x0011,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x9d0d,
    0x0302, 0x00ac,
    0x0303, 0xc075,
    0x0302, 0x0083,
    0x0303, 0x830c,
    0x0302, 0x000b,
    0x0303, 0xe80a,
    0x0302, 0x002e,
    0x0303, 0x5ec2,
    0x0302, 0x0017,
    0x0303, 0x010a,
    0x0302, 0x00c1,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xe243,
    0x0302, 0x001f,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x0900,
    0x0302, 0x003a,
    0x0303, 0x0372,
    0x0302, 0x0099,
    0x0303, 0xea03,
    0x0302, 0x0097,
    0x0303, 0x010b,
    0x0302, 0x0041,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x7591,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x1090,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x536a,
    0x0302, 0x0003,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0xc853,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x411c,
    0x0302, 0x002a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0x15c4,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x8410,
    0x0302, 0x002a,
    0x0303, 0x5384,
    0x0302, 0x0088,
    0x0303, 0xd743,
    0x0302, 0x001f,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x40ce,
    0x0302, 0x001b,
    0x0303, 0x0367,
    0x0302, 0x0097,
    0x0303, 0x012d,
    0x0302, 0x00a1,
    0x0303, 0x67c9,
    0x0302, 0x001c,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0340,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x6740,
    0x0302, 0x0006,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x400f,
    0x0302, 0x001f,
    0x0303, 0x03c6,
    0x0302, 0x009c,
    0x0303, 0x0309,
    0x0302, 0x002b,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc800,
    0x0302, 0x0010,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x013a,
    0x0302, 0x0080,
    0x0303, 0xd740,
    0x0302, 0x0083,
    0x0303, 0x15a0,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x001f,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x009b,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x15a1,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x5368,
    0x0302, 0x0083,
    0x0303, 0x15a2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x1090,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xe0c0,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x001b,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x67c8,
    0x0302, 0x009c,
    0x0303, 0x036a,
    0x0302, 0x0011,
    0x0303, 0x0369,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x108f,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6769,
    0x0302, 0x0019,
    0x0303, 0x0f6a,
    0x0302, 0x0082,
    0x0303, 0x03c2,
    0x0302, 0x001c,
    0x0303, 0x036a,
    0x0302, 0x0099,
    0x0303, 0x0f6a,
    0x0302, 0x0082,
    0x0303, 0x68c3,
    0x0302, 0x001c,
    0x0303, 0x036a,
    0x0302, 0x0099,
    0x0303, 0x0f6a,
    0x0302, 0x0082,
    0x0303, 0x01db,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x0194,
    0x0302, 0x003a,
    0x0303, 0x036a,
    0x0302, 0x0017,
    0x0303, 0x016d,
    0x0302, 0x0041,
    0x0303, 0xc767,
    0x0302, 0x0003,
    0x0303, 0x017c,
    0x0302, 0x0000,
    0x0303, 0x01ae,
    0x0302, 0x003a,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x015c,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0017,
    0x0303, 0x0174,
    0x0302, 0x00c1,
    0x0303, 0xc667,
    0x0302, 0x0083,
    0x0303, 0x017c,
    0x0302, 0x0000,
    0x0303, 0x0181,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x013c,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0017,
    0x0303, 0x017b,
    0x0302, 0x00c1,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0x017c,
    0x0302, 0x0000,
    0x0303, 0xc467,
    0x0302, 0x0003,
    0x0303, 0x67c4,
    0x0302, 0x009c,
    0x0303, 0x03c8,
    0x0302, 0x0091,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0368,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x1010,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc653,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x9a33,
    0x0302, 0x000c,
    0x0303, 0x9d29,
    0x0302, 0x0009,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0808,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x4105,
    0x0302, 0x00af,
    0x0303, 0x1010,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc753,
    0x0302, 0x0083,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1580,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1581,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1588,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x15a4,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x0f00,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0404,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0202,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x01cc,
    0x0302, 0x0080,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x01d3,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01cc,
    0x0302, 0x0080,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xd568,
    0x0302, 0x0003,
    0x0303, 0x01da,
    0x0302, 0x0000,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x6d68,
    0x0302, 0x0003,
    0x0303, 0x6700,
    0x0302, 0x0010,
    0x0303, 0x0387,
    0x0302, 0x001b,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0384,
    0x0302, 0x0011,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0010,
    0x0303, 0x0375,
    0x0302, 0x009b,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x01df,
    0x0302, 0x0021,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0387,
    0x0302, 0x0011,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6204,
    0x0302, 0x0084,
    0x0303, 0x6207,
    0x0302, 0x0003,
    0x0303, 0xc062,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x9917,
    0x0302, 0x0028,
    0x0303, 0xb603,
    0x0302, 0x00ab,
    0x0303, 0x9982,
    0x0302, 0x002b,
    0x0303, 0x010f,
    0x0302, 0x0080,
    0x0303, 0xb60f,
    0x0302, 0x001f,
    0x0303, 0x0023,
    0x0302, 0x0080,
    0x0303, 0x000b,
    0x0302, 0x0080,
    0x0303, 0x9b03,
    0x0302, 0x002f,
    0x0303, 0x9d07,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0xe801,
    0x0302, 0x001f,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x1000,
    0x0302, 0x00da,
    0x0303, 0x03b6,
    0x0302, 0x009b,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x000b,
    0x0302, 0x0080,
    0x0303, 0x00d0,
    0x0302, 0x0080,
    0x0303, 0x030c,
    0x0302, 0x0028,
    0x0303, 0x030d,
    0x0302, 0x0029,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x030f,
    0x0302, 0x0028,
    0x0303, 0x030f,
    0x0302, 0x00a9,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x030a,
    0x0302, 0x00a9,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x0305,
    0x0302, 0x00a9,
    0x0303, 0x000d,
    0x0302, 0x0080,
    0x0303, 0x00cb,
    0x0302, 0x0080,
    0x0303, 0x0093,
    0x0302, 0x0000,
    0x0303, 0x0056,
    0x0302, 0x0000,
    0x0303, 0x00c9,
    0x0302, 0x0000,
    0x0303, 0x00b6,
    0x0302, 0x0080,
    0x0303, 0x00a6,
    0x0302, 0x0000,
    0x0303, 0x0071,
    0x0302, 0x0000,
    0x0303, 0x0075,
    0x0302, 0x0080,
    0x0303, 0x6a03,
    0x0302, 0x0028,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x003b,
    0x0302, 0x0080,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0x6753,
    0x0302, 0x0083,
    0x0303, 0x9b02,
    0x0302, 0x00ac,
    0x0303, 0x6853,
    0x0302, 0x0083,
    0x0303, 0x1023,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x9b0f,
    0x0302, 0x002c,
    0x0303, 0x1082,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x684f,
    0x0302, 0x009f,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x1079,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6953,
    0x0302, 0x0003,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x107a,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x694f,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x6b04,
    0x0302, 0x0028,
    0x0303, 0x0054,
    0x0302, 0x00ba,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0101,
    0x0302, 0x0000,
    0x0303, 0x7507,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x005c,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0xc7ee,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0xc06a,
    0x0302, 0x0003,
    0x0303, 0x9c6b,
    0x0302, 0x0083,
    0x0303, 0x3034,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x3039,
    0x0302, 0x003a,
    0x0303, 0x000b,
    0x0302, 0x00da,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xc3c3,
    0x0302, 0x003a,
    0x0303, 0x00c3,
    0x0302, 0x005a,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x0069,
    0x0302, 0x003a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0037,
    0x0302, 0x0080,
    0x0303, 0xc19c,
    0x0302, 0x0083,
    0x0303, 0xc099,
    0x0302, 0x0003,
    0x0303, 0x1804,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x8300,
    0x0302, 0x000b,
    0x0303, 0x0012,
    0x0302, 0x0000,
    0x0303, 0x1892,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5053,
    0x0302, 0x0003,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x007b,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0xc7ee,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0xf099,
    0x0302, 0x0003,
    0x0303, 0xc16a,
    0x0302, 0x0083,
    0x0303, 0x9c0f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x009d,
    0x0303, 0x036b,
    0x0302, 0x0083,
    0x0303, 0xc29c,
    0x0302, 0x0083,
    0x0303, 0x3005,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x3009,
    0x0302, 0x003a,
    0x0303, 0x000c,
    0x0302, 0x005a,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xe1e1,
    0x0302, 0x003a,
    0x0303, 0x0021,
    0x0302, 0x005a,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x008c,
    0x0302, 0x00ba,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0037,
    0x0302, 0x0080,
    0x0303, 0xffff,
    0x0302, 0x00fa,
    0x0303, 0x03e2,
    0x0302, 0x001b,
    0x0303, 0x0092,
    0x0302, 0x00a1,
    0x0303, 0x0d80,
    0x0302, 0x00fa,
    0x0303, 0x03e2,
    0x0302, 0x0011,
    0x0303, 0x03e2,
    0x0302, 0x0003,
    0x0303, 0x0012,
    0x0302, 0x0000,
    0x0303, 0x0065,
    0x0302, 0x003a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x1892,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5153,
    0x0302, 0x0083,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x1821,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x00e4,
    0x0302, 0x0060,
    0x0303, 0xd500,
    0x0302, 0x0010,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x182a,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x9a4f,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x0012,
    0x0302, 0x0000,
    0x0303, 0xc099,
    0x0302, 0x0003,
    0x0303, 0x9b0b,
    0x0302, 0x002d,
    0x0303, 0x1821,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x00e4,
    0x0302, 0x0060,
    0x0303, 0xd553,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x182a,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xcb53,
    0x0302, 0x0083,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0xc06a,
    0x0302, 0x0003,
    0x0303, 0xc06b,
    0x0302, 0x0083,
    0x0303, 0xc89c,
    0x0302, 0x0083,
    0x0303, 0x0081,
    0x0302, 0x0000,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x9c0f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x036b,
    0x0302, 0x0083,
    0x0303, 0x3026,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x3029,
    0x0302, 0x00ba,
    0x0303, 0x000e,
    0x0302, 0x00da,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xb4b4,
    0x0302, 0x003a,
    0x0303, 0x00b4,
    0x0302, 0x003a,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x00c7,
    0x0302, 0x00ba,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0037,
    0x0302, 0x0080,
    0x0303, 0xc49c,
    0x0302, 0x0083,
    0x0303, 0x0012,
    0x0302, 0x0000,
    0x0303, 0x9a6a,
    0x0302, 0x0003,
    0x0303, 0x005d,
    0x0302, 0x0080,
    0x0303, 0xd199,
    0x0302, 0x0003,
    0x0303, 0xf20f,
    0x0302, 0x001f,
    0x0303, 0xb663,
    0x0302, 0x001f,
    0x0303, 0x03f2,
    0x0302, 0x0083,
    0x0303, 0x0012,
    0x0302, 0x0000,
    0x0303, 0xf20f,
    0x0302, 0x001f,
    0x0303, 0x9903,
    0x0302, 0x009f,
    0x0303, 0x03f2,
    0x0302, 0x0083,
    0x0303, 0xc099,
    0x0302, 0x0003,
    0x0303, 0xf204,
    0x0302, 0x002b,
    0x0303, 0x00de,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x0075,
    0x0302, 0x0080,
    0x0303, 0x00db,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x0056,
    0x0302, 0x0000,
    0x0303, 0x00de,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x00c9,
    0x0302, 0x0000,
    0x0303, 0x000b,
    0x0302, 0x0080,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x00e7,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x00ee,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x00e7,
    0x0302, 0x0000,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x6a0f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x1033,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x00e4,
    0x0302, 0x0060,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0x5853,
    0x0302, 0x009b,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x00df,
    0x0302, 0x00e0,
    0x0303, 0xf906,
    0x0302, 0x003a,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x00fa,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc7ee,
    0x0302, 0x0083,
    0x0303, 0x9905,
    0x0302, 0x00aa,
    0x0303, 0x9947,
    0x0302, 0x001b,
    0x0303, 0x011c,
    0x0302, 0x00a0,
    0x0303, 0x03c7,
    0x0302, 0x009b,
    0x0303, 0x011c,
    0x0302, 0x0021,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc100,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x8004,
    0x0302, 0x0088,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0x0121,
    0x0302, 0x0080,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0xe80f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0xee67,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8000,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8001,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8002,
    0x1222, 0x0005,
    0x1221, 0x4818,
    0x1220, 0x8003,
    0x1222, 0x000b,
    0x1221, 0x4818,
    0x1220, 0x8004,
    0x1222, 0x0017,
    0x1221, 0x4820,
    0x1220, 0x8005,
    0x1222, 0x001f,
    0x1221, 0x0000,
    0x1220, 0x8006,
    0x1222, 0x0010,
    0x1221, 0x0000,
    0x1220, 0x8007,
    0x1222, 0x0010,
    0x1221, 0x0000,
    0x1220, 0x8008,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8009,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800a,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800b,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800c,
    0x1222, 0x0028,
    0x1221, 0x0000,
    0x1220, 0x800d,
    0x1222, 0x0001,
    0x1221, 0x0000,
    0x1220, 0x800e,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800f,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8010,
    0x1222, 0x0a60,
    0x1221, 0x8000,
    0x1220, 0x8011,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8012,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8013,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8014,
    0x1222, 0x001e,
    0x1221, 0x0000,
    0x1220, 0x8015,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8016,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8017,
    0x1222, 0x7fff,
    0x1221, 0x0000,
    0x1220, 0x8018,
    0x1222, 0x0003,
    0x1221, 0x0000,
    0x1220, 0x8019,
    0x1222, 0x0003,
    0x1221, 0x0000,
    0x1220, 0x801a,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x801b,
    0x1222, 0x0003,
    0x1221, 0x0000,
    0x1220, 0x801c,
    0x1222, 0x0400,
    0x1221, 0x0000,
    0x1220, 0x801d,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x801e,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x801f,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8020,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8021,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8022,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8023,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8024,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8025,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8026,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8027,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8028,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8029,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x802a,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x802b,
    0x1222, 0x0f70,
    0x1221, 0x8000,
    0x1220, 0x802c,
    0x1222, 0x0100,
    0x1221, 0x0000,
    0x1220, 0x802d,
    0x1222, 0x007f,
    0x1221, 0x0000,
    0x1220, 0x802e,
    0x1222, 0x0040,
    0x1221, 0x8000,
    0x1220, 0x802f,
    0x1222, 0x0001,
    0x1221, 0x0000,
    0x1220, 0x8030,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8031,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8032,
    0x1222, 0x00fa,
    0x1221, 0x0000,
    0x1220, 0x8033,
    0x1222, 0x00d2,
    0x1221, 0x0000,
    0x1220, 0x8034,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8035,
    0x1222, 0x02aa,
    0x1221, 0x0000,
    0x1220, 0x8036,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8037,
    0x1222, 0x0014,
    0x1221, 0x8000,
    0x1220, 0x8038,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8039,
    0x1222, 0x47ab,
    0x1221, 0x0000,
    0x1220, 0x803a,
    0x1222, 0x0554,
    0x1221, 0x0000,
    0x1220, 0x803b,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x803c,
    0x1222, 0x03ff,
    0x1221, 0x0000,
    0x1220, 0x803d,
    0x1222, 0x1fff,
    0x1221, 0x8000,
    0x1220, 0x803e,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x803f,
    0x102f, 0xc0f0,
    0x1000, 0x0000,
    0x100b, 0xf182,
    0x1001, 0x0000,
    0x1007, 0x0004,
    0x1228, 0x0000,
    0x1235, 0x0000,
    0x1a35, 0x0000,
    0x1327, 0x0000,
    0x132b, 0x0000,
    0x0003, 0x0001,
    0x0004, 0x0001,
    0x0005, 0x0001,
    0x0006, 0x0001,
    0x0007, 0x0001,
    0x0301, 0x0000,
    0x1320, 0x0000,
    0x1324, 0x0000,
    0x1328, 0x0000,
    0x0017, 0x0040,
    0x1238, 0x0003,
    0x1a38, 0x0003,
    0x1249, 0x0001,
    0x1343, 0x0006,
    0x1262, 0x007f,
    0x1263, 0x007f,
    0x1264, 0x007f,
    0x1248, 0x8100,
    0x1247, 0x8010,
    0x1268, 0x0002,
    0x1282, 0x0005,
    0x1288, 0x3000,
    0x124c, 0x8001,
    0x1298, 0x0003,
    0x1245, 0x8c0f,
    0x10aa, 0xff5d,
    0x1265, 0x001e,
    0x1027, 0x00dd,
    0x12b1, 0x0000,
    0x1a98, 0x0003,
    0x18ae, 0x0441,
    0x18a1, 0x0004,
    0x18a7, 0xdfff,
    0x18a6, 0x000d,
    0x1a45, 0x8c0f,
    0x18aa, 0xff5d,
    0x1a34, 0x0002,
    0x1a5e, 0x0000,
    0x1a5f, 0x0700,
    0x1a49, 0x0001,
    0x1b43, 0x0006,
    0x1a65, 0x001e,
    0x1a62, 0x007f,
    0x1a63, 0x007f,
    0x1a64, 0x007f,
    0x1a48, 0x8100,
    0x1a47, 0x8010,
    0x1a68, 0x0002,
    0x1a82, 0x0014,
    0x1a4c, 0x8001,
    0x1827, 0x00dd,
    0x1a35, 0x01f7,
    0x1ab1, 0x0000,
    0x0017, 0x0000,
    0x000a, 0x1557,
    0x0009, 0x2015,
    0x0008, 0x0702,
    0x0005, 0x0003,
    0x0007, 0x0000,
    0x0011, 0x0000,
    0x0014, 0x25e0,
    0x0017, 0x0000,
};

unsigned int cs4224_kr_ucode_image_length = sizeof(cs4224_kr_ucode_image)/sizeof(cs4224_kr_ucode_image[0]);

#endif /* !CS_SKIP_UCODE_DOWNLOAD */

/** @file cs4224_fc_ucode_image.c
 ****************************************************************************
 *
 * @brief
 *    This module contains the microcode to the downloaded to the
 *    device.
 *
 *****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ****************************************************************************/
  
#if !defined(CS_SKIP_UCODE_DOWNLOAD)
/* The following array contains the microcode image to download
 * to the device. It consists of a series of register writes
 * in the format:
 *    address, data
 */
unsigned short cs4224_fc_ucode_image[] = {
    /* Addr, Data */
    0x0011, 0x0001,
    0x0017, 0x8080,
    0x1091, 0x0001,
    0x1007, 0x8004,
    0x1225, 0x0008,
    0x1238, 0x0000,
    0x0301, 0x9000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7c0d,
    0x0302, 0x0084,
    0x0303, 0x7c02,
    0x0302, 0x0088,
    0x0303, 0x010d,
    0x0302, 0x0060,
    0x0303, 0x7c02,
    0x0302, 0x0009,
    0x0303, 0x019f,
    0x0302, 0x00e0,
    0x0303, 0x7c02,
    0x0302, 0x008d,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x7c02,
    0x0302, 0x00af,
    0x0303, 0x01ea,
    0x0302, 0x0060,
    0x0303, 0x7c02,
    0x0302, 0x002e,
    0x0303, 0x016d,
    0x0302, 0x0060,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x0180,
    0x0302, 0x0060,
    0x0303, 0x016d,
    0x0302, 0x0060,
    0x0303, 0xe805,
    0x0302, 0x008d,
    0x0303, 0x4804,
    0x0302, 0x008c,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0x001b,
    0x0302, 0x0000,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x6893,
    0x0302, 0x0083,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x9002,
    0x0302, 0x008c,
    0x0303, 0x000f,
    0x0302, 0x003a,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x9002,
    0x0302, 0x008a,
    0x0303, 0x6793,
    0x0302, 0x0083,
    0x0303, 0x9006,
    0x0302, 0x0009,
    0x0303, 0x0708,
    0x0302, 0x003a,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x050b,
    0x0302, 0x00ba,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x002d,
    0x0302, 0x0000,
    0x0303, 0x9003,
    0x0302, 0x0028,
    0x0303, 0xe2f5,
    0x0302, 0x0003,
    0x0303, 0x002d,
    0x0302, 0x0000,
    0x0303, 0xc8f5,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xe605,
    0x0302, 0x002f,
    0x0303, 0xe6f5,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xe643,
    0x0302, 0x009f,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0xe7f9,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x037a,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x003c,
    0x0302, 0x0041,
    0x0303, 0x7a5f,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0045,
    0x0302, 0x0080,
    0x0303, 0x7b75,
    0x0302, 0x0097,
    0x0303, 0x004e,
    0x0302, 0x0041,
    0x0303, 0xf970,
    0x0302, 0x001c,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x757b,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x7b5f,
    0x0302, 0x0099,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x003c,
    0x0302, 0x0000,
    0x0303, 0x7b75,
    0x0302, 0x0097,
    0x0303, 0x004e,
    0x0302, 0x0041,
    0x0303, 0xf970,
    0x0302, 0x009d,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x757b,
    0x0302, 0x009e,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x5f7b,
    0x0302, 0x001e,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x0045,
    0x0302, 0x0080,
    0x0303, 0xcc60,
    0x0302, 0x0003,
    0x0303, 0xdb68,
    0x0302, 0x0083,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x03db,
    0x0302, 0x0011,
    0x0303, 0x03db,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x000f,
    0x0302, 0x005a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0xc375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf467,
    0x0302, 0x0003,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x0056,
    0x0302, 0x0041,
    0x0303, 0x0017,
    0x0302, 0x009a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf40f,
    0x0302, 0x001f,
    0x0303, 0x2267,
    0x0302, 0x0002,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x005b,
    0x0302, 0x00c1,
    0x0303, 0x002b,
    0x0302, 0x009a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf472,
    0x0302, 0x0083,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x0062,
    0x0302, 0x00c1,
    0x0303, 0x003f,
    0x0302, 0x009a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x00f6,
    0x0302, 0x0060,
    0x0303, 0xf40f,
    0x0302, 0x001f,
    0x0303, 0x2272,
    0x0302, 0x0082,
    0x0303, 0x4df4,
    0x0302, 0x0097,
    0x0303, 0x0068,
    0x0302, 0x00c1,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x4f75,
    0x0302, 0x0082,
    0x0303, 0x7567,
    0x0302, 0x0011,
    0x0303, 0x03ec,
    0x0302, 0x0083,
    0x0303, 0x68db,
    0x0302, 0x0083,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0x00e6,
    0x0302, 0x00ba,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0xcffe,
    0x0302, 0x0083,
    0x0303, 0xc2fd,
    0x0302, 0x0003,
    0x0303, 0x9015,
    0x0302, 0x000b,
    0x0303, 0x780f,
    0x0302, 0x009f,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0x0083,
    0x0302, 0x0080,
    0x0303, 0xfd03,
    0x0302, 0x0004,
    0x0303, 0xc0fd,
    0x0302, 0x0083,
    0x0303, 0x0083,
    0x0302, 0x0080,
    0x0303, 0xfe70,
    0x0302, 0x001d,
    0x0303, 0x03fe,
    0x0302, 0x0083,
    0x0303, 0xc1ae,
    0x0302, 0x0003,
    0x0303, 0xc2ae,
    0x0302, 0x0003,
    0x0303, 0x6f0f,
    0x0302, 0x009f,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0xc0ae,
    0x0302, 0x0083,
    0x0303, 0xb100,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01f4,
    0x0302, 0x003a,
    0x0303, 0xb003,
    0x0302, 0x0097,
    0x0303, 0xfe02,
    0x0302, 0x0009,
    0x0303, 0x007e,
    0x0302, 0x0041,
    0x0303, 0x00c0,
    0x0302, 0x003a,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0xc0ea,
    0x0302, 0x0083,
    0x0303, 0x8403,
    0x0302, 0x008d,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x01ea,
    0x0302, 0x0060,
    0x0303, 0xe805,
    0x0302, 0x000a,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x9000,
    0x0302, 0x005a,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0x9000,
    0x0302, 0x0018,
    0x0303, 0x0390,
    0x0302, 0x0003,
    0x0303, 0xe812,
    0x0302, 0x0024,
    0x0303, 0xe811,
    0x0302, 0x00aa,
    0x0303, 0xe809,
    0x0302, 0x0009,
    0x0303, 0x810f,
    0x0302, 0x009f,
    0x0303, 0x037d,
    0x0302, 0x001b,
    0x0303, 0x0370,
    0x0302, 0x001c,
    0x0303, 0x0370,
    0x0302, 0x0019,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x7d81,
    0x0302, 0x001b,
    0x0303, 0x037d,
    0x0302, 0x0017,
    0x0303, 0x009f,
    0x0302, 0x0021,
    0x0303, 0x800f,
    0x0302, 0x00da,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0x810f,
    0x0302, 0x009f,
    0x0303, 0x037d,
    0x0302, 0x001b,
    0x0303, 0x0370,
    0x0302, 0x009d,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x8184,
    0x0302, 0x0028,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x07d0,
    0x0302, 0x003a,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0x9c40,
    0x0302, 0x00ba,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x0106,
    0x0302, 0x00e0,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x00c0,
    0x0302, 0x009a,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0xd294,
    0x0302, 0x0083,
    0x0303, 0xd295,
    0x0302, 0x0003,
    0x0303, 0xb2ef,
    0x0302, 0x0083,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x01ea,
    0x0302, 0x0060,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xc0e1,
    0x0302, 0x0003,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xc3df,
    0x0302, 0x0083,
    0x0303, 0xe803,
    0x0302, 0x0003,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0xc04c,
    0x0302, 0x0083,
    0x0303, 0x0053,
    0x0302, 0x003a,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x00d6,
    0x0302, 0x00c1,
    0x0303, 0x7572,
    0x0302, 0x0019,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xdf00,
    0x0302, 0x0098,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0x00ce,
    0x0302, 0x0080,
    0x0303, 0xe803,
    0x0302, 0x0003,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03cc,
    0x0302, 0x001b,
    0x0303, 0x03df,
    0x0302, 0x0097,
    0x0303, 0x00dc,
    0x0302, 0x00c1,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0xe50f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0xdf03,
    0x0302, 0x009e,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0xe802,
    0x0302, 0x008f,
    0x0303, 0x00e8,
    0x0302, 0x0000,
    0x0303, 0x9003,
    0x0302, 0x008b,
    0x0303, 0xdc0f,
    0x0302, 0x001f,
    0x0303, 0x00e7,
    0x0302, 0x0000,
    0x0303, 0x0021,
    0x0302, 0x003a,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0xe36e,
    0x0302, 0x001b,
    0x0303, 0x03c5,
    0x0302, 0x009c,
    0x0303, 0x035d,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf663,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf501,
    0x0302, 0x001f,
    0x0303, 0x0375,
    0x0302, 0x0019,
    0x0303, 0x757f,
    0x0302, 0x0003,
    0x0303, 0xc0eb,
    0x0302, 0x0003,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x0180,
    0x0302, 0x0060,
    0x0303, 0xcbf4,
    0x0302, 0x0003,
    0x0303, 0x7580,
    0x0302, 0x0003,
    0x0303, 0xf400,
    0x0302, 0x0098,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x4dd1,
    0x0302, 0x0011,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x8003,
    0x0302, 0x00a4,
    0x0303, 0x838a,
    0x0302, 0x002b,
    0x0303, 0x0105,
    0x0302, 0x0080,
    0x0303, 0x838c,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xe821,
    0x0302, 0x009f,
    0x0303, 0x030c,
    0x0302, 0x008b,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x4c00,
    0x0302, 0x00ba,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x011a,
    0x0302, 0x0041,
    0x0303, 0x4e00,
    0x0302, 0x003a,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x011b,
    0x0302, 0x00c1,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x03e6,
    0x0302, 0x0083,
    0x0303, 0x011b,
    0x0302, 0x0080,
    0x0303, 0xc0e6,
    0x0302, 0x0083,
    0x0303, 0xc071,
    0x0302, 0x0003,
    0x0303, 0xc06a,
    0x0302, 0x0003,
    0x0303, 0xc06b,
    0x0302, 0x0083,
    0x0303, 0xc07f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xe977,
    0x0302, 0x0083,
    0x0303, 0xc16a,
    0x0302, 0x0083,
    0x0303, 0xc17f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc26a,
    0x0302, 0x0083,
    0x0303, 0xc27f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc36a,
    0x0302, 0x0003,
    0x0303, 0xc37f,
    0x0302, 0x0097,
    0x0303, 0xc0e6,
    0x0302, 0x0083,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc16b,
    0x0302, 0x0003,
    0x0303, 0xc171,
    0x0302, 0x0083,
    0x0303, 0xc47f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc46a,
    0x0302, 0x0083,
    0x0303, 0xc57f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc26b,
    0x0302, 0x0003,
    0x0303, 0xc67f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc56a,
    0x0302, 0x0003,
    0x0303, 0xc77f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc36b,
    0x0302, 0x0083,
    0x0303, 0xc87f,
    0x0302, 0x0017,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc66a,
    0x0302, 0x0003,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc46b,
    0x0302, 0x0003,
    0x0303, 0x000a,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc76a,
    0x0302, 0x0083,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc56b,
    0x0302, 0x0083,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc86a,
    0x0302, 0x0083,
    0x0303, 0x000d,
    0x0302, 0x00ba,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc66b,
    0x0302, 0x0083,
    0x0303, 0x000e,
    0x0302, 0x00ba,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x000f,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0xc76b,
    0x0302, 0x0003,
    0x0303, 0xc97f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0x000a,
    0x0302, 0x003a,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x0011,
    0x0302, 0x003a,
    0x0303, 0x037f,
    0x0302, 0x0097,
    0x0303, 0x0162,
    0x0302, 0x00a0,
    0x0303, 0x000b,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x6ac8,
    0x0302, 0x001c,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x778b,
    0x0302, 0x0011,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x6bc8,
    0x0302, 0x009c,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0xcc0f,
    0x0302, 0x009f,
    0x0303, 0x03f6,
    0x0302, 0x001b,
    0x0303, 0x038b,
    0x0302, 0x0011,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xb612,
    0x0302, 0x002c,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0xb60f,
    0x0302, 0x001f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0302,
    0x0302, 0x002f,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x0055,
    0x0302, 0x003a,
    0x0303, 0x03b8,
    0x0302, 0x001b,
    0x0303, 0x0178,
    0x0302, 0x0020,
    0x0303, 0x1891,
    0x0302, 0x001a,
    0x0303, 0x0179,
    0x0302, 0x0000,
    0x0303, 0x1091,
    0x0302, 0x009a,
    0x0303, 0x68b5,
    0x0302, 0x0003,
    0x0303, 0x03b4,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb591,
    0x0302, 0x00aa,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0007,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0027,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0067,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x00e7,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x01e7,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x7e86,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x00e7,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0067,
    0x0302, 0x001a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0027,
    0x0302, 0x009a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0xc781,
    0x0302, 0x0083,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xac0a,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb211,
    0x0302, 0x0084,
    0x0303, 0x6eac,
    0x0302, 0x009b,
    0x0303, 0xc803,
    0x0302, 0x0097,
    0x0303, 0x01b2,
    0x0302, 0x00c1,
    0x0303, 0xb20f,
    0x0302, 0x009f,
    0x0303, 0x0372,
    0x0302, 0x001e,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01b1,
    0x0302, 0x0080,
    0x0303, 0xb20f,
    0x0302, 0x009f,
    0x0303, 0x03cf,
    0x0302, 0x0017,
    0x0303, 0x01b2,
    0x0302, 0x0020,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x03ac,
    0x0302, 0x0017,
    0x0303, 0x01b2,
    0x0302, 0x00c1,
    0x0303, 0xb200,
    0x0302, 0x0018,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x6d95,
    0x0302, 0x0083,
    0x0303, 0xb275,
    0x0302, 0x0083,
    0x0303, 0x73b2,
    0x0302, 0x0097,
    0x0303, 0x01c7,
    0x0302, 0x0041,
    0x0303, 0xfe09,
    0x0302, 0x000e,
    0x0303, 0xfd04,
    0x0302, 0x0084,
    0x0303, 0xcc60,
    0x0302, 0x0017,
    0x0303, 0x01c3,
    0x0302, 0x00c1,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xc2fd,
    0x0302, 0x0003,
    0x0303, 0x75cb,
    0x0302, 0x001e,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xfe70,
    0x0302, 0x009c,
    0x0303, 0x03fe,
    0x0302, 0x0083,
    0x0303, 0x75c8,
    0x0302, 0x001e,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0x6000,
    0x0302, 0x0018,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0360,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xcb75,
    0x0302, 0x0017,
    0x0303, 0x01dd,
    0x0302, 0x00c1,
    0x0303, 0x740f,
    0x0302, 0x009f,
    0x0303, 0xfe02,
    0x0302, 0x008e,
    0x0303, 0x03c9,
    0x0302, 0x001e,
    0x0303, 0xb203,
    0x0302, 0x0017,
    0x0303, 0x01e8,
    0x0302, 0x00c1,
    0x0303, 0x6005,
    0x0302, 0x0084,
    0x0303, 0x60c1,
    0x0302, 0x009e,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0360,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xfd05,
    0x0302, 0x0089,
    0x0303, 0xc0fd,
    0x0302, 0x0083,
    0x0303, 0xcb75,
    0x0302, 0x0099,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x01e8,
    0x0302, 0x0080,
    0x0303, 0xfe10,
    0x0302, 0x0009,
    0x0303, 0xfe70,
    0x0302, 0x001d,
    0x0303, 0x03fe,
    0x0302, 0x0083,
    0x0303, 0x75c8,
    0x0302, 0x0099,
    0x0303, 0x03b2,
    0x0302, 0x0003,
    0x0303, 0x000e,
    0x0302, 0x001a,
    0x0303, 0x03b2,
    0x0302, 0x0017,
    0x0303, 0x01e2,
    0x0302, 0x00c1,
    0x0303, 0x6008,
    0x0302, 0x0004,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0x75c5,
    0x0302, 0x0097,
    0x0303, 0x01e8,
    0x0302, 0x00c1,
    0x0303, 0x00d0,
    0x0302, 0x001a,
    0x0303, 0x6003,
    0x0302, 0x0017,
    0x0303, 0x01cf,
    0x0302, 0x00c1,
    0x0303, 0x6098,
    0x0302, 0x0004,
    0x0303, 0xb2ef,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x01ec,
    0x0302, 0x0021,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7c02,
    0x0302, 0x0088,
    0x0303, 0x0085,
    0x0302, 0x0080,
    0x0303, 0x7c02,
    0x0302, 0x0009,
    0x0303, 0x005d,
    0x0302, 0x0080,
    0x0303, 0x7c02,
    0x0302, 0x008d,
    0x0303, 0x004d,
    0x0302, 0x0000,
    0x0303, 0x7c02,
    0x0302, 0x00af,
    0x0303, 0x01a6,
    0x0302, 0x0080,
    0x0303, 0x7c02,
    0x0302, 0x002e,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0xb606,
    0x0302, 0x002f,
    0x0303, 0x4000,
    0x0302, 0x007a,
    0x0303, 0x037c,
    0x0302, 0x0083,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xea19,
    0x0302, 0x0088,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec01,
    0x0302, 0x009f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x009e,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec61,
    0x0302, 0x009f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x0017,
    0x0302, 0x003a,
    0x0303, 0x0380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x0019,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0008,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0x0047,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec41,
    0x0302, 0x001f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x002b,
    0x0302, 0x003a,
    0x0303, 0x0380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x0019,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xec21,
    0x0302, 0x001f,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0380,
    0x0302, 0x0083,
    0x0303, 0xaaa0,
    0x0302, 0x003a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0xf10f,
    0x0302, 0x001f,
    0x0303, 0xf403,
    0x0302, 0x009e,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0008,
    0x0302, 0x00ba,
    0x0303, 0x01df,
    0x0302, 0x0060,
    0x0303, 0xeb07,
    0x0302, 0x002f,
    0x0303, 0x8306,
    0x0302, 0x000d,
    0x0303, 0xe805,
    0x0302, 0x0009,
    0x0303, 0xcb7c,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0x8306,
    0x0302, 0x00a4,
    0x0303, 0xea6d,
    0x0302, 0x0017,
    0x0303, 0x0055,
    0x0302, 0x0041,
    0x0303, 0xc075,
    0x0302, 0x0083,
    0x0303, 0xc872,
    0x0302, 0x0083,
    0x0303, 0x0058,
    0x0302, 0x0080,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xc172,
    0x0302, 0x0083,
    0x0303, 0x75ea,
    0x0302, 0x001b,
    0x0303, 0x005d,
    0x0302, 0x00a1,
    0x0303, 0xc27c,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x007a,
    0x0302, 0x00a1,
    0x0303, 0xd16e,
    0x0302, 0x0091,
    0x0303, 0xeb03,
    0x0302, 0x001b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x035f,
    0x0302, 0x001e,
    0x0303, 0x0072,
    0x0302, 0x0041,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x5f03,
    0x0302, 0x001e,
    0x0303, 0x7b03,
    0x0302, 0x0017,
    0x0303, 0x007a,
    0x0302, 0x00c1,
    0x0303, 0xf970,
    0x0302, 0x009d,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x5f7b,
    0x0302, 0x001e,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x01ef,
    0x0302, 0x0060,
    0x0303, 0x75eb,
    0x0302, 0x0083,
    0x0303, 0x007a,
    0x0302, 0x0080,
    0x0303, 0x7b03,
    0x0302, 0x0017,
    0x0303, 0x007a,
    0x0302, 0x00c1,
    0x0303, 0xf970,
    0x0302, 0x001c,
    0x0303, 0x03f9,
    0x0302, 0x0003,
    0x0303, 0x7b5f,
    0x0302, 0x0099,
    0x0303, 0x035f,
    0x0302, 0x0003,
    0x0303, 0x01ef,
    0x0302, 0x0060,
    0x0303, 0x75eb,
    0x0302, 0x0083,
    0x0303, 0xe651,
    0x0302, 0x002b,
    0x0303, 0x00ff,
    0x0302, 0x003a,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x0101,
    0x0302, 0x0021,
    0x0303, 0xc071,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf501,
    0x0302, 0x001f,
    0x0303, 0x0377,
    0x0302, 0x0003,
    0x0303, 0xc17c,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf601,
    0x0302, 0x001f,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdc43,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0xa96e,
    0x0302, 0x009b,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x009c,
    0x0302, 0x0041,
    0x0303, 0xa908,
    0x0302, 0x00ab,
    0x0303, 0x8b0c,
    0x0302, 0x0084,
    0x0303, 0x0006,
    0x0302, 0x009a,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x009c,
    0x0302, 0x0041,
    0x0303, 0xf670,
    0x0302, 0x009e,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x009c,
    0x0302, 0x0000,
    0x0303, 0x8b0f,
    0x0302, 0x009f,
    0x0303, 0xcc03,
    0x0302, 0x0017,
    0x0303, 0x009c,
    0x0302, 0x00a0,
    0x0303, 0xf600,
    0x0302, 0x0018,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0xcb0f,
    0x0302, 0x001f,
    0x0303, 0x03ef,
    0x0302, 0x0097,
    0x0303, 0x00a5,
    0x0302, 0x0041,
    0x0303, 0x0008,
    0x0302, 0x001a,
    0x0303, 0x03e9,
    0x0302, 0x0097,
    0x0303, 0x00af,
    0x0302, 0x0041,
    0x0303, 0xe970,
    0x0302, 0x001e,
    0x0303, 0x03e9,
    0x0302, 0x0083,
    0x0303, 0x00af,
    0x0302, 0x0000,
    0x0303, 0xc90f,
    0x0302, 0x009f,
    0x0303, 0xef03,
    0x0302, 0x0097,
    0x0303, 0x00af,
    0x0302, 0x0041,
    0x0303, 0x000f,
    0x0302, 0x009a,
    0x0303, 0x03e2,
    0x0302, 0x001b,
    0x0303, 0xe903,
    0x0302, 0x0097,
    0x0303, 0x00af,
    0x0302, 0x0041,
    0x0303, 0xe900,
    0x0302, 0x0098,
    0x0303, 0x03e9,
    0x0302, 0x0083,
    0x0303, 0x00c5,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf563,
    0x0302, 0x009f,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xed07,
    0x0302, 0x0004,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde03,
    0x0302, 0x0006,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0097,
    0x0303, 0x00be,
    0x0302, 0x0041,
    0x0303, 0xe977,
    0x0302, 0x0097,
    0x0303, 0x00cb,
    0x0302, 0x0020,
    0x0303, 0xf570,
    0x0302, 0x009e,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x00cb,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde43,
    0x0302, 0x001f,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x6103,
    0x0302, 0x0097,
    0x0303, 0x00cb,
    0x0302, 0x00c1,
    0x0303, 0x6807,
    0x0302, 0x0005,
    0x0303, 0xe20f,
    0x0302, 0x009f,
    0x0303, 0x03cc,
    0x0302, 0x001b,
    0x0303, 0x0377,
    0x0302, 0x0017,
    0x0303, 0x00cb,
    0x0302, 0x0020,
    0x0303, 0xf500,
    0x0302, 0x0018,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf141,
    0x0302, 0x001f,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0xeb33,
    0x0302, 0x00af,
    0x0303, 0x8332,
    0x0302, 0x008d,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xe802,
    0x0302, 0x00ad,
    0x0303, 0x00e0,
    0x0302, 0x0080,
    0x0303, 0x7971,
    0x0302, 0x009e,
    0x0303, 0x4c03,
    0x0302, 0x0019,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x7275,
    0x0302, 0x0097,
    0x0303, 0x00da,
    0x0302, 0x00c1,
    0x0303, 0x72fa,
    0x0302, 0x0003,
    0x0303, 0x00e0,
    0x0302, 0x0080,
    0x0303, 0xdc6e,
    0x0302, 0x001b,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x00df,
    0x0302, 0x00c1,
    0x0303, 0xdcfa,
    0x0302, 0x0083,
    0x0303, 0x00e0,
    0x0302, 0x0080,
    0x0303, 0x75fa,
    0x0302, 0x0083,
    0x0303, 0xeb01,
    0x0302, 0x00ae,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd75,
    0x0302, 0x0086,
    0x0303, 0xed75,
    0x0302, 0x0097,
    0x0303, 0x00f1,
    0x0302, 0x00c1,
    0x0303, 0x68c3,
    0x0302, 0x0097,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0x6eeb,
    0x0302, 0x009b,
    0x0303, 0x03c3,
    0x0302, 0x0099,
    0x0303, 0xfa03,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xfa4d,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xfa00,
    0x0302, 0x0018,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x0379,
    0x0302, 0x0083,
    0x0303, 0x0101,
    0x0302, 0x0000,
    0x0303, 0x4c10,
    0x0302, 0x0005,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd43,
    0x0302, 0x001f,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x75ed,
    0x0302, 0x0097,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0x6eeb,
    0x0302, 0x009b,
    0x0303, 0x03c2,
    0x0302, 0x009e,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xdc6e,
    0x0302, 0x001b,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0101,
    0x0302, 0x0041,
    0x0303, 0xfa70,
    0x0302, 0x009e,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x0379,
    0x0302, 0x0083,
    0x0303, 0x00ff,
    0x0302, 0x003a,
    0x0303, 0x8302,
    0x0302, 0x0024,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x0116,
    0x0302, 0x0021,
    0x0303, 0xa06e,
    0x0302, 0x009b,
    0x0303, 0xa002,
    0x0302, 0x00ab,
    0x0303, 0xc003,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0xa16e,
    0x0302, 0x001b,
    0x0303, 0xa102,
    0x0302, 0x002b,
    0x0303, 0xc003,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0019,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x0303,
    0x0302, 0x002b,
    0x0303, 0x675d,
    0x0302, 0x0099,
    0x0303, 0x035d,
    0x0302, 0x0083,
    0x0303, 0x5dc5,
    0x0302, 0x009d,
    0x0303, 0x03ed,
    0x0302, 0x0003,
    0x0303, 0x5d03,
    0x0302, 0x009e,
    0x0303, 0x035d,
    0x0302, 0x0083,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x3e00,
    0x0302, 0x00ba,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x0120,
    0x0302, 0x0041,
    0x0303, 0x4400,
    0x0302, 0x003a,
    0x0303, 0x038b,
    0x0302, 0x0017,
    0x0303, 0x0125,
    0x0302, 0x0041,
    0x0303, 0xc0e1,
    0x0302, 0x0003,
    0x0303, 0x0125,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf663,
    0x0302, 0x009f,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0x0600,
    0x0302, 0x003a,
    0x0303, 0x03e1,
    0x0302, 0x0003,
    0x0303, 0x8311,
    0x0302, 0x000d,
    0x0303, 0xe821,
    0x0302, 0x009f,
    0x0303, 0x030f,
    0x0302, 0x000a,
    0x0303, 0xec01,
    0x0302, 0x009f,
    0x0303, 0x03cb,
    0x0302, 0x009e,
    0x0303, 0x03c4,
    0x0302, 0x0019,
    0x0303, 0x01fc,
    0x0302, 0x00e0,
    0x0303, 0x780f,
    0x0302, 0x009f,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0xc1ae,
    0x0302, 0x0003,
    0x0303, 0xc2ae,
    0x0302, 0x0003,
    0x0303, 0x6dd1,
    0x0302, 0x0091,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0xc0ae,
    0x0302, 0x0083,
    0x0303, 0xb100,
    0x0302, 0x00af,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xa26e,
    0x0302, 0x001b,
    0x0303, 0xa206,
    0x0302, 0x00ab,
    0x0303, 0x03c6,
    0x0302, 0x0099,
    0x0303, 0x03c4,
    0x0302, 0x001c,
    0x0303, 0x6103,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x0080,
    0x0303, 0xc603,
    0x0302, 0x001e,
    0x0303, 0x0140,
    0x0302, 0x0041,
    0x0303, 0x0144,
    0x0302, 0x0080,
    0x0303, 0x03c4,
    0x0302, 0x001c,
    0x0303, 0x6103,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0083,
    0x0303, 0x0144,
    0x0302, 0x0080,
    0x0303, 0x61c6,
    0x0302, 0x009d,
    0x0303, 0x6103,
    0x0302, 0x009e,
    0x0303, 0x0361,
    0x0302, 0x0083,
    0x0303, 0x06ff,
    0x0302, 0x003a,
    0x0303, 0x8302,
    0x0302, 0x0024,
    0x0303, 0x01ff,
    0x0302, 0x00ba,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x0163,
    0x0302, 0x00a1,
    0x0303, 0x8302,
    0x0302, 0x0024,
    0x0303, 0xed07,
    0x0302, 0x0004,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde03,
    0x0302, 0x0006,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x0361,
    0x0302, 0x0097,
    0x0303, 0x015a,
    0x0302, 0x00c1,
    0x0303, 0x0012,
    0x0302, 0x003a,
    0x0303, 0x7f03,
    0x0302, 0x0097,
    0x0303, 0x0163,
    0x0302, 0x00c1,
    0x0303, 0x7f00,
    0x0302, 0x0098,
    0x0303, 0x037f,
    0x0302, 0x0083,
    0x0303, 0x0163,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xde43,
    0x0302, 0x001f,
    0x0303, 0x03e1,
    0x0302, 0x001e,
    0x0303, 0x03e6,
    0x0302, 0x0019,
    0x0303, 0x6103,
    0x0302, 0x0097,
    0x0303, 0x0163,
    0x0302, 0x00c1,
    0x0303, 0x7f03,
    0x0302, 0x0004,
    0x0303, 0x7f70,
    0x0302, 0x001e,
    0x0303, 0x037f,
    0x0302, 0x0083,
    0x0303, 0xea00,
    0x0302, 0x0098,
    0x0303, 0x03ea,
    0x0302, 0x0083,
    0x0303, 0xe075,
    0x0302, 0x0006,
    0x0303, 0x7503,
    0x0302, 0x0097,
    0x0303, 0x019b,
    0x0302, 0x0041,
    0x0303, 0xe803,
    0x0302, 0x000f,
    0x0303, 0xd1eb,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0000,
    0x0303, 0xeb30,
    0x0302, 0x002b,
    0x0303, 0x7dea,
    0x0302, 0x009b,
    0x0303, 0x0170,
    0x0302, 0x0021,
    0x0303, 0xfa00,
    0x0302, 0x0018,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x8305,
    0x0302, 0x000b,
    0x0303, 0x002e,
    0x0302, 0x003a,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0175,
    0x0302, 0x00a0,
    0x0303, 0x0010,
    0x0302, 0x0080,
    0x0303, 0x7dea,
    0x0302, 0x0097,
    0x0303, 0x01cf,
    0x0302, 0x00c1,
    0x0303, 0xc90f,
    0x0302, 0x009f,
    0x0303, 0xfa03,
    0x0302, 0x009c,
    0x0303, 0x03df,
    0x0302, 0x0091,
    0x0303, 0xfd02,
    0x0302, 0x0084,
    0x0303, 0x03c1,
    0x0302, 0x009e,
    0x0303, 0x03df,
    0x0302, 0x0083,
    0x0303, 0xc0ea,
    0x0302, 0x0083,
    0x0303, 0xd170,
    0x0302, 0x009d,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0xdf6e,
    0x0302, 0x001b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdf43,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x009e,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0xdc6e,
    0x0302, 0x001b,
    0x0303, 0xfa03,
    0x0302, 0x0017,
    0x0303, 0x018b,
    0x0302, 0x00c1,
    0x0303, 0xdcfa,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf141,
    0x0302, 0x001f,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x03fa,
    0x0302, 0x0017,
    0x0303, 0x0191,
    0x0302, 0x0041,
    0x0303, 0x72fa,
    0x0302, 0x0003,
    0x0303, 0xfa0f,
    0x0302, 0x009f,
    0x0303, 0x0379,
    0x0302, 0x0083,
    0x0303, 0x03eb,
    0x0302, 0x0011,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0xd294,
    0x0302, 0x0083,
    0x0303, 0xd295,
    0x0302, 0x0003,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x8001,
    0x0302, 0x005a,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x0010,
    0x0302, 0x0080,
    0x0303, 0x8334,
    0x0302, 0x008b,
    0x0303, 0x3000,
    0x0302, 0x003a,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0xe243,
    0x0302, 0x001f,
    0x0303, 0x03ea,
    0x0302, 0x0097,
    0x0303, 0x01cb,
    0x0302, 0x0041,
    0x0303, 0x8325,
    0x0302, 0x0024,
    0x0303, 0xd17c,
    0x0302, 0x0083,
    0x0303, 0xcb67,
    0x0302, 0x0003,
    0x0303, 0xc00f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0xc07c,
    0x0302, 0x0083,
    0x0303, 0xe3dd,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd75,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xdd43,
    0x0302, 0x001f,
    0x0303, 0x0375,
    0x0302, 0x0019,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x0370,
    0x0302, 0x009d,
    0x0303, 0x036e,
    0x0302, 0x009b,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x03ed,
    0x0302, 0x0017,
    0x0303, 0x01c6,
    0x0302, 0x00c1,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xe543,
    0x0302, 0x009f,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6775,
    0x0302, 0x0099,
    0x0303, 0x03ed,
    0x0302, 0x0017,
    0x0303, 0x01bf,
    0x0302, 0x0041,
    0x0303, 0x67dd,
    0x0302, 0x0019,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0x67c9,
    0x0302, 0x001c,
    0x0303, 0x03dd,
    0x0302, 0x0099,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0x01c6,
    0x0302, 0x00c1,
    0x0303, 0xed75,
    0x0302, 0x009e,
    0x0303, 0x03dd,
    0x0302, 0x0099,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0xed75,
    0x0302, 0x009e,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03dd,
    0x0302, 0x0099,
    0x0303, 0x03dd,
    0x0302, 0x0003,
    0x0303, 0xe805,
    0x0302, 0x000a,
    0x0303, 0xe804,
    0x0302, 0x00ab,
    0x0303, 0x9000,
    0x0302, 0x00fa,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0xe804,
    0x0302, 0x002a,
    0x0303, 0xe803,
    0x0302, 0x0024,
    0x0303, 0x0010,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x01d1,
    0x0302, 0x00e0,
    0x0303, 0x0391,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7886,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7695,
    0x0302, 0x0083,
    0x0303, 0x0394,
    0x0302, 0x0083,
    0x0303, 0x6f86,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xc094,
    0x0302, 0x0083,
    0x0303, 0xc095,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x8503,
    0x0302, 0x0086,
    0x0303, 0x038b,
    0x0302, 0x0003,
    0x0303, 0xc04c,
    0x0302, 0x0083,
    0x0303, 0x3213,
    0x0302, 0x003a,
    0x0303, 0x8b03,
    0x0302, 0x0017,
    0x0303, 0x01f7,
    0x0302, 0x0041,
    0x0303, 0xc24c,
    0x0302, 0x0003,
    0x0303, 0x01fb,
    0x0302, 0x0000,
    0x0303, 0x3d00,
    0x0302, 0x00ba,
    0x0303, 0x8b03,
    0x0302, 0x0017,
    0x0303, 0x01fb,
    0x0302, 0x0041,
    0x0303, 0xc14c,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xcd03,
    0x0302, 0x0019,
    0x0303, 0x0360,
    0x0302, 0x001e,
    0x0303, 0x03f4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6204,
    0x0302, 0x0084,
    0x0303, 0x6207,
    0x0302, 0x0003,
    0x0303, 0xc062,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x100e,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5383,
    0x0302, 0x0085,
    0x0303, 0x0001,
    0x0302, 0x00ba,
    0x0303, 0x9a4c,
    0x0302, 0x001f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x9b83,
    0x0302, 0x0088,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0xc064,
    0x0302, 0x0083,
    0x0303, 0x0065,
    0x0302, 0x003a,
    0x0303, 0x0381,
    0x0302, 0x0003,
    0x0303, 0x0010,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x1092,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x3d3d,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xf00f,
    0x0302, 0x009f,
    0x0303, 0xfa44,
    0x0302, 0x009f,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0x001e,
    0x0302, 0x003a,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0xe000,
    0x0302, 0x007a,
    0x0303, 0x039b,
    0x0302, 0x009b,
    0x0303, 0x9b41,
    0x0302, 0x001f,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x9b00,
    0x0302, 0x0010,
    0x0303, 0x0307,
    0x0302, 0x008a,
    0x0303, 0xc040,
    0x0302, 0x0083,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0x0036,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1526,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1501,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1600,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1640,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xfdff,
    0x0302, 0x00ba,
    0x0303, 0x0382,
    0x0302, 0x001b,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0xc200,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x1538,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1537,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x53c2,
    0x0302, 0x009b,
    0x0303, 0x0058,
    0x0302, 0x0020,
    0x0303, 0x53c1,
    0x0302, 0x009b,
    0x0303, 0x00aa,
    0x0302, 0x00a0,
    0x0303, 0xc165,
    0x0302, 0x0083,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x3034,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x3039,
    0x0302, 0x003a,
    0x0303, 0x000b,
    0x0302, 0x00da,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xc3c3,
    0x0302, 0x003a,
    0x0303, 0x00c3,
    0x0302, 0x005a,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x0068,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0xc569,
    0x0302, 0x0003,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x00dd,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x1011,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x4a0f,
    0x0302, 0x001f,
    0x0303, 0x01dc,
    0x0302, 0x0060,
    0x0303, 0x9b24,
    0x0302, 0x0029,
    0x0303, 0x1500,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x9b2d,
    0x0302, 0x0008,
    0x0303, 0x992c,
    0x0302, 0x00a8,
    0x0303, 0x0081,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0123,
    0x0302, 0x0000,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x03d6,
    0x0302, 0x009b,
    0x0303, 0x0306,
    0x0302, 0x0005,
    0x0303, 0x00d0,
    0x0302, 0x00ba,
    0x0303, 0x03d6,
    0x0302, 0x009b,
    0x0303, 0x038c,
    0x0302, 0x0004,
    0x0303, 0xc575,
    0x0302, 0x0083,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0xd661,
    0x0302, 0x009f,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x151b,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x5303,
    0x0302, 0x001d,
    0x0303, 0x0304,
    0x0302, 0x0089,
    0x0303, 0x0020,
    0x0302, 0x00ba,
    0x0303, 0x9d03,
    0x0302, 0x0091,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x0017,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0308,
    0x0302, 0x0004,
    0x0303, 0xc366,
    0x0302, 0x0003,
    0x0303, 0xc164,
    0x0302, 0x0003,
    0x0303, 0x00a2,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0xc569,
    0x0302, 0x0003,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x0305,
    0x0302, 0x002e,
    0x0303, 0x1538,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x00b8,
    0x0302, 0x0000,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0xc065,
    0x0302, 0x0003,
    0x0303, 0x1688,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5383,
    0x0302, 0x0004,
    0x0303, 0x1689,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0x5303,
    0x0302, 0x009f,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x0028,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x000e,
    0x0302, 0x00a1,
    0x0303, 0x9b13,
    0x0302, 0x008b,
    0x0303, 0x9c75,
    0x0302, 0x0083,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x00bf,
    0x0302, 0x0020,
    0x0303, 0x75c9,
    0x0302, 0x009d,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x1522,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x7553,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1523,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1526,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0020,
    0x0302, 0x00ba,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x00d1,
    0x0302, 0x00a0,
    0x0303, 0x0080,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x00f5,
    0x0302, 0x0000,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0099,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0010,
    0x0302, 0x00ba,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x00e2,
    0x0302, 0x0021,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xf041,
    0x0302, 0x009f,
    0x0303, 0x03fa,
    0x0302, 0x0003,
    0x0303, 0x2000,
    0x0302, 0x00ba,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0x0160,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1092,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x5153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0040,
    0x0302, 0x00ba,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0x3026,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x3029,
    0x0302, 0x00ba,
    0x0303, 0x000e,
    0x0302, 0x00da,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xb4b4,
    0x0302, 0x003a,
    0x0303, 0x00b4,
    0x0302, 0x003a,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x00f5,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0xc569,
    0x0302, 0x0003,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0101,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x030d,
    0x0302, 0x002a,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0xd603,
    0x0302, 0x008f,
    0x0303, 0xc875,
    0x0302, 0x0003,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x1482,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5370,
    0x0302, 0x009b,
    0x0303, 0x0304,
    0x0302, 0x0085,
    0x0303, 0x00fc,
    0x0302, 0x003a,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0123,
    0x0302, 0x0000,
    0x0303, 0x1480,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x7053,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc94e,
    0x0302, 0x0003,
    0x0303, 0x00dc,
    0x0302, 0x0080,
    0x0303, 0x168a,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x759a,
    0x0302, 0x0083,
    0x0303, 0xf200,
    0x0302, 0x0098,
    0x0303, 0x03f2,
    0x0302, 0x0083,
    0x0303, 0x0001,
    0x0302, 0x00ba,
    0x0303, 0x9926,
    0x0302, 0x001f,
    0x0303, 0x01d2,
    0x0302, 0x00e0,
    0x0303, 0xc100,
    0x0302, 0x0010,
    0x0303, 0x9903,
    0x0302, 0x001b,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x9b04,
    0x0302, 0x0024,
    0x0303, 0x000e,
    0x0302, 0x00ba,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x9b84,
    0x0302, 0x00a8,
    0x0303, 0x000e,
    0x0302, 0x00ba,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0xc169,
    0x0302, 0x0083,
    0x0303, 0x9b6f,
    0x0302, 0x001f,
    0x0303, 0x0304,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc2ee,
    0x0302, 0x0083,
    0x0303, 0x6991,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4a0f,
    0x0302, 0x001f,
    0x0303, 0x01dc,
    0x0302, 0x0060,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x9bab,
    0x0302, 0x0088,
    0x0303, 0x99ac,
    0x0302, 0x0028,
    0x0303, 0x6409,
    0x0302, 0x0004,
    0x0303, 0x6508,
    0x0302, 0x0004,
    0x0303, 0x1681,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0102,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5381,
    0x0302, 0x000a,
    0x0303, 0x4d75,
    0x0302, 0x0083,
    0x0303, 0x83b7,
    0x0302, 0x000b,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x0306,
    0x0302, 0x00aa,
    0x0303, 0x1480,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x7d75,
    0x0302, 0x0083,
    0x0303, 0x53be,
    0x0302, 0x0028,
    0x0303, 0x650d,
    0x0302, 0x0004,
    0x0303, 0x640c,
    0x0302, 0x0004,
    0x0303, 0x1685,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6667,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5275,
    0x0302, 0x0003,
    0x0303, 0x53c6,
    0x0302, 0x0009,
    0x0303, 0x5270,
    0x0302, 0x0099,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6787,
    0x0302, 0x0085,
    0x0303, 0x0040,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x0136,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0123,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x1526,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x1546,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x1523,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x9a75,
    0x0302, 0x0083,
    0x0303, 0x68db,
    0x0302, 0x00a8,
    0x0303, 0x68dc,
    0x0302, 0x00a9,
    0x0303, 0x168a,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0010,
    0x0302, 0x00ba,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x017a,
    0x0302, 0x00a0,
    0x0303, 0x1538,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0136,
    0x0302, 0x00a1,
    0x0303, 0x4a0f,
    0x0302, 0x001f,
    0x0303, 0x01dc,
    0x0302, 0x0060,
    0x0303, 0x9b00,
    0x0302, 0x0010,
    0x0303, 0x030a,
    0x0302, 0x000c,
    0x0303, 0x4b09,
    0x0302, 0x0028,
    0x0303, 0x2000,
    0x0302, 0x007a,
    0x0303, 0x03d5,
    0x0302, 0x0091,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03eb,
    0x0302, 0x001b,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0x018d,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0x0004,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x9d02,
    0x0302, 0x008e,
    0x0303, 0x0197,
    0x0302, 0x0000,
    0x0303, 0x9b02,
    0x0302, 0x008e,
    0x0303, 0x0197,
    0x0302, 0x0000,
    0x0303, 0x0002,
    0x0302, 0x00ba,
    0x0303, 0xe803,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x0199,
    0x0302, 0x0080,
    0x0303, 0x010e,
    0x0302, 0x0000,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x9b82,
    0x0302, 0x0008,
    0x0303, 0x9983,
    0x0302, 0x00a8,
    0x0303, 0xe802,
    0x0302, 0x0029,
    0x0303, 0x01a1,
    0x0302, 0x0000,
    0x0303, 0xfdff,
    0x0302, 0x00ba,
    0x0303, 0x0382,
    0x0302, 0x001b,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x6409,
    0x0302, 0x0004,
    0x0303, 0x6508,
    0x0302, 0x0004,
    0x0303, 0x1681,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0102,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x5381,
    0x0302, 0x000a,
    0x0303, 0x4d75,
    0x0302, 0x0083,
    0x0303, 0x8393,
    0x0302, 0x000b,
    0x0303, 0x9b4f,
    0x0302, 0x009f,
    0x0303, 0x0314,
    0x0302, 0x00aa,
    0x0303, 0x9b0f,
    0x0302, 0x001f,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x03cc,
    0x0302, 0x001b,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6507,
    0x0302, 0x0004,
    0x0303, 0xd70d,
    0x0302, 0x00ab,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6783,
    0x0302, 0x0005,
    0x0303, 0x7d75,
    0x0302, 0x0083,
    0x0303, 0x010e,
    0x0302, 0x0000,
    0x0303, 0xd902,
    0x0302, 0x000a,
    0x0303, 0x01c1,
    0x0302, 0x0000,
    0x0303, 0x6770,
    0x0302, 0x001e,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6784,
    0x0302, 0x0085,
    0x0303, 0x7b75,
    0x0302, 0x0083,
    0x0303, 0x010e,
    0x0302, 0x0000,
    0x0303, 0xe804,
    0x0302, 0x0089,
    0x0303, 0x0200,
    0x0302, 0x00ba,
    0x0303, 0x0382,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x4b05,
    0x0302, 0x0028,
    0x0303, 0x4b04,
    0x0302, 0x0089,
    0x0303, 0xc34b,
    0x0302, 0x0003,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x0040,
    0x0302, 0x00ba,
    0x0303, 0x9a0c,
    0x0302, 0x009f,
    0x0303, 0x039a,
    0x0302, 0x0003,
    0x0303, 0x3000,
    0x0302, 0x003a,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x0199,
    0x0302, 0x00ba,
    0x0303, 0x0362,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x00ae,
    0x0303, 0xc000,
    0x0302, 0x00fa,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x009b,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x01ec,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x01f3,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01ec,
    0x0302, 0x0000,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x030c,
    0x0302, 0x0028,
    0x0303, 0x0326,
    0x0302, 0x0029,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0356,
    0x0302, 0x0028,
    0x0303, 0x0307,
    0x0302, 0x0029,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x6304,
    0x0302, 0x0004,
    0x0303, 0x6307,
    0x0302, 0x0083,
    0x0303, 0xc063,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x0006,
    0x0302, 0x0000,
    0x0303, 0x00bf,
    0x0302, 0x0080,
    0x0303, 0xc0ea,
    0x0302, 0x0083,
    0x0303, 0x0127,
    0x0302, 0x00e0,
    0x0303, 0x8403,
    0x0302, 0x008d,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x004c,
    0x0302, 0x00e0,
    0x0303, 0xe805,
    0x0302, 0x000a,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x9000,
    0x0302, 0x005a,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0x9000,
    0x0302, 0x0018,
    0x0303, 0x0390,
    0x0302, 0x0003,
    0x0303, 0xe806,
    0x0302, 0x0024,
    0x0303, 0xe805,
    0x0302, 0x00aa,
    0x0303, 0xdd04,
    0x0302, 0x00a8,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0x800f,
    0x0302, 0x00da,
    0x0303, 0x0058,
    0x0302, 0x00e0,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x07d0,
    0x0302, 0x003a,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x0058,
    0x0302, 0x00e0,
    0x0303, 0xc380,
    0x0302, 0x0083,
    0x0303, 0x9c40,
    0x0302, 0x00ba,
    0x0303, 0x036f,
    0x0302, 0x0011,
    0x0303, 0x0058,
    0x0302, 0x00e0,
    0x0303, 0xe814,
    0x0302, 0x00aa,
    0x0303, 0x0127,
    0x0302, 0x00e0,
    0x0303, 0xe804,
    0x0302, 0x00a4,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0x8002,
    0x0302, 0x0088,
    0x0303, 0x839f,
    0x0302, 0x000b,
    0x0303, 0xea00,
    0x0302, 0x0098,
    0x0303, 0x03ea,
    0x0302, 0x0083,
    0x0303, 0x7d03,
    0x0302, 0x0017,
    0x0303, 0x003e,
    0x0302, 0x00c1,
    0x0303, 0x8303,
    0x0302, 0x00a4,
    0x0303, 0xcb67,
    0x0302, 0x0003,
    0x0303, 0x004c,
    0x0302, 0x00e0,
    0x0303, 0xe804,
    0x0302, 0x008a,
    0x0303, 0x9000,
    0x0302, 0x00fa,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x0354,
    0x0302, 0x0083,
    0x0303, 0xe803,
    0x0302, 0x0024,
    0x0303, 0xe802,
    0x0302, 0x002a,
    0x0303, 0x002e,
    0x0302, 0x0000,
    0x0303, 0xee67,
    0x0302, 0x0086,
    0x0303, 0x0044,
    0x0302, 0x0000,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x004e,
    0x0302, 0x0021,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x011b,
    0x0302, 0x00e0,
    0x0303, 0x0808,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x159d,
    0x0302, 0x003a,
    0x0303, 0x4102,
    0x0302, 0x00ad,
    0x0303, 0x1596,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x011b,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x001f,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x009b,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x159e,
    0x0302, 0x003a,
    0x0303, 0x4102,
    0x0302, 0x00ad,
    0x0303, 0x1597,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x011b,
    0x0302, 0x00e0,
    0x0303, 0x536a,
    0x0302, 0x0003,
    0x0303, 0x159f,
    0x0302, 0x00ba,
    0x0303, 0x4102,
    0x0302, 0x00ad,
    0x0303, 0x1598,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x011b,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x1090,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x011b,
    0x0302, 0x00e0,
    0x0303, 0xe0c0,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x67c8,
    0x0302, 0x009c,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0369,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0xc045,
    0x0302, 0x0083,
    0x0303, 0x5345,
    0x0302, 0x0091,
    0x0303, 0x0345,
    0x0302, 0x0083,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x108f,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6769,
    0x0302, 0x0019,
    0x0303, 0x0f6b,
    0x0302, 0x0002,
    0x0303, 0x03c2,
    0x0302, 0x001c,
    0x0303, 0x036b,
    0x0302, 0x0019,
    0x0303, 0x0f6b,
    0x0302, 0x0002,
    0x0303, 0x6ac3,
    0x0302, 0x009c,
    0x0303, 0x036b,
    0x0302, 0x0019,
    0x0303, 0x0f6b,
    0x0302, 0x0002,
    0x0303, 0x01db,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x0194,
    0x0302, 0x003a,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x00a6,
    0x0302, 0x0041,
    0x0303, 0xc767,
    0x0302, 0x0003,
    0x0303, 0x00b5,
    0x0302, 0x0080,
    0x0303, 0x01ae,
    0x0302, 0x003a,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x015c,
    0x0302, 0x00ba,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x00ad,
    0x0302, 0x00c1,
    0x0303, 0xc667,
    0x0302, 0x0083,
    0x0303, 0x00b5,
    0x0302, 0x0080,
    0x0303, 0x0181,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x013c,
    0x0302, 0x00ba,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x00b4,
    0x0302, 0x0041,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0x00b5,
    0x0302, 0x0080,
    0x0303, 0xc467,
    0x0302, 0x0003,
    0x0303, 0x67c4,
    0x0302, 0x009c,
    0x0303, 0x03c8,
    0x0302, 0x0091,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x036a,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0345,
    0x0302, 0x0091,
    0x0303, 0x0345,
    0x0302, 0x0083,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x0041,
    0x0302, 0x0000,
    0x0303, 0x0202,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x03cf,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x001b,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x2c2c,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6753,
    0x0302, 0x0083,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x1600,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x1640,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x14c1,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xaaaa,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x14c2,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xfda2,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x14c4,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x14c3,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x00aa,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x0116,
    0x0302, 0x0060,
    0x0303, 0x0041,
    0x0302, 0x0000,
    0x0303, 0x0044,
    0x0302, 0x0000,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc3ee,
    0x0302, 0x0003,
    0x0303, 0x9b6f,
    0x0302, 0x001f,
    0x0303, 0x0386,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x003a,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xd568,
    0x0302, 0x0003,
    0x0303, 0x00f7,
    0x0302, 0x0080,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x6d68,
    0x0302, 0x0003,
    0x0303, 0x6700,
    0x0302, 0x0010,
    0x0303, 0x0387,
    0x0302, 0x001b,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0384,
    0x0302, 0x0011,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0010,
    0x0303, 0x0375,
    0x0302, 0x009b,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x00fc,
    0x0302, 0x0021,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0387,
    0x0302, 0x0011,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x75d1,
    0x0302, 0x0091,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x00ae,
    0x0303, 0xc000,
    0x0302, 0x00fa,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x009b,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x011e,
    0x0302, 0x0080,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x0125,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x011e,
    0x0302, 0x0080,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xb611,
    0x0302, 0x002c,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0xb60f,
    0x0302, 0x001f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0302,
    0x0302, 0x002f,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x0055,
    0x0302, 0x003a,
    0x0303, 0x03b8,
    0x0302, 0x001b,
    0x0303, 0x0132,
    0x0302, 0x00a0,
    0x0303, 0x1891,
    0x0302, 0x001a,
    0x0303, 0x0133,
    0x0302, 0x0080,
    0x0303, 0x1091,
    0x0302, 0x009a,
    0x0303, 0x68b5,
    0x0302, 0x0003,
    0x0303, 0x03b4,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb590,
    0x0302, 0x002a,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x030d,
    0x0302, 0x00a8,
    0x0303, 0x4e00,
    0x0302, 0x0014,
    0x0303, 0x03cb,
    0x0302, 0x0097,
    0x0303, 0x0012,
    0x0302, 0x00a0,
    0x0303, 0x4f07,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xf002,
    0x0302, 0x00ab,
    0x0303, 0x000e,
    0x0302, 0x0080,
    0x0303, 0xc0f0,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x9c81,
    0x0302, 0x0088,
    0x0303, 0xc868,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0060,
    0x0303, 0x1092,
    0x0302, 0x003a,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0022,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0xd50f,
    0x0302, 0x001f,
    0x0303, 0x03e8,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xdcfa,
    0x0302, 0x0083,
    0x0303, 0xc079,
    0x0302, 0x0083,
    0x0303, 0xc200,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xc092,
    0x0302, 0x0083,
    0x0303, 0xc080,
    0x0302, 0x0083,
    0x0303, 0x0028,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01ed,
    0x0302, 0x00e0,
    0x0303, 0x9d0b,
    0x0302, 0x0009,
    0x0303, 0x2000,
    0x0302, 0x007a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0033,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f7,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x9d02,
    0x0302, 0x0028,
    0x0303, 0x00e7,
    0x0302, 0x0000,
    0x0303, 0xf000,
    0x0302, 0x0018,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0xc081,
    0x0302, 0x0003,
    0x0303, 0xc09c,
    0x0302, 0x0003,
    0x0303, 0x6b01,
    0x0302, 0x003a,
    0x0303, 0x003e,
    0x0302, 0x00da,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x9ad2,
    0x0302, 0x003a,
    0x0303, 0x0290,
    0x0302, 0x00da,
    0x0303, 0x038a,
    0x0302, 0x0083,
    0x0303, 0x9a46,
    0x0302, 0x0083,
    0x0303, 0xc09b,
    0x0302, 0x0083,
    0x0303, 0x01bf,
    0x0302, 0x0060,
    0x0303, 0x0043,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f1,
    0x0302, 0x0060,
    0x0303, 0x0046,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e5,
    0x0302, 0x0060,
    0x0303, 0xc04a,
    0x0302, 0x0083,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0011,
    0x0302, 0x003a,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x004d,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x500a,
    0x0302, 0x0028,
    0x0303, 0x8405,
    0x0302, 0x002d,
    0x0303, 0x0052,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f3,
    0x0302, 0x00e0,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0056,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x0048,
    0x0302, 0x0000,
    0x0303, 0x484a,
    0x0302, 0x0083,
    0x0303, 0xc868,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0060,
    0x0303, 0x005d,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f1,
    0x0302, 0x0060,
    0x0303, 0x0060,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e5,
    0x0302, 0x0060,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0065,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x5008,
    0x0302, 0x00a8,
    0x0303, 0x8402,
    0x0302, 0x00ad,
    0x0303, 0x0078,
    0x0302, 0x0000,
    0x0303, 0x006c,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x4849,
    0x0302, 0x0083,
    0x0303, 0x0062,
    0x0302, 0x0080,
    0x0303, 0x4748,
    0x0302, 0x001e,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0320,
    0x0302, 0x00ab,
    0x0303, 0x4b48,
    0x0302, 0x0017,
    0x0303, 0x0091,
    0x0302, 0x0020,
    0x0303, 0x484a,
    0x0302, 0x0091,
    0x0303, 0x0f4a,
    0x0302, 0x0002,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x0067,
    0x0302, 0x0080,
    0x0303, 0x4748,
    0x0302, 0x0003,
    0x0303, 0x007c,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e9,
    0x0302, 0x0060,
    0x0303, 0x007f,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x5011,
    0x0302, 0x0028,
    0x0303, 0xc968,
    0x0302, 0x0083,
    0x0303, 0x019b,
    0x0302, 0x0060,
    0x0303, 0xb60b,
    0x0302, 0x00aa,
    0x0303, 0x0029,
    0x0302, 0x00ba,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x0089,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f3,
    0x0302, 0x00e0,
    0x0303, 0x4948,
    0x0302, 0x0083,
    0x0303, 0x008d,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x0062,
    0x0302, 0x0080,
    0x0303, 0x4a46,
    0x0302, 0x0003,
    0x0303, 0x01bf,
    0x0302, 0x0060,
    0x0303, 0x0084,
    0x0302, 0x0000,
    0x0303, 0xf3de,
    0x0302, 0x003a,
    0x0303, 0x0057,
    0x0302, 0x00da,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x4847,
    0x0302, 0x001b,
    0x0303, 0x009a,
    0x0302, 0x0021,
    0x0303, 0x4847,
    0x0302, 0x0003,
    0x0303, 0x009a,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f5,
    0x0302, 0x00e0,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x480c,
    0x0302, 0x000c,
    0x0303, 0x9d06,
    0x0302, 0x0029,
    0x0303, 0x14e2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xce53,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x00ad,
    0x0302, 0x0080,
    0x0303, 0x15c2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x00ad,
    0x0302, 0x0080,
    0x0303, 0x14a4,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x0031,
    0x0302, 0x00ba,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x00b7,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x00b5,
    0x0302, 0x00a1,
    0x0303, 0xe802,
    0x0302, 0x000e,
    0x0303, 0x01da,
    0x0302, 0x0060,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0x848a,
    0x0302, 0x00ad,
    0x0303, 0x9b00,
    0x0302, 0x0098,
    0x0303, 0x039b,
    0x0302, 0x0083,
    0x0303, 0x8310,
    0x0302, 0x008b,
    0x0303, 0x00bc,
    0x0302, 0x0080,
    0x0303, 0x4806,
    0x0302, 0x000c,
    0x0303, 0x9d03,
    0x0302, 0x0089,
    0x0303, 0xd80c,
    0x0302, 0x000a,
    0x0303, 0x00c4,
    0x0302, 0x0080,
    0x0303, 0xd90a,
    0x0302, 0x008a,
    0x0303, 0x00c4,
    0x0302, 0x0080,
    0x0303, 0xda08,
    0x0302, 0x000a,
    0x0303, 0x00c4,
    0x0302, 0x0080,
    0x0303, 0x9d14,
    0x0302, 0x008f,
    0x0303, 0x018f,
    0x0302, 0x0060,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x009d,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x030f,
    0x0302, 0x0088,
    0x0303, 0x9d04,
    0x0302, 0x008d,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x039b,
    0x0302, 0x009e,
    0x0303, 0x0371,
    0x0302, 0x002b,
    0x0303, 0x00d1,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e7,
    0x0302, 0x00e0,
    0x0303, 0x00d4,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01e3,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0x50c5,
    0x0302, 0x0028,
    0x0303, 0x00ca,
    0x0302, 0x0000,
    0x0303, 0x84ab,
    0x0302, 0x00ad,
    0x0303, 0xc29c,
    0x0302, 0x0083,
    0x0303, 0x47c9,
    0x0302, 0x0017,
    0x0303, 0x014b,
    0x0302, 0x00a1,
    0x0303, 0x48c9,
    0x0302, 0x0017,
    0x0303, 0x014b,
    0x0302, 0x00a1,
    0x0303, 0x9d6d,
    0x0302, 0x0009,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x018f,
    0x0302, 0x0060,
    0x0303, 0x3b00,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x00ea,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01ef,
    0x0302, 0x0060,
    0x0303, 0x0187,
    0x0302, 0x00e0,
    0x0303, 0xd70f,
    0x0302, 0x009f,
    0x0303, 0x03c7,
    0x0302, 0x001c,
    0x0303, 0x0386,
    0x0302, 0x00ab,
    0x0303, 0x7500,
    0x0302, 0x0098,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0389,
    0x0302, 0x000b,
    0x0303, 0x0051,
    0x0302, 0x00ba,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x1580,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc253,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x0001,
    0x0302, 0x007a,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x0140,
    0x0302, 0x003a,
    0x0303, 0x038a,
    0x0302, 0x0083,
    0x0303, 0xcf00,
    0x0302, 0x0090,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x9d41,
    0x0302, 0x001f,
    0x0303, 0x0341,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0xc040,
    0x0302, 0x0083,
    0x0303, 0xc05e,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x2000,
    0x0302, 0x00da,
    0x0303, 0x0341,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x010a,
    0x0302, 0x00ba,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01f7,
    0x0302, 0x0060,
    0x0303, 0x010d,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x01eb,
    0x0302, 0x00e0,
    0x0303, 0x5e9b,
    0x0302, 0x0003,
    0x0303, 0xd730,
    0x0302, 0x00aa,
    0x0303, 0x0110,
    0x0302, 0x0000,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x9d13,
    0x0302, 0x000a,
    0x0303, 0xd70f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0310,
    0x0302, 0x002f,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x0029,
    0x0303, 0x15c6,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x018f,
    0x0302, 0x0060,
    0x0303, 0x0800,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0126,
    0x0302, 0x00a0,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x039d,
    0x0302, 0x0083,
    0x0303, 0x2424,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x0128,
    0x0302, 0x0080,
    0x0303, 0x0404,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6753,
    0x0302, 0x0083,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x018a,
    0x0302, 0x0060,
    0x0303, 0x28cb,
    0x0302, 0x00ba,
    0x0303, 0x000c,
    0x0302, 0x005a,
    0x0303, 0x0389,
    0x0302, 0x0083,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x013b,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x00b5,
    0x0302, 0x00a1,
    0x0303, 0xe802,
    0x0302, 0x000e,
    0x0303, 0x01da,
    0x0302, 0x0060,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0x8488,
    0x0302, 0x002d,
    0x0303, 0xd902,
    0x0302, 0x000a,
    0x0303, 0x014b,
    0x0302, 0x0080,
    0x0303, 0xc49c,
    0x0302, 0x0083,
    0x0303, 0x4700,
    0x0302, 0x0090,
    0x0303, 0x039a,
    0x0302, 0x001b,
    0x0303, 0x0147,
    0x0302, 0x0020,
    0x0303, 0x0f9a,
    0x0302, 0x0082,
    0x0303, 0xc59c,
    0x0302, 0x0003,
    0x0303, 0x0014,
    0x0302, 0x0000,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x039c,
    0x0302, 0x0003,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x0392,
    0x0302, 0x0091,
    0x0303, 0x0392,
    0x0302, 0x0083,
    0x0303, 0x0189,
    0x0302, 0x0000,
    0x0303, 0xf289,
    0x0302, 0x0003,
    0x0303, 0x568a,
    0x0302, 0x0083,
    0x0303, 0x0060,
    0x0302, 0x003a,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0348,
    0x0302, 0x0011,
    0x0303, 0x039b,
    0x0302, 0x0083,
    0x0303, 0x4748,
    0x0302, 0x0017,
    0x0303, 0x0147,
    0x0302, 0x00a1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03eb,
    0x0302, 0x001b,
    0x0303, 0x03eb,
    0x0302, 0x0003,
    0x0303, 0xd500,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x9c2e,
    0x0302, 0x0028,
    0x0303, 0x8257,
    0x0302, 0x0083,
    0x0303, 0x9d09,
    0x0302, 0x00ab,
    0x0303, 0x9d02,
    0x0302, 0x002d,
    0x0303, 0x0166,
    0x0302, 0x0080,
    0x0303, 0xc20f,
    0x0302, 0x001f,
    0x0303, 0x03e8,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xff00,
    0x0302, 0x003a,
    0x0303, 0x0382,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x016e,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x016c,
    0x0302, 0x00a1,
    0x0303, 0xe802,
    0x0302, 0x000e,
    0x0303, 0x01da,
    0x0302, 0x0000,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x0080,
    0x0303, 0x5782,
    0x0302, 0x0083,
    0x0303, 0x01a8,
    0x0302, 0x0060,
    0x0303, 0x4803,
    0x0302, 0x000c,
    0x0303, 0xd904,
    0x0302, 0x000a,
    0x0303, 0x015b,
    0x0302, 0x0000,
    0x0303, 0xda02,
    0x0302, 0x000a,
    0x0303, 0x015b,
    0x0302, 0x0000,
    0x0303, 0xc200,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x8488,
    0x0302, 0x002e,
    0x0303, 0xd5d9,
    0x0302, 0x0003,
    0x0303, 0xd5da,
    0x0302, 0x0003,
    0x0303, 0xc0d9,
    0x0302, 0x0083,
    0x0303, 0xc0da,
    0x0302, 0x0083,
    0x0303, 0x01a5,
    0x0302, 0x00e0,
    0x0303, 0x0180,
    0x0302, 0x003a,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0x8498,
    0x0302, 0x00ad,
    0x0303, 0x9d05,
    0x0302, 0x002a,
    0x0303, 0x4703,
    0x0302, 0x000c,
    0x0303, 0xd9be,
    0x0302, 0x0089,
    0x0303, 0x0186,
    0x0302, 0x0000,
    0x0303, 0xdac0,
    0x0302, 0x0089,
    0x0303, 0x015b,
    0x0302, 0x0000,
    0x0303, 0x8402,
    0x0302, 0x002a,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0014,
    0x0302, 0x0000,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x0192,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x0199,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0192,
    0x0302, 0x0000,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x680f,
    0x0302, 0x001f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xd568,
    0x0302, 0x0003,
    0x0303, 0x01aa,
    0x0302, 0x0080,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x6d68,
    0x0302, 0x0003,
    0x0303, 0x6700,
    0x0302, 0x0010,
    0x0303, 0x0387,
    0x0302, 0x001b,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0384,
    0x0302, 0x0011,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0010,
    0x0303, 0x0375,
    0x0302, 0x009b,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x01af,
    0x0302, 0x00a1,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0387,
    0x0302, 0x0011,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0306,
    0x0302, 0x00a9,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x4608,
    0x0302, 0x00a9,
    0x0303, 0x4609,
    0x0302, 0x00a8,
    0x0303, 0xc94b,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc84b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc44b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc24b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc14b,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc667,
    0x0302, 0x0083,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc767,
    0x0302, 0x0003,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0x01db,
    0x0302, 0x0080,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc4ee,
    0x0302, 0x0083,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc94e,
    0x0302, 0x0003,
    0x0303, 0x01d2,
    0x0302, 0x0080,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0x01d4,
    0x0302, 0x0080,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d4,
    0x0302, 0x0080,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x0080,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0xc84e,
    0x0302, 0x0083,
    0x0303, 0x01d6,
    0x0302, 0x0000,
    0x0303, 0xc44e,
    0x0302, 0x0083,
    0x0303, 0x01d8,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xee13,
    0x0302, 0x002f,
    0x0303, 0x4f0f,
    0x0302, 0x001f,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03c7,
    0x0302, 0x009b,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xee67,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x0308,
    0x0302, 0x0029,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0347,
    0x0302, 0x0028,
    0x0303, 0x0359,
    0x0302, 0x00a9,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0375,
    0x0302, 0x00a8,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x56d1,
    0x0302, 0x0011,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xc050,
    0x0302, 0x0003,
    0x0303, 0x8337,
    0x0302, 0x008b,
    0x0303, 0x480f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0302,
    0x0302, 0x00a8,
    0x0303, 0x0043,
    0x0302, 0x0080,
    0x0303, 0x9d0d,
    0x0302, 0x0009,
    0x0303, 0x15c4,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x15c2,
    0x0302, 0x003a,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x9d18,
    0x0302, 0x000e,
    0x0303, 0xcdd8,
    0x0302, 0x0083,
    0x0303, 0x510f,
    0x0302, 0x001f,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xd802,
    0x0302, 0x000b,
    0x0303, 0x005c,
    0x0302, 0x0000,
    0x0303, 0xd826,
    0x0302, 0x00a8,
    0x0303, 0x005c,
    0x0302, 0x0000,
    0x0303, 0x14e1,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x14e2,
    0x0302, 0x003a,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x9d0c,
    0x0302, 0x000e,
    0x0303, 0xcdd9,
    0x0302, 0x0003,
    0x0303, 0x510f,
    0x0302, 0x001f,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0xd902,
    0x0302, 0x008b,
    0x0303, 0x005c,
    0x0302, 0x0000,
    0x0303, 0xd91a,
    0x0302, 0x0028,
    0x0303, 0x005c,
    0x0302, 0x0000,
    0x0303, 0x14a6,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x14a4,
    0x0302, 0x00ba,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x6752,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x5361,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0311,
    0x0302, 0x0088,
    0x0303, 0x6852,
    0x0302, 0x0003,
    0x0303, 0xce53,
    0x0302, 0x0083,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x510f,
    0x0302, 0x001f,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x5361,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0302,
    0x0302, 0x0008,
    0x0303, 0x005c,
    0x0302, 0x0000,
    0x0303, 0x6752,
    0x0302, 0x0003,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x5361,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0302,
    0x0302, 0x0008,
    0x0303, 0xc150,
    0x0302, 0x0083,
    0x0303, 0xc0d9,
    0x0302, 0x0083,
    0x0303, 0xc0d8,
    0x0302, 0x0003,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x9cbf,
    0x0302, 0x00a8,
    0x0303, 0xbada,
    0x0302, 0x003a,
    0x0303, 0x0399,
    0x0302, 0x0003,
    0x0303, 0x005f,
    0x0302, 0x0000,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0306,
    0x0302, 0x00a9,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x9a08,
    0x0302, 0x0029,
    0x0303, 0x9a09,
    0x0302, 0x0028,
    0x0303, 0xc948,
    0x0302, 0x0003,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0xc848,
    0x0302, 0x0083,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0xc448,
    0x0302, 0x0083,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0xc248,
    0x0302, 0x0083,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0xc148,
    0x0302, 0x0083,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0x480f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x030d,
    0x0302, 0x00a8,
    0x0303, 0x480f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x030f,
    0x0302, 0x00a9,
    0x0303, 0x0313,
    0x0302, 0x00a8,
    0x0303, 0x4815,
    0x0302, 0x0029,
    0x0303, 0x4802,
    0x0302, 0x00a8,
    0x0303, 0x005f,
    0x0302, 0x0000,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0303,
    0x0302, 0x0088,
    0x0303, 0xc948,
    0x0302, 0x0003,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0303,
    0x0302, 0x0009,
    0x0303, 0xc848,
    0x0302, 0x0083,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0x9a0f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0303,
    0x0302, 0x0088,
    0x0303, 0xc448,
    0x0302, 0x0083,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0x9a03,
    0x0302, 0x0009,
    0x0303, 0xc248,
    0x0302, 0x0083,
    0x0303, 0x0094,
    0x0302, 0x0080,
    0x0303, 0x9a92,
    0x0302, 0x0008,
    0x0303, 0xc148,
    0x0302, 0x0083,
    0x0303, 0xcc0f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0382,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xcf0f,
    0x0302, 0x009f,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0xc85a,
    0x0302, 0x0083,
    0x0303, 0x480f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0308,
    0x0302, 0x00a8,
    0x0303, 0x480f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0314,
    0x0302, 0x00a9,
    0x0303, 0x0320,
    0x0302, 0x00a8,
    0x0303, 0x4827,
    0x0302, 0x00a9,
    0x0303, 0x482f,
    0x0302, 0x00a8,
    0x0303, 0x005f,
    0x0302, 0x0000,
    0x0303, 0xc35c,
    0x0302, 0x0003,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x0359,
    0x0302, 0x0003,
    0x0303, 0xc05b,
    0x0302, 0x0083,
    0x0303, 0x550f,
    0x0302, 0x009f,
    0x0303, 0x0356,
    0x0302, 0x0003,
    0x0303, 0xcc68,
    0x0302, 0x0083,
    0x0303, 0xc30f,
    0x0302, 0x009f,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x0396,
    0x0302, 0x0003,
    0x0303, 0x0300,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x00e3,
    0x0302, 0x0080,
    0x0303, 0xc15c,
    0x0302, 0x0083,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x55c1,
    0x0302, 0x001c,
    0x0303, 0x0356,
    0x0302, 0x0003,
    0x0303, 0xc768,
    0x0302, 0x0003,
    0x0303, 0xc10f,
    0x0302, 0x001f,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x0396,
    0x0302, 0x0003,
    0x0303, 0x0300,
    0x0302, 0x003a,
    0x0303, 0x03e8,
    0x0302, 0x0011,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x00e3,
    0x0302, 0x0080,
    0x0303, 0x5ac1,
    0x0302, 0x0091,
    0x0303, 0x035a,
    0x0302, 0x0003,
    0x0303, 0xc35c,
    0x0302, 0x0003,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x55c2,
    0x0302, 0x001c,
    0x0303, 0x0356,
    0x0302, 0x0003,
    0x0303, 0x00e3,
    0x0302, 0x0080,
    0x0303, 0xc5df,
    0x0302, 0x0083,
    0x0303, 0x5ac2,
    0x0302, 0x0091,
    0x0303, 0x035a,
    0x0302, 0x0003,
    0x0303, 0xc75c,
    0x0302, 0x0083,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x55c3,
    0x0302, 0x009c,
    0x0303, 0x0356,
    0x0302, 0x0003,
    0x0303, 0x00e3,
    0x0302, 0x0080,
    0x0303, 0x5ac3,
    0x0302, 0x0011,
    0x0303, 0x035a,
    0x0302, 0x0003,
    0x0303, 0xc75c,
    0x0302, 0x0083,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x55c4,
    0x0302, 0x001c,
    0x0303, 0x0356,
    0x0302, 0x0003,
    0x0303, 0x00e3,
    0x0302, 0x0080,
    0x0303, 0xdc0f,
    0x0302, 0x001f,
    0x0303, 0x03ce,
    0x0302, 0x009b,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x684f,
    0x0302, 0x009f,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x03dc,
    0x0302, 0x0083,
    0x0303, 0x1023,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xcc00,
    0x0302, 0x0090,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0359,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1021,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0xd500,
    0x0302, 0x0010,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x035b,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x5c0f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x001c,
    0x0303, 0x035a,
    0x0302, 0x0011,
    0x0303, 0x03db,
    0x0302, 0x0003,
    0x0303, 0xc075,
    0x0302, 0x0083,
    0x0303, 0xc072,
    0x0302, 0x0003,
    0x0303, 0x48c8,
    0x0302, 0x009b,
    0x0303, 0x0106,
    0x0302, 0x0020,
    0x0303, 0xe805,
    0x0302, 0x008e,
    0x0303, 0x7778,
    0x0302, 0x003a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x10a8,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x7553,
    0x0302, 0x0083,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x10a9,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x7253,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1027,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x4806,
    0x0302, 0x000c,
    0x0303, 0xe803,
    0x0302, 0x008e,
    0x0303, 0x0099,
    0x0302, 0x003a,
    0x0303, 0x0117,
    0x0302, 0x0080,
    0x0303, 0x00dd,
    0x0302, 0x003a,
    0x0303, 0x0117,
    0x0302, 0x0080,
    0x0303, 0x0044,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x10a1,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x0120,
    0x0302, 0x0021,
    0x0303, 0xe803,
    0x0302, 0x008e,
    0x0303, 0xc50f,
    0x0302, 0x009f,
    0x0303, 0x0121,
    0x0302, 0x0080,
    0x0303, 0xc40f,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x10ae,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xe807,
    0x0302, 0x000e,
    0x0303, 0x4803,
    0x0302, 0x000c,
    0x0303, 0x1f70,
    0x0302, 0x003a,
    0x0303, 0x012d,
    0x0302, 0x0080,
    0x0303, 0x4803,
    0x0302, 0x008b,
    0x0303, 0x1b30,
    0x0302, 0x003a,
    0x0303, 0x012d,
    0x0302, 0x0080,
    0x0303, 0x0441,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x0137,
    0x0302, 0x0021,
    0x0303, 0xe806,
    0x0302, 0x008e,
    0x0303, 0xe20f,
    0x0302, 0x009f,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x013c,
    0x0302, 0x0080,
    0x0303, 0xe20f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x03f5,
    0x0302, 0x0003,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03f6,
    0x0302, 0x0003,
    0x0303, 0x102a,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x4803,
    0x0302, 0x000c,
    0x0303, 0x0047,
    0x0302, 0x003a,
    0x0303, 0x0142,
    0x0302, 0x0080,
    0x0303, 0x0020,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x480e,
    0x0302, 0x008c,
    0x0303, 0x013a,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0127,
    0x0302, 0x00ba,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x0117,
    0x0302, 0x00ba,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x013f,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x012f,
    0x0302, 0x003a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0127,
    0x0302, 0x00ba,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x015a,
    0x0302, 0x0080,
    0x0303, 0x018f,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x015f,
    0x0302, 0x00ba,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xc069,
    0x0302, 0x0003,
    0x0303, 0x536a,
    0x0302, 0x0003,
    0x0303, 0x6875,
    0x0302, 0x0003,
    0x0303, 0xc072,
    0x0302, 0x0003,
    0x0303, 0x1041,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1040,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6853,
    0x0302, 0x0083,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x103f,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6953,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1046,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6a53,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1045,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x7553,
    0x0302, 0x0083,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1044,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x7253,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0xc080,
    0x0302, 0x0083,
    0x0303, 0x1033,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x5367,
    0x0302, 0x0083,
    0x0303, 0xd50f,
    0x0302, 0x001f,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x6753,
    0x0302, 0x0083,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0x8001,
    0x0302, 0x005a,
    0x0303, 0x01e4,
    0x0302, 0x00e0,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x0189,
    0x0302, 0x0021,
    0x0303, 0xe807,
    0x0302, 0x000e,
    0x0303, 0xc090,
    0x0302, 0x0003,
    0x0303, 0xc100,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x018e,
    0x0302, 0x0080,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0xe80f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0xc46a,
    0x0302, 0x0083,
    0x0303, 0x01da,
    0x0302, 0x0060,
    0x0303, 0x0193,
    0x0302, 0x00ba,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x01eb,
    0x0302, 0x0080,
    0x0303, 0xc96a,
    0x0302, 0x0003,
    0x0303, 0x01da,
    0x0302, 0x0060,
    0x0303, 0x48c7,
    0x0302, 0x009b,
    0x0303, 0x01a2,
    0x0302, 0x0021,
    0x0303, 0xe80b,
    0x0302, 0x000e,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x8303,
    0x0302, 0x000b,
    0x0303, 0xb68a,
    0x0302, 0x002d,
    0x0303, 0x01a5,
    0x0302, 0x0080,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x900f,
    0x0302, 0x009f,
    0x0303, 0x03c7,
    0x0302, 0x009b,
    0x0303, 0x03c7,
    0x0302, 0x0097,
    0x0303, 0x018e,
    0x0302, 0x00a1,
    0x0303, 0x01a5,
    0x0302, 0x0080,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0xb694,
    0x0302, 0x002d,
    0x0303, 0x480f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0302,
    0x0302, 0x00a8,
    0x0303, 0x01ae,
    0x0302, 0x0000,
    0x0303, 0x9d03,
    0x0302, 0x0089,
    0x0303, 0xc867,
    0x0302, 0x0003,
    0x0303, 0x01af,
    0x0302, 0x0080,
    0x0303, 0xc467,
    0x0302, 0x0003,
    0x0303, 0x01af,
    0x0302, 0x0080,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01ce,
    0x0302, 0x0060,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x480f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0302,
    0x0302, 0x00a8,
    0x0303, 0x01c2,
    0x0302, 0x0000,
    0x0303, 0x9d03,
    0x0302, 0x0089,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0xc20f,
    0x0302, 0x001f,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0xc10f,
    0x0302, 0x001f,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x03cf,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x001b,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x01d1,
    0x0302, 0x0080,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x01d8,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01d1,
    0x0302, 0x0080,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x6a0f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x4fc9,
    0x0302, 0x001c,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0x680f,
    0x0302, 0x001f,
    0x0303, 0x034f,
    0x0302, 0x0091,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03c5,
    0x0302, 0x0011,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x0011,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xee0a,
    0x0302, 0x00af,
    0x0303, 0x4f0f,
    0x0302, 0x001f,
    0x0303, 0x0307,
    0x0302, 0x0083,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x03c7,
    0x0302, 0x009b,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x030e,
    0x0302, 0x00a8,
    0x0303, 0x0302,
    0x0302, 0x0029,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0x0183,
    0x0302, 0x0000,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0xee91,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x5e00,
    0x0302, 0x0098,
    0x0303, 0x035e,
    0x0302, 0x0083,
    0x0303, 0xe802,
    0x0302, 0x00ae,
    0x0303, 0x03f0,
    0x0302, 0x0003,
    0x0303, 0x0026,
    0x0302, 0x00ba,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x00df,
    0x0302, 0x0080,
    0x0303, 0x4102,
    0x0302, 0x008c,
    0x0303, 0x0033,
    0x0302, 0x0000,
    0x0303, 0x01d5,
    0x0302, 0x0060,
    0x0303, 0xd72c,
    0x0302, 0x002a,
    0x0303, 0x002d,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x0056,
    0x0302, 0x0060,
    0x0303, 0x0031,
    0x0302, 0x00ba,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x4188,
    0x0302, 0x0024,
    0x0303, 0x8489,
    0x0302, 0x00ad,
    0x0303, 0xcd00,
    0x0302, 0x0010,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0039,
    0x0302, 0x003a,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x009a,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xd71b,
    0x0302, 0x00aa,
    0x0303, 0x003e,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x0056,
    0x0302, 0x0060,
    0x0303, 0x0042,
    0x0302, 0x003a,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0x4248,
    0x0302, 0x009f,
    0x0303, 0x030a,
    0x0302, 0x002b,
    0x0303, 0x418a,
    0x0302, 0x000d,
    0x0303, 0xcd41,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x004a,
    0x0302, 0x00ba,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x009a,
    0x0302, 0x0000,
    0x0303, 0x4248,
    0x0302, 0x009f,
    0x0303, 0x0302,
    0x0302, 0x00ab,
    0x0303, 0x001f,
    0x0302, 0x0080,
    0x0303, 0x0050,
    0x0302, 0x003a,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x00f3,
    0x0302, 0x0000,
    0x0303, 0x0053,
    0x0302, 0x003a,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x0112,
    0x0302, 0x0080,
    0x0303, 0xd702,
    0x0302, 0x002a,
    0x0303, 0xd787,
    0x0302, 0x002d,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xc36b,
    0x0302, 0x0083,
    0x0303, 0x4102,
    0x0302, 0x002f,
    0x0303, 0xc26b,
    0x0302, 0x0003,
    0x0303, 0x4041,
    0x0302, 0x001f,
    0x0303, 0x03c3,
    0x0302, 0x001b,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x0064,
    0x0302, 0x0020,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x0062,
    0x0302, 0x00a1,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x0065,
    0x0302, 0x0000,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0x0065,
    0x0302, 0x0000,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0x4031,
    0x0302, 0x009f,
    0x0303, 0x03c3,
    0x0302, 0x001b,
    0x0303, 0x03c3,
    0x0302, 0x0017,
    0x0303, 0x0072,
    0x0302, 0x00a0,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x0070,
    0x0302, 0x00a1,
    0x0303, 0x4103,
    0x0302, 0x0088,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0x0073,
    0x0302, 0x0080,
    0x0303, 0xc268,
    0x0302, 0x0003,
    0x0303, 0x0073,
    0x0302, 0x0080,
    0x0303, 0xc168,
    0x0302, 0x0003,
    0x0303, 0x0073,
    0x0302, 0x0080,
    0x0303, 0xc368,
    0x0302, 0x0083,
    0x0303, 0x4041,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x03c3,
    0x0302, 0x001b,
    0x0303, 0x036b,
    0x0302, 0x0097,
    0x0303, 0x0080,
    0x0302, 0x0020,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x007d,
    0x0302, 0x0021,
    0x0303, 0xc069,
    0x0302, 0x0003,
    0x0303, 0x4108,
    0x0302, 0x0029,
    0x0303, 0x0088,
    0x0302, 0x0000,
    0x0303, 0xc169,
    0x0302, 0x0083,
    0x0303, 0x4105,
    0x0302, 0x00a9,
    0x0303, 0x0088,
    0x0302, 0x0000,
    0x0303, 0x4183,
    0x0302, 0x0029,
    0x0303, 0xc369,
    0x0302, 0x0003,
    0x0303, 0x0088,
    0x0302, 0x0000,
    0x0303, 0x0064,
    0x0302, 0x00ba,
    0x0303, 0x035e,
    0x0302, 0x0097,
    0x0303, 0x0088,
    0x0302, 0x0041,
    0x0303, 0xc269,
    0x0302, 0x0091,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0368,
    0x0302, 0x0091,
    0x0303, 0x0369,
    0x0302, 0x0011,
    0x0303, 0x0304,
    0x0302, 0x0008,
    0x0303, 0xcb41,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0092,
    0x0302, 0x0080,
    0x0303, 0xcb00,
    0x0302, 0x0010,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0368,
    0x0302, 0x009b,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0302,
    0x0302, 0x0029,
    0x0303, 0x0099,
    0x0302, 0x0000,
    0x0303, 0xc941,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc042,
    0x0302, 0x0003,
    0x0303, 0x4104,
    0x0302, 0x008c,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x00d6,
    0x0302, 0x0080,
    0x0303, 0x4102,
    0x0302, 0x000e,
    0x0303, 0x00d6,
    0x0302, 0x0080,
    0x0303, 0xc142,
    0x0302, 0x0083,
    0x0303, 0x4102,
    0x0302, 0x002f,
    0x0303, 0xc242,
    0x0302, 0x0083,
    0x0303, 0x4103,
    0x0302, 0x0028,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x00a8,
    0x0302, 0x0080,
    0x0303, 0xc467,
    0x0302, 0x0003,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0342,
    0x0302, 0x001b,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0xcb68,
    0x0302, 0x0003,
    0x0303, 0xc969,
    0x0302, 0x0003,
    0x0303, 0x4103,
    0x0302, 0x00af,
    0x0303, 0xc968,
    0x0302, 0x0083,
    0x0303, 0xcb69,
    0x0302, 0x0083,
    0x0303, 0x4102,
    0x0302, 0x0029,
    0x0303, 0x00c6,
    0x0302, 0x0000,
    0x0303, 0x4104,
    0x0302, 0x008f,
    0x0303, 0x01ff,
    0x0302, 0x00ba,
    0x0303, 0x03ea,
    0x0302, 0x009b,
    0x0303, 0x00be,
    0x0302, 0x0021,
    0x0303, 0xf561,
    0x0302, 0x001f,
    0x0303, 0x03c1,
    0x0302, 0x0097,
    0x0303, 0x00be,
    0x0302, 0x00a0,
    0x0303, 0x03c0,
    0x0302, 0x0017,
    0x0303, 0x00c2,
    0x0302, 0x0020,
    0x0303, 0x00c6,
    0x0302, 0x0000,
    0x0303, 0xd541,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x00c7,
    0x0302, 0x0080,
    0x0303, 0xd541,
    0x0302, 0x0091,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x6867,
    0x0302, 0x0003,
    0x0303, 0x00c7,
    0x0302, 0x0080,
    0x0303, 0x6967,
    0x0302, 0x0083,
    0x0303, 0x0030,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0342,
    0x0302, 0x001b,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x4103,
    0x0302, 0x000a,
    0x0303, 0x2000,
    0x0302, 0x00ba,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x4103,
    0x0302, 0x008b,
    0x0303, 0x1000,
    0x0302, 0x00ba,
    0x0303, 0x0342,
    0x0302, 0x0003,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0341,
    0x0302, 0x001b,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0xcf00,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0342,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xd611,
    0x0302, 0x00ab,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0xc068,
    0x0302, 0x0083,
    0x0303, 0x15c7,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x000c,
    0x0302, 0x003a,
    0x0303, 0x5303,
    0x0302, 0x001d,
    0x0303, 0x03c1,
    0x0302, 0x009b,
    0x0303, 0x0367,
    0x0302, 0x0019,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0098,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x038a,
    0x0302, 0x000b,
    0x0303, 0x67c4,
    0x0302, 0x001e,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0303,
    0x0302, 0x002b,
    0x0303, 0xc941,
    0x0302, 0x0011,
    0x0303, 0x0341,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x4fc9,
    0x0302, 0x001c,
    0x0303, 0x034f,
    0x0302, 0x0083,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x034f,
    0x0302, 0x0091,
    0x0303, 0x0f4f,
    0x0302, 0x0002,
    0x0303, 0xee0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03c6,
    0x0302, 0x0011,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03ee,
    0x0302, 0x0003,
    0x0303, 0x9d0d,
    0x0302, 0x00ac,
    0x0303, 0xc075,
    0x0302, 0x0083,
    0x0303, 0x830c,
    0x0302, 0x000b,
    0x0303, 0xe80a,
    0x0302, 0x002e,
    0x0303, 0x5ec2,
    0x0302, 0x0017,
    0x0303, 0x010a,
    0x0302, 0x00c1,
    0x0303, 0x0000,
    0x0302, 0x0093,
    0x0303, 0xe243,
    0x0302, 0x001f,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x0900,
    0x0302, 0x003a,
    0x0303, 0x0372,
    0x0302, 0x0099,
    0x0303, 0xea03,
    0x0302, 0x0097,
    0x0303, 0x010b,
    0x0302, 0x0041,
    0x0303, 0xc175,
    0x0302, 0x0003,
    0x0303, 0x7591,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x1090,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x536a,
    0x0302, 0x0003,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0xc853,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x411c,
    0x0302, 0x002a,
    0x0303, 0x01d8,
    0x0302, 0x00e0,
    0x0303, 0x15c4,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x8410,
    0x0302, 0x002a,
    0x0303, 0x5384,
    0x0302, 0x0088,
    0x0303, 0xd743,
    0x0302, 0x001f,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x40ce,
    0x0302, 0x001b,
    0x0303, 0x0367,
    0x0302, 0x0097,
    0x0303, 0x012d,
    0x0302, 0x00a1,
    0x0303, 0x67c9,
    0x0302, 0x001c,
    0x0303, 0x0367,
    0x0302, 0x0091,
    0x0303, 0x0340,
    0x0302, 0x0083,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x6740,
    0x0302, 0x0006,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x400f,
    0x0302, 0x001f,
    0x0303, 0x03c6,
    0x0302, 0x009c,
    0x0303, 0x0309,
    0x0302, 0x002b,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc800,
    0x0302, 0x0010,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x013a,
    0x0302, 0x0080,
    0x0303, 0xd740,
    0x0302, 0x0083,
    0x0303, 0x15a0,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x001f,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x009b,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x15a1,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x5368,
    0x0302, 0x0083,
    0x0303, 0x15a2,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c9,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x4102,
    0x0302, 0x00ab,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x003f,
    0x0302, 0x003a,
    0x0303, 0x0369,
    0x0302, 0x001b,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x1090,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xe0c0,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x001b,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x67c8,
    0x0302, 0x009c,
    0x0303, 0x036a,
    0x0302, 0x0011,
    0x0303, 0x0369,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x108f,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6769,
    0x0302, 0x0019,
    0x0303, 0x0f6a,
    0x0302, 0x0082,
    0x0303, 0x03c2,
    0x0302, 0x001c,
    0x0303, 0x036a,
    0x0302, 0x0099,
    0x0303, 0x0f6a,
    0x0302, 0x0082,
    0x0303, 0x68c3,
    0x0302, 0x001c,
    0x0303, 0x036a,
    0x0302, 0x0099,
    0x0303, 0x0f6a,
    0x0302, 0x0082,
    0x0303, 0x01db,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x0194,
    0x0302, 0x003a,
    0x0303, 0x036a,
    0x0302, 0x0017,
    0x0303, 0x016d,
    0x0302, 0x0041,
    0x0303, 0xc767,
    0x0302, 0x0003,
    0x0303, 0x017c,
    0x0302, 0x0000,
    0x0303, 0x01ae,
    0x0302, 0x003a,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x015c,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0017,
    0x0303, 0x0174,
    0x0302, 0x00c1,
    0x0303, 0xc667,
    0x0302, 0x0083,
    0x0303, 0x017c,
    0x0302, 0x0000,
    0x0303, 0x0181,
    0x0302, 0x00ba,
    0x0303, 0xe802,
    0x0302, 0x000b,
    0x0303, 0x013c,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0017,
    0x0303, 0x017b,
    0x0302, 0x00c1,
    0x0303, 0xc567,
    0x0302, 0x0083,
    0x0303, 0x017c,
    0x0302, 0x0000,
    0x0303, 0xc467,
    0x0302, 0x0003,
    0x0303, 0x67c4,
    0x0302, 0x009c,
    0x0303, 0x03c8,
    0x0302, 0x0091,
    0x0303, 0x03c8,
    0x0302, 0x001c,
    0x0303, 0x0368,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0x1010,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc653,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x9a33,
    0x0302, 0x000c,
    0x0303, 0x9d29,
    0x0302, 0x0009,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0808,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x4105,
    0x0302, 0x00af,
    0x0303, 0x1010,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc753,
    0x0302, 0x0083,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1580,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1581,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1588,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc353,
    0x0302, 0x0003,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x15a4,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc153,
    0x0302, 0x0083,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x0f00,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0404,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0202,
    0x0302, 0x003a,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x01c4,
    0x0302, 0x0060,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x01c3,
    0x0302, 0x0080,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x01cc,
    0x0302, 0x0080,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x01d3,
    0x0302, 0x0000,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x01cc,
    0x0302, 0x0080,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xd568,
    0x0302, 0x0003,
    0x0303, 0x01da,
    0x0302, 0x0000,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x6d68,
    0x0302, 0x0003,
    0x0303, 0x6700,
    0x0302, 0x0010,
    0x0303, 0x0387,
    0x0302, 0x001b,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0384,
    0x0302, 0x0011,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0010,
    0x0303, 0x0375,
    0x0302, 0x009b,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x01df,
    0x0302, 0x0021,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0387,
    0x0302, 0x0011,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x00aa,
    0x0302, 0x003a,
    0x0303, 0x03b8,
    0x0302, 0x001b,
    0x0303, 0x000a,
    0x0302, 0x00a0,
    0x0303, 0x00d2,
    0x0302, 0x0000,
    0x0303, 0xc04e,
    0x0302, 0x0003,
    0x0303, 0x9c05,
    0x0302, 0x003a,
    0x0303, 0x0207,
    0x0302, 0x005a,
    0x0303, 0x038a,
    0x0302, 0x0083,
    0x0303, 0xf289,
    0x0302, 0x0003,
    0x0303, 0xb603,
    0x0302, 0x00ab,
    0x0303, 0x9981,
    0x0302, 0x002b,
    0x0303, 0x0181,
    0x0302, 0x0080,
    0x0303, 0xb60f,
    0x0302, 0x001f,
    0x0303, 0x030c,
    0x0302, 0x0028,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x1000,
    0x0302, 0x00da,
    0x0303, 0x03b6,
    0x0302, 0x009b,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x9d0f,
    0x0302, 0x001f,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0x000f,
    0x0302, 0x0000,
    0x0303, 0x03c1,
    0x0302, 0x009d,
    0x0303, 0x032a,
    0x0302, 0x00a8,
    0x0303, 0x0307,
    0x0302, 0x0029,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0308,
    0x0302, 0x00a8,
    0x0303, 0x031e,
    0x0302, 0x00a9,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x031e,
    0x0302, 0x0028,
    0x0303, 0x0010,
    0x0302, 0x0080,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xd568,
    0x0302, 0x0003,
    0x0303, 0x002d,
    0x0302, 0x0000,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0x6d68,
    0x0302, 0x0003,
    0x0303, 0x6700,
    0x0302, 0x0010,
    0x0303, 0x0387,
    0x0302, 0x001b,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x7572,
    0x0302, 0x0083,
    0x0303, 0x0016,
    0x0302, 0x00ba,
    0x0303, 0x8403,
    0x0302, 0x001d,
    0x0303, 0x0384,
    0x0302, 0x0011,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x6800,
    0x0302, 0x0010,
    0x0303, 0x0375,
    0x0302, 0x009b,
    0x0303, 0x0384,
    0x0302, 0x0003,
    0x0303, 0x8475,
    0x0302, 0x0083,
    0x0303, 0x720f,
    0x0302, 0x009f,
    0x0303, 0x0375,
    0x0302, 0x0097,
    0x0303, 0x0032,
    0x0302, 0x00a1,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0387,
    0x0302, 0x0011,
    0x0303, 0x0387,
    0x0302, 0x0003,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x849d,
    0x0302, 0x0083,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x1892,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0083,
    0x0303, 0x0033,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0xc267,
    0x0302, 0x0003,
    0x0303, 0xb60f,
    0x0302, 0x001f,
    0x0303, 0x03c9,
    0x0302, 0x001d,
    0x0303, 0x0347,
    0x0302, 0x0003,
    0x0303, 0xc85a,
    0x0302, 0x0083,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0307,
    0x0302, 0x00a8,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x030a,
    0x0302, 0x00a9,
    0x0303, 0x030d,
    0x0302, 0x00a8,
    0x0303, 0x4712,
    0x0302, 0x00a9,
    0x0303, 0x4717,
    0x0302, 0x0028,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0xc35c,
    0x0302, 0x0003,
    0x0303, 0x0009,
    0x0302, 0x003a,
    0x0303, 0x0359,
    0x0302, 0x0003,
    0x0303, 0xc05b,
    0x0302, 0x0083,
    0x0303, 0x0074,
    0x0302, 0x0000,
    0x0303, 0xc15c,
    0x0302, 0x0083,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x0074,
    0x0302, 0x0000,
    0x0303, 0x5ac1,
    0x0302, 0x0091,
    0x0303, 0x035a,
    0x0302, 0x0003,
    0x0303, 0xc35c,
    0x0302, 0x0003,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x0074,
    0x0302, 0x0000,
    0x0303, 0x5ac2,
    0x0302, 0x0091,
    0x0303, 0x035a,
    0x0302, 0x0003,
    0x0303, 0xc75c,
    0x0302, 0x0083,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x0074,
    0x0302, 0x0000,
    0x0303, 0x5ac3,
    0x0302, 0x0011,
    0x0303, 0x035a,
    0x0302, 0x0003,
    0x0303, 0xc75c,
    0x0302, 0x0083,
    0x0303, 0xc659,
    0x0302, 0x0003,
    0x0303, 0xd55b,
    0x0302, 0x0003,
    0x0303, 0x0074,
    0x0302, 0x0000,
    0x0303, 0x1823,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0156,
    0x0302, 0x00e0,
    0x0303, 0xcc00,
    0x0302, 0x0090,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x0359,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x5c0f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x001c,
    0x0303, 0x035a,
    0x0302, 0x0011,
    0x0303, 0x03db,
    0x0302, 0x0003,
    0x0303, 0x1821,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0156,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xd500,
    0x0302, 0x0010,
    0x0303, 0x0353,
    0x0302, 0x001b,
    0x0303, 0x035b,
    0x0302, 0x0091,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x0368,
    0x0302, 0x0097,
    0x0303, 0x00c8,
    0x0302, 0x0020,
    0x0303, 0x182a,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x4703,
    0x0302, 0x000c,
    0x0303, 0x0047,
    0x0302, 0x003a,
    0x0303, 0x0093,
    0x0302, 0x0000,
    0x0303, 0x0020,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x470e,
    0x0302, 0x008c,
    0x0303, 0x013a,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0127,
    0x0302, 0x00ba,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0x0117,
    0x0302, 0x00ba,
    0x0303, 0x0369,
    0x0302, 0x0003,
    0x0303, 0x013f,
    0x0302, 0x00ba,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x012f,
    0x0302, 0x003a,
    0x0303, 0x0375,
    0x0302, 0x0083,
    0x0303, 0x0127,
    0x0302, 0x00ba,
    0x0303, 0x0372,
    0x0302, 0x0003,
    0x0303, 0x00ab,
    0x0302, 0x0080,
    0x0303, 0x018f,
    0x0302, 0x003a,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x015f,
    0x0302, 0x00ba,
    0x0303, 0x0368,
    0x0302, 0x0083,
    0x0303, 0xc069,
    0x0302, 0x0003,
    0x0303, 0x536a,
    0x0302, 0x0003,
    0x0303, 0x6875,
    0x0302, 0x0003,
    0x0303, 0xc072,
    0x0302, 0x0003,
    0x0303, 0x1841,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x1840,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6853,
    0x0302, 0x0083,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x183f,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6953,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x1846,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x6a53,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x1845,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x7553,
    0x0302, 0x0083,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x1844,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x7253,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x6780,
    0x0302, 0x0003,
    0x0303, 0x00c6,
    0x0302, 0x003a,
    0x0303, 0x0f07,
    0x0302, 0x0002,
    0x0303, 0x0173,
    0x0302, 0x0000,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0xc280,
    0x0302, 0x0003,
    0x0303, 0x0530,
    0x0302, 0x003a,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x016c,
    0x0302, 0x00e0,
    0x0303, 0x6780,
    0x0302, 0x0003,
    0x0303, 0x3e41,
    0x0302, 0x00ba,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x016c,
    0x0302, 0x00e0,
    0x0303, 0x8388,
    0x0302, 0x000b,
    0x0303, 0x0015,
    0x0302, 0x0080,
    0x0303, 0x4e0f,
    0x0302, 0x009f,
    0x0303, 0x0305,
    0x0302, 0x00a9,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0305,
    0x0302, 0x0028,
    0x0303, 0x0322,
    0x0302, 0x00a9,
    0x0303, 0x00d2,
    0x0302, 0x0000,
    0x0303, 0x4b47,
    0x0302, 0x0003,
    0x0303, 0x00f8,
    0x0302, 0x0080,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x030c,
    0x0302, 0x0028,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x030e,
    0x0302, 0x0029,
    0x0303, 0x0312,
    0x0302, 0x0028,
    0x0303, 0x4714,
    0x0302, 0x00a9,
    0x0303, 0x4701,
    0x0302, 0x00a8,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0303,
    0x0302, 0x0088,
    0x0303, 0xc947,
    0x0302, 0x0003,
    0x0303, 0x00f8,
    0x0302, 0x0080,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0303,
    0x0302, 0x0009,
    0x0303, 0xc847,
    0x0302, 0x0083,
    0x0303, 0x00f8,
    0x0302, 0x0080,
    0x0303, 0x460f,
    0x0302, 0x001f,
    0x0303, 0x03c2,
    0x0302, 0x009d,
    0x0303, 0x0303,
    0x0302, 0x0088,
    0x0303, 0xc447,
    0x0302, 0x0083,
    0x0303, 0x00f8,
    0x0302, 0x0080,
    0x0303, 0x4603,
    0x0302, 0x0089,
    0x0303, 0xc247,
    0x0302, 0x0083,
    0x0303, 0x00f8,
    0x0302, 0x0080,
    0x0303, 0x4692,
    0x0302, 0x0088,
    0x0303, 0xc147,
    0x0302, 0x0083,
    0x0303, 0x00f8,
    0x0302, 0x0080,
    0x0303, 0xcc0f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x0382,
    0x0302, 0x0011,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0156,
    0x0302, 0x00e0,
    0x0303, 0x530f,
    0x0302, 0x009f,
    0x0303, 0x03cf,
    0x0302, 0x001b,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03c2,
    0x0302, 0x0091,
    0x0303, 0x036a,
    0x0302, 0x0003,
    0x0303, 0x0162,
    0x0302, 0x0060,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0302,
    0x0302, 0x00a8,
    0x0303, 0x0116,
    0x0302, 0x0000,
    0x0303, 0x9d04,
    0x0302, 0x0009,
    0x0303, 0x0800,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x0119,
    0x0302, 0x0000,
    0x0303, 0x0400,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x0119,
    0x0302, 0x0000,
    0x0303, 0x0200,
    0x0302, 0x00ba,
    0x0303, 0x0367,
    0x0302, 0x0083,
    0x0303, 0x0119,
    0x0302, 0x0000,
    0x0303, 0x1004,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0156,
    0x0302, 0x00e0,
    0x0303, 0x670f,
    0x0302, 0x001f,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x1003,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x0302,
    0x0302, 0x00a8,
    0x0303, 0x012c,
    0x0302, 0x0000,
    0x0303, 0x9d03,
    0x0302, 0x0089,
    0x0303, 0xc80f,
    0x0302, 0x001f,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0xc20f,
    0x0302, 0x001f,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0xc10f,
    0x0302, 0x001f,
    0x0303, 0x012e,
    0x0302, 0x0080,
    0x0303, 0x0300,
    0x0302, 0x0090,
    0x0303, 0x03c9,
    0x0302, 0x009c,
    0x0303, 0x03ce,
    0x0302, 0x0091,
    0x0303, 0x0382,
    0x0302, 0x001b,
    0x0303, 0x0382,
    0x0302, 0x0003,
    0x0303, 0x470f,
    0x0302, 0x009f,
    0x0303, 0x03c4,
    0x0302, 0x009d,
    0x0303, 0x030b,
    0x0302, 0x0008,
    0x0303, 0x9d0a,
    0x0302, 0x0089,
    0x0303, 0x15a5,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0xc053,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x0f00,
    0x0302, 0x003a,
    0x0303, 0x039d,
    0x0302, 0x009b,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x4703,
    0x0302, 0x000c,
    0x0303, 0x4575,
    0x0302, 0x0003,
    0x0303, 0x0147,
    0x0302, 0x0080,
    0x0303, 0x4703,
    0x0302, 0x008b,
    0x0303, 0x4475,
    0x0302, 0x0083,
    0x0303, 0x0147,
    0x0302, 0x0080,
    0x0303, 0x4375,
    0x0302, 0x0003,
    0x0303, 0x108f,
    0x0302, 0x003a,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x75c9,
    0x0302, 0x009d,
    0x0303, 0x0353,
    0x0302, 0x0003,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x1090,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x7553,
    0x0302, 0x0083,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x0199,
    0x0302, 0x0080,
    0x0303, 0x520f,
    0x0302, 0x001f,
    0x0303, 0x0358,
    0x0302, 0x009b,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x53b5,
    0x0302, 0x0083,
    0x0303, 0x0159,
    0x0302, 0x0080,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0352,
    0x0302, 0x0091,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x52b4,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0xb581,
    0x0302, 0x002f,
    0x0303, 0xb502,
    0x0302, 0x00aa,
    0x0303, 0x0160,
    0x0302, 0x0080,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0159,
    0x0302, 0x0080,
    0x0303, 0xb553,
    0x0302, 0x0086,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0xd100,
    0x0302, 0x0090,
    0x0303, 0x03b6,
    0x0302, 0x0083,
    0x0303, 0x6a0f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0xe802,
    0x0302, 0x008a,
    0x0303, 0x0354,
    0x0302, 0x0091,
    0x0303, 0x03b7,
    0x0302, 0x0003,
    0x0303, 0xb600,
    0x0302, 0x002f,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x0386,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x00e1,
    0x0303, 0x1033,
    0x0302, 0x00ba,
    0x0303, 0x0f52,
    0x0302, 0x0002,
    0x0303, 0x0156,
    0x0302, 0x00e0,
    0x0303, 0x8000,
    0x0302, 0x00ba,
    0x0303, 0x0353,
    0x0302, 0x0011,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0x5853,
    0x0302, 0x009b,
    0x0303, 0x0f53,
    0x0302, 0x0082,
    0x0303, 0x0151,
    0x0302, 0x0060,
    0x0303, 0xf906,
    0x0302, 0x003a,
    0x0303, 0x03d1,
    0x0302, 0x0011,
    0x0303, 0x016c,
    0x0302, 0x00e0,
    0x0303, 0x0000,
    0x0302, 0x0081,
    0x0303, 0xc7ee,
    0x0302, 0x0083,
    0x0303, 0x9905,
    0x0302, 0x00aa,
    0x0303, 0x9947,
    0x0302, 0x001b,
    0x0303, 0x018f,
    0x0302, 0x00a0,
    0x0303, 0x03c7,
    0x0302, 0x009b,
    0x0303, 0x018f,
    0x0302, 0x0021,
    0x0303, 0xe808,
    0x0302, 0x000e,
    0x0303, 0xc067,
    0x0302, 0x0083,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0xc167,
    0x0302, 0x0003,
    0x0303, 0xc100,
    0x0302, 0x0010,
    0x0303, 0x03e8,
    0x0302, 0x001b,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0000,
    0x0303, 0xc24e,
    0x0302, 0x0083,
    0x0303, 0x8004,
    0x0302, 0x0088,
    0x0303, 0x8302,
    0x0302, 0x008b,
    0x0303, 0x0194,
    0x0302, 0x0000,
    0x0303, 0xc14e,
    0x0302, 0x0083,
    0x0303, 0xc367,
    0x0302, 0x0083,
    0x0303, 0xe80f,
    0x0302, 0x009f,
    0x0303, 0x03c1,
    0x0302, 0x0091,
    0x0303, 0x03e8,
    0x0302, 0x0003,
    0x0303, 0x019b,
    0x0302, 0x0000,
    0x0303, 0xee67,
    0x0302, 0x0083,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x6791,
    0x0302, 0x0003,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x0303, 0x0000,
    0x0302, 0x0042,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8000,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8001,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8002,
    0x1222, 0x0005,
    0x1221, 0x4818,
    0x1220, 0x8003,
    0x1222, 0x000b,
    0x1221, 0x4818,
    0x1220, 0x8004,
    0x1222, 0x0017,
    0x1221, 0x4820,
    0x1220, 0x8005,
    0x1222, 0x001f,
    0x1221, 0x0000,
    0x1220, 0x8006,
    0x1222, 0x0010,
    0x1221, 0x0000,
    0x1220, 0x8007,
    0x1222, 0x0010,
    0x1221, 0x0000,
    0x1220, 0x8008,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8009,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800a,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800b,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800c,
    0x1222, 0x0028,
    0x1221, 0x0000,
    0x1220, 0x800d,
    0x1222, 0x0001,
    0x1221, 0x0000,
    0x1220, 0x800e,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x800f,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8010,
    0x1222, 0x0a60,
    0x1221, 0x8000,
    0x1220, 0x8011,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8012,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8013,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8014,
    0x1222, 0x001e,
    0x1221, 0x0000,
    0x1220, 0x8015,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8016,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8017,
    0x1222, 0x7fff,
    0x1221, 0x0000,
    0x1220, 0x8018,
    0x1222, 0x0003,
    0x1221, 0x0000,
    0x1220, 0x8019,
    0x1222, 0x0003,
    0x1221, 0x0000,
    0x1220, 0x801a,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x801b,
    0x1222, 0x0003,
    0x1221, 0x0000,
    0x1220, 0x801c,
    0x1222, 0x0400,
    0x1221, 0x0000,
    0x1220, 0x801d,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x801e,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x801f,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8020,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8021,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8022,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8023,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8024,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8025,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8026,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8027,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8028,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8029,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x802a,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x802b,
    0x1222, 0x0f70,
    0x1221, 0x8000,
    0x1220, 0x802c,
    0x1222, 0x0100,
    0x1221, 0x0000,
    0x1220, 0x802d,
    0x1222, 0x007f,
    0x1221, 0x0000,
    0x1220, 0x802e,
    0x1222, 0x0040,
    0x1221, 0x8000,
    0x1220, 0x802f,
    0x1222, 0x0001,
    0x1221, 0x0000,
    0x1220, 0x8030,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8031,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8032,
    0x1222, 0x00fa,
    0x1221, 0x0000,
    0x1220, 0x8033,
    0x1222, 0x00d2,
    0x1221, 0x0000,
    0x1220, 0x8034,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8035,
    0x1222, 0x02aa,
    0x1221, 0x0000,
    0x1220, 0x8036,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8037,
    0x1222, 0x0014,
    0x1221, 0x8000,
    0x1220, 0x8038,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x8039,
    0x1222, 0x47ab,
    0x1221, 0x0000,
    0x1220, 0x803a,
    0x1222, 0x0554,
    0x1221, 0x0000,
    0x1220, 0x803b,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x803c,
    0x1222, 0x03ff,
    0x1221, 0x0000,
    0x1220, 0x803d,
    0x1222, 0x1fff,
    0x1221, 0x8000,
    0x1220, 0x803e,
    0x1222, 0x0000,
    0x1221, 0x0000,
    0x1220, 0x803f,
    0x102f, 0xc0f0,
    0x1000, 0x0000,
    0x100b, 0xf182,
    0x1001, 0x0000,
    0x1007, 0x0004,
    0x1228, 0x0000,
    0x1235, 0x0000,
    0x1a35, 0x0000,
    0x1327, 0x0000,
    0x132b, 0x0000,
    0x0003, 0x0001,
    0x0004, 0x0001,
    0x0005, 0x0001,
    0x0006, 0x0001,
    0x0007, 0x0001,
    0x0301, 0x0000,
    0x1320, 0x0000,
    0x1324, 0x0000,
    0x1328, 0x0000,
    0x0017, 0x0040,
    0x1238, 0x0003,
    0x1a38, 0x0003,
    0x1249, 0x0001,
    0x1343, 0x0006,
    0x1262, 0x007f,
    0x1263, 0x007f,
    0x1264, 0x007f,
    0x1248, 0x8100,
    0x1247, 0x8010,
    0x1268, 0x0002,
    0x1282, 0x0005,
    0x1288, 0x3000,
    0x124c, 0x8001,
    0x1298, 0x0003,
    0x1245, 0x8c0f,
    0x10aa, 0xff5d,
    0x1265, 0x001e,
    0x1027, 0x00dd,
    0x12b1, 0x0000,
    0x1a98, 0x0003,
    0x18ae, 0x0441,
    0x18a1, 0x0004,
    0x18a7, 0xdfff,
    0x18a6, 0x000d,
    0x1a45, 0x8c0f,
    0x18aa, 0xff5d,
    0x1a34, 0x0002,
    0x1a5e, 0x0000,
    0x1a5f, 0x0700,
    0x1a49, 0x0001,
    0x1b43, 0x0006,
    0x1a65, 0x001e,
    0x1a62, 0x007f,
    0x1a63, 0x007f,
    0x1a64, 0x007f,
    0x1a48, 0x8100,
    0x1a47, 0x8010,
    0x1a68, 0x0002,
    0x1a82, 0x0014,
    0x1a4c, 0x8001,
    0x1827, 0x00dd,
    0x1a35, 0x01f7,
    0x1ab1, 0x0000,
    0x0017, 0x0000,
    0x000a, 0x1557,
    0x0009, 0x2015,
    0x0008, 0x0702,
    0x0005, 0x0000,
    0x0007, 0x0003,
    0x0011, 0x0000,
    0x0014, 0x2de7,
    0x0017, 0x0000,
};

unsigned int cs4224_fc_ucode_image_length = sizeof(cs4224_fc_ucode_image)/sizeof(cs4224_fc_ucode_image[0]);

#endif /* !CS_SKIP_UCODE_DOWNLOAD */

/** @file cs4224.c
 ****************************************************************************
 *
 * @brief
 *    This module describes the high level API methods provided by the
 *    K2 API.
 *
 ****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ***************************************************************************/

#define CS_HAS_INLINE_UCODE 1

#if defined(CS_HAS_INLINE_UCODE)

#endif

/* defined in cs4224_diags.c */
extern cs_uint16 g_cs4224_simplex_valid_mate_slice[];
cs_boolean cs4224_diags_register_can_read(cs_uint16 addr);

/*============================================================
 * Static state maintained by the API
 *============================================================*/
static e_cs4224_hardware_id cs4224_sku_hw_id = CS4224_HW_UNDEF;

cs4224_switch_pair_state_t g_cs4224_switch_pair_state[CS4224_MAX_NUM_CS4224_PORTS/2] = 
{
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
    {FALSE, FALSE, {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},0},
};

/**
 * The delay used when stalling the microsequencer to manage
 * waiting for internal timers to expire
 */
int g_cs4224_mseq_stall_delay_us = 100;

void cs4224_diags_reset_static_state(cs_uint32 slice);

/**
 * Reset any static state stored by the API.
 *
 * @param slice [I] - The slice of the device to reset any static state.
 *
 */
void cs4224_reset_static_state_for_slice(cs_uint32 slice)
{
    cs4224_diags_reset_static_state(slice);

    g_cs4224_switch_pair_state[(slice&0x6)/2].initialized  = FALSE;
}

/**
 * Reset the entire static state stored by the API for
 * all slices of the device.
 * 
 * @deprecated Use the cs4224_reset_die_static_state() method instead
 *             as this one does not support multiple ASICs, or systems
 *             without a valid address on die 0x00000000
 */
void cs4224_reset_static_state(void)
{
    cs4224_reset_die_static_state(0);
}

/**
 * Reset the entire static state stored by the API for
 * all slices of the device.
 * 
 * Note: The API by default only supports one type of ASIC at a time, but multiple ASICs.
 *   So you can have 2 CS4343 or 2 CS4224, but not 1 CS4343 and 1 CS4224. 
 *   As a workaround for this, we made this method in order to have two types of
 *   ASICs at once. This method can be used before switching to another ASIC by 
 *   resetting the cached hardware id, switch state, etc. Run this method EVERY
 *   time you want to switch (see example below).
 * 
 * @param die [I] - The die of the device to reset to static state
 *                  Only the upper bits are used (0xFFFFFF00)
 *
 * @return None
 * 
 * @example
 * //read from slice 10 of EDC1, a CS4224 16P simplex
 * // (how you handle the upper bits of slice in reg_set and reg_get is up to you)
 * slice = 0x010a;
 * cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP0, &data);
 * //now we want to read from EDC2, a CS4343, so reset cached state from EDC1
 * cs4224_reset_die_static_state(0x0100); //0x0100 is important here!
 * //read from slice 4 of EDC2, a CS4343 8P duplex
 * slice = 0x0204;
 * cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP0, &data2);
 */
void cs4224_reset_die_static_state(cs_uint32 die)
{
    cs_uint32 upper_bits = die & 0xFFFFFF00;
    cs_uint32 slice;

    for(slice = upper_bits; (slice&0xFF) < CS4224_MAX_NUM_SLICES(die); slice++)
    {
        cs4224_reset_static_state_for_slice(slice);
    }

    /* this forces the cached hw_id to be re-initialized */
    cs4224_sku_hw_id = CS4224_HW_UNDEF;

}

/**
 * This is an internal method used to program the API version
 * number in one of the scratch registers to that it can be
 * identified through register dumps
 *
 * @param slice [I] - The slice of the device to program.
 *
 * @return CS_OK On success, CS_ERROR on failure
 */
cs_status cs4224_init_api_version(cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs_uint16 api_version;
    
    /* Program the API version number */
    api_version = (CS_API_VERSION_MAJOR & 0xF);
    api_version <<= 4;
    api_version |= (CS_API_VERSION_MINOR & 0xF);
    api_version <<= 8;
    api_version |= CS_API_VERSION_UPDATE;
    status |= cs4224_reg_set_channel(slice, CS4224_GLOBAL_SCRATCH7, api_version);

    return status;
}

cs_uint32 cs4224_max_num_ports = 0;
cs_uint32 cs4224_max_num_dies  = 0;

/* Get the h/w ID */
e_cs4224_hardware_id cs4224_hw_id(
    cs_uint32 slice);

/**
 * Query the number of ports supported on this h/w. This
 * returns different values depending on the underlying
 * h/w.
 *
 * @return The number of ports/slices/channels supported
 *         on this h/w.
 *
 * @deprecated The CS4224_MAX_NUM_SLICES() method should
 *             be used instead of this method as it properly
 *             supports multiple ASICs. It will currently
 *             set the upper 24 bits of the die parameter
 *             for accessing multiple ASICs to 0 when calling
 *             cs4224_reg_get() to read the SKU
 */
cs_uint32 CS4224_MAX_NUM_PORTS(void)
{
    return CS4224_MAX_NUM_SLICES(0);
}

/**
 * Query the number of ports supported on this h/w. This
 * accesses the SKU ID stored with the h/w and returns
 * different values depending on the underlying
 * h/w. The slice parameter can be any slice on the
 * ASIC being accessed. The upper 24 bits of this parameter
 * are required in order to differentiate between
 * multiple ASICs.
 *
 * This method replaces the CS4224_MAX_NUM_PORTS()
 * method which cannot properly reference multiple
 * ASICs.
 *
 * @param slice [I] - Pass any slice on the target device
 *                    in order to determine the number of
 *                    slices/ports/channels supported. The
 *                    upper 24 bits of this parameter are used
 *                    to address multiple ASICs. This
 *                    gets passed down through the API to
 *                    the cs4224_reg_get() and cs4224_reg_set()
 *                    calls.
 *
 * @return The number of ports/slices/channels supported
 *         on this h/w.
 */
cs_uint32 CS4224_MAX_NUM_SLICES(cs_uint32 slice)
{
    /* Determine the h/w ID in order to
     * initialize the number of ports */
    cs4224_hw_id(slice);
    
    /* Now that the number of ports has been identified
     * just return the initialized value */
    return cs4224_max_num_ports;
}

/**
 * Query the number of dies on this h/w. This
 * accesses the SKU ID stored with the h/w and returns
 * different values depending on the underlying
 * h/w. The slice parameter can be any slice on the
 * ASIC being accessed. The upper 24 bits of this parameter
 * are required in order to differentiate between
 * multiple ASICs.
 *
 * @param slice [I] - Pass any slice on the target device
 *                    in order to determine the number of
 *                    dies present in the package. The
 *                    upper 24 bits of this parameter are used
 *                    to address multiple ASICs. This
 *                    gets passed down through the API to
 *                    the cs4224_reg_get() and cs4224_reg_set()
 *                    calls.
 *
 * @return The number of dies supported on this h/w
 *
 */
cs_uint32 CS4224_MAX_NUM_DIES(cs_uint32 slice)
{
    /* Determine the h/w ID in order to
     * initialize the number of dies */
    cs4224_hw_id(slice);
    
    /* Now that the number of dies has been identified
     * just return the initialized value */
    return cs4224_max_num_dies;
}

cs4224_callback_lock   g_cs4224_callback_lock   = NULL;
cs4224_callback_unlock g_cs4224_callback_unlock = NULL;

/**
 * Setup a callback method to support h/w locking. Hardware
 * locks, if required, must currently be implemented as recursive
 * or counting locks as the API may attempt to obtain the same lock
 * twice in child function calls.
 *
 * Setting up hardware locking is optional. It will be disabled
 * by default.
 *
 * Locking is not functional in this release and should be
 * not be implemented until testing is completed to prevent
 * deadlock.
 *
 * @param callback [I] - Pointer to the callback function to
 *                       call to lock access to the h/w.
 *
 * @return None
 */
void cs4224_set_callback_for_lock(cs4224_callback_lock callback)
{
    g_cs4224_callback_lock = callback;
}

/**
 * Setup a callback method to support h/w unlocking. Hardware
 * locks, if required, must currently be implemented as recursive
 * or counting locks as the API may attempt to obtain the same lock
 * twice in child function calls.
 *
 * Setting up hardware locking is optional. It will be disabled
 * by default.
 *
 * Locking is not functional in this release and should be
 * not be implemented until testing is completed to prevent
 * deadlock.
 *
 * @param callback [I] - Pointer to the callback function to
 *                       call to lock access to the h/w.
 *
 * @return None
 */
void cs4224_set_callback_for_unlock(cs4224_callback_unlock callback)
{
    g_cs4224_callback_unlock = callback;
}

/**
 * Lock the hardware for exclusive access. If hardware locking
 * has not been enabled then these methods silently return.
 *
 * @param slice [I] - The slice or port of the device to access.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @see cs4224_set_callback_for_lock, cs4224_set_callback_for_unlock
 */
cs_status cs4224_lock(
    cs_uint32 slice)
{
    if(g_cs4224_callback_lock == NULL)
    {
        return CS_OK;
    }

    return g_cs4224_callback_lock(slice);
}

/**
 * Unlock the hardware for exclusive access. If hardware locking
 * has not been enabled then these methods silently return.
 *
 * @param slice [I] - The slice or port of the device to access.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @see cs4224_set_callback_for_lock, cs4224_set_callback_for_unlock
 */
cs_status cs4224_unlock(
    cs_uint32 slice)
{
    if(g_cs4224_callback_unlock == NULL)
    {
        return CS_OK;
    }
    return g_cs4224_callback_unlock(slice);
}

/**
 * This method is called to retrieve the hardware ID of the
 * ASIC. The hardware ID can be one of:
 * 
 * - CS4224_HW_UNDEF  (undefined)    
 * - CS4224_HW_CS4223 (4 port duplex)
 * - CS4224_HW_CS4224 (16 port simplex)
 * - CS4224_HW_CS4343 (8 port duplex) 
 * - CS4224_HW_CS4221 (10 port simplex)
 * - CS4224_HW_CS4227 (2 port duplex)
 * - CS4224_HW_CS4210 (16 port simplex, 15G only)
 * - CS4224_HW_CS4341 (8 port duplex, 10G only) 
 * 
 * @param slice [I] - The slice of the device to retrieve the ID for.
 *
 * @return The HW ID number of the ASIC.
 */
e_cs4224_hardware_id cs4224_hw_id(
    cs_uint32 slice)
{
    if(CS4224_HW_UNDEF == cs4224_sku_hw_id)
    {
        cs_uint16 sku;
        cs_status status = CS_OK;

        cs4224_lock(slice);

        status |= cs4224_reg_get(0 | (slice & 0xffffff00), CS4224_EFUSE_PDF_SKU, &sku);

        cs4224_unlock(slice);

        if (status != CS_OK)
        {
            /* This just means that the upper bits of slice are not valid, handle with care */
            CS_TRACE(("WARNING: Could not read SKU, setting to 0x0000\n"));
            sku = 0x0000;
        }
        
        /* clear SKU bits [15:5] and [3] */ 
        sku &= 0x0017;

        /* If the EFUSE is not programmed then default to CS4343.
         * Bit 5 will be set to 1 if the EFUSE is programmed. If it
         * is not programmed it will 0. */
        if((sku & 0x10) != 0x10)
        {
            cs_uint16 chip_id;

            /* Try reading the ASIC ID from the second die. If it returns
             * a non valid value then assume this is a 4D part. If it is a 4D
             * part then the ASIC ID should return 0xffff. A value of 0
             * probably means that we're running CS Explorer in offline mode. */
            status |= cs4224_reg_get(1 | (slice & 0xffffff00), CS4224_GLOBAL_CHIP_ID_MSB, &chip_id);
            
            if(chip_id == 0 || chip_id == 0x3e5)
            {
                /* SKU must be cs4343 or if undefined we default to 8 port duplex */
                CS_TRACE(("WARNING: EFUSE Not programmed, defaulting to CS4343 8P Duplex\n"));

                cs4224_sku_hw_id = CS4224_HW_CS4343;
                cs4224_max_num_ports = CS4224_MAX_NUM_CS4343_PORTS;
                cs4224_max_num_dies  = CS4224_MAX_NUM_CS4343_DIES;
            }
            else
            {
                CS_TRACE(("WARNING: EFUSE Not programmed, defaulting to CS4223 4P Duplex\n"));

                cs4224_sku_hw_id = CS4224_HW_CS4223;
                cs4224_max_num_ports = CS4224_MAX_NUM_CS4223_PORTS;
                cs4224_max_num_dies  = CS4224_MAX_NUM_CS4223_DIES;
            }
        }
        /* Otherwise check what SKU is programmed */
        else
        {
            switch (sku)
            {
                case CS4224_HW_CS4223:
                    /* 4 port duplex */ 
                    cs4224_sku_hw_id     = CS4224_HW_CS4223;
                    cs4224_max_num_ports = CS4224_MAX_NUM_CS4223_PORTS;
                    cs4224_max_num_dies  = CS4224_MAX_NUM_CS4223_DIES;
                    break;
                case CS4224_HW_CS4224:
                    /* 16 port simplex */ 
                    cs4224_sku_hw_id     = CS4224_HW_CS4224;
                    cs4224_max_num_ports = CS4224_MAX_NUM_CS4224_PORTS;
                    cs4224_max_num_dies  = CS4224_MAX_NUM_CS4224_DIES;
                    break;
                case CS4224_HW_CS4221:
                    /* 10 port simplex */ 
                    cs4224_sku_hw_id     = CS4224_HW_CS4221;
                    cs4224_max_num_ports = CS4224_MAX_NUM_CS4221_PORTS;
                    cs4224_max_num_dies  = CS4224_MAX_NUM_CS4221_DIES;
                    break;
                case CS4224_HW_CS4227:
                    /* 2 port duplex */ 
                    cs4224_sku_hw_id     = CS4224_HW_CS4227;
                    cs4224_max_num_ports = CS4224_MAX_NUM_CS4227_PORTS;
                    cs4224_max_num_dies  = CS4224_MAX_NUM_CS4227_DIES;
                    break;
                case CS4224_HW_CS4210:
                    /* 16 port simplex */ 
                    cs4224_sku_hw_id     = CS4224_HW_CS4210;
                    cs4224_max_num_ports = CS4224_MAX_NUM_CS4210_PORTS;
                    cs4224_max_num_dies  = CS4224_MAX_NUM_CS4210_DIES;
                    break;
                case CS4224_HW_CS4341:
                    /* 8 port duplex */ 
                    cs4224_sku_hw_id     = CS4224_HW_CS4341;
                    cs4224_max_num_ports = CS4224_MAX_NUM_CS4341_PORTS;
                    cs4224_max_num_dies  = CS4224_MAX_NUM_CS4341_DIES;
                    break;
                default:
                    /* SKU must be cs4343 or if undefined we default to 8 port duplex */ 
                    cs4224_sku_hw_id     = CS4224_HW_CS4343; 
                    cs4224_max_num_ports = CS4224_MAX_NUM_CS4343_PORTS;
                    cs4224_max_num_dies  = CS4224_MAX_NUM_CS4343_DIES;
                    break;
            }
        }
    }

    return cs4224_sku_hw_id;
}

/**
 * This method is called to retrieve the hardware type of the
 * ASIC. This method returns TRUE if the ASIC suppports 16 simplex 
 * ports, FALSE otherwise.
 *
 * @param slice [I] - The slice of the device.
 *
 * @return TRUE or FALSE
 */
cs_boolean cs4224_is_hw_simplex(
    cs_uint32 slice)
{
    e_cs4224_hardware_id hw_id = cs4224_hw_id(slice);

    if ((CS4224_HW_CS4224 == hw_id) || 
        (CS4224_HW_CS4221 == hw_id) ||
        (CS4224_HW_CS4210 == hw_id))
    {
        return TRUE;
    }
    return FALSE;

}

/**
 * This method is called to retrieve the hardware type of the
 * ASIC. This method returns TRUE if the ASIC suppports 8 duplex 
 * ports, FALSE otherwise.
 *
 * @param slice [I] - The slice of the device.
 *
 * @return TRUE or FALSE
 */
cs_boolean cs4224_is_hw_duplex(
    cs_uint32 slice)
{
    /* only keep the 'list' of simplex/duplex slices in one place */
    if (cs4224_is_hw_simplex(slice))   
    {
        return FALSE;
    }
    return TRUE;

}

/* CS4224_HW_CS4223   4 port duplex  
 * CS4224_HW_CS4343   8 port duplex  
 * CS4224_HW_CS4227   2 port duplex  
 * CS4224_HW_CS4341   8 port duplex, 10G only
 */
cs_uint16 cs4224_pp_sku_cs4343_offset[8] =
{
    /* slice       0,      1,      2,      3,      4,      5,      6,      7 */
              0x0000, 0x1000, 0x2000, 0x3000, 0x3000, 0x2000, 0x1000, 0x0000   
};
cs_uint16 cs4224_mseq_sku_cs4343_offset[8] =
{
    /* slice       0,      1,     2,     3,      4,      5,      6,      7 */
              0x0000, 0x0000, 0x100, 0x100, 0x0100, 0x0100, 0x0000, 0x0000   
};

/* CS4224_HW_CS4224  16 port simplex 
 * CS4224_HW_CS4210  16 port simplex, 15G only
 */
cs_uint16 cs4224_pp_sku_cs4224_offset[16] =
{
    /* slice       0,      1,      2,      3,      4,      5,      6,      7 */
              0x0000, 0x1000, 0x3000, 0x1000, 0x2000, 0x0000, 0x3000, 0x2000, 
    /* slice       8,      9,     10,     11,     12,     13,     14,     15 */
              0x0000, 0x2000, 0x1000, 0x3000, 0x2000, 0x0000, 0x1000, 0x3000  
};
cs_uint16 cs4224_mseq_sku_cs4224_offset[16] =
{
    /* slice       0,      1,      2,      3,      4,      5,      6,      7 */
              0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0100, 0x0100, 
    /* slice       8,      9,     10,     11,     12,     13,     14,     15 */
              0x0000, 0x0100, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000, 0x0100  
};

/* CS4224_HW_CS4221  10 port simplex
 * Relative to CS4224, CS4221 is mapped:
 *    CS4221   CS4224
 *     Port     Port
 *       0        1
 *       1        0
 *       2        3
 *       3        5
 *       4        6
 *       5       10
 *       6        9
 *       7       11
 *       8       13
 *       9       14
 */
cs_uint16 cs4224_pp_sku_cs4221_offset[10] =
{
    /* slice       0,      1,      2,      3,      4,      5,      6,      7 */
              0x1000, 0x0000, 0x1000, 0x0000, 0x3000, 0x1000, 0x2000, 0x3000, 
    /* slice       8,      9,                                                */
              0x0000, 0x1000  
};
cs_uint16 cs4224_mseq_sku_cs4221_offset[10] =
{
    /* slice       0,      1,      2,      3,      4,      5,      6,      7 */
              0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0100, 
    /* slice       8,      9,                                                */
              0x0000, 0x0000  
};

/**
 * This wrapper method is called to adjust a register address such 
 * that it points to the correct port pair (PP) register instance. 
 * To be used as a wrapper to translate the register argument for methods 
 * cs4224_reg_get/set. Only registers beginning with CS4224_PP_ should 
 * use this wrapper.
 *
 * @return adjusted register address
 *
 * @private
 */
cs_uint32 cs4224_adj_pp(
    cs_uint32 slice, 
    cs_uint16 addr)
{ 
    cs_uint16 adj_addr = addr;
    e_cs4224_hardware_id hw_id = cs4224_hw_id(slice);

    switch(hw_id)
    { 
        case CS4224_HW_CS4223: /*  4 port duplex   */
         
            if((slice & 0xFF) > 3)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 3, slice=0x%x\n", slice));
            }
            /* same mapping as cs4343 */
            adj_addr = (addr + cs4224_pp_sku_cs4343_offset[slice & 0x7]); 
            break;

        case CS4224_HW_CS4224: /* 16 port simplex  */
         
            if((slice & 0xFF) > 15)
            {
                CS_TRACE(("ERROR: Simplex slice argument > 15, slice=0x%x\n", slice));
            }
            adj_addr = (addr + cs4224_pp_sku_cs4224_offset[slice & 0xF]); 
         
            break;

        case CS4224_HW_CS4343: /*  8 port duplex   */
         
            if((slice & 0xFF) > 7)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 7, slice=0x%x\n", slice));
            }
            adj_addr = (addr + cs4224_pp_sku_cs4343_offset[slice & 0x7]); 
         
            break;

        case CS4224_HW_CS4221: /* 10 port simplex */
         
            if((slice & 0xFF) > 9)
            {
                CS_TRACE(("ERROR: Simplex slice argument > 9, slice=0x%x\n", slice));
                adj_addr = (addr + cs4224_pp_sku_cs4221_offset[0]); 
            }
            else
            {
                adj_addr = (addr + cs4224_pp_sku_cs4221_offset[slice & 0xF]); 
            }
         
            break;

        case CS4224_HW_CS4227: /*  2 port duplex   */
         
            if((slice & 0xFF) > 1)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 1, slice=0x%x\n", slice));
            }
            /* same mapping as cs4343 */
            adj_addr = (addr + cs4224_pp_sku_cs4343_offset[slice & 0x7]); 
            break;

        case CS4224_HW_CS4210: /* 16 port simplex  */
         
            if((slice & 0xFF) > 15)
            {
                CS_TRACE(("ERROR: Simplex slice argument > 15, slice=0x%x\n", slice));
            }
            adj_addr = (addr + cs4224_pp_sku_cs4224_offset[slice & 0xF]); 
         
            break;

        case CS4224_HW_CS4341: /*  8 port duplex   */
         
            if((slice & 0xFF) > 7)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 7, slice=0x%x\n", slice));
            }
            adj_addr = (addr + cs4224_pp_sku_cs4343_offset[slice & 0x7]); 
         
            break;

        default:
            CS_TRACE(("ERROR: invalid hw_id: %x\n",hw_id));
            break;

    }

    return adj_addr;
}

/**
 * This wrapper method is called to adjust a register address such 
 * that it points to the correct MSEQ_PS register instance. 
 * To be used as a wrapper to translate the register argument for methods 
 * cs4224_reg_get/set. Only registers beginning with CS4224_MSEQ_ should 
 * use this wrapper.
 *
 * @return adjusted register address
 *
 * @private
 */
cs_uint32 cs4224_adj_mseq(
    cs_uint32 slice, 
    cs_uint16 addr)
{ 
    cs_uint16 adj_addr = addr;
    e_cs4224_hardware_id hw_id = cs4224_hw_id(slice);

    switch(hw_id)
    { 
        case CS4224_HW_CS4223: /*  4 port duplex   */
         
            if((slice & 0xFF) > 3)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 3, slice=%d\n", slice));
            }
            /* same mapping as cs4343 */
            adj_addr = (addr + cs4224_mseq_sku_cs4343_offset[slice & 0x7]); 
            break;

        case CS4224_HW_CS4224: /* 16 port simplex  */
         
            if((slice & 0xFF) > 15)
            {
                CS_TRACE(("ERROR: Simplex slice argument > 15, slice=%d\n", slice));
            }
            adj_addr = (addr + cs4224_mseq_sku_cs4224_offset[slice & 0xF]); 
         
            break;

        case CS4224_HW_CS4343: /*  8 port duplex   */
         
            if((slice & 0xFF) > 7)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 7, slice=%d\n", slice));
            }
            adj_addr = (addr + cs4224_mseq_sku_cs4343_offset[slice & 0x7]); 
         
            break;

        case CS4224_HW_CS4221: /* 10 port simplex */
         
            if((slice & 0xFF) > 9)
            {
                CS_TRACE(("ERROR: Simplex slice argument > 9, slice=%d\n", slice));
                adj_addr = (addr + cs4224_mseq_sku_cs4221_offset[0]); 
            }
            else
            {
                adj_addr = (addr + cs4224_mseq_sku_cs4221_offset[slice & 0xF]); 
            }
         
            break;

        case CS4224_HW_CS4227: /*  2 port duplex   */
         
            if((slice & 0xFF) > 1)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 1, slice=%d\n", slice));
            }
            /* same mapping as cs4343 */
            adj_addr = (addr + cs4224_mseq_sku_cs4343_offset[slice & 0x7]); 
            break;

        case CS4224_HW_CS4210: /* 16 port simplex  */
         
            if((slice & 0xFF) > 15)
            {
                CS_TRACE(("ERROR: Simplex slice argument > 15, slice=%d\n", slice));
            }
            adj_addr = (addr + cs4224_mseq_sku_cs4224_offset[slice & 0xF]); 
         
            break;

        case CS4224_HW_CS4341: /*  8 port duplex   */
         
            if((slice & 0xFF) > 7)
            {
                CS_TRACE(("ERROR: Duplex slice argument > 7, slice=%d\n", slice));
            }
            adj_addr = (addr + cs4224_mseq_sku_cs4343_offset[slice & 0x7]); 
         
            break;

        default:
            CS_TRACE(("ERROR: invalid hw_id: %x\n",hw_id));
            break;

    }

    return adj_addr;
}

/* simplex mate slices (slices with the same PP number on the die) */
cs_uint16 cs4224_mate_slice_sku_cs4224[16] =
{
    /* slice    0, 1, 2, 3, 4, 5, 6, 7 */
                5, 3, 6, 1, 7, 0, 2, 4,
    /* slice     8,  9, 10, 11, 12, 13, 14, 15 */
                13, 12, 14, 15,  9,  8, 10, 11
};

/* CS4221 has some 'empty' slices that don't have a mate slice, those must be handled
 * manually, as there is no way to address them with reg_Xet_channel */
cs_uint16 cs4224_mate_slice_sku_cs4221[10] =
{
    /* slice    0, 1, 2, 3,    4 */
                2, 3, 0, 1, 0xff,
    /* slice    5,    6,    7,    8, 9 */
                9, 0xff, 0xff, 0xff, 5
};

/**
 * This function just reports back what the mate slice of a simplex slice is,
 * that is, the slice that has the same port-pair offset.
 * 
 * Note that for CS4221, many slices don't have mates. In that case mate will be
 * set to 0xFF and this will return CS_ERROR.
 * 
 * For duplex devices, mate will be set to slice and return CS_OK.
 * 
 * @param slice [I] - The slice
 * @param mate  [O] - The mate slice
 * 
 * @return CS_OK on pass, CS_ERROR if there was a general error or if there was no
 * mate slice.
 * 
 * @private
 */
cs_status cs4224_simplex_mate_slice(
    cs_uint32 slice,
    cs_uint32 *mate)
{
    cs_status status = CS_OK;
    e_cs4224_hardware_id hw_id = cs4224_hw_id(slice);
    cs_uint8 base_slice = (slice & 0xFF);
    cs_uint32 upper_bits = (slice & 0xFFFFFF00);
    
    *mate = 0xFF;
    
    switch(hw_id)
    {
        case CS4224_HW_CS4224:
        case CS4224_HW_CS4210: /*16 port simplex*/
            if((slice & 0xFF) > 15)
            {
                CS_TRACE(("ERROR: base-slice portion of slice paramter > 15, base_slice=%d\n", base_slice));
                return CS_ERROR;
            }
            *mate = cs4224_mate_slice_sku_cs4224[base_slice];
            
            break;
        case CS4224_HW_CS4221: /*10 port simplex*/
            if((slice & 0xFF) > 10)
            {
                CS_TRACE(("ERROR: base-slice portion of slice paramter > 10, base_slice=%d\n", base_slice));
                return CS_ERROR;
            }
            *mate = cs4224_mate_slice_sku_cs4221[base_slice];
            
            break;
        default:
            /* if duplex then just return the same slice, since that's technically correct */
            *mate = base_slice;
            
            break;
    }
    
    if(0xFF == *mate)
    {
        CS_TRACE(("ERROR: base_slice %d does not have a simplex mate slice\n", base_slice));
        status |= CS_ERROR;
    }
    
    *mate |= upper_bits;
    
    return status;
}

/**
 * This method is used to identify the direction of the simplex data-path.
 * Note: This method should only be called when hw is simplex.
 * 
 * @param slice [I] - The slice or port of the device
 *
 * @return TRUE on traffic flow from Line Rx to Host Tx, otherwise FALSE.
 */
cs_boolean cs4224_line_rx_to_host_tx_dir(
    cs_uint32 slice)
{
    cs_boolean lrx_to_htx = TRUE;
    e_cs4224_hardware_id hw_id = cs4224_hw_id(slice);

    /* Mask off the upper bits in case they are set
     * by the user. Otherwise the switch statement
     * below won't work properly. */
    slice = slice & 0xFF;

    if ((CS4224_HW_CS4224 == hw_id) || (CS4224_HW_CS4210 == hw_id))
    { 
        /* 16 port simplex */
        switch (slice)
        {
            case 0:
            case 1:
            case 2:
                lrx_to_htx =  TRUE;
                break;
        
            case 3:
                lrx_to_htx =  FALSE;
                break;
        
            case 4:
                lrx_to_htx =  TRUE;
                break;
        
            case 5:
            case 6:
            case 7:
                lrx_to_htx =  FALSE;
                break;
        
            case 8:
            case 9:
            case 10:
            case 11:
                lrx_to_htx =  TRUE;
                break;
        
            case 12:
            case 13:
            case 14:
            case 15:
                lrx_to_htx =  FALSE;
                break;
        
            default:
                lrx_to_htx =  TRUE;
                break;
        }
    }
    else if (CS4224_HW_CS4221 == hw_id)
    {
        /* 10 port simplex */
        switch (slice)
        {
            case 0:
            case 1:
                lrx_to_htx =  TRUE;
                break;
        
            case 2:
            case 3:
            case 4:
                lrx_to_htx =  FALSE;
                break;
        
            case 5:
            case 6:
            case 7: 
                lrx_to_htx =  TRUE;
                break;
        
            case 8:
            case 9:
                lrx_to_htx =  FALSE;
                break;
        
            default:
                lrx_to_htx =  TRUE;
                break;
        }
    }

    return lrx_to_htx;
}

/**
 * This is an internal method to get what the true mseq interface (line or host)
 * This only really matters when using simplex devices
 * 
 * @param slice   [I] - slice being checked
 * @param mseq_id [I/O] - MSEQ id/interface, will be set to line/host for simplex
 *                        and double-checked in duplex
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_get_mseq_id(
    cs_uint32         slice, 
    e_cs4224_mseq_id*  mseq_id)
{
    cs_status status = CS_OK;
    
    /* if mseq_id isn't simplex then just assume the user knows what they are doing */
    if (cs4224_is_hw_simplex(slice) && *mseq_id == CS4224_SPLX_MSEQ)
    {
        if(cs4224_line_rx_to_host_tx_dir(slice))
        {
            *mseq_id = CS4224_DPLX_LINE_MSEQ;
        }
        else
        {
            *mseq_id = CS4224_DPLX_HOST_MSEQ;
        }
    }
    else
    {
        if (*mseq_id == CS4224_SPLX_MSEQ)
        {
            CS_TRACE(("ERROR: Duplex slice, invalid mseq_id = CS4224_SPLX_MSEQ\n"));
            status |= CS_ERROR;
        }
    }
    
    return status;
}

/**
 * This method is used to determine the address offset
 * for the specified microsequencer. The offset is different
 * depending on whether the microsequencer is in the Line RX or
 * Host RX direction.
 *
 * @param slice [I] - The slice of the device being accessed.
 * @param mseq  [I] - The microsequencer being accessed (Rx side).
 *
 * @return The register address offset in the port pair space.
 * 
 * @private
 */
cs_uint32 cs4224_mseq_get_addr_offset(
    cs_uint32 slice,
    e_cs4224_mseq_id mseq)
{
    cs_uint32 offset = 0; /* 0 is line side, 0x800 is host side */

    if(cs4224_is_hw_simplex(slice) && mseq == CS4224_SPLX_MSEQ)
    {
        if(!cs4224_line_rx_to_host_tx_dir(slice))
        {
            offset = 0x800;
        }
    }
    else if(mseq == CS4224_DPLX_HOST_MSEQ)
    {
        offset = 0x800;
    }

    return offset;
}

/**
 * This is an internal method to get what the true cfg interface (line or host)
 * This only really matters when using simplex devices
 * 
 * @param slice   [I] - slice being checked
 * @param side    [I/O] - interface, will be set to line/host for simplex
 *                        and double-checked in duplex
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_get_cfg_side(
    cs_uint32              slice,
    e_cs4224_cfg_sides_t*  side)
{
    cs_status status = CS_OK;
    
    /* a bit different than get_mseq_id, if you specify a non-simplex side then
     * default to using that, otherwise use the Rx side of the simplex slice */
    if (cs4224_is_hw_simplex(slice) && (*side == CS4224_CFG_SIMPLEX))
    {
        if(cs4224_line_rx_to_host_tx_dir(slice))
        {
            *side = CS4224_CFG_LINE_SIDE;
        }
        else
        {
            *side = CS4224_CFG_HOST_SIDE;
        }
    }
    else
    {
        if (*side == CS4224_CFG_SIMPLEX)
        {
            CS_TRACE(("ERROR: Duplex slice, invalid side = CS4224_CFG_SIMPLEX\n"));
            status |= CS_ERROR;
        }
    }
    
    return status;
}

/**
 * Power-up/power-down the mux
 *
 * @param slice      [I] - The slice to the port of the device to access 
 * @param side       [I] - Identifies the line or host side mux 
 * @param enable     [I] - Enable/disable the mux 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_mux_enable(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t side, 
    cs_boolean enable)
{
    cs_status status = CS_OK;
    cs_uint16 stx0_misc_addr;
    cs_uint16 data;
    
    if (side == CS4224_CFG_SIMPLEX)
    {
        CS_TRACE(("ERROR: CS4224_CFG_SIMPLEX argument not supported, only LINE or HOST\n"));
        return CS_ERROR;
    }
    
    if (side == CS4224_CFG_LINE_SIDE)
    {
        stx0_misc_addr = CS4224_PP_LINE_SDS_COMMON_STX0_MISC;
    }
    else
    {
        stx0_misc_addr = CS4224_PP_HOST_SDS_COMMON_STX0_MISC;
    }

    cs4224_lock(slice);

    status |= cs4224_reg_get_channel(slice, stx0_misc_addr, &data);
    if (enable)
    {
        data &= ~0x11; /* power-up mux, STX_EYEMODE_EN=0 */
    }
    else
    {
        data |= 0x11; /* power-down mux, STX_EYEMODE_EN=1 */
    }
    status |= cs4224_reg_set_channel(slice, stx0_misc_addr, data);

    cs4224_unlock(slice);

    return status;

}

/**
 * Power-up/power-down the demux
 *
 * @param slice      [I] - The slice to the port of the device to access 
 * @param side       [I] - Identifies the line or host side demux 
 * @param enable     [I] - Enable/disable the demux 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_demux_enable(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t side, 
    cs_boolean enable)
{
    cs_status status = CS_OK;
    cs_uint16 mseq_power_down_addr;
    cs_uint16 agc_config1_addr;
    cs_uint16 data;

    if (side == CS4224_CFG_SIMPLEX)
    {
        CS_TRACE(("ERROR: CS4224_CFG_SIMPLEX argument not supported, only LINE or HOST\n"));
        return CS_ERROR;
    }
    
    if (side == CS4224_CFG_LINE_SIDE)
    {
        mseq_power_down_addr = CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        agc_config1_addr = CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1;
    }
    else
    {
        mseq_power_down_addr = CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        agc_config1_addr = CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1;
    }

    cs4224_lock(slice);

    cs4224_reg_get_channel(slice, agc_config1_addr, &data);

    /* Don't touch the power down registers if we're in CX1 mode */
    if(data != 0x5)
    {
        if (enable)
        {
            status |= cs4224_reg_get_channel(slice, mseq_power_down_addr, &data);
            data |= 0x001f; /* partial power-up */
            status |= cs4224_reg_set_channel(slice, mseq_power_down_addr, data);
            data &= ~0x001f; /* clear the partial power-up */ 
            data &= ~0x01c0; /* full power-up demux */
            status |= cs4224_reg_set_channel(slice, mseq_power_down_addr, data);
        }
        else
        {
            status |= cs4224_reg_get_channel(slice, mseq_power_down_addr, &data);
            data |= 0x01c0; /* power-down demux */
            status |= cs4224_reg_set_channel(slice, mseq_power_down_addr, data);
        }
    }

    cs4224_unlock(slice);

    return status;

}

#define CS4224_SENSE_POINT_LOCAL_TEMPERATURE  1 << 0
#define CS4224_SENSE_POINT_REMOTE_TEMPERATURE 1 << 1
#define CS4224_SENSE_POINT_0p9_RX_VOLTAGE     1 << 2
#define CS4224_SENSE_POINT_0p9_TX_VOLTAGE     1 << 3
#define CS4224_SENSE_POINT_0p9_DIG_RX_VOLTAGE 1 << 4
#define CS4224_SENSE_POINT_0p9_DIG_TX_VOLTAGE 1 << 5
#define CS4224_SENSE_POINT_1p8_RX_VOLTAGE     1 << 6
#define CS4224_SENSE_POINT_1p8_TX_VOLTAGE     1 << 7
#define CS4224_SENSE_POINT_1p5_RX_VOLTAGE     1 << 8
#define CS4224_SENSE_POINT_1p5_TX_VOLTAGE     1 << 9

/**
 * This is an internal method used to enable the sense points
 * for the temperature and voltage monitors. It is called by
 * cs4224_slice_enter_operational_state() or by the temperature
 * monitors directly if the slice has not been previously
 * enabled.
 *
 * @param die                  [I] - The die of the ASIC to turn the monitors
 *                                   on for.
 * @param wait_till_stabilized [I] - Block until the monitors
 *                                   are stable before returning.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_enable_monitor_sense_points(
    cs_uint32  die,
    cs_boolean wait_till_stabilized)
{
    cs_uint16 reg_data;
    cs_status status = CS_OK;

    status |= cs4224_reg_get(die, CS4224_MONITOR_CONTROL0, &reg_data);

    if(reg_data != 0x630F)
    {
        status |= cs4224_reg_set(die, CS4224_MONITOR_CONFIG_MASK, 
            CS4224_SENSE_POINT_LOCAL_TEMPERATURE |
            CS4224_SENSE_POINT_0p9_RX_VOLTAGE |
            CS4224_SENSE_POINT_1p8_RX_VOLTAGE);

        status |= cs4224_reg_set(die, CS4224_MONITOR_CONTROL0, 0x630F);

        if(wait_till_stabilized)
        {
            cs_uint16 reg_data;
            int last = 0;
            int i;

            /*
            CS_PRINTF(("Waiting for the monitors to stabilize\n"));
            */
            cs4224_reg_get(die, CS4224_MONITOR_STATUS_FINAL6, &reg_data);

            for(i = 0; i < 100; i++)
            {
                CS_MDELAY(10);

                /*
                CS_PRINTF(("  FINAL0[%d] = %x (last = %x, %d)\n",
                           i, reg_data, last, last > (int)reg_data));
                */
                if(last > (int)reg_data)
                {
                    break;
                }
                
                last = (int)reg_data;
                cs4224_reg_get(die, CS4224_MONITOR_STATUS_FINAL6, &reg_data);
            }
        }
    }

    return status;
}

/**
 * Reads the current value of the temperature monitor and returns a fixed-point
 * value.
 *
 * @param slice      [I] - The slice to the port of the device to access 
 * @param temp       [O] - The calibrated temperature in milli-degrees Celsius (fixed-point)
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_mon_temp_read_fixp(
    cs_uint32  slice,
    cs_uint32* temp)
{
    cs_status status = CS_OK;
    long long int dac, tmp;
    cs_uint16 data;

    cs4224_lock(slice);

    /* If the monitors weren't enabled previously then turn them on */
    cs4224_enable_monitor_sense_points(cs4224_get_die_from_slice(slice), TRUE);
    
    status |= cs4224_reg_get_channel(slice, CS4224_MONITOR_STATUS_FINAL0, &data);

    cs4224_unlock(slice);

    tmp = (long long int)data;
    dac = (long long int)(tmp*1000);
 /* *temp = (2.563 * ((data / 256.0)-78.17)) + 85;*/       /* floating-point math */
    *temp = ((2563 * ((dac / 256) - 78170))/1000) + 85000; /* fixed-point math    */
    
    return status;
}

/**
 * This method is called to select a particular voltage and read back it's value. 
 * This may take upwards of 50ms as it takes time for the sensor to settle when the 
 * source is changed. 
 *
 * @param slice       [I] -  The slice to the port of the device to access 
 * @param volt_source [I] -  The voltage source to sample 
 * @param voltage     [O] -  The output voltage in milli-volts (fixed-point)
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_mon_volt_read_fixp(
    cs_uint32               slice,
    e_cs4224_mon_vlt_supply volt_source,
    cs_uint32*              voltage)
{
    cs_uint16 data;
    long long int dac, tmp;
    cs_status status = CS_OK;

    cs4224_lock(slice);

    
    /* If the monitors weren't enabled previously then turn them on */
    cs4224_enable_monitor_sense_points(cs4224_get_die_from_slice(slice), TRUE);

    switch(volt_source)
    {
        case CS4224_VLT_SUPPLY_0p9V:

            status |= cs4224_reg_get_channel(slice, CS4224_MONITOR_STATUS_FINAL2, &data);
            tmp = (long long int)data;
            dac = (long long int)(tmp*1000);
         /* *voltage = (((data / 256.0) -191.931) / 214.003) + 0.9;*/ /* floating-point math */
            *voltage = (((dac / 256) -191931) / 214) + 900;           /* fixed-point math */
            break;

        case CS4224_VLT_SUPPLY_1p8V:
        {
            status |= cs4224_reg_get_channel(slice, CS4224_MONITOR_STATUS_FINAL6, &data);
            tmp = (long long int)data;
            dac = (long long int)(tmp*1000);
         /* *voltage = (((data / 256.0) - 192.170) / 102.542) + 1.8;*/ /* floating-point math */
            *voltage = (((dac / 256) - 192170) / 102) + 1800;          /* fixed-point math */
            break;
        }
        default:
            CS_TRACE(("ERROR: Invalid volt_source argument\n"));
            break;
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * This method is used to retreive the version string describing
 * the version of the API in use. The user must allocate
 * a buffer of at least 256 bytes to retrieve the version information.
 * 
 * @param buffer     [O] - The output buffer where the version string will
 *                         be stored.
 * @param buffer_len [I] - The length of the allocated buffer.
 *
 * @return CS_OK on success, CS_ERROR on failure 
 */
cs_status cs4224_version(
    char* buffer, 
    cs_uint32 buffer_len)
{
    CS_STRNCPY(buffer,
            "CS4224 API Version " CS_API_VERSION "\n"
            "Built on " CS_API_BUILD_DATE "\n",
            buffer_len); 

    return CS_OK;
}

/**
 * This is method used to resync the elastic store. It should
 * not be necessary to do this manually unless you change the datapath.
 * 
 * NOTE: This method is not compatible with loopbacks
 * 
 * NOTE: Not to be used for the analog elastic stores
 * 
 * @param slice     [I] - The slice upon which the loopback is applied.
 * @param elsto_reg [I] - The elastic store register address.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_resync_elsto(
    cs_uint32 slice, 
    cs_uint16 elsto_reg)
{
    cs_status status = CS_OK;

    cs4224_lock(slice);

    /* this assumes use_lockdet is always enabled, which it is unless you are using a loopback */
    status |= cs4224_reg_set_channel(slice, elsto_reg, 0x2); /* make sure it's 0 */
    status |= cs4224_reg_set_channel(slice, elsto_reg, 0x3); /* resync */

    cs4224_unlock(slice);

    return status;
}

/** 
 * This is an internal method used to trigger the re-sync
 * of a VCO.
 * 
 * Note that the microsequencer must be stalled prior to 
 * calling this method.
 *
 * @param slice [I] - The slice of the device to trigger
 *                    a VCO re-sync on.
 * @param addr  [I] - The address of the VCO, either CS4224_PP_LINE_SDS_COMMON_RXVCO0_CONTROL or
 *                    CS4224_PP_HOST_SDS_COMMON_RXVCO0_CONTROL
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_init_vco(
    cs_uint32 slice, 
    cs_uint32 addr)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;
    cs_uint16 data = 0;
    cs_uint16 i = 0;
    
    if(addr & CS4224_LINE_TO_HOST_OFFSET)
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }
    else
    {
        offset = 0;
    }

    cs4224_lock(slice);

    /* re-initialize the VCO ALT coarse tuning algorithm 
       to start searching for the correct frequency */
    status |= cs4224_reg_set_channel(slice, addr, 0x2001);
    status |= cs4224_reg_set_channel(slice, addr, 0xa001);
    status |= cs4224_reg_set_channel(slice, addr, 0x2001);

    /* the worst-case time out value is where F(ref_clk) > F(vco_clk) so a timeout
       of 3.3ms should suffice for the completion of the coarse tuning.
    */
    for(i=1500; i>0; i--)
    {
        /* check for CTVALID */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_STATUS + offset, &data);
        if((data & CS_BIT15) || (CS_OK != status))
        {
            /* tuning done or error, exit */
            break;
        }
        CS_UDELAY(10);
    }
    cs4224_unlock(slice);

    if(i == 0)
    {
        CS_TRACE(("ERROR: Timed out waiting for VCO to lock, waited 15ms (check CS_UDELAY implementation for delay accuracy)\n"));
        status |= CS_ERROR;
    }
    
    return status;
}

/**
 * This method resets the analog elastic stores of a switch pair. 
 * The analog elastic store is only used when an analog protection
 * switch is applied.
 * 
 * @param slice    [I] - The base slice number of the switching pair
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @public
 */
cs_status cs4224_switch_reset_analog_elsto(
    cs_uint32 slice) 
{
    cs_status status = CS_OK;

    if (slice & 1)
    {
        CS_TRACE(("ERROR: Analog elastic store reset can only be applied to even slices (0,2,4,etc.)\n"));
        return CS_ERROR;
    } 

#if 0
    cs_uint16 reg_line_0,reg_line_1,reg_host_0,reg_host_1;
    status |= cs4224_reg_get_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS, &reg_line_0);
    status |= cs4224_reg_get_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS, &reg_line_1);
    status |= cs4224_reg_get_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS, &reg_host_0);
    status |= cs4224_reg_get_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS, &reg_host_1);
    CS_PRINTF(("\nEDC Converged: line(6)=%s, line(7)=%s, host(6)=%s, host(7)=%s", 
                    reg_line_0&0x20?"True":"False",
                    reg_line_1&0x20?"True":"False",
                    reg_host_0&0x20?"True":"False",
                    reg_host_1&0x20?"True":"False"));
    status |= cs4224_reg_get_channel(slice,   CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS, &reg_line_0);
    status |= cs4224_reg_get_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS, &reg_line_1);
    status |= cs4224_reg_get_channel(slice,   CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS, &reg_host_0);
    status |= cs4224_reg_get_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS, &reg_host_1);
    CS_PRINTF(("\nRX Lock Stat : line(6)=0x%02x, line(7)=0x%02x, host(6)=0x%02x, host(7)=0x%02x\n", 
                    reg_line_0,
                    reg_line_1,
                    reg_host_0,
                    reg_host_1));
#endif 

    status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);
    status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);
    status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);
    status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);

    return status;

}

/**
 * This is an internal method used to save the interface
 * context for when a digital protection switch is enabled. 
 * This context will be written back to the chip when the
 * digital protection switch is tore down.
 * 
 * @param slice    [I] - The slice upon which the switch is applied.
 * @param state    [O] - A pointer to the structure where the context is saved.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_save_duplex_state(
    cs_uint32             slice, 
    cs4224_switch_state_t *state)
{
    cs_status status = CS_OK;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->line_srx0_rx_clkout_ctrl));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->host_srx0_rx_clkout_ctrl));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, &(state->line_stx0_misc));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, &(state->host_stx0_misc));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &(state->line_stx0_driver_config));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &(state->host_stx0_driver_config));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &(state->line_dsp_mseq_mail_sel));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &(state->host_dsp_mseq_mail_sel));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, &(state->host_srx0_vco_config));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, &(state->host_srx0_agc_config1));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG, &(state->host_srx0_dfe_config));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &(state->line_srx0_rx_config));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &(state->host_srx0_rx_config));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, &(state->line_spare12_lsb));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, &(state->host_spare12_lsb));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &(state->line_spare26_lsb));

    return status;
}

/**
 * This is an internal method used to restore the interface
 * context for when a duplex protection switch is tore down. 
 * 
 * @param slice    [I] - The slice upon which the switch is applied.
 * @param state    [O] - A pointer to the structure from where the context is restored.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_restore_duplex_state(
    cs_uint32             slice, 
    cs4224_switch_state_t *state)
{
    cs_status status = CS_OK;

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->line_srx0_rx_clkout_ctrl));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->host_srx0_rx_clkout_ctrl));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, (state->line_stx0_misc));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, (state->host_stx0_misc));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, (state->line_stx0_driver_config));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, (state->host_stx0_driver_config));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, (state->line_dsp_mseq_mail_sel));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, (state->host_dsp_mseq_mail_sel));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, (state->host_srx0_vco_config));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, (state->host_srx0_agc_config1));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG, (state->host_srx0_dfe_config));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, (state->line_srx0_rx_config));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, (state->host_srx0_rx_config));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, (state->line_spare12_lsb));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, (state->host_spare12_lsb));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, (state->line_spare26_lsb));

    return status;
}

/**
 * This method attempts to forcibly initialize the switch state in the
 * event that it cannot be cached in memory. This might be useful in a case
 * where you have two VMs that don't have a shared memory space in order
 * to maintain the switch pair state.
 *
 * This method works by querying a subset of the current h/w state
 * and then modifies the queried state to undo any switching configuration.
 * This creates a close approximation of the h/w state before any switch
 * operation was applied.
 *
 * @{note,
 * NOTE: This method will only work for duplex switching.
 * }
 * 
 * @{note,
 * NOTE: This method has a number of caveats that require extra care. Contact your
 *       Cortina AE before using it.
 * }
 *
 * @param slice [I] - The slice of the device to forcibly initialize
 *                    the state for.
 * @param state [O] - The state being forcibly initialized rather than
 *                    queried from the ASIC.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_switch_duplex_force_init_state(
    cs_uint32                   slice,
    cs4224_switch_pair_state_t* state)
{
    cs_status status = CS_OK;
    cs_uint32 i;
    
    /* This method can't be used on simplex devices */
    if(cs4224_is_hw_simplex(slice))
    {
        return CS_ERROR;
    }
    
    /* Make sure we start with the base slice in the switch pair */
    slice = slice & 0xfffffffe;
    
    state->initialized = TRUE;
    if(state->low_latency_switching)
    {
        CS_TRACE(("WARNING: low latency switching is not supported by this method, automatically setting it to FALSE.\n"));
    }
    state->low_latency_switching = FALSE;
    
    /* First query the current state from the h/w and then override
     * anything that controls the muxing of the 2x2. Not worrying
     * about power considerations here. */
    for(i = 0; i < 2; i++)
    {
        /* First load the existing h/w state in to the state structure */
        status |= cs4224_switch_save_duplex_state(slice + i, &(state->slices[i]));
        
        /* Now override anything that might have gotten changed by a previous
         * call to the switch duplex methods */
        
        /* Undo the mailbox re-direction */
        state->slices[i].line_dsp_mseq_mail_sel = 0;
        state->slices[i].host_dsp_mseq_mail_sel = 0;
        
        /* Clear the SRX_EXT_SERCLK_EN bit */
        state->slices[i].line_srx0_rx_clkout_ctrl &= ~0x2000;
        state->slices[i].host_srx0_rx_clkout_ctrl &= ~0x2000;
        
        /* Clear the SRX_2X2_DMUX_EN bit */
        state->slices[i].line_srx0_rx_config &= ~0x1000;
        /* also clear the srx_amp_pd bit */
        state->slices[i].host_srx0_rx_config &= ~0x1040;
        
        /* Clear the 2x2 mux and disable the mux (from cs4224_mux_enable) */
        state->slices[i].line_stx0_misc &= ~0x0080;
        state->slices[i].line_stx0_misc |= 0x0011;
        /* also clear stx_pd */
        state->slices[i].host_stx0_misc &= ~0x8080;
        state->slices[i].host_stx0_misc |= 0x0011;
        
        /* Clear STX_EXT_SERCLEN_EN */
        state->slices[i].line_stx0_driver_config &= ~0x0008;
        state->slices[i].host_stx0_driver_config &= ~0x0008;
        
        /* clear srx_vco_pdmux_en and set srx_vco_en */
        state->slices[i].host_srx0_vco_config &= ~0x0100;
        state->slices[i].host_srx0_vco_config |= 0x0002;
        
        /* note that power_down_lsb is left as-is since it's a bit of a mess to force this */
    }
    
    return status;
}

/**
 * This is an internal method used to save the interface
 * context for when a analog protection switch is enabled. 
 * This context will be written back to the chip when the
 * analog protection switch is tore down.
 * 
 * @param slice    [I] - The slice upon which the switch is applied.
 * @param state    [O] - A pointer to the structure where the context is saved.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_save_simplex_state(
    cs_uint32             slice, 
    cs4224_switch_state_t *state)
{
    cs_status status = CS_OK;

    if (cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, &(state->line_spare12_lsb));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->line_srx0_rx_clkout_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &(state->host_stx0_driver_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &(state->line_srx0_rx_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, &(state->host_stx0_misc));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &(state->line_dsp_mseq_mail_sel));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->line_mseq_power_down));
    }
    else
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, &(state->host_spare12_lsb));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &(state->host_srx0_rx_clkout_ctrl));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &(state->line_stx0_driver_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &(state->host_srx0_rx_config));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, &(state->line_stx0_misc));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &(state->host_dsp_mseq_mail_sel));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, &(state->host_mseq_power_down));
    }
    return status;
}

/**
 * This is an internal method used to restore the interface
 * context for when a analog protection switch is tore down. 
 * 
 * @param slice    [I] - The slice upon which the switch is applied.
 * @param state    [O] - A pointer to the structure from where the context is restored.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_restore_simplex_state(
    cs_uint32             slice, 
    cs4224_switch_state_t *state)
{
    cs_status status = CS_OK;

    if (cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, (state->line_spare12_lsb));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->line_srx0_rx_clkout_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, (state->host_stx0_driver_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, (state->line_srx0_rx_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, (state->host_stx0_misc));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, (state->line_dsp_mseq_mail_sel));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->line_mseq_power_down));
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, (state->host_spare12_lsb));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, (state->host_srx0_rx_clkout_ctrl));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, (state->line_stx0_driver_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, (state->host_srx0_rx_config));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, (state->line_stx0_misc));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, (state->host_dsp_mseq_mail_sel));
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, (state->host_mseq_power_down));
    }
    return status;
}

/**
 * This is an internal method used to power-down the unused host side Rx and Tx 
 * blocks of the selected slice.
 * 
 * @param slice    [I] - The slice upon which the power-down is applied.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_power_down(
    cs_uint32   slice) 
{
    cs_status status = CS_OK;
    cs_uint16 reg_data;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, &reg_data);
    reg_data |= 0x8001; /* stx_pd=1, stx_pd_mux = 1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, reg_data);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, &reg_data);
    reg_data &= ~0x0002; /* srx_vco_en=0 */
    reg_data |=  0x0100; /* srx_vco_pdmux_en=1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, reg_data);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, &reg_data);
    reg_data &= ~0x0001; /* srx_agc_enb_limamp=0 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, reg_data);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG, &reg_data);
    reg_data |= 0x0001; /* srx_dfe_bypass_en=1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG, reg_data);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &reg_data);
    reg_data |= 0x0040; /* srx_amp_pd=1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, reg_data);

    return status;
}

/**
 * This is an internal switching method used to do enable the low latency analog data switch
 * between Line RX and Host TX of mate.
 *
 * @param slice [I] - The slice of the receiver. The mate will automatically
 *                    be detected.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_connect_line_rx_to_host_tx_of_mate(cs_uint32 slice)
{
    cs_uint16 reg_data;
    cs_status status = CS_OK;
    cs_uint32 mate_slice;

    if(0x1 == (slice & 0x1))
    {
        mate_slice = slice - 1;
    }
    else
    {
        mate_slice = slice + 1;
    }
    
    /* Connect Line RX slice N to Host TX of slice N+1 */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
    reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1, drive Rx clock to other slice */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

    status |= cs4224_reg_get_channel(mate_slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
    reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1, mux A */
    status |= cs4224_reg_set_channel(mate_slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &reg_data);
    reg_data |= 0x1000; /* SRX_2X2_DMUX_EN = 1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, reg_data);

    /* Turn on STX_2X2MUX_EN */
    status |= cs4224_reg_set_channel(mate_slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x00a2);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
    reg_data |= 0x0001; /* mail_source = 1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);
    
    status |= cs4224_reg_get_channel(mate_slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
    reg_data |= 0x0001; /* mail_source = 1 */
    status |= cs4224_reg_set_channel(mate_slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);
    
    return status;
}

/**
 * This is an internal switching method used to do enable the low latency analog data switch
 * between Host RX and Line TX of mate.
 *
 * @param slice [I] - The slice of the receiver. The mate will automatically
 *                    be detected.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_connect_host_rx_to_line_tx_of_mate(cs_uint32 slice)
{
    cs_uint16 reg_data;
    cs_status status = CS_OK;
    cs_uint32 mate_slice;

    if(0x1 == (slice & 0x1))
    {
        mate_slice = slice - 1;
    }
    else
    {
        mate_slice = slice + 1;
    }

    /* Connect Host RX slice N to line TX of slice N+1 */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
    reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1, drive Rx clock to other slice */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

    status |= cs4224_reg_get_channel(mate_slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
    reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1, mux A */
    status |= cs4224_reg_set_channel(mate_slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &reg_data);
    reg_data |= 0x1000; /* SRX_2X2_DMUX_EN = 1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, reg_data);

    /* Turn on STX_2X2MUX_EN to transmit traffic to partner line */
    status |= cs4224_reg_set_channel(mate_slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, 0x00a2);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
    reg_data |= 0x0001; /* mail_source = 1 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);
    
    status |= cs4224_reg_get_channel(mate_slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
    reg_data |= 0x0001; /* mail_source = 1 */
    status |= cs4224_reg_set_channel(mate_slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

    return status;
}

/**
 * Configure the protection switching (digital) on this device.
 *
 * @param slice         [I] - The even (lower) slice number of the switching pair ie, 0, 2, 4 etc.
 * @param switch_action [I] - An enum type identifying the switch action, one of:
 *                                CS4224_SWITCH_DIGITAL_SWITCH_2x2, 
 *                                CS4224_SWITCH_DIGITAL_BROADCAST_0_to_0, 
 *                                CS4224_SWITCH_DIGITAL_BROADCAST_1_to_1, 
 *                                CS4224_SWITCH_DIGITAL_BROADCAST_0_to_1, 
 *                                CS4224_SWITCH_DIGITAL_BROADCAST_1_to_0 or 
 *                                CS4224_SWITCH_DISABLE 
 *
 * Note that protection switching cannot be combined with loopbacks.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @deprecated The cs4224_switch_duplex() method should be used instead of this method
 *             as it properly supports multiple ASICs and any warm reboot requirements.
 *
 */
cs_status cs4224_switch_digital(
    cs_uint32                slice,
    e_cs4224_switch_action_t switch_action)
{
    int switch_pair = (slice & 0x6) / 2;

    CS_PRINTF(("Switch pair = %d\n", switch_pair));
    
    return cs4224_switch_duplex(
        slice,
        switch_action,
        &g_cs4224_switch_pair_state[switch_pair]);
}

/**
 * Configure the data-store variables for protection switching on a KR-AN configured slice.
 *
 * @param slice         [I] - The even (lower) slice number of the switching pair ie, 0, 2, 4 etc.
 * @param switch_action [I] - An enum type identifying the switch action, one of:
 *                                CS4224_SWITCH_DUPLEX_SWITCH_2x2, 
 *                                CS4224_SWITCH_DISABLE 
 * @param switch_state [I/O] - A state variable used to manage tracking
 *                             the h/w state when changing the configuration
 *                             of the protection switching. This structure
 *                             is used to manage disabling of the switch
 *                             when it is no longer being used.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_kr(
    cs_uint32                slice,
    e_cs4224_switch_action_t switch_action,
    cs4224_switch_pair_state_t* switch_state)
{

    cs_status status = CS_OK;
    cs_uint16 DATA_STORE_DS_tx_eye_or_2x2_ADDR = 0x51 - 0x40;
    cs_uint16 data_L, data_H;
    cs_uint16 reg_data, i;
    cs_uint32 slice_num;
    cs_uint32 guard;
 
    /* Clear SPARE26[0] to force KR to stop */
    for(slice_num = slice; slice_num <= slice+1; slice_num++)
    {
        status |= cs4224_reg_get_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &data_L);
        data_L &= ~CS_BIT0;
        status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, data_L);

        /* now wait for KR to stop... */
        guard = 0;
        do
        {
            CS_MDELAY(1);
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE25_LSB, &data_L);
            guard++;
        }
        while ((data_L != 0x0001) && (data_L != 0x0002) && (guard < 1000));

        /* 1 second timeout seems to be enough */
        if (guard == 1000)
        {
            CS_TRACE(("ERROR: Timed out waiting for KR-AN to stop on slice %x\n", slice_num));
            return CS_ERROR;
        }
    }
    
    for(slice_num = slice, i = 0; slice_num <= slice+1; slice_num++, i++)
    {
        /* Stall the MSEQs */
        cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL, 0x8004);
        cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS, 0x0008);
        cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_HOSTMISC_MSEQCLKCTRL, 0x8004);
        cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS, 0x0008);

        /* pre-stuff D1 with zeroes */
        status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0);
        status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D1, 0);

        /* setup the switch data-path here */
        if (CS4224_SWITCH_DUPLEX_SWITCH_2x2 == switch_action)
        {
            CS_PRINTF(("KR Duplex switch, slice=%x, Action=SWITCH_2x2\n", slice_num));

            /* check to see if Digital Switch already applied */
            if (TRUE == switch_state->initialized)
            {
                CS_TRACE(("ERROR: Duplex switch already applied\n"));
                return CS_ERROR;
            }
            else  
            {
                CS_PRINTF(("KR Duplex switch, slice=%x, Saving context\n", slice_num));
                /* save context prior to applying digital switch to be restored when digital switch tore down */
                if (i == 1)
                {
                    /* set initialized flag to True on second pass only */
                    switch_state->initialized = TRUE;
                }
                status |= cs4224_switch_save_duplex_state(slice_num, &(switch_state->slices[i]));
            }

            /* Read current data store register representing STX0_MISC */
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8800 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_CR, 0x8800 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);
            status |= cs4224_reg_get_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, &data_L);
            status |= cs4224_reg_get_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D0, &data_H);

            /* Set 2X2MUX_EN (bit 7), clear EYEMODE_EN (bit 4), clear PD_MUX (bit 0) */
            data_L |=  CS_BIT7; data_H |=  CS_BIT7;
            data_L &= ~CS_BIT4; data_H &= ~CS_BIT4;
            data_L &= ~CS_BIT0; data_H &= ~CS_BIT0;

            /* Write new value to data store register */
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, data_L);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D0, data_H);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);

            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0303);

            /* Clear SPARE26[6] to disable power-savings on the line side */
            status |= cs4224_reg_get_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &reg_data);
            reg_data |=  CS_BIT6;
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, reg_data);

            /* drive Rx clock to other slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            /* demux */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &reg_data);
            reg_data |= 0x1000; /* SRX_2X2_DMUX_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &reg_data);
            reg_data |= 0x1000; /* SRX_2X2_DMUX_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mail_source = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mail_source = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            cs4224_resync_elsto(slice_num,   CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
            cs4224_resync_elsto(slice_num,   CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);
            cs4224_resync_elsto(slice_num,   CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);
            cs4224_resync_elsto(slice_num,   CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);
        }
        else if(switch_action == CS4224_SWITCH_DISABLE)
        {
            CS_PRINTF(("KR Duplex switch, slice=%x, Action=DISABLE\n", slice_num)); 

            /* check to see if Digital Switch already applied */
            if (FALSE == switch_state->initialized)
            {
                CS_TRACE(("ERROR: Duplex switch not already applied\n"));
                return CS_ERROR;
            }
            else  
            {
                CS_PRINTF(("KR Duplex switch, slice=%x, Restoring context\n", slice_num));
                /* restore context to the state it was in prior to when digital switch applied */
                status |= cs4224_switch_restore_duplex_state(slice_num, &switch_state->slices[i]);
                if (i == 1)
                {
                    /* set initialized flag to False on second pass only */
                    switch_state->initialized = FALSE;
                }
            }

            /* Read current data store register representing STX0_MISC */
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8800 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_CR, 0x8800 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);
            status |= cs4224_reg_get_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, &data_L);
            status |= cs4224_reg_get_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D0, &data_H);

            /* Clear 2X2MUX_EN (bit 7), set EYEMODE_EN (bit 4), set PD_MUX (bit 0) */
            data_L &= ~CS_BIT7; data_H &= ~CS_BIT7;
            data_L |=  CS_BIT4; data_H |=  CS_BIT4;
            data_L |=  CS_BIT0; data_H |=  CS_BIT0;    

            /* Write new value to data store register */
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, data_L);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D0, data_H);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_DS_tx_eye_or_2x2_ADDR);

            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0000);

#if 0       /* this block replaced by the restore context...*/
            /* Clear SPARE26[6] to re-enable power-savings on the line side */
            status |= cs4224_reg_get_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &reg_data);
            reg_data &= ~CS_BIT6;
            status |= cs4224_reg_set_channel(slice_num,     CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, reg_data);

            /* drive Rx clock to same slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data &= ~0x2000; /* SRX_EXT_SERCLK_EN = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data &= ~0x2000; /* SRX_EXT_SERCLK_EN = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data &= ~0x0008; /* STX_EXT_SERCLK_EN = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data &= ~0x0008; /* STX_EXT_SERCLK_EN = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            /* demux */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &reg_data);
            reg_data &= ~0x1000; /* SRX_2X2_DMUX_EN = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &reg_data);
            reg_data &= ~0x1000; /* SRX_2X2_DMUX_EN = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data &= ~0x0001; /* mail_source = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data &= ~0x0001; /* mail_source = 0 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);
#endif
            cs4224_resync_elsto(slice_num,   CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
            cs4224_resync_elsto(slice_num,   CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);
            cs4224_resync_elsto(slice_num,   CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);
            cs4224_resync_elsto(slice_num,   CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);
        }
        else
        {
            CS_TRACE(("ERROR: Invalid KR Switch Action=%d, only CS4224_SWITCH_DUPLEX_SWITCH_2x2 and CS4224_SWITCH_DISABLE actions are valid\n", switch_action));
            return CS_ERROR;
        }

        /* Release MSEQ stall */
        cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL, 0x0004);
        cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS, 0x0007);
        cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_HOSTMISC_MSEQCLKCTRL, 0x0004);
        cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS, 0x0007);
    }

    /* Set SPARE26[0] to permit KR to re-start (at the beginning of AN) */
    for(slice_num = slice; slice_num <= slice+1; slice_num++)
    {
        status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, &data_L);
        data_L |= CS_BIT0;
        status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, data_L);
    }

    return status;

}

/**
 * Initialize the switch state so the switch_duplex_superfast method doesn't have to
 * spend time doing it.
 * 
 * This should be run once on every prime-slice in a switch pair that you want to run
 * super fast switching on.
 * 
 * @{note,
 * NOTE: Makes the same assumptions as cs4224_switch_duplex_superfast
 * 
 * Note that at this point it's not stable and EXPERIMENTAL only. Talk to your Cortina
 * FAE for more info.
 * }
 * 
 * For duplex switching on dual-die devices, using die_broadcast will write the switch config to both
 * dies at the same time. This halves the number of writes needed and will halve the time taken to apply
 * the switch.
 * 
 * When enabled, only slices 4 and 6 will actually apply any config. Calls to slices 0/2 will return CS_OK
 * without setting any config. This is to ease integration into projects that already call the switch methods
 * on all switch pairs, and facilitates using die broadcast due to the nature of maddr masking
 * 
 * Only relevant for the 8-port duplex devices.
 * 
 * For which pairs will be set at the same time:
 * 
 * @{table,
 * -h Slice pairs that will be set when broadcast is enabled
 * -s Die 1 ! Die 0
 * - 0/1 ! 6/7
 * - 2/3 ! 4/5
 * }
 * 
 * @param slice         [I] - The even (lower) slice number of the switching pair ie, 0, 2, 4, 6
 * @param switch_state [I/O] - A state variable used to manage tracking the h/w state when changing the configuration
 *                             of the protection switching. Only the initialized flag is used from the struct (unlike 
 *                             the other switch methods)
 * @param die_broadcast [I] - If TRUE, will enable the broadcasting of writes to the other die on dual-die devices.
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @example
 * 
 * //init the states after running cs4224_slice_enter_operational_state
 * //low-speed portion of the program, board bringup, etc.
 * for(slice=0; slice<8; slice+=2)
 * {
 *     cs4224_switch_duplex_superfast_init(0, &(switch_state[slice/2]), FALSE);
 * }
 * 
 * ...
 * 
 * //high-speed portion of the program, need <50ms switching times
 * cs4224_switch_duplex_superfast(0, CS4224_SWITCH_DUPLEX_SWITCH_2x2, &switch_state[0], FALSE);
 * 
 * @private
 */
cs_status cs4224_switch_duplex_superfast_init(
    cs_uint32                   slice,
    cs4224_switch_pair_state_t* switch_state,
    cs_boolean                  die_broadcast)
{
    cs_status status = CS_OK;
    
    if(slice & 1)
    {
        CS_TRACE(("ERROR: Duplex switch can only be applied to even slices (0,2,4,etc.)\n"));
        return CS_ERROR;
    }
    
    if(switch_state->low_latency_switching)
    {
        CS_TRACE(("ERROR: Low latency not supported.\n"));
        return CS_ERROR;
    }
    
    if(die_broadcast)
    {
        if(CS4224_MAX_NUM_DIES(slice) != 2)
        {
            CS_TRACE(("ERROR: Cannot use broadcast with single-die devices\n"));
            return CS_ERROR;
        }
        /* ignore calls to this method on slices 0/2, only care about ones to 4/6 */
        if( ((slice&0xFF) == 0) || ((slice&0xFF) == 2) )
        {
            CS_TRACE(("WARNING: Ignoring this call to slice %x while broadcast is enabled (only responds to slice 4 & 6)\n", slice));
            return CS_OK;
        }
    }

    /* check to see if Digital Switch already applied */
    if (!switch_state->initialized)
    {
        /* the following assumes that slice is only even (check above) */
        cs_uint32 dev_addr = (slice & 0xFFFFFF00);
        cs_uint32 other_slice = (8 - 2 - (slice & 0xFF)) | dev_addr; /* 8D: 0 to 6, 2 to 4 */
        if(die_broadcast && (other_slice > slice))
        {
            /* For broadcast we want to run all of the reg writes on die 0. So find the 'other slice'
             * that has the same PP number and use the higher of the two as 'slice' and the lower as 'other_slice'
             * Only applies to broadcast.
             */
            cs_uint32 temp = slice;
            slice = other_slice;
            other_slice = temp;
        }
        
        /* disable power savings */
        status |= cs4224_mseq_enable_power_savings(slice,   CS4224_DPLX_HOST_MSEQ, FALSE);
        status |= cs4224_mseq_enable_power_savings(slice,   CS4224_DPLX_LINE_MSEQ, FALSE);
        status |= cs4224_mseq_enable_power_savings(slice+1, CS4224_DPLX_HOST_MSEQ, FALSE);
        status |= cs4224_mseq_enable_power_savings(slice+1, CS4224_DPLX_LINE_MSEQ, FALSE);
        
        if(die_broadcast)
        {
            /* the fn here uses reads, so to make this easy just run the function on the other slices as well */
            status |= cs4224_mseq_enable_power_savings(other_slice,   CS4224_DPLX_HOST_MSEQ, FALSE);
            status |= cs4224_mseq_enable_power_savings(other_slice,   CS4224_DPLX_LINE_MSEQ, FALSE);
            status |= cs4224_mseq_enable_power_savings(other_slice+1, CS4224_DPLX_HOST_MSEQ, FALSE);
            status |= cs4224_mseq_enable_power_savings(other_slice+1, CS4224_DPLX_LINE_MSEQ, FALSE);
            
            /* enable die broadcast, IGNORE THE STATUS since changing the maddr mask may cause the comms to drop */
            cs4224_reg_set(dev_addr+1, CS4224_GLOBAL_BROADCAST, 0x0100);
        }
        
        /* power everything up */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0);
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0);
        
        /* enable the clk ext buffer to go to the other slice, can leave this on */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, 0x22ff); /* SRX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, 0x22ff); /* SRX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, 0x22ff); /* SRX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, 0x22ff); /* SRX_EXT_SERCLK_EN = 1 */

        /* enable muxes and eye mode, uses more power but just leave this on */
        /* note that the host ones get overwritten each time you switch, line ones can stay on */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_MISC, 0x22); /* power-up mux, STX_EYEMODE_EN=0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, 0x22);
        
        if(die_broadcast)
        {
            /* disable die broadcast */
            status |= cs4224_reg_set(dev_addr, CS4224_GLOBAL_BROADCAST, 0x0000);
        }
        
        if(CS_OK != status)
        {
            CS_TRACE(("ERROR: register write failed, setting initialized = FALSE\n"));
            return status;
        }
        switch_state->initialized = TRUE;
    }
    
    return status;
}

/**
 * See cs4224_switch_duplex.
 * 
 * This version is specially designed to make some assumptions about the system
 * in order to greatly reduce the number of register writes required to switch.
 * 
 * It assumes:
 *  - NOT using 15G or FC rates (16/8/4/2/1G FC)
 *  - Only using digital (high latency) switch
 *  - NOT using KRAN or FCAN
 *  - Only using duplex devices
 *  - Assumes power savings is already OFF
 *  - POWER_DOWN_LSB has already been set to 0x0 on all interfaces (line/host of both slices)
 * 
 * @{note,
 * Note that at this point it's not stable and EXPERIMENTAL only. Talk to your Cortina
 * FAE for more info.
 * }
 * 
 * For duplex switching on dual-die devices, using die_broadcast will write the switch config to both
 * dies at the same time. This halves the number of writes needed and will halve the time taken to apply
 * the switch.
 * 
 * When enabled, only slices 4 and 6 will actually apply any config. Calls to slices 0/2 will return CS_OK
 * without setting any config. This is to ease integration into projects that already call the switch methods
 * on all switch pairs, and facilitates using die broadcast due to the nature of maddr masking
 * 
 * Only relevant for the 8-port duplex devices.
 * 
 * For which pairs will be set at the same time:
 * 
 * @{table,
 * -h Slice pairs that will be set when broadcast is enabled
 * -s Die 1 ! Die 0
 * - 0/1 ! 6/7
 * - 2/3 ! 4/5
 * }
 * 
 * @param slice         [I] - The even (lower) slice number of the switching pair ie, 0, 2, 4, 6
 * @param switch_action [I] - An enum type identifying the switch action, one of:
 *                                CS4224_SWITCH_DUPLEX_SWITCH_2x2, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0 or 
 *                                CS4224_SWITCH_DISABLE 
 * @param switch_state [I/O] - A state variable used to manage tracking the h/w state when changing the configuration
 *                             of the protection switching. Only the initialized flag is used from the struct (unlike 
 *                             the other switch methods)
 * @param die_broadcast [I] - If TRUE, will enable the broadcasting of writes to the other die on dual-die devices.
 *
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_switch_duplex_superfast(
    cs_uint32                   slice,
    e_cs4224_switch_action_t    switch_action,
    cs4224_switch_pair_state_t* switch_state,
    cs_boolean                  die_broadcast)
{
    cs_status status = CS_OK;
    /* Set this to TRUE to power down the unused VCO. This may improve performance and reduce xtalk,
     * but you will lose lock on some downstream ports during the next switch (the one after this one) */
    cs_boolean powerdown_unused_vco = FALSE;
    cs_uint32 dev_addr = (slice & 0xFFFFFF00);
    /* the following assumes that slice is only even (check below) */
    cs_uint32 other_slice = (8 - 2 - (slice & 0xFF)) | dev_addr; /* 8D: 0 to 6, 2 to 4 */

    if (slice & 1)
    {
        CS_TRACE(("ERROR: Duplex switch can only be applied to even slices (0,2,4,etc.)\n"));
        return CS_ERROR;
    }
    
    if(switch_state->low_latency_switching)
    {
        CS_TRACE(("ERROR: Low latency not supported. There are many caveats to using this function. Read the comment block for a description\n"));
        return CS_ERROR;
    }
    
    if(die_broadcast)
    {
        if(CS4224_MAX_NUM_DIES(slice) != 2)
        {
            CS_TRACE(("ERROR: Cannot use broadcast with single-die devices\n"));
            return CS_ERROR;
        }
        if( (switch_action != CS4224_SWITCH_DISABLE) && (switch_action != CS4224_SWITCH_DUPLEX_SWITCH_2x2) )
        {
            CS_TRACE(("ERROR: Cannot use die_broadcast with broadcast switching, can only be used with 2x2 and disabled\n"));
            return CS_ERROR;
        }
        /* ignore calls to this method on slices 0/2, only care about ones to 4/6 */
        if( ((slice & 0xFF) == 0) || ((slice & 0xFF) == 2) )
        {
            CS_TRACE(("WARNING: Ignoring this call to slice %x while broadcast is enabled (only responds to slice 4 & 6)\n", slice));
            return CS_OK;
        }
    }
    
    if(die_broadcast && (other_slice > slice))
    {
        /* For broadcast we want to run all of the reg writes on die 0. So find the 'other slice'
         * that has the same PP number and use the higher of the two as 'slice' and the lower as 'other_slice'
         * Only applies to broadcast.
         */
        cs_uint32 temp = slice;
        slice = other_slice;
        other_slice = temp;
    }
    
    if(switch_action == CS4224_SWITCH_DUPLEX_SWITCH_2x2)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_2x2\n", slice)); */
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_0_to_0\n", slice)); */
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_1_to_1\n", slice)); */
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_0_to_1\n", slice)); */
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_1_to_0\n", slice)); */
    }
    else if(switch_action == CS4224_SWITCH_DISABLE)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=DISABLE\n", slice)); */
    }
    else
    {
        CS_TRACE(("ERROR: Invalid Duplex Switch Action=%d\n", switch_action));
        return CS_ERROR;
    }

    cs4224_lock(slice);
    cs4224_lock(slice+1);
    
    if (switch_action != CS4224_SWITCH_DISABLE)
    {
        status |= cs4224_switch_duplex_superfast_init(slice, switch_state, die_broadcast);
        if(CS_OK != status)
        {
            CS_TRACE(("ERROR initializing superfast switch state\n"));
            return status;
        }
    }

    if(die_broadcast)
    {
        /* enable die broadcast, IGNORE THE STATUS since changing the maddr mask may cause the comms to drop */
        cs4224_reg_set(dev_addr+1, CS4224_GLOBAL_BROADCAST, 0x0100);
    }
    
    /* configure the Rx to Tx timing */
    if(switch_action == CS4224_SWITCH_DUPLEX_SWITCH_2x2)
    {
        if(powerdown_unused_vco)
        {
            /* power up the previously-unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
            status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
        }
        
        /* enable both host muxes */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x22); /* power-up mux, STX_EYEMODE_EN=0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x22);
        
        /* host Tx/Rx clock/data selection */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0303);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0303);
        
        /* now actually make the switch */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */

        /* mailbox setup */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
    }

    if(switch_action == CS4224_SWITCH_DIGITAL_BROADCAST_0_to_0)
    {
        if(powerdown_unused_vco)
        {
            /* power up the previously-unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
        }
        
        /* from mux enable */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x22); /* power-up mux, STX_EYEMODE_EN=0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x8033); /* stx_pd=1, power-down mux, STX_EYEMODE_EN=1 */
        
        /* host Tx/Rx clock/data selection */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0000);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0101);
        
        /* now actually make the switch */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */

        if(powerdown_unused_vco)
        {
            /* power down the unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x705);
        }

        /* mailbox setup */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        /*status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);*/
    }

    if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1)
    {
        if(powerdown_unused_vco)
        {
            /* power up the previously-unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
        }
        
        /* from mux enable */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x8033); /* stx_pd=1, power-down mux, STX_EYEMODE_EN=1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x22); /* power-up mux, STX_EYEMODE_EN=0 */
        
        /* host Tx/Rx clock/data selection */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0101);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0000);
        
        /* now actually make the switch */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */

        /* mailbox setup */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        /*status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);*/
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        
        if(powerdown_unused_vco)
        {
            /* power down the unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x705);
        }

    }

    if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1)
    {
        if(powerdown_unused_vco)
        {
            /* power up the previously-unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
        }
        
        /* from mux enable */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x22); /* power-up mux, STX_EYEMODE_EN=0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x8033); /* stx_pd=1, power-down mux, STX_EYEMODE_EN=1 */
        
        /* host Tx/Rx clock/data selection */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0002);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0301);
        
        /* now actually make the switch */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */

        /* mailbox setup */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        /*status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);*/
        
        if(powerdown_unused_vco)
        {
            /* power down the unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x705);
        }

    }

    if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0)
    {
        if(powerdown_unused_vco)
        {
            /* power up the previously-unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
        }
        
        /* from mux enable */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x8033); /* stx_pd=1, power-down mux, STX_EYEMODE_EN=1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x22); /* power-up mux, STX_EYEMODE_EN=0 */
        
        /* host Tx/Rx clock/data selection */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0301);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0002);
        
        /* now actually make the switch */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x18); /* STX_EXT_SERCLK_EN = 1 */

        /* mailbox setup */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        /*status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);*/
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x1);
        
        if(powerdown_unused_vco)
        {
            /* power down the unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x705);
        }

    }

    if (switch_action == CS4224_SWITCH_DISABLE) 
    {
        if(powerdown_unused_vco)
        {
            /* power up the previously-unused host side Rx/Tx */
            status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
            status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG, 0x607);
        }

        /* make the switch */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, 0x10); /* STX_EXT_SERCLK_EN = 0 */

        /* stop getting Tx clock/data from the mate */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0000);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, 0x0000);
        
        /* disable both host muxes */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x33); /* power-down mux, STX_EYEMODE_EN=1 */
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_MISC, 0x33);
        
        /* mailbox setup */
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, 0x0);
        
        switch_state->initialized = FALSE;
    }

    if(!switch_state->low_latency_switching)
    {
        /* cs4224_resync_elsto supports write buffering */
        status |= cs4224_resync_elsto(slice,   CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
        /*status |= cs4224_resync_elsto(slice,   CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);*/
        status |= cs4224_resync_elsto(slice,   CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);
        /*status |= cs4224_resync_elsto(slice,   CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);*/
        status |= cs4224_resync_elsto(slice+1, CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
        /*status |= cs4224_resync_elsto(slice+1, CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);*/
        status |= cs4224_resync_elsto(slice+1, CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);
        /*status |= cs4224_resync_elsto(slice+1, CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);*/
    }
    
    if(die_broadcast)
    {
        /* disable die broadcast */
        status |= cs4224_reg_set(dev_addr, CS4224_GLOBAL_BROADCAST, 0x0000);
    }
    
    cs4224_unlock(slice);
    cs4224_unlock(slice+1);
    

    return status;
}

/**
 * Configure the 2x2 protection switching on duplex devices. This
 * method can be used to enable either the digital switch or
 * the analog switch (lower latency). The analog switch provides
 * lower latency but cannot be used when KR-AN or FC-AN
 * are required.
 *
 * Note that protection switching cannot be combined with loopbacks.
 *
 * @param slice         [I] - The even (lower) slice number of the switching pair ie, 0, 2, 4 etc.
 * @param switch_action [I] - An enum type identifying the switch action, one of:
 *                                CS4224_SWITCH_DUPLEX_SWITCH_2x2, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1, 
 *                                CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0 or 
 *                                CS4224_SWITCH_DISABLE 
 * @param switch_state [I/O] - A state variable used to manage tracking
 *                             the h/w state when changing the configuration
 *                             of the protection switching. This structure
 *                             is used to manage disabling of the switch
 *                             when it is no longer being used.
 *
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 *    // This structure is used to maintain the switch
 *    // state. It is used in order to revert the device
 *    // state when the switch is disabled
 *    cs4224_switch_pair_state_t switch_state;
 *    
 *    switch_state.initialized      = FALSE; // Not initialized yet
 *    switch_state.low_latency_mode = FALSE;  // Use low latency switching
 *    
 *    // Setup the device for 10G mode. The enter_operational_state
 *    // method manages the reset, programming the microcode (as required)
 *    // and initialization of the device
 *    for(i = 0; i < CS4224_MAX_NUM_SLICES(SELECT_ASIC(0)); i++)
 *    {
 *        cs4224_rules_t rules;
 *    
 *        // Setup the default rules for 10G operation
 *        cs4224_rules_set_default(CS4224_TARGET_APPLICATION_10G, &rules);
 *    
 *        // Initialize the slice and bring it into operational state
 *        cs4224_slice_enter_operational_state(i, &rules);
 *    }
 *    
 *    // Activate a duplex 2x2 protection switch event on ports 2 and 3
 *    status |= cs4224_switch_duplex(2, CS4224_SWITCH_DUPLEX_SWITCH_2x2, &switch_state);
 *    
 *    // Deactivate the duplex 2x2 protection event on ports 2 and 3
 *    status |= cs4224_switch_duplex(2, CS4224_SWITCH_DISABLE, &switch_state);
 *
 */
cs_status cs4224_switch_duplex(
    cs_uint32                   slice,
    e_cs4224_switch_action_t    switch_action,
    cs4224_switch_pair_state_t* switch_state)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data;
    cs_uint16 mate_sel[2] = {0, 0};

    if (cs4224_is_hw_simplex(slice))
    {
        CS_TRACE(("ERROR: Duplex switch supported on duplex part only\n"));
        return CS_ERROR;
    }

    if (slice & 1)
    {
        CS_TRACE(("ERROR: Duplex switch can only be applied to even slices (0,2,4,etc.)\n"));
        return CS_ERROR;
    } 

    /* if slice configured for KR-AN */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB, &reg_data);
    if (reg_data & 0x4000)
    {
        status |= cs4224_switch_kr(slice, switch_action, switch_state);
        return status;
    }

    /* if slice configured for FC-AN */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, &reg_data);
    if (reg_data & 0x0020)
    {
        status = cs4224_slice_soft_reset(slice);
        status = cs4224_slice_soft_reset(slice+1);
    }

    /* configure the MATE_SELECT register */
    if(switch_action == CS4224_SWITCH_DUPLEX_SWITCH_2x2)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_2x2\n", slice)); */
        mate_sel[0] = 0x0303; 
        mate_sel[1] = 0x0303; 
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_0_to_0\n", slice)); */
        mate_sel[0] = 0x0000; 
        mate_sel[1] = 0x0101; 
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_1_to_1\n", slice)); */
        mate_sel[0] = 0x0101; 
        mate_sel[1] = 0x0000; 
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_0_to_1\n", slice)); */
        mate_sel[0] = 0x0002; 
        mate_sel[1] = 0x0301; 
    }
    else if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=SWITCH_BROADCAST_1_to_0\n", slice)); */
        mate_sel[0] = 0x0301; 
        mate_sel[1] = 0x0002; 
    }
    else if(switch_action == CS4224_SWITCH_DISABLE)
    {
        /* CS_PRINTF(("Duplex switch, slice=%d, Action=DISABLE\n", slice)); */
        mate_sel[0] = 0x0000; 
        mate_sel[1] = 0x0000; 
    }
    else
    {
        CS_TRACE(("ERROR: Invalid Duplex Switch Action=%d\n", switch_action));
        return CS_ERROR;
    }

    cs4224_lock(slice);
    cs4224_lock(slice+1);

    if (switch_action != CS4224_SWITCH_DISABLE)
    {
        /* check to see if Digital Switch already applied */
        if (TRUE == switch_state->initialized)
        {
            /* CS_PRINTF(("Duplex switch, Restoring context...\n"));*/
            /* we may be going from one switch state to another */
            /* restore context to the state it was in prior to when digital switch applied */
            status |= cs4224_switch_restore_duplex_state(slice,   &switch_state->slices[0]);
            status |= cs4224_switch_restore_duplex_state(slice+1, &switch_state->slices[1]);
        }
        else
        {
            /* CS_PRINTF(("Duplex switch, Saving context...\n"));*/
            /* save context prior to applying digital switch to be restored when digital switch tore down */
            switch_state->initialized = TRUE;
            status |= cs4224_switch_save_duplex_state(slice,   &(switch_state->slices[0]));
            status |= cs4224_switch_save_duplex_state(slice+1, &(switch_state->slices[1]));
        }

        cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
        cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_HOST_MSEQ, FALSE);
        cs4224_mseq_enable_power_savings(slice+1, CS4224_DPLX_LINE_MSEQ, FALSE);
        cs4224_mseq_enable_power_savings(slice+1, CS4224_DPLX_HOST_MSEQ, FALSE);
    }
#if 0
    CS_PRINTF(("CS4224_PP_HOST_HOSTMISC_MATE_SELECT[0]=0x%04x\n", mate_sel[0]));
    CS_PRINTF(("CS4224_PP_HOST_HOSTMISC_MATE_SELECT[1]=0x%04x\n", mate_sel[1]));
#endif
    /* Don't program the mate select register if we're using the low latency analog switch path */
    if(TRUE != switch_state->low_latency_switching)
    {
        status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, mate_sel[0]);
        status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, mate_sel[1]);
    }

    /* configure the Rx to Tx timing */
    if(switch_action == CS4224_SWITCH_DUPLEX_SWITCH_2x2)
    {
        cs_uint32 slice_num;

        /* CS_PRINTF(("Duplex switch, SWITCH_2x2\n"));*/

        for(slice_num = slice; slice_num <= slice+1; slice_num++)
        {
            if(TRUE == switch_state->low_latency_switching)
            {
                /* Form cross connect on both slices for a 2x2 */
                cs4224_switch_connect_line_rx_to_host_tx_of_mate(slice_num);
                cs4224_switch_connect_host_rx_to_line_tx_of_mate(slice_num);
            }
            else
            {
                /* power-up the muxes/demuxes */
                status |= cs4224_mux_enable(slice_num,     CS4224_CFG_LINE_SIDE, TRUE);
                status |= cs4224_mux_enable(slice_num,     CS4224_CFG_HOST_SIDE, TRUE);
                status |= cs4224_demux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
                status |= cs4224_demux_enable(slice_num,   CS4224_CFG_HOST_SIDE, TRUE);

                /* drive Rx clock to other slice */
                status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
                reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
                status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

                /* mux A */
                status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
                reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
                status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

                /* drive Rx clock to other slice */
                status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
                reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
                status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

                /* mux A */
                status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
                reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
                status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

                status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
                reg_data |= 0x0001; /* mail_source = 1 */
                status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

                status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
                reg_data |= 0x0001; /* mail_source = 1 */
                status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);
            }
        }
    }

    if(switch_action == CS4224_SWITCH_DIGITAL_BROADCAST_0_to_0)
    {
        /* Note: this applied to the egress direction only */
        /* Rx/Tx on low to low slice with line Tx only on high (Egress dir only) */
        cs_uint32 slice_num;

        /* CS_PRINTF(("Duplex switch, SWITCH_BROADCAST_0_to_0\n"));*/

        slice_num = slice;

        /* In this case we need to connect the host receiver on slice N to the
         * line transmitter on the partner slice N+1. This serves as the broadcast
         * path. Then we need to enable eye mode so that the data goes straight
         * through */
        if(TRUE == switch_state->low_latency_switching)
        {
            cs4224_switch_connect_host_rx_to_line_tx_of_mate(slice);
        }
        else
        {
            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_HOST_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_HOST_SIDE, TRUE);

            /* drive Rx clock to other slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            slice_num = slice+1;

            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);
            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mate mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            /* power down the unused host side Rx/Tx */
            status |= cs4224_switch_power_down(slice+1);
        }
    }

    if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1)
    {
        /* Note: this applied to the egress direction only */
        /* Rx/Tx on high to high slice with line Tx only on low (Egress dir only) */

        cs_uint32 slice_num;

        /* CS_PRINTF(("Duplex switch, SWITCH_BROADCAST_1_to_1\n"));*/

        slice_num = slice;
        
        /* In this case we need to connect the host receiver on slice N to the
         * line transmitter on the partner slice N+1. This serves as the broadcast
         * path. Then we need to enable eye mode so that the data goes straight
         * through */
        if(TRUE == switch_state->low_latency_switching)
        {
            cs4224_switch_connect_host_rx_to_line_tx_of_mate(slice+1);
        }
        else
        {
            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);

            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mate mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            slice_num = slice+1;

            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_HOST_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_HOST_SIDE, TRUE);

            /* drive Rx clock to other slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            /* power down the unused host side Rx/Tx */
            status |= cs4224_switch_power_down(slice);
        }
    }

    if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1)
    {
        /* Note: this applied to the egress direction only */

        cs_uint32 slice_num;

        /* CS_PRINTF(("Duplex switch, SWITCH_BROADCAST_0_to_1\n"));*/

        slice_num = slice;
        
        if(TRUE == switch_state->low_latency_switching)
        {
            cs4224_switch_connect_host_rx_to_line_tx_of_mate(slice);
            cs4224_switch_connect_line_rx_to_host_tx_of_mate(slice+1);
        }
        else
        {
            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_HOST_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_HOST_SIDE, TRUE);

            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            /* drive Rx clock to other slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mate mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            slice_num = slice+1;

            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);

            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            /* drive Rx clock to other slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mate mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            /* power down the unused host side Rx/Tx */
            status |= cs4224_switch_power_down(slice+1);
        }
    }

    if(switch_action == CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0)
    {
        /* Note: this applied to the egress direction only */

        cs_uint32 slice_num;

        /* CS_PRINTF(("Duplex switch, SWITCH_BROADCAST_1_to_0\n"));*/

        slice_num = slice;
        
        if(TRUE == switch_state->low_latency_switching)
        {
            cs4224_switch_connect_host_rx_to_line_tx_of_mate(slice+1);
            cs4224_switch_connect_line_rx_to_host_tx_of_mate(slice);
        }
        else
        {
            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);

            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            /* drive Rx clock to other slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mate mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            slice_num = slice+1;

            /* power-up the muxes/demuxes */
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_mux_enable(slice_num,   CS4224_CFG_HOST_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice_num, CS4224_CFG_HOST_SIDE, TRUE);

            /* mux A */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &reg_data);
            reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, reg_data);

            /* drive Rx clock to other slice */
            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, &reg_data);
            reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1 */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0000; /* local mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            status |= cs4224_reg_get_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, &reg_data);
            reg_data |= 0x0001; /* mait mail */
            status |= cs4224_reg_set_channel(slice_num, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL, reg_data);

            /* power down the unused host side Rx/Tx */
            status |= cs4224_switch_power_down(slice);
        }
    }

    if (switch_action == CS4224_SWITCH_DISABLE) 
    {
        /* CS_PRINTF(("Duplex switch, DISABLE\n"));*/

        if (TRUE == switch_state->initialized)
        {
            /* CS_PRINTF(("Duplex switch, Restoring context...\n"));*/
            /* restore context to the state it was in prior to when digital switch applied */
            status |= cs4224_switch_restore_duplex_state(slice,   &switch_state->slices[0]);
            status |= cs4224_switch_restore_duplex_state(slice+1, &switch_state->slices[1]);

            switch_state->initialized = FALSE;
        }
    }

    if(FALSE == switch_state->low_latency_switching)
    {
        cs4224_resync_elsto(slice,   CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
        cs4224_resync_elsto(slice,   CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);
        cs4224_resync_elsto(slice,   CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);
        cs4224_resync_elsto(slice,   CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);
        cs4224_resync_elsto(slice+1, CS4224_PP_LINE_SDS_COMMON_TXELST0_Control);
        cs4224_resync_elsto(slice+1, CS4224_PP_LINE_SDS_COMMON_RXELST0_Control);
        cs4224_resync_elsto(slice+1, CS4224_PP_HOST_SDS_COMMON_TXELST0_Control);
        cs4224_resync_elsto(slice+1, CS4224_PP_HOST_SDS_COMMON_RXELST0_Control);
    }
    
    if(TRUE == switch_state->low_latency_switching)
    {
        status |= cs4224_switch_reset_analog_elsto(slice);
    }

    /* resend any squelch requests (harmless in most cases) */
    status |= cs4224_reg_set_channel(slice,   CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_MSB, 0x9000);
    status |= cs4224_reg_set_channel(slice,   CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_MSB, 0x9000);
    status |= cs4224_reg_set_channel(slice+1, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_MSB, 0x9000);
    status |= cs4224_reg_set_channel(slice+1, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_MSB, 0x9000);
    
    cs4224_unlock(slice);
    cs4224_unlock(slice+1);
        

    return status;
}

/**
 * This method may be called to query the current switch mode from the
 * hardware. It returns the active mode as well as whether the low latency
 * path is applied. This currently only really works for duplex
 * parts.
 *
 * @param slice            [I] - The slice of the device to query.
 * @param switch_mode      [O] - The active switch mode.
 * @param low_latency_mode [O] - TRUE if the low latency path is applied.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_switch_query_mode(
    cs_uint32                 slice,
    e_cs4224_switch_action_t* switch_mode,
    cs_boolean*               low_latency_mode)
{
    cs_status status = CS_OK;
    cs_uint16 mate_select_0;
    cs_uint16 mate_select_1;
    cs_uint16 line_driver_config_sel0;
    cs_uint16 line_driver_config_sel1;
    cs_uint16 host_driver_config_sel0;
    cs_uint16 host_driver_config_sel1;
    cs_uint8  driver_config_bits;

    slice &= ~0x1;
    
    status |= cs4224_reg_get_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, &mate_select_0);
    status |= cs4224_reg_get_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, &mate_select_1);
    
    *low_latency_mode = FALSE;
    *switch_mode = CS4224_SWITCH_DISABLE;
    
    /* look for evidence of a digital switch first */

    if ((mate_select_0 == 0x0303) && (mate_select_1 == 0x0303))
    {
        *switch_mode = CS4224_SWITCH_DUPLEX_SWITCH_2x2;
    }
    else if ((mate_select_0 == 0x0000) && (mate_select_1 == 0x0101))
    {
        *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0;
    }
    else if ((mate_select_0 == 0x0101) && (mate_select_1 == 0x0000))
    {
        *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1;
    }
    else if ((mate_select_0 == 0x0002) && (mate_select_1 == 0x0301))
    {
        *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1;
    }
    else if ((mate_select_0 == 0x0301) && (mate_select_1 == 0x0002))
    {
        *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0;
    }
    else
    {
        /* otherwise check for an analog switch */

        status |= cs4224_reg_get_channel(slice,   CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &line_driver_config_sel0);
        status |= cs4224_reg_get_channel(slice+1, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG, &line_driver_config_sel1);
            
        status |= cs4224_reg_get_channel(slice,   CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &host_driver_config_sel0);
        status |= cs4224_reg_get_channel(slice+1, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG, &host_driver_config_sel1);
    
        driver_config_bits = (((line_driver_config_sel0 >> 3) & 0x1) << 3) |
                             (((line_driver_config_sel1 >> 3) & 0x1) << 2) |
                             (((host_driver_config_sel0 >> 3) & 0x1) << 1) |
                             ( (host_driver_config_sel1 >> 3) & 0x1);

        if (driver_config_bits == 0xf)
        {
            *switch_mode = CS4224_SWITCH_DUPLEX_SWITCH_2x2;
            *low_latency_mode = TRUE;
        }
        else if (driver_config_bits == 0x4)
        {
            *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0;
            *low_latency_mode = TRUE;
        }
        else if (driver_config_bits == 0x8)
        {
            *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1;
            *low_latency_mode = TRUE;
        }
        else if (driver_config_bits == 0x6)
        {
            *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1;
            *low_latency_mode = TRUE;
        }
        else if (driver_config_bits == 0x9)
        {
            *switch_mode = CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0;
            *low_latency_mode = TRUE;
        }
    } 
    return status;    
}

/**
 * Configure the protection switching (analog) on this device. 
 *
 * Analog switching is supported on Simplex devices only. This method supports 
 * Analog switching. Unlike digital switching, analog switching do not switch
 * on a port-pair. The two slices seem arbitrary, as can be seen in the following 
 * slice/mate association table.
 *
 * 16 port Simplex CS4224 slice/mate association table: 
 *
 * {{
 *
 *                          (16-port)  
 *                            CS4224   
 *                  Slice     Mate       Direction 
 *                    0        1     Rx (line to host) 
 *                    1        0     Rx (line to host)
 *                    2        4     Rx (line to host) 
 *                    3        5     Tx (host to line) 
 *                    4        2     Rx (line to host) 
 *                    5        3     Tx (host to line) 
 *                    6        7     Tx (host to line) 
 *                    7        6     Tx (host to line) 
 *                    8       10     Rx (line to host) 
 *                    9       11     Rx (line to host) 
 *                   10        8     Rx (line to host)
 *                   11        9     Rx (line to host)
 *                   12       15     Tx (host to line)
 *                   13       14     Tx (host to line)
 *                   14       13     Tx (host to line)
 *                   15       12     Tx (host to line)
 * }}
 *
 * As can be seen from the above table, on a 16 port simplex CS4224 device, slice 14 
 * can switch or broadcast to slice 13 or vice-versa.

 * @param slice         [I] - The base slice number of the switching pair
 * @param switch_action [I] - An enum type identifying the switch action, one of:
 *                                CS4224_SWITCH_ANALOG_SWITCH_2x2, 
 *                                CS4224_SWITCH_ANALOG_BROADCAST or
 *                                CS4224_SWITCH_DISABLE 
 *
 * Note that protection switching cannot be combined with loopbacks.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @deprecated The cs4224_switch_simplex() should be used instead of this
 *             method as it properly supports multiple ASICs and any
 *             warm reboot requirements.
 */
cs_status cs4224_switch_analog(
    cs_uint32                slice,
    e_cs4224_switch_action_t switch_action)
{
    int switch_pair = (slice & 0x6) / 2;
    
    return cs4224_switch_simplex(
        slice,
        switch_action,
        &g_cs4224_switch_pair_state[switch_pair]);
}

/**
 * Configure the protection switching (analog) on this device. 
 *
 * Analog switching is supported on Simplex devices only. This method supports 
 * Analog switching. Unlike digital switching, analog switching do not switch
 * on a port-pair. The two slices seem arbitrary, as can be seen in the following 
 * slice/mate association table.
 *
 * 16 port Simplex CS4224 slice/mate association table: 
 *
 * {{
 *                          (16-port)  
 *                            CS4224   
 *                  Slice     Mate       Direction 
 *                    0        1     Rx (line to host) 
 *                    1        0     Rx (line to host)
 *                    2        4     Rx (line to host) 
 *                    3        5     Tx (host to line) 
 *                    4        2     Rx (line to host) 
 *                    5        3     Tx (host to line) 
 *                    6        7     Tx (host to line) 
 *                    7        6     Tx (host to line) 
 *                    8       10     Rx (line to host) 
 *                    9       11     Rx (line to host) 
 *                   10        8     Rx (line to host)
 *                   11        9     Rx (line to host)
 *                   12       15     Tx (host to line)
 *                   13       14     Tx (host to line)
 *                   14       13     Tx (host to line)
 *                   15       12     Tx (host to line)
 * }}
 *
 * As can be seen from the above table, on a 16 port simplex CS4224 device, slice 14 
 * can switch or broadcast to slice 13 or vice-versa.
 *
 * Note that protection switching cannot be combined with loopbacks.
 *
 * @param slice         [I] - The base slice number of the switching pair
 * @param switch_action [I] - An enum type identifying the switch action, one of:
 *                                CS4224_SWITCH_SIMPLEX_SWITCH_2x2, 
 *                                CS4224_SWITCH_SIMPLEX_BROADCAST or
 *                                CS4224_SWITCH_DISABLE 
 *
 * @param switch_state [I/O] - A state variable used to manage tracking
 *                             the h/w state when changing the configuration
 *                             of the protection switching. This structure
 *                             is used to manage disabling of the switch
 *                             when it is no longer being used.
 *
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_switch_simplex(
    cs_uint32                   slice,
    e_cs4224_switch_action_t    switch_action,
    cs4224_switch_pair_state_t* switch_state)
{
    cs_status status = CS_OK;
    cs_uint32 slice_num;
    cs_uint32 mate_slice;
    cs_uint16 reg_data;
    cs_uint16 spare12_addr;
    cs_uint16 clkout_ctrl_addr;
    cs_uint16 driver_config_addr;
    cs_uint16 rx_config_addr;
    cs_uint16 tx_misc_addr;
    cs_uint16 mail_sel_addr;
    cs_uint16 rxelst0_addr;
    cs_uint16 txelst0_addr;
    cs_uint16 power_down_addr;
    cs_uint16 mseq_options_addr;
    cs_uint16 mseq_options;

    if (cs4224_is_hw_duplex(slice))
    {
        CS_TRACE(("ERROR: Analog switch supported on simplex part only\n"));
        return CS_ERROR;
    }

    /* Get the mate and make sure to preserve the upper bits of the slice */
    mate_slice = g_cs4224_simplex_valid_mate_slice[slice&0xf];
    mate_slice |= slice & 0xffffff00;

    if (cs4224_line_rx_to_host_tx_dir(slice))
    {
        /* CS_PRINTF(("Analog switch Line Rx to Host Tx, slices %d and %d\n", slice, mate_slice));*/
        spare12_addr       = CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB;
        clkout_ctrl_addr   = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
        driver_config_addr = CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG;
        rx_config_addr     = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG;
        tx_misc_addr       = CS4224_PP_HOST_SDS_COMMON_STX0_MISC;
        mail_sel_addr      = CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_SEL;
        rxelst0_addr       = CS4224_PP_LINE_SDS_COMMON_RXELST0_Control;
        txelst0_addr       = CS4224_PP_HOST_SDS_COMMON_TXELST0_Control;
        power_down_addr    = CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_options_addr  = CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW;
    }
    else
    {
        /* CS_PRINTF(("Analog switch Host Rx to Line Tx, slices %d and %d\n", slice, mate_slice));*/
        spare12_addr       = CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB;
        clkout_ctrl_addr   = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKOUT_CTRL;
        driver_config_addr = CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_CONFIG;
        rx_config_addr     = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG;
        tx_misc_addr       = CS4224_PP_LINE_SDS_COMMON_STX0_MISC;
        mail_sel_addr      = CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_SEL;
        rxelst0_addr       = CS4224_PP_HOST_SDS_COMMON_RXELST0_Control;
        txelst0_addr       = CS4224_PP_LINE_SDS_COMMON_TXELST0_Control;
        power_down_addr    = CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_options_addr  = CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW;
    }
    cs4224_lock(slice);
    cs4224_lock(mate_slice);

    /* find out if microsequencer is running */
    status |= cs4224_reg_get_channel(slice, mseq_options_addr, &mseq_options);

    if (switch_action != CS4224_SWITCH_DISABLE)
    {
        /* check to see if Analog Switch already applied */
        if (switch_state->initialized)
        {
            CS_TRACE(("ERROR: Analog Switch already applied, cannot save state\n"));
            cs4224_unlock(slice);
            cs4224_unlock(mate_slice);
            return CS_ERROR;
        }

        /* save context prior to applying analog switch to be restored when analog switch tore down */
        status = cs4224_switch_save_simplex_state(slice,      &switch_state->slices[0]);
        status = cs4224_switch_save_simplex_state(mate_slice, &switch_state->slices[1]);
        switch_state->initialized = TRUE;

        /* if microsequencer is running */
        if (0 == (0x0008 & mseq_options)) 
        {
            /* stall the microsequencer */
            status |= cs4224_mseq_stall(slice,      CS4224_SPLX_MSEQ, TRUE);
            status |= cs4224_mseq_stall(mate_slice, CS4224_SPLX_MSEQ, TRUE);
        }

        status |= cs4224_reg_get_channel(slice, spare12_addr, &reg_data);
        reg_data &= ~0x0006; /* disable squelch and power savings */
        status |= cs4224_reg_set_channel(slice, spare12_addr, reg_data);

        status |= cs4224_reg_get_channel(mate_slice, spare12_addr, &reg_data);
        reg_data &= ~0x0006; /* disable squelch and power savings */
        status |= cs4224_reg_set_channel(mate_slice, spare12_addr, reg_data);

        CS_UDELAY(5);
    }

    if(switch_action == CS4224_SWITCH_ANALOG_SWITCH_2x2)
    {
        /* CS_PRINTF(("Analog switch, 2x2\n"));*/

        slice_num = slice;

        status |= cs4224_reg_get_channel(slice_num, clkout_ctrl_addr, &reg_data);
        reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1, drive Rx clock to other slice */
        status |= cs4224_reg_set_channel(slice_num, clkout_ctrl_addr, reg_data);

        status |= cs4224_reg_get_channel(slice_num, driver_config_addr, &reg_data);
        reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1, mux A */
        status |= cs4224_reg_set_channel(slice_num, driver_config_addr, reg_data);

        status |= cs4224_reg_get_channel(slice_num, rx_config_addr, &reg_data);
        reg_data |= 0x1000; /* SRX_2X2_DMUX_EN = 1 */
        status |= cs4224_reg_set_channel(slice_num, rx_config_addr, reg_data);

        /* Turn on STX_2X2MUX_EN */
        status |= cs4224_reg_set_channel(slice_num, tx_misc_addr, 0x00a2);

        status |= cs4224_reg_get_channel(slice_num, mail_sel_addr, &reg_data);
        reg_data |= 0x0001; /* mail_source = 1 */
        status |= cs4224_reg_set_channel(slice_num, mail_sel_addr, reg_data);

        status |= cs4224_reg_set_channel(slice_num, power_down_addr, 0x001f); 
        status |= cs4224_reg_set_channel(slice_num, power_down_addr, 0x0000); 

        /* re-synch the elastic stores */
        cs4224_resync_elsto(slice_num, rxelst0_addr);
        cs4224_resync_elsto(slice_num, txelst0_addr);

        slice_num = mate_slice;

        status |= cs4224_reg_get_channel(slice_num, clkout_ctrl_addr, &reg_data);
        reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1, drive Rx clock to other slice */
        status |= cs4224_reg_set_channel(slice_num, clkout_ctrl_addr, reg_data);

        status |= cs4224_reg_get_channel(slice_num, driver_config_addr, &reg_data);
        reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1, mux A */
        status |= cs4224_reg_set_channel(slice_num, driver_config_addr, reg_data);

        status |= cs4224_reg_get_channel(slice_num, rx_config_addr, &reg_data);
        reg_data |= 0x1000; /* SRX_2X2_DMUX_EN = 1 */
        status |= cs4224_reg_set_channel(slice_num, rx_config_addr, reg_data);

        status |= cs4224_reg_set_channel(slice_num, tx_misc_addr, 0x00a2);

        status |= cs4224_reg_get_channel(slice_num, mail_sel_addr, &reg_data);
        reg_data |= 0x0001; /* mail_source = 1 */
        status |= cs4224_reg_set_channel(slice_num, mail_sel_addr, reg_data);

        status |= cs4224_reg_set_channel(slice_num, power_down_addr, 0x001f); 
        status |= cs4224_reg_set_channel(slice_num, power_down_addr, 0x0000); 
    }

    if(switch_action == CS4224_SWITCH_ANALOG_BROADCAST)
    {
        /* CS_PRINTF(("Analog switch, BROADCAST\n"));*/

        status |= cs4224_reg_get_channel(slice, clkout_ctrl_addr, &reg_data);
        reg_data |= 0x2000; /* SRX_EXT_SERCLK_EN = 1, drive Rx clock to other slice */
        status |= cs4224_reg_set_channel(slice, clkout_ctrl_addr, reg_data);

        status |= cs4224_reg_get_channel(mate_slice, driver_config_addr, &reg_data);
        reg_data |= 0x0008; /* STX_EXT_SERCLK_EN = 1, mux A */
        status |= cs4224_reg_set_channel(mate_slice, driver_config_addr, reg_data);

        status |= cs4224_reg_get_channel(slice, rx_config_addr, &reg_data);
        reg_data |= 0x1000; /* SRX_2X2_DMUX_EN = 1 */
        status |= cs4224_reg_set_channel(slice, rx_config_addr, reg_data);

        status |= cs4224_reg_set_channel(mate_slice, tx_misc_addr, 0x00a2);

        status |= cs4224_reg_get_channel(slice, mail_sel_addr, &reg_data);
        reg_data |= 0x0001; /* mail_source = 1 */
        status |= cs4224_reg_set_channel(slice, mail_sel_addr, reg_data);

        status |= cs4224_reg_get_channel(mate_slice, mail_sel_addr, &reg_data);
        reg_data |= 0x0001; /* mail_source = 1 */
        status |= cs4224_reg_set_channel(mate_slice, mail_sel_addr, reg_data);

        status |= cs4224_reg_set_channel(slice, power_down_addr, 0x001f); 
        status |= cs4224_reg_set_channel(mate_slice, power_down_addr, 0x001f); 
        status |= cs4224_reg_set_channel(slice, power_down_addr, 0x0000); 
        status |= cs4224_reg_set_channel(mate_slice, power_down_addr, 0x0000); 
    }

    if (switch_action == CS4224_SWITCH_DISABLE) 
    {
        /* CS_PRINTF(("Analog switch, DISABLE\n"));*/

        /* check to see if Analog Switch already applied */
        if (!switch_state->initialized)
        {
            CS_TRACE(("ERROR: Simplex switch not applied, cannot restore state\n"));
            cs4224_unlock(slice);
            cs4224_unlock(mate_slice);
            return CS_ERROR;
        }

        /* if microsequencer is running */
        if (0 == (0x0008 & mseq_options)) 
        {
            /* stall the microsequencer */
            status |= cs4224_mseq_stall(slice,      CS4224_SPLX_MSEQ, TRUE);
            status |= cs4224_mseq_stall(mate_slice, CS4224_SPLX_MSEQ, TRUE);
        }

        /* restore context to the state it was in prior to when analog switch applied */
        status = cs4224_switch_restore_simplex_state(slice,      &switch_state->slices[0]);
        status = cs4224_switch_restore_simplex_state(mate_slice, &switch_state->slices[1]);
        switch_state->initialized = FALSE;

    }

    /* if microsequencer was running */
    if (0 == (0x0008 & mseq_options)) 
    {
        /* un-stall the microsequencer */
        status |= cs4224_mseq_stall(slice,      CS4224_SPLX_MSEQ, FALSE);
        status |= cs4224_mseq_stall(mate_slice, CS4224_SPLX_MSEQ, FALSE);
    }

    cs4224_reg_set_channel(slice,      CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    cs4224_reg_set_channel(slice,      CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);
    cs4224_reg_set_channel(slice,      CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    cs4224_reg_set_channel(slice,      CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);
    cs4224_reg_set_channel(mate_slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    cs4224_reg_set_channel(mate_slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);
    cs4224_reg_set_channel(mate_slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0x80F0);
    cs4224_reg_set_channel(mate_slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, 0xC0F0);

    cs4224_unlock(slice);
    cs4224_unlock(mate_slice);

    return status;
}

/**
 * Configure the global (gbl) clock monitor.
 *
 * @param slice         [I] - The base slice number of the clock monitor
 * @param clk_mon_cfg   [I] - A structure containing the per-port clock monitor configuration
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 * 
 */
cs_status cs4224_gbl_clock_monitor(
    cs_uint32 slice,
    cs4224_gbl_clk_mon_cfg_t *clk_mon_cfg)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    CS_PRINTF(("Configuring the GBL clkmon\n"));

    data = clk_mon_cfg->clksel_divider | clk_mon_cfg->clksel_src;
    status |= cs4224_reg_set_channel(slice, CS4224_CLKMON_GBL_CLKSEL, data);

    data = 0;
    if (clk_mon_cfg->go)
    {
        data = 0x0002;
    }

    if (clk_mon_cfg->free_run)
    {
        data |= 0x0010;
    }
    status |= cs4224_reg_set_channel(slice, CS4224_CLKMON_GBL_CTRL, data);

    status |= cs4224_reg_set_channel(slice, CS4224_CLKMON_GBL_DURATION, clk_mon_cfg->duration);

    status |= cs4224_reg_set_channel(slice, CS4224_CLKMON_GBL_MINTHRESH0, clk_mon_cfg->min_thresh_0);
    status |= cs4224_reg_set_channel(slice, CS4224_CLKMON_GBL_MINTHRESH1, clk_mon_cfg->min_thresh_1);
    status |= cs4224_reg_set_channel(slice, CS4224_CLKMON_GBL_MAXTHRESH0, clk_mon_cfg->max_thresh_0);
    status |= cs4224_reg_set_channel(slice, CS4224_CLKMON_GBL_MAXTHRESH1, clk_mon_cfg->max_thresh_1);

    return status;
}

/**
 * Initializes the cs4224_pp_clk_mon_cfg_t config
 * 
 * @param clk_mon_cfg [O] - A structure containing the per-port clock monitor configuration
 */
void cs4224_pp_clk_mon_cfg_init(
    cs4224_pp_clk_mon_cfg_t *clk_mon_cfg)
{
    clk_mon_cfg->clksel_divider = CS4224_CLK_MON_DIV1;
    clk_mon_cfg->clksel_src = CS4224_CLK_MON_PP_SRX;
    clk_mon_cfg->go = TRUE;
    clk_mon_cfg->free_run = TRUE;
    clk_mon_cfg->duration = 0x4000;
    clk_mon_cfg->min_thresh = 0;
    clk_mon_cfg->max_thresh = 0;
    
    return;
}

/**
 * Configure the per-port (pp) clock monitor and start if clk_mon_cfg.go is set
 *
 * @param slice       [I] - The base slice number of the clock monitor
 * @param side        [I] - Identifies the line (ING) or host (EGR) side clock monitor 
 * @param clk_mon_cfg [I] - A structure containing the per-port clock monitor configuration
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_pp_clock_monitor(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t side,
    cs4224_pp_clk_mon_cfg_t *clk_mon_cfg)
{
    cs_status status = CS_OK;
    cs_uint16 clksel_addr;
    cs_uint16 ctrl_addr;
    cs_uint16 duration_addr;
    cs_uint16 min_thresh0_addr;
    cs_uint16 min_thresh1_addr;
    cs_uint16 max_thresh0_addr;
    cs_uint16 max_thresh1_addr;
    cs_uint16 data;

    status |= cs4224_get_cfg_side(slice, &side);
    
    if (side == CS4224_CFG_HOST_SIDE)
    {
        /*CS_PRINTF(("Configuring the PP EGR (egress) clkmon\n"));*/
        clksel_addr      = CS4224_PP_CLKMON_EGR_CLKSEL;
        ctrl_addr        = CS4224_PP_CLKMON_EGR_CTRL;
        duration_addr    = CS4224_PP_CLKMON_EGR_DURATION;
        min_thresh0_addr = CS4224_PP_CLKMON_EGR_MINTHRESH0;
        min_thresh1_addr = CS4224_PP_CLKMON_EGR_MINTHRESH1;
        max_thresh0_addr = CS4224_PP_CLKMON_EGR_MAXTHRESH0;
        max_thresh1_addr = CS4224_PP_CLKMON_EGR_MAXTHRESH1; 
    }
    else
    {
        /*CS_PRINTF(("Configuring the PP ING (ingress) clkmon\n"));*/
        clksel_addr      = CS4224_PP_CLKMON_ING_CLKSEL;
        ctrl_addr        = CS4224_PP_CLKMON_ING_CTRL;
        duration_addr    = CS4224_PP_CLKMON_ING_DURATION;
        min_thresh0_addr = CS4224_PP_CLKMON_ING_MINTHRESH0;
        min_thresh1_addr = CS4224_PP_CLKMON_ING_MINTHRESH1;
        max_thresh0_addr = CS4224_PP_CLKMON_ING_MAXTHRESH0;
        max_thresh1_addr = CS4224_PP_CLKMON_ING_MAXTHRESH1; 
    }

    data = clk_mon_cfg->clksel_divider | clk_mon_cfg->clksel_src;
    status |= cs4224_reg_set_channel(slice, clksel_addr, data);

    status |= cs4224_reg_set_channel(slice, duration_addr, clk_mon_cfg->duration);

    status |= cs4224_reg_set_channel(slice, min_thresh0_addr, (cs_uint16)clk_mon_cfg->min_thresh );
    status |= cs4224_reg_set_channel(slice, min_thresh1_addr, (clk_mon_cfg->min_thresh >> 16)    );
    status |= cs4224_reg_set_channel(slice, max_thresh0_addr, (cs_uint16)clk_mon_cfg->max_thresh );
    status |= cs4224_reg_set_channel(slice, max_thresh1_addr, (clk_mon_cfg->max_thresh >> 16)    );

    data = 0x0100; /* config */
    if (clk_mon_cfg->go)
    {
        data |= CS_BIT1; /* go */
    }
    if (clk_mon_cfg->free_run)
    {
        data |= CS_BIT4; /* free-run */
    }
    status |= cs4224_reg_set_channel(slice, ctrl_addr, data);
    data &= ~CS_BIT1; /* clear go */
    status |= cs4224_reg_set_channel(slice, ctrl_addr, data);
    
    return status;
}

/** 
 * This method will setup and read the frequency of the desired clock monitor
 * 
 * Note: this will change the synce configuration
 * 
 * @param slice          [I] - The base slice number of the clock monitor
 * @param side           [I] - Identifies the line (ING) or host (EGR) side clock monitor 
 * @param pp_clk_mon_cfg [I] - A structure containing the per-port clock monitor configuration
 * @param ref_clk_rate   [I] - The reference clock rate, same as rules.ref_clk_rate
 * @param freq          [I/O]- Input the desired frequency to generate a warning if actual frequency
 *                              is off by +/- 10%, set to 0 to turn off warnings
 *                             Outputs actual counted frequency
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 * cs4224_pp_clk_mon_cfg_t pp_clk_mon_cfg;
 * cs_uint16 freq = 230;
 * cs4224_pp_clk_mon_cfg_init(&pp_clk_mon_cfg);
 * pp_clk_mon_cfg.clksel_src = CS4224_CLK_MON_PP_SRX;
 * status |= cs4224_pp_clock_monitor_freq(slice, CS4224_CFG_HOST_SIDE, &pp_clk_mon_cfg, 156250, &freq);
 * CS_PRINTF(("slice %x | des freq 230 | freq %d\n",slice,freq));
 */
cs_status cs4224_pp_clock_monitor_freq_fixp(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t side,
    cs4224_pp_clk_mon_cfg_t *pp_clk_mon_cfg,
    cs_uint32 ref_clk_rate,
    cs_uint16 *freq)
{
    cs_status status = CS_OK;
    cs_int8 i = 0;
    cs_uint16 data = 0;
    cs_uint32 count = 0;
    cs_uint32 ticks_per_sec = 0;
    cs_uint16 des_freq = *freq;
    cs_boolean stalled = FALSE;
    cs_uint16 power_down = 0;
    
    cs_uint16 status_addr;
    cs_uint16 count0_addr;
    cs_uint16 count1_addr;
    cs_uint16 power_down_addr;
    e_cs4224_mseq_id mseq_id;

    status |= cs4224_get_cfg_side(slice, &side);
    
    if (side == CS4224_CFG_HOST_SIDE)
    {
        status_addr      = CS4224_PP_CLKMON_EGR_STATUS;
        count0_addr      = CS4224_PP_CLKMON_EGR_COUNT0;
        count1_addr      = CS4224_PP_CLKMON_EGR_COUNT1;
        power_down_addr  = CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_id          = CS4224_DPLX_HOST_MSEQ;
    }
    else
    {
        status_addr      = CS4224_PP_CLKMON_ING_STATUS;
        count0_addr      = CS4224_PP_CLKMON_ING_COUNT0;
        count1_addr      = CS4224_PP_CLKMON_ING_COUNT1;
        power_down_addr  = CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_id          = CS4224_DPLX_LINE_MSEQ;
    }
    
    status |= cs4224_query_mseq_is_stalled(slice, mseq_id, &stalled);
    if(!stalled)
    {
        cs4224_mseq_stall(slice, mseq_id, TRUE);
    }
    status |= cs4224_reg_get_channel(slice, power_down_addr, &power_down);
    if(power_down != 0x0000)
    {
        status |= cs4224_reg_set_channel(slice, power_down_addr, 0x1f);
        status |= cs4224_reg_set_channel(slice, power_down_addr, 0x00);
    }
    
    /* setup clock mon */
    pp_clk_mon_cfg->clksel_divider = CS4224_CLK_MON_DIV1;
    pp_clk_mon_cfg->go             = TRUE;
    pp_clk_mon_cfg->free_run       = TRUE;
    pp_clk_mon_cfg->duration       = 0x4000;

    status |= cs4224_pp_clock_monitor(slice, side, pp_clk_mon_cfg);
    
    for (i=10; i > 0; i--)
    {
        status |= cs4224_reg_get_channel(slice, status_addr, &data);
        if(data&0x1)
            break;
        CS_UDELAY(200); /* 1/156.25MHz * 0x4000 = 154us */
    }
    if (i<=0)
    {
        CS_TRACE(("ERROR: clock monitor count never completed\n"));
        status |= CS_ERROR;
        return status;
    }
    
    status |= cs4224_reg_get_channel(slice, count1_addr, &data);
    count = (cs_uint32)data << 16;
    status |= cs4224_reg_get_channel(slice, count0_addr, &data);
    count |= (cs_uint32)data;
    
    /* freq = count * ref * div / duration */
    /* control the truncating; don't loose precision unintentionally */
    ticks_per_sec = ((long long int)count * ref_clk_rate) / 1000;

    *freq = (ticks_per_sec * 1) / 0x4000;
    
    /*CS_PRINTF(("Slice %d pp clock %x: count %u freq %uMHz\n",slice,pp_clk_mon_cfg->clksel_src,count,*freq));*/
    
    if(des_freq != 0)
    {
        cs_uint16 temp = des_freq * 9;
        if((*freq * 10) < temp)
        {
            CS_TRACE(("WARNING: freq < des_freq -10%: %u < %u\n", *freq, temp / 9));
        }
        temp = des_freq * 11;
        if((*freq * 10) > temp)
        {
            CS_TRACE(("WARNING: freq > des_freq +10%: %u > %u\n", *freq, temp / 11));
        }
    }

    if(power_down != 0x0000)
    {
        status |= cs4224_reg_set_channel(slice, power_down_addr, power_down);
    }
    if(!stalled)
    {
        cs4224_mseq_stall(slice, mseq_id, FALSE);
    }
    
    return status;
}

/**
 * This method is called to initialize the Core Fractional-N divider.
 * 
 * This method programs the Core FracN block with a divisor and numerator passed
 * in as arguments. Prior to configuring the Core FracN, the datapath must be 
 * programmed to tune the VCO to a specific data rate. The Rx VCO coarse tuner 
 * frequency is sub-divided by the FracN to a desired pilot tone frequency. 
 * This pilot tone is directed towards SRX_FASTCLK. 
 *
 * In order to send the pilot tone out a GPIO, The clock monitor must  
 * be programmed to source its clock from SRX_FASTCLK. The GPIO can then
 * be configured as an output and to select the CLKMON_CLK output.
 *
 * See the user guide section under 'Calculating the SyncE Clock' for a python
 * example of how to calculate the divisor and numerator.
 *
 * @param slice           [I] - The slice or port of the device to initialize
 * @param dir             [I] - The direction of the datapath
 * @param divisor         [I] - The divisor 
 * @param numerator       [I] - The numerator
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_fracdiv_core_init(
    cs_uint32               slice,
    e_cs4224_datapath_dir_t dir,    
    cs_uint16               divisor,
    cs_uint32               numerator)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data;
    cs_uint16 frac0_reset_addr;
    cs_uint16 frac0_en_addr;
    cs_uint16 clkdiv_ctrl_addr;
    cs_uint16 frac0_width_addr;
    cs_uint16 frac0_intdiv_addr;
    cs_uint16 frac0_numerator0_addr;
    cs_uint16 frac0_numerator1_addr;
    cs_uint16 frac0_stage1preload0_addr;
    cs_uint16 frac0_stage1preload1_addr;
    cs_uint16 frac0_dither_addr;
    cs_uint16 frac0_stage_en_addr ;
    cs_uint16 frac0_power_down_addr;
    cs_uint16 mseq_options_addr;
    cs_uint16 mseq_options;      
    e_cs4224_mseq_id mseq_id;

    if ((cs4224_is_hw_simplex(slice) && cs4224_line_rx_to_host_tx_dir(slice)) ||
        (CS4224_LINE_RX_TO_HOST_TX_DIR == dir))
    {
        frac0_reset_addr          = CS4224_PP_LINE_SDS_COMMON_FRAC0_RESET;
        frac0_en_addr             = CS4224_PP_LINE_SDS_COMMON_FRAC0_EN;
        clkdiv_ctrl_addr          = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
        frac0_width_addr          = CS4224_PP_LINE_SDS_COMMON_FRAC0_WIDTH;
        frac0_intdiv_addr         = CS4224_PP_LINE_SDS_COMMON_FRAC0_INTDIV;
        frac0_numerator0_addr     = CS4224_PP_LINE_SDS_COMMON_COREFRAC0_NUMERATOR0;
        frac0_numerator1_addr     = CS4224_PP_LINE_SDS_COMMON_COREFRAC0_NUMERATOR1;
        frac0_stage1preload0_addr = CS4224_PP_LINE_SDS_COMMON_COREFRAC0_STAGE1PRELOAD0;
        frac0_stage1preload1_addr = CS4224_PP_LINE_SDS_COMMON_COREFRAC0_STAGE1PRELOAD1;
        frac0_dither_addr         = CS4224_PP_LINE_SDS_COMMON_FRAC0_DITHER;
        frac0_stage_en_addr       = CS4224_PP_LINE_SDS_COMMON_FRAC0_STAGE_EN;
        frac0_power_down_addr     = CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_options_addr         = CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW;
        mseq_id                   = CS4224_DPLX_LINE_MSEQ;
    } 
    else
    {
        frac0_reset_addr          = CS4224_PP_HOST_SDS_COMMON_FRAC0_RESET;
        frac0_en_addr             = CS4224_PP_HOST_SDS_COMMON_FRAC0_EN;
        clkdiv_ctrl_addr          = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
        frac0_width_addr          = CS4224_PP_HOST_SDS_COMMON_FRAC0_WIDTH;
        frac0_intdiv_addr         = CS4224_PP_HOST_SDS_COMMON_FRAC0_INTDIV;
        frac0_numerator0_addr     = CS4224_PP_HOST_SDS_COMMON_COREFRAC0_NUMERATOR0;
        frac0_numerator1_addr     = CS4224_PP_HOST_SDS_COMMON_COREFRAC0_NUMERATOR1;
        frac0_stage1preload0_addr = CS4224_PP_HOST_SDS_COMMON_COREFRAC0_STAGE1PRELOAD0;
        frac0_stage1preload1_addr = CS4224_PP_HOST_SDS_COMMON_COREFRAC0_STAGE1PRELOAD1;
        frac0_dither_addr         = CS4224_PP_HOST_SDS_COMMON_FRAC0_DITHER;
        frac0_stage_en_addr       = CS4224_PP_HOST_SDS_COMMON_FRAC0_STAGE_EN;
        frac0_power_down_addr     = CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_options_addr         = CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW;
        mseq_id                   = CS4224_DPLX_HOST_MSEQ;
    }

    cs4224_lock(slice);

    /* find out if microsequencer is running */
    status |= cs4224_reg_get_channel(slice, mseq_options_addr, &mseq_options);

    /* if microsequencer is running */
    if (0 == (0x0008 & mseq_options)) 
    {
        /* stall the microsequencer */
        status |= cs4224_mseq_stall(slice, mseq_id, TRUE);
    }

    status |= cs4224_reg_get_channel(slice, frac0_power_down_addr, &reg_data);
    reg_data &= ~0x0010; /* power-up FracN for configuration */
    status |= cs4224_reg_set_channel(slice, frac0_power_down_addr, reg_data);

    status |= cs4224_reg_get_channel(slice, frac0_reset_addr, &reg_data);
    reg_data &= ~0x0002; /* reset core fracn */
    status |= cs4224_reg_set_channel(slice, frac0_reset_addr, reg_data);

    status |= cs4224_reg_get_channel(slice, frac0_en_addr, &reg_data);
    reg_data |= 0x0100; /* enable the core fracN */
    status |= cs4224_reg_set_channel(slice, frac0_en_addr, reg_data);

    status |= cs4224_reg_get_channel(slice, clkdiv_ctrl_addr, &reg_data);
    reg_data &= ~0xf000; 
    reg_data |= (0x9 << 12); /* Configure FASTCLK to get it's clock from the Core FracN */
    status |= cs4224_reg_set_channel(slice, clkdiv_ctrl_addr, reg_data);

    status |= cs4224_reg_get_channel(slice, frac0_width_addr, &reg_data);
    reg_data &= ~0x000c; /* Setup to use a 24 bit accumulator */
    reg_data |= (CS4224_FRACDIV_ACCUM_WIDTH_24BIT << 2);
    status |= cs4224_reg_set_channel(slice, frac0_width_addr, reg_data);
    
    status |= cs4224_reg_get_channel(slice, frac0_intdiv_addr, &reg_data);
    reg_data &= ~0xff00;
    reg_data |= (divisor << 8); /* Configure the denominator value */
    status |= cs4224_reg_set_channel(slice, frac0_intdiv_addr, reg_data);

    /* Configure the numerator value */
    status |= cs4224_reg_set_channel(slice, frac0_numerator0_addr, numerator & 0xFFFF);
    status |= cs4224_reg_set_channel(slice, frac0_numerator1_addr, (numerator >> 16) & 0xFF);

    /* Configure the stage 1 preload value */
    status |= cs4224_reg_set_channel(slice, frac0_stage1preload0_addr, 0x5DC6);
    status |= cs4224_reg_set_channel(slice, frac0_stage1preload1_addr, 0x0034);

    status |= cs4224_reg_set_channel(slice, frac0_dither_addr, 0x0000);
    
    /* Enable stage1 only */
    status |= cs4224_reg_set_channel(slice, frac0_stage_en_addr, 0x0408);

    status |= cs4224_reg_get_channel(slice, frac0_reset_addr, &reg_data);
    reg_data |= 0x0002; /* reset core fracn */
    status |= cs4224_reg_set_channel(slice, frac0_reset_addr, reg_data);
    reg_data &= ~0x0002; /* pull out of reset core fracn */
    status |= cs4224_reg_set_channel(slice, frac0_reset_addr, reg_data);

    /* if microsequencer was running */
    if (0 == (0x0008 & mseq_options)) 
    {
        /* un-stall the microsequencer */
        status |= cs4224_mseq_stall(slice, mseq_id, FALSE);
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * Configure Core Fractional-Divider, clock monitor and a GPIO to output a SyncE 
 * signal as per the configuration specified in the rules.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_synce(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs4224_gpio_cfg_t gpio_cfg;
    cs4224_pp_clk_mon_cfg_t pp_clk_mon_cfg;

    if (rules->synce.enable == FALSE)
    {
        return status;
    }

    /* Configure the Core fracN to output the desired SyncE tone to SRX_FASTCLK */
    status = cs4224_fracdiv_core_init(slice,
                                      rules->synce.dir,
                                      rules->synce.divisor,
                                      rules->synce.numerator); 

    /* Configure the per-port (pp) clkmon to get its clock input from SRX_FASTCLK */
    cs4224_pp_clk_mon_cfg_init(&pp_clk_mon_cfg);
    pp_clk_mon_cfg.clksel_divider = rules->synce.clk_divider;
    pp_clk_mon_cfg.clksel_src     = CS4224_CLK_MON_PP_FAST;
    pp_clk_mon_cfg.go             = FALSE;
    pp_clk_mon_cfg.free_run       = TRUE;

    status = cs4224_pp_clock_monitor(slice, rules->synce.dir, &pp_clk_mon_cfg);

    /* Configure a GPIO to output the tone received by the per-port (pp) clock monitor */
    status |= cs4224_gpio_cfg_output(&gpio_cfg, CS4224_GPIO_OUT_FCN_PORT_CLKMON_CLK);

    /* adjust the dir/side because cs4224_gpio_cfg_output defaults to line */
    if (rules->synce.dir == CS4224_HOST_RX_TO_LINE_TX_DIR)
    {
        gpio_cfg.side = CS4224_CFG_HOST_SIDE;
    }

    status |= cs4224_gpio_init(slice, rules->synce.gpio, &gpio_cfg);

    return status;
}

/**
 * Configure internal AC decoupling caps. 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_ac_decoupling_caps(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data;
    
    if ((cs4224_is_hw_simplex(slice) && cs4224_line_rx_to_host_tx_dir(slice)) ||
        (cs4224_is_hw_duplex(slice)))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG4, &reg_data);
        if (rules->enable_ac_decoupling_caps)
        {
            reg_data |=  0x0080; /* enable internal AC decoupling caps */
        }
        else
        {
            reg_data &= ~0x0080; /* disable internal AC decoupling caps */
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG4, reg_data);
    } 
    if ((cs4224_is_hw_simplex(slice) && !cs4224_line_rx_to_host_tx_dir(slice)) ||
        (cs4224_is_hw_duplex(slice)))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG4, &reg_data);
        if (rules->enable_ac_decoupling_caps)
        {
            reg_data |=  0x0080; /* enable internal AC decoupling caps */
        }
        else
        {
            reg_data &= ~0x0080; /* disable internal AC decoupling caps */
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG4, reg_data);
    } 

    return status;
}

/**
 * This function sets the default initialization rules
 * based on the specified target application. This is generally followed
 * by a call to cs4224_slice_enter_operational_state to put a slice/channel
 * of the device in service.
 *
 * @param application [I] - The target application to configure the device in
 * @param rules       [O] - The default initialization rules for the specified
 *                          application.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 *
 *   cs4224_rules_t rules;
 *
 *   // Default the rules for applications in the 10G range.
 *   cs4224_rules_set_default(CS4224_TARGET_APPLICATION_10G, &rules);
 *
 *   // Customize the rules to support OC48 traffic from
 *   // a 155.52MHz reference.
 *   rules.clkdiv.enable = TRUE;
 *   rules.clkdiv.rdiv = CS4224_RDIV_DIV64;
 *   rules.clkdiv.ddiv = CS4224_DDIV_DIV2;
 *
 *   // Put the device into operational state
 *   cs4224_slice_enter_operational_state(slice, &rules);
 */
cs_status cs4224_rules_set_default(
    e_cs4224_target_application application,
    cs4224_rules_t*             rules)
{
    cs_status status = CS_OK;

    rules->application                      = application;

    rules->rx_if.splx_eq.traceloss          = CS_HSIO_TRACE_LOSS_2dB;
    rules->rx_if.splx_edc_mode              = CS_HSIO_EDC_MODE_SR;

    rules->tx_if.splx_driver.traceloss      = CS_HSIO_TRACE_LOSS_2dB;
    rules->tx_if.splx_disable               = FALSE;

    rules->rx_if.dplx_line_eq.traceloss     = CS_HSIO_TRACE_LOSS_2dB;
    rules->rx_if.dplx_host_eq.traceloss     = CS_HSIO_TRACE_LOSS_2dB;
    rules->rx_if.dplx_line_edc_mode         = CS_HSIO_EDC_MODE_SR;
    rules->rx_if.dplx_host_edc_mode         = CS_HSIO_EDC_MODE_SR;

    rules->tx_if.dplx_line_driver.traceloss = CS_HSIO_TRACE_LOSS_2dB;
    rules->tx_if.dplx_host_driver.traceloss = CS_HSIO_TRACE_LOSS_2dB;
    rules->tx_if.dplx_line_disable          = FALSE;
    rules->tx_if.dplx_host_disable          = FALSE;

    rules->clkdiv.enable                    = FALSE;
    rules->clkdiv.rdiv                      = CS4224_RULE_DISABLED;
    rules->clkdiv.ddiv                      = CS4224_RULE_DISABLED;
    rules->clkdiv.fastdiv                   = CS4224_RULE_DISABLED;

    rules->fracdiv.enable                   = FALSE;
    rules->fracdiv.numerator                = CS4224_RULE_DISABLED;
    rules->fracdiv.divisor                  = CS4224_RULE_DISABLED;

    rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;
    rules->synce.enable                     = FALSE;
    rules->synce.numerator                  = CS4224_RULE_DISABLED;
    rules->synce.divisor                    = CS4224_RULE_DISABLED;
    rules->synce.clk_divider                = CS4224_CLK_MON_DIV1;
    rules->synce.gpio                       = CS4224_GPIO1;
    rules->synce.dir                        = CS4224_LINE_RX_TO_HOST_TX_DIR;

    /* By default the auto-squelch feature is turned off
       and the driver will be unsquelched after calling
       cs4224_slice_enter_operational_state() */
    rules->unsquelch_driver                 = TRUE;
    rules->tx_auto_squelch                  = FALSE;

    rules->enable_ac_decoupling_caps        = TRUE;
    rules->enable_power_savings             = TRUE;
    rules->enable_fec                       = FALSE;
    rules->polarity_inv                     = CS4224_POLARITY_INV_NONE;
    rules->enable_die_broadcast             = TRUE;

#if defined(CS_HAS_FILESYSTEM)
    /* By default assume the microcode is inlined */
    rules->ucode_kr_path                    = NULL;
    rules->ucode_fc_path                    = NULL;
#endif /* CS_HAS_FILESYSTEM */

    /* By default leave debugging info enabled. Customers
     * can turn this off if desired. */
    rules->show_debug_info                  = TRUE;

    /* By default turn off the ability of the microsequencer to 
       perform a dynamic reconfig */
    rules->mseq_dyn_reconfig                = FALSE;

    /* By default all advanced rules should be turned off */
    rules->advanced.phsel_bypass = FALSE;
    rules->advanced.phsel_bypass_value = CS4224_RULE_DISABLED;

    /* Note for clkdiv, Rate = RefClk * rdiv / ddiv */
    switch(application)
    {
        case CS4224_TARGET_APPLICATION_OC12:
        {
            /* 156.25MHz ref clock, 622.08MHz */
            /* set datarate to 9.95328G then divide by 16 */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

            rules->clkdiv.enable  = TRUE;
            rules->clkdiv.fastdiv = 0x0; /* div by 8 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV16;
            /* automatically set to 0x9 by fracdiv_cdr_init */
            rules->clkdiv.rdiv    = 0x9;

            rules->fracdiv.enable    = TRUE;
            rules->fracdiv.divisor   = 0x7;
            rules->fracdiv.numerator = 0xF66E87;

            /* edc disabled by default */
            rules->rx_if.splx_edc_mode      = CS_HSIO_EDC_MODE_SR;
            rules->rx_if.dplx_line_edc_mode = CS_HSIO_EDC_MODE_SR;
            rules->rx_if.dplx_host_edc_mode = CS_HSIO_EDC_MODE_SR;

            break;
        }
        case CS4224_TARGET_APPLICATION_1G:
        {
            /* 156.25MHz ref clock, 1.25GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x3; /* div by 40 (default) */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV8;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV64;

            /* edc disabled by default */
            rules->rx_if.splx_edc_mode      = CS_HSIO_EDC_MODE_SR;
            rules->rx_if.dplx_line_edc_mode = CS_HSIO_EDC_MODE_SR;
            rules->rx_if.dplx_host_edc_mode = CS_HSIO_EDC_MODE_SR;

            break;
        }
        case CS4224_TARGET_APPLICATION_5G:
        {
            /* 156.25MHz ref clock, 5GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

            rules->clkdiv.enable  = TRUE;
            rules->clkdiv.fastdiv = 0x3; /* div by 40 (default) */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV2;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV64;

            /* edc 5G_BP by default */
            rules->rx_if.splx_edc_mode              = CS_HSIO_EDC_MODE_5G_BP;
            rules->rx_if.dplx_line_edc_mode         = CS_HSIO_EDC_MODE_5G_BP;
            rules->rx_if.dplx_host_edc_mode         = CS_HSIO_EDC_MODE_5G_BP;

            break;
        }
        case CS4224_TARGET_APPLICATION_7p5G:
        {
            /* 156.25MHz ref clock, 7.5GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

            rules->clkdiv.enable  = TRUE;
            rules->clkdiv.fastdiv = 0x0; /* div by 8 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV2;
            /* automatically set to 0x9 by fracdiv_cdr_init */
            rules->clkdiv.rdiv    = 0x9;

            rules->fracdiv.enable    = TRUE;
            rules->fracdiv.divisor   = 0x0C;
            rules->fracdiv.numerator = 0;

            /* edc 7p5G_BP by default */
            rules->rx_if.splx_edc_mode              = CS_HSIO_EDC_MODE_7p5G_BP;
            rules->rx_if.dplx_line_edc_mode         = CS_HSIO_EDC_MODE_7p5G_BP;
            rules->rx_if.dplx_host_edc_mode         = CS_HSIO_EDC_MODE_7p5G_BP;

            rules->rx_if.splx_eq.traceloss          = CS_HSIO_TRACE_LOSS_6dB;
            rules->tx_if.splx_driver.traceloss      = CS_HSIO_TRACE_LOSS_27dB;

            rules->rx_if.dplx_line_eq.traceloss     = CS_HSIO_TRACE_LOSS_6dB;
            rules->rx_if.dplx_host_eq.traceloss     = CS_HSIO_TRACE_LOSS_6dB;
            rules->tx_if.dplx_line_driver.traceloss = CS_HSIO_TRACE_LOSS_27dB;
            rules->tx_if.dplx_host_driver.traceloss = CS_HSIO_TRACE_LOSS_27dB;

            break;
        }
        case CS4224_TARGET_APPLICATION_8G:
        {
/* TODO: Verify this datarate */
            CS_TRACE(("WARNING: This mode hasn't been fully verified yet\n"));
            
            /* 156.25MHz ref clock, 8GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x3; /* div by 40 (default) */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV1;
            /* automatically set to 0x9 by fracdiv_cdr_init */
            rules->clkdiv.rdiv    = 0x9;

            rules->fracdiv.enable    = TRUE;
            rules->fracdiv.divisor   = 0x06;
            rules->fracdiv.numerator = 0x666666;

            /* this mode uses the ring oscillator */
            break;
        }
        case CS4224_TARGET_APPLICATION_8p5G:
        {
/* TODO: Verify this datarate */
            CS_TRACE(("WARNING: This mode hasn't been fully verified yet\n"));
            
            /* 156.25MHz ref clock, 8GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x3; /* div by 40 (default) */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV1;
            /* automatically set to 0x9 by fracdiv_cdr_init */
            rules->clkdiv.rdiv    = 0x9;

            rules->fracdiv.enable    = TRUE;
            rules->fracdiv.divisor   = 0x06;
            rules->fracdiv.numerator = 0xCCCCCD;

            /* edc 8p5G_BP by default */
            rules->rx_if.splx_edc_mode              = CS_HSIO_EDC_MODE_8p5G_BP;
            rules->rx_if.dplx_line_edc_mode         = CS_HSIO_EDC_MODE_8p5G_BP;
            rules->rx_if.dplx_host_edc_mode         = CS_HSIO_EDC_MODE_8p5G_BP;

            /* this mode uses the ring oscillator */
            break;
        }
        case CS4224_TARGET_APPLICATION_10G:
        {
            /* 156.25MHz ref clock, 10.3125GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x3; /* div by 40 (default) */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV1;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV66;

            break;
        }
        case CS4224_TARGET_APPLICATION_15G:
        {
            /* 156.25MHz ref clock, 15GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_156p25;

#if 0
            /* Enable clkdiv and disable fracdiv
             * to use 15.625GHz instead
             */
            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x3; /* div by 40 (default) */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV1;
            /* automatically set to 0x9 by fracdiv_cdr_init */
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV100;
#else
            rules->fracdiv.enable                   = TRUE;
            rules->fracdiv.divisor                  = 0x0C;
            rules->fracdiv.numerator                = 0;
#endif

            rules->rx_if.splx_edc_mode              = CS_HSIO_EDC_MODE_15G_BP;
            rules->rx_if.dplx_line_edc_mode         = CS_HSIO_EDC_MODE_15G_BP;
            rules->rx_if.dplx_host_edc_mode         = CS_HSIO_EDC_MODE_15G_BP;

            rules->rx_if.splx_eq.traceloss          = CS_HSIO_TRACE_LOSS_6dB;
            rules->tx_if.splx_driver.traceloss      = CS_HSIO_TRACE_LOSS_27dB;

            rules->rx_if.dplx_line_eq.traceloss     = CS_HSIO_TRACE_LOSS_6dB;
            rules->rx_if.dplx_host_eq.traceloss     = CS_HSIO_TRACE_LOSS_6dB;
            rules->tx_if.dplx_line_driver.traceloss = CS_HSIO_TRACE_LOSS_27dB;
            rules->tx_if.dplx_host_driver.traceloss = CS_HSIO_TRACE_LOSS_27dB;

            break;
        }

        case CS4224_TARGET_APPLICATION_16G_FC:
        {
            /* 106.25MHz ref clock, 14.025GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_106p25;

            rules->fracdiv.enable                   = TRUE;
            rules->fracdiv.divisor                  = 0x10;
            rules->fracdiv.numerator                = 0x7FFFFF;
            
            break;
        }
        case CS4224_TARGET_APPLICATION_10G_FC:
        {
            /* 106.25MHz ref clock, 10.51875GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_106p25;

            rules->fracdiv.enable                   = TRUE;
            rules->fracdiv.divisor                  = 0x0C;
            rules->fracdiv.numerator                = 0x600000;

            break;
        }
        case CS4224_TARGET_APPLICATION_8G_FC:
        {
            /* 106.25MHz ref clock, 8.5GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_106p25;

            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV1;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;

            /* this mode uses the ring oscillator */
            break;
        }
        case CS4224_TARGET_APPLICATION_4G_FC:
        {
            /* 106.25MHz ref clock, 4.25GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_106p25;
            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV2;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;

            /* this mode uses the ring oscillator */
            break;
        }
        case CS4224_TARGET_APPLICATION_2G_FC:
        {
            /* 106.25MHz ref clock, 2.125GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_106p25;

            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV4;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;

            /* this mode uses the ring oscillator */
            break;
        }
        case CS4224_TARGET_APPLICATION_1G_FC:
        {
            /* 106.25MHz ref clock, 1.0625GHz */
            rules->ref_clk_rate                     = CS4224_REF_CLK_106p25;

            rules->clkdiv.enable = TRUE;
            rules->clkdiv.fastdiv = 0x5; /* div by 66 */
            rules->clkdiv.ddiv    = CS4224_DDIV_DIV8;
            rules->clkdiv.rdiv    = CS4224_RDIV_DIV80;

            /* this mode uses the ring oscillator */
            break;
        }
        
        case CS4224_TARGET_APPLICATION_10G_KR:
        case CS4224_TARGET_APPLICATION_40G_KR:
        case CS4224_TARGET_APPLICATION_KRAN:
        {
            /* edc mode to 10G_BP */
            rules->rx_if.dplx_line_edc_mode   = CS_HSIO_EDC_MODE_10G_BP;

            rules->kran.data_rates            = CS4224_KRAN_DATA_RATE_1G | 
                                                CS4224_KRAN_DATA_RATE_10G;

            /* Advertised capabilities */
            rules->kran.fec_ability_f0        = TRUE;   /* Our chip has this ability, although we don't always request it */
            rules->kran.fec_requested_f1      = FALSE;
            rules->kran.pause_ability_c0      = FALSE;
            rules->kran.pause_ability_c1      = FALSE;
            rules->kran.remote_fault_d13      = FALSE;

            rules->kran.wait_for_an_done      = FALSE;
            rules->kran.allow_training        = TRUE;

            rules->kran.poll_kran_callback.fcn_ptr = (void*)cs4224_kran_wait_for_an;

            /* Internal KRAN advanced settings */
            rules->kran.advanced.phase_or           = FALSE;  /* Enable the Line side fixed-phase override */
            rules->kran.advanced.hphase_or          = FALSE;  /* Enable the Host side fixed-phase override */
            rules->kran.advanced.en_adt             = FALSE;  /* Enable/disable AN ability detect timeout */
            rules->kran.advanced.en_mwt             = TRUE;   /* Enable/disable TP Max Wait Timer */
            rules->kran.advanced.skip_an            = FALSE;  /* Skip Auto-Negotiation */
            rules->kran.advanced.skip_tp            = FALSE;  /* Skip Training */
            rules->kran.advanced.skip_phsc          = FALSE;  /* Skip line side Phase Calibration */
            rules->kran.advanced.en_lfit            = TRUE;                                                                                               
            rules->kran.advanced.en_retry           = TRUE;   /* Enable retries */
            rules->kran.advanced.dis_start          = FALSE;  /* Disable AN Start */
            rules->kran.advanced.en_pwrsv           = TRUE;   /* Enable power savings */
            rules->kran.advanced.en_dfe             = TRUE;   /* Use 10G_BP EDC mode */
            rules->kran.advanced.bad_mrkrs          = FALSE;  /* Count frames with invalid markers */
            rules->kran.advanced.dis_sync           = FALSE;                                                                                              
            rules->kran.advanced.sqlch_egr          = TRUE;   /* Controls the transmitter squelch control in the egress (host->line) path */
            rules->kran.advanced.sqlch_ing          = FALSE;  /* Controls the transmitter squelch control in the ingress (line->host) path */
            rules->kran.advanced.ring               = FALSE;  /* Enables the use of the ring oscillator VCO */
            rules->kran.advanced.phase_ov           = 0x001f; /* Line side fixed-phase value, used only when phase_or is TRUE */
            rules->kran.advanced.hphase_ov          = 0x001f; /* Host side fixed-phase value, used only when hphase_or is TRUE */
            rules->kran.advanced.xtra_f             = 2;      /* Number of additional frames to send at the start of SEND_DATA */
            rules->kran.advanced.pcs_itr            = 2;                                                                                                  
#if 0
            /* 3500 msecs timers */
            rules->kran.advanced.lfi_10g            = 0x20a5; /* 10G LFI timeout */
            rules->kran.advanced.max_wait           = 0x433b; /* maximum wait time */
            rules->kran.advanced.lfi_thres          = 0x2039; /* LFI threshold */
#endif
            rules->kran.advanced.lfi_10g            = 0x04b5; /* 10G LFI timeout */
            rules->kran.advanced.max_wait           = 0x099a; /* maximum wait time */
            rules->kran.advanced.lfi_thres          = 0x0449; /* LFI threshold */

            rules->kran.advanced.lfi_1g             = 0x006c; /* 1G LFI timeout */
            rules->kran.advanced.wait_tmr           = 200;    /* Override the LINK_READY Wait timer */
            rules->kran.advanced.tpm0               = FALSE;  /* True = Main-cursor incremented to maximum, False=Main-cursor untouched */
            rules->kran.advanced.tpm1               = FALSE;  /* True = Post-cursor adaptive calibration, False=Post-cursor incremented to maximum */
            rules->kran.advanced.tpm2               = FALSE;  /* True = Send preset command at start */
            rules->kran.advanced.tpm3               = FALSE;  /* True = Send init command at start */
            rules->kran.advanced.tpm4               = FALSE;  /* True = Force local_rx_ready to True immediately */
            rules->kran.advanced.tpm567             = 0;      /* Always set to 'b000 */
            rules->kran.advanced.preset             = FALSE;  /* True = Enable pre/main/post Cursor Preset Values */
            rules->kran.advanced.tpm30              = FALSE;  /* True = Skip Rx data corruption */
            rules->kran.advanced.tpm31              = FALSE;  /* True = Invert Pre and Post cursor orientation (Leeds emulation mode) */
            rules->kran.advanced.jmp2cal            = TRUE;   /* True = calibrate if we lose lock */
            rules->kran.advanced.ref106             = FALSE;  /* True = reference clock frequency is 106.25Mhz, set according to rules->ref_clk_rate */
            rules->kran.advanced.two_pass_mode      = FALSE;  /* True = two-pass mode for optical links */
            rules->kran.advanced.fec_bypass         = FALSE;  /* True = disable FEC even when FEC is advertized and negotiated */
            rules->kran.advanced.line_t_to_conv_dfe = 0x0180; /* Time to EDC converge in DFE mode, line side */
            rules->kran.advanced.host_t_to_conv_dfe = 0x0240; /* Time to EDC converge in DFE mode, host side */

            break;
        }

        case CS4224_TARGET_APPLICATION_FCAN:
        {
            /* 106.25MHz ref clock, 14.025GHz */
            rules->ref_clk_rate                              = CS4224_REF_CLK_106p25;

            rules->fracdiv.enable                            = TRUE;
            rules->fracdiv.divisor                           = 0x10;
            rules->fracdiv.numerator                         = 0x7FFFFF;

            /* Enable DFE mode by default */
            rules->rx_if.dplx_line_edc_mode                  = CS_HSIO_EDC_MODE_FCAN;
            rules->rx_if.dplx_host_edc_mode                  = CS_HSIO_EDC_MODE_15G_BP;

            rules->fcan.data_rates                           = CS4224_FCAN_DATA_RATE_4G |
                                                               CS4224_FCAN_DATA_RATE_8G |
                                                               CS4224_FCAN_DATA_RATE_16G;

            rules->fcan.poll_fcan_callback.fcn_ptr           = NULL;
            rules->fcan.poll_fcan_callback.user_data         = NULL;

            rules->fcan.wait_for_an_done                     = TRUE;

            /* Advertised capabilities */
            rules->fcan.speed_negotiation_support            = TRUE; 
            rules->fcan.training_protocol_support            = TRUE;
            rules->fcan.fec_capable                          = FALSE;
            rules->fcan.fec_request                          = FALSE;
            rules->fcan.transmitter_fixed                    = FALSE;

            /* Internal FCAN advanced settings */
            rules->fcan.advanced.enable_tp_main_tap_to_max   = FALSE;
            rules->fcan.advanced.enable_tp_adaptive_post     = FALSE;
            rules->fcan.advanced.enable_tp_send_preset       = FALSE;
            rules->fcan.advanced.enable_tp_send_init         = FALSE;
            rules->fcan.advanced.enable_tp_frc_lcl_rx_ready  = FALSE;
            rules->fcan.advanced.enable_tp_lp_status         = FALSE;
            rules->fcan.advanced.enable_tp_send_hold         = FALSE;
            rules->fcan.advanced.enable_tp_swc_in_limits     = FALSE;
            rules->fcan.advanced.enable_jmp_to_caldotasm     = FALSE;
            rules->fcan.advanced.disable_fc_power_savings    = TRUE;
            rules->fcan.advanced.disable_pcs_checks          = FALSE;
            rules->fcan.advanced.enable_no_loss              = FALSE;
            rules->fcan.advanced.start_an                    = TRUE;

            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Invalid application=%d\n", application));
            status = CS_ERROR;
            break;
        }
    }

    return status;
}

/**
 * Enable/disable automatic Tx squelch control based on Rx lock status.
 * 
 * The Rx mseq will monitor the lock status, and in the event of a link down the
 * mseq will squelch the downstream Tx.
 * 
 * example: Duplex device, mseq that controls the ingress path will monitor the 
 * line Rx. If the line Rx looses lock the mseq will squelch the downstream host 
 * Tx. In this case the dir should be CS4224_LINE_RX_TO_HOST_TX_DIR.
 *
 * NOTE: Does not work when using 2x2 swith unless you call it on every interface in the
 * switch pair (ie line/host rx on slice 0, line/host rx on slice 1)
 *
 * @param slice   [I] - The slice of the device to reset.
 * @param dir     [I] - References the direction of the datapath being configured
 * @param enable  [I] - enable flag, one of True or False
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_mseq_squelch_ctrl(
    cs_uint32 slice,
    e_cs4224_datapath_dir_t dir, 
    cs_boolean enable)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0x0;
    cs_uint16 spare12;
    e_cs4224_mseq_id mate_mseq;
    cs_boolean stalled = FALSE;
    cs_uint16 data;

    status |= cs4224_get_cfg_side(slice, (e_cs4224_cfg_sides_t*)&dir);
    if (CS_OK != status)
    {
        return status;
    }
    
    if (dir == CS4224_LINE_RX_TO_HOST_TX_DIR)
    {
        offset = 0x0;
        mate_mseq = CS4224_DPLX_HOST_MSEQ;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
        mate_mseq = CS4224_DPLX_LINE_MSEQ;
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset, &spare12);
    
    if(enable)
    {
        if(cs4224_is_hw_simplex(slice))
        {
            /* if we're using a simplex part, we'll want to make sure that the mate mseq is
             * also enabled so it can process the squelch requests from this mseq.
             * Note that this stuff will work even though the slice number is incorrect
             * This is so the CS4221 (10S) will still work */
             status |= cs4224_query_mseq_is_stalled(slice, mate_mseq, &stalled);
             if(stalled)
             {
                 status |= cs4224_mseq_stall(slice, mate_mseq, FALSE);
             }
        }
        if(CS_IF_CLR(spare12,CS_BIT2))
        {
            /* enable MSEQ control of squelch */
            spare12 = CS_SET(spare12, CS_BIT2);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset, spare12);
        }
    }
    else
    {
        if(spare12 & CS_BIT2)
        {
            /* disable MSEQ control of squelch */
            spare12 = CS_CLR(spare12, CS_BIT2);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset, spare12);

            /* delay for mseq to catch up */
            CS_UDELAY(30);
            
            /* disable this interfaces mail-out */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_LSB + offset, 0);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_MSB + offset, 0);
            /* disable the connected interface's mail in */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_MSB - offset, &data);
            data = CS_CLR(data, CS_BIT15 | CS_BIT12);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_MSB - offset, data);
        }
    }

    return status;
}

/**
 * This method will send a squelch/unsquelch request to the MSEQ.
 * This can be used to squelch/unsquelch when the auto-squelch feature
 * is on. The auto-squelch feature is not required to use this function.
 * 
 * Note that this method only sets the squelch and does not turn off the 
 * driver (CTRLA value), which may leave a low level signal on the line. 
 * Use cs4224_squelch_driver instead, however that method behaves a bit 
 * differently and is not compatible with the auto-squelch feature.
 * 
 * Dir is the direction of traffic you want to squelch.
 * Ex: To squelch the host Tx use dir = CS4224_LINE_RX_TO_HOST_TX_DIR. The
 * squelch request will be sent to the Line Rx MSEQ and processed in the
 * Host Tx MSEQ, squelching the host Tx.
 *
 * This method is compatible with the 2x2 switch and broadcast. In the
 * broadcast case both of the active transmitters will be squelched.
 * Ex: Broadcast 0-0 (host Rx goes to line Tx on both slices in switch pair)
 * If this method is used on the host Rx (4224_LINE_RX_TO_HOST_TX_DIR) then
 * both slice and slice+1 line Tx's will be squelched.
 * 
 * @param slice   [I] - The slice of the device to reset.
 * @param dir     [I] - Identifies the line or host side Tx 
 * @param squelch [I] - squelch flag, True or False
 *
 * @return CS_OK on success, CS_ERROR on failure
 */
cs_status cs4224_send_squelch_request(
    cs_uint32 slice,
    e_cs4224_datapath_dir_t dir,
    cs_boolean squelch)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;

    status |= cs4224_get_cfg_side(slice, (e_cs4224_cfg_sides_t*) &dir);
    if(CS_OK != status)
    {
        return status;
    }
    if (dir == CS4224_LINE_RX_TO_HOST_TX_DIR)
    {
        offset = 0;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }
    
    if (squelch)
    {
        /* enable squelch */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_LSB+offset, 0x8000);
    }
    else
    {
        /* disable squelch */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_LSB+offset, 0x0000);
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_MSB+offset, 0x9000);

    return status;
}

/**
 * This method squelches/un-squelches a Tx driver.
 *
 * This method squelches by setting SQUELCH[0] and clears the driver
 * output levels. Prior to clearing, the driver output levels (CTRLA) 
 * are saved in a temporary register associated with that interface. 
 * When un-squelching, the SQUELCH[0] bit is cleared and the saved CTRLA
 * values are restored.
 * 
 * Note that when squelching attempted when the temporary register
 * already contains a saved CTRLA value, the saved value is not updated and 
 * the interface is squelched. When un-squelching, if the temporary register
 * does not contain a saved CTRLA value (it is set to its default value),
 * the interface is un-squelched without updating CTRLA. 
 * 
 * Side is the side that contains the Tx driver.
 * ex: To squelch the host Tx, use side = CS4224_CFG_HOST_SIDE
 * 
 * @param slice   [I] - The slice of the device to reset.
 * @param side    [I] - Identifies the line or host side Tx 
 * @param squelch [I] - squelch flag, True or False
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_squelch_driver(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t side, 
    cs_boolean squelch)
{
    cs_status status = CS_OK;
    cs_uint16 squelch_addr;
    cs_uint16 ctrla_addr;
    cs_uint16 ctrla_storage_addr;
    cs_uint16 spare12_addr;
    cs_uint16 ctrla_storage_dft;
    cs_uint16 ctrla;
    cs_uint16 spare12;

    /* Cannot use cs4224_get_cfg_side, since that fn is for the Rx side, not Tx */
    if (cs4224_is_hw_simplex(slice) && (side == CS4224_CFG_SIMPLEX))
    {
        if(cs4224_line_rx_to_host_tx_dir(slice))
        {
            side = CS4224_CFG_HOST_SIDE;
        }
        else
        {
            side = CS4224_CFG_LINE_SIDE;
        }
    }
    else
    {
        if (side == CS4224_CFG_SIMPLEX)
        {
            CS_TRACE(("ERROR: Duplex slice, invalid side = CS4224_CFG_SIMPLEX\n"));
            status |= CS_ERROR;
        }
    }
    
    if (side == CS4224_CFG_LINE_SIDE)
    {
        squelch_addr       = CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH;
        ctrla_addr         = CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA;
        ctrla_storage_addr = CS4224_PP_LINE_SDS_COMMON_COREFRAC0_STAGE2PRELOAD0;
        spare12_addr       = CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB;
    }
    else
    {
        squelch_addr       = CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH;
        ctrla_addr         = CS4224_PP_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLA;
        ctrla_storage_addr = CS4224_PP_HOST_SDS_COMMON_COREFRAC0_STAGE2PRELOAD0;
        spare12_addr       = CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB;
    }
    ctrla_storage_dft = CS4224_PP_LINE_SDS_COMMON_COREFRAC0_STAGE2PRELOAD0_dft;

    status |= cs4224_reg_get_channel(slice, spare12_addr, &spare12);
    if (spare12 & 4)
    {
        CS_TRACE(("ERROR: Squelching controlled by microsequencer, call cs4224_mseq_squelch_ctrl to disable automatic Tx squelch control on slice %x, or use cs4224_send_squelch_request instead (slightly different use).\n", slice));
        return CS_ERROR;
    }

    if (squelch)
    {
        /* enable squelch */

        status |= cs4224_reg_get_channel(slice, ctrla_addr, &ctrla);
        if (ctrla != 0x0000)
        {
            /* save then clear ctrla */
            status |= cs4224_reg_set_channel(slice, ctrla_storage_addr, ctrla);
            status |= cs4224_reg_set_channel(slice, ctrla_addr, 0x0000);
        }
        status |= cs4224_reg_set_channel(slice, squelch_addr, 0x0001);
    }
    else
    {
        /* disable squelch */

        status |= cs4224_reg_get_channel(slice, ctrla_storage_addr, &ctrla);
        if (ctrla != ctrla_storage_dft)
        {
            /* restore cltra */
            status |= cs4224_reg_set_channel(slice, ctrla_addr, ctrla);
            /* set cltra storage back to 0xcccc (default) */
            status |= cs4224_reg_set_channel(slice, ctrla_storage_addr, ctrla_storage_dft);
        }
        status |= cs4224_reg_set_channel(slice, squelch_addr, 0x0000);
    }

    return status;
}

/* This method performs a hard reset of a single die. See the
 * header file for details */
cs_status cs4224_hard_reset_die(
    cs_uint32 die)
{
    cs_status status = CS_OK;
    cs_uint32 stride = 0;
    cs_uint16 data = 0x0;

    
    
    /* Wait for EEPROM download (which will be running after reset) */
    status |= cs4224_wait_for_eeprom_finished(die, 2500, 1);
    
    cs4224_lock(die);
    
    /* Fix the MDIO_CONFIG register so accesses to MSEQ registers don't time out (bug 35875) */
    if(CS_OK != cs4224_reg_set(die, CS4224_GLOBAL_MDIO_CONFIG, CS4224_GLOBAL_MDIO_CONFIG_pref))
    {
        /* If there is something wrong with the comms then quit immediately */
        CS_TRACE(("ERROR: Something wrong with reg get/set methods, not resetting\n"));
        return CS_ERROR;
    }
    
    /* Blindly stall all the mseqs */
    for(stride = 0; stride < 0x4000; stride += 0x1000)
    {
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL + stride,  0x8004);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS + stride,  0x0008);
        status |= cs4224_reg_set(die, CS4224_PP_HOST_HOSTMISC_MSEQCLKCTRL + stride,  0x8004);
        status |= cs4224_reg_set(die, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS + stride,  0x0008);
    }
    
    /* Use broadcast to write to all the ports at once, which can't be used to stall the mseqs */
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST,                    0x80);
    {
        /* Reset all port-pairs (PP) on the die */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_CLKEN,              0xFFFF);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_SOFT_RESET,         0x0001);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_MPIF_RESET_DOTREG,  0x0007);
        /* Fix common_tx_sr default (ACJTAG) (bug 37448) */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_SOFT_RESET,         0x0000);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_MPIF_RESET_DOTREG,  0x0000);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_CLKEN,              0x0000);

    }
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST,                    0x0);

#ifndef CS_DONT_USE_MPIF_SOFT_RESET
    /* Reset a die of the ASIC. This write is self clearing
     * 
     * NOTE: This reset will trigger the moment the internal register is written to.
     * This will cause communications with the chip to cease at exactly that point, usually
     * before the transaction will complete. Depending on your I2C implementation this
     * can cause the bus to become locked up. This is known to happen on OMAP ARM parts
     * with linux kernel 3.8.13
     * 
     * Ignore the return status
     */
    cs4224_reg_set(die, CS4224_GLOBAL_MPIF_SOFT_RESET, 0xDEAD);
#endif

    /* Wait for the EEPROM to finish downloading the die */
    status |= cs4224_wait_for_eeprom_finished(die, 2500, 1);
    
    /* Squelch all transmitters out of reset */ 
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST,                    0x80);
    {
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH,     0x1);
#if 0
        /* Power-down the receive block to save fuel, SRX_PD=1, see Youtrack k2-292  */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG,   0x0024);
#endif
    }
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST,                    0x0);
    
    if(CS_OK == status)
    {
        /* if everything worked, then set the scratch to say this die was successfully reset */
        status |= cs4224_reg_get(die, CS4224_GLOBAL_SCRATCH6, &data);
        status |= cs4224_reg_set(die, CS4224_GLOBAL_SCRATCH6, CS_SET(data, CS_BIT1));
    }
    
    cs4224_unlock(die);
    
    /* reset the API static-state */
    cs4224_reset_die_static_state(die);
    
    return status;
}

/* This method performs a hard reset on the K2 package. See
 * the header file for details */
cs_status cs4224_hard_reset(
    cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs_uint32 die = slice & 0xFFFFFF00;
    
    /* reset die 0, which is always present */
    status |= cs4224_hard_reset_die(die);

    if (CS4224_MAX_NUM_DIES(die) > 1)
    {
        /* reset die 1, which is chip-dependant */
        status |= cs4224_hard_reset_die(die | 0x1);
    }
    
    return status;
}

/**
 * This method is called to disable power savings on the specified
 * microsequencer.
 *
 * @{note,
 * Note: Power savings cannot be enabled with the ring oscillator. The ring oscillator
 * is used for 8G fibrechannel and related rates: 8/4/2/1. This method will
 * automatcially detect the ring oscillator and silently exit without enabling
 * power savings.
 * }
 * 
 * @param slice    [I] - The slice of the device to access.
 * @param mseq_id  [I] - The microsequencer ID to disable power
 *                       savings on.
 * @param enable   [I] - TRUE to enable power savings or FALSE
 *                       to disable it.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 *    
 *    slice = 0
 *
 *    // Disable power savings on the line side microsequencer in a duplex part
 *    cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
 */
cs_status cs4224_mseq_enable_power_savings(
    cs_uint32         slice, 
    e_cs4224_mseq_id  mseq_id,
    cs_boolean        enable)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data = 0;
    cs_uint16 spare12 = 0;
    cs_uint16 clkdiv_ctrl = 0;
    e_cs4224_edc_mode edc_mode = CS_HSIO_EDC_MODE_DISABLED;
    cs_boolean stalled;
    cs_uint16 offset = 0;
    
    status |= cs4224_get_mseq_id(slice, &mseq_id);
    if(CS_OK != status)
    {
        return status;
    }
    
    if(mseq_id == CS4224_DPLX_LINE_MSEQ)
    {
        offset = 0;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }
    
    /* get the edc mode */
    status |= cs4224_query_edc_mode(slice, mseq_id, &edc_mode);
    /* see if the mseq is stalled */
    status |= cs4224_query_mseq_is_stalled(slice, mseq_id, &stalled);
    /* check the power-savings state */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset, &spare12);
    
    if(enable)
    {
        /* ring oscillator can't have power savings enabled; allow one to turn it off but not on */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, &reg_data);
        if(reg_data & CS_BIT7)
        {
            return status;
        }
        
        /* clkdiv helps us figure out the config of this Rx intf */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL + offset, &clkdiv_ctrl);
        
        /* if the mseq is stalled or in SR mode then you need to control power savings manually */
        if(stalled || (CS_HSIO_EDC_MODE_SR == edc_mode))
        {
            /* if the fracn is needed we need to make sure we don't turn it off! */
            if((clkdiv_ctrl&0x000F) == 0x0009)
            {
                /*fracn used*/
                reg_data = 0x1e7;
            }
            else
            {
                /*fracn not used*/
                reg_data = 0x1f7;
            }
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + offset, reg_data);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_MSB + offset, 0x0);
        }

        /* power savings enable bit */
        spare12 |= CS_BIT1;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset, spare12);
    }
    else /* disable */
    {
        /* if the mseq is stalled or in SR mode then you need to control power savings manually */
        if(stalled || (CS_HSIO_EDC_MODE_SR == edc_mode))
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + offset, 0x65);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_MSB + offset, 0x0);
        }

        /* power savings bit */
        spare12 = CS_CLR(spare12,CS_BIT1);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset, spare12);
        
        /* Delay while the mseq changes the power down reg */
        CS_UDELAY(50);
    }

    return status;
}

/**
 * This method is used to determine whether power savings is enabled or not 
 * on the specified microsequencer.
 *
 * @param slice    [I] - The slice of the device to access.
 * @param mseq_id  [I] - The microsequencer ID for the slice in question
 * @param enabled  [O] - TRUE if power savings is enabled or FALSE
 *                       if disabled.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_query_mseq_power_savings(
    cs_uint32         slice, 
    e_cs4224_mseq_id  mseq_id,
    cs_boolean*       enabled)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data = 0;
    cs_uint32 spare12_addr;

    *enabled = FALSE;
    
    status |= cs4224_get_mseq_id(slice, &mseq_id);
    if(CS_OK != status)
    {
        return status;
    }
    
    if(CS4224_DPLX_LINE_MSEQ == mseq_id)
    {
        spare12_addr = CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB;
    }
    else
    {
        spare12_addr = CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB;
    }

    status |= cs4224_reg_get_channel(slice, spare12_addr, &reg_data);

    if ( (reg_data & 0x2) == 0x2 )
    {
        *enabled = TRUE;
    }
    else
    {
        *enabled = FALSE;
    }

    return status;
}

/**
 * This method can be used to determine whether or not the microsequencer
 * is currently stalled or not.
 *
 * @param slice   [I] - The slice of the device to query the run status
 *                      of the microsequencer.
 * @param mseq_id [I] - The ID of the microsequencer.
 * @param stalled [O] - TRUE if stalled, FALSE if running.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_query_mseq_is_stalled(
    cs_uint32         slice, 
    e_cs4224_mseq_id  mseq_id,
    cs_boolean*       stalled)
{
    cs_status status = CS_OK;
    cs_uint16 options_shadow_addr;
    cs_uint16 data;

    status |= cs4224_get_mseq_id(slice, &mseq_id);
    if(CS_OK != status)
    {
        return status;
    }

    if(mseq_id == CS4224_DPLX_LINE_MSEQ)
    {
        options_shadow_addr = CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW;
    }
    else
    {
        options_shadow_addr = CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW;
    }

    status |= cs4224_reg_get_channel(slice, options_shadow_addr, &data);

    if(0xbada == data)
    {
        /* some kind of read issue with power savings */
        CS_TRACE(("ERROR: SDS_DSP_MSEQ_OPTIONS_SHADOW register returned 0xbada\n"));
        return CS_ERROR;
    }
    
    if((data & 0x8) == 0x8)
    {
        *stalled = TRUE;
    }
    else
    {
        *stalled = FALSE;
    }

    return status;
}

/* minimum link guard time for k2 */
#define CS4224_MIN_LINK_GUARD 50

/**
 * This method can be used to determine whether or not the interface is locked
 * and able to pass traffic
 * 
 * NOTE1: Not for use with KR or FC auto-negotiation. Use their respective AN-done
 * methods instead.
 * 
 * NOTE2: check_time should be long enough to gain confidence the link is stable. For
 * most applications this is ~500ms. This value needs to be longer than 50ms
 * (approximate time it takes to lock).
 * 
 * @param slice      [I] - The slice of the device to query
 * @param mseq_id    [I] - The interface (line/host/simplex) to query
 * @param check_time [I] - The minimum duration in ms to check the link interrupt status, usually 500ms
 * @param link_ready [O] - TRUE if link is locked and ready, FALSE otherwise.
 *
 * @return CS_OK on success, CS_ERROR on failure. Does not represent lock state, 
 *   link_ready can be false while status can return CS_OK.
 * 
 */
cs_status cs4224_query_link_ready(
    cs_uint32         slice,
    e_cs4224_mseq_id  mseq_id,
    cs_uint32         check_time,
    cs_boolean*       link_ready)
{
    cs_status status = CS_OK;
    cs_boolean stalled = FALSE;
    cs_uint16 data = 0;
    cs_uint16 lock_intstatus_addr;
    cs_uint16 lock_interrupt_addr;
    cs_uint16 mseq_status_addr;
    cs_uint16 altct_status_addr;
    
    status |= cs4224_get_mseq_id(slice, &mseq_id);
    
    if(mseq_id == CS4224_DPLX_LINE_MSEQ)
    {
        lock_intstatus_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS;
        lock_interrupt_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT;
        mseq_status_addr    = CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS;
        altct_status_addr   = CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_STATUS;
    }
    else
    {
        lock_intstatus_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS;
        lock_interrupt_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT;
        mseq_status_addr    = CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS;
        altct_status_addr   = CS4224_PP_HOST_SDS_COMMON_RXVCO0_ALTCT_STATUS;
    }
    
    /* Check that check_time is at least our absolute minimum */
    if(check_time < CS4224_MIN_LINK_GUARD)
    {
        CS_TRACE(("WARNING: link guard check_time (%ums) is too short, should be >%ums, recommend 500ms.\n", \
                  check_time, CS4224_MIN_LINK_GUARD));
    }
    
    /* By default link_ready will be false */
    *link_ready = FALSE;
    
    /* check if we have lock */
    status |= cs4224_reg_get_channel(slice, lock_intstatus_addr, &data);
    if( (0xbada == data) || (data & CS_BIT6) == 0x0 )
    {
        /* not locked, do not proceed */
        return status;
    }
    /*CS_TRACE(("Locked...\n"));*/
    
    /* check if tuning was sucessful */
    status |= cs4224_reg_get_channel(slice, altct_status_addr, &data);
    if( (0xbada == data) || (data & CS_BIT15) == 0x0 )
    {
        /* not properly tuned, do not proceed */
        return status;
    }
    /*CS_TRACE(("Tuned...\n"));*/
    
    /* Check if mseq stalled, EDC converged is only valid when mseq is running */
    status |= cs4224_query_mseq_is_stalled(slice, mseq_id, &stalled);
    if(!stalled)
    {
        /* check for EDC converged */
        status |= cs4224_reg_get_channel(slice, mseq_status_addr, &data);
        if( (0xbada == data) || (data & CS_BIT5) == 0x0 )
        {
            /* not converged, do not proceed */
            return status;
        }
        /*CS_TRACE(("EDC Converged...\n"));*/
    }
    
    /* we're locked right now, but check the lock interrupt for a few ms */
    status |= cs4224_reg_set_channel(slice, lock_interrupt_addr, 0xFFFF);
    
    /* do two checks in the timeframe */
    CS_MDELAY(check_time >> 1);
    status |= cs4224_reg_get_channel(slice, lock_interrupt_addr, &data);
    if( (0xbada == data) || (data & CS_BIT6) )
    {
        /* lock state changed */
        return status;
    }
    /*CS_TRACE(("Still locked...\n"));*/
    
    CS_MDELAY(check_time >> 1);
    status |= cs4224_reg_get_channel(slice, lock_interrupt_addr, &data);
    if(0xbada == data)
    {
        return status;
    }
    if( (data & CS_BIT6) == 0x0 )
    {
        /* lock state is constant, link should be good, check we didn't have
         * any status errors */
        if(CS_OK == status)
        {
            *link_ready = TRUE;
            /*CS_TRACE(("Lock Confirmed\n"));*/
        }
    }
    
    return status;
}

/**
 * This method can be used to determine whether or not multiple interfaces are locked
 * and ready to pass traffic. This is a far more efficient method than query_link_ready
 * for multiple slices.
 * 
 * NOTE1: Not for use with KR or FC auto-negotiation. Use their respective AN-done
 * methods instead.
 * 
 * NOTE2: check_time should be long enough to gain confidence the link is stable. For
 * most applications this is ~500ms. This value needs to be longer than 50ms
 * (approximate time it takes to lock).
 * 
 * NOTE3: fault_index will be updated with the index of the link that's not ready if
 * links_ready is returned FALSE. You can use this to print out an error or check
 * the status of the faulty link.
 * 
 * @param interfaces  [I] - A struct containing the interfaces to query
 * @param length      [I] - The length of the interface struct (num of interfaces)
 * @param check_time  [I] - The minimum duration in ms to check the link interrupt status, usually 500ms
 * @param fault_index [O] - The index of the interface in interfaces[] that is not ready, useful for debugging
 * @param links_ready [O] - TRUE if all links are locked and ready, FALSE otherwise.
 *
 * @return CS_OK on success, CS_ERROR on failure. Does not represent lock state, 
 *   link_ready can be false while status can return CS_OK.
 * 
 */
cs_status cs4224_query_links_ready(
    cs4224_interface_t interfaces[],
    cs_uint16          length,
    cs_uint32          check_time,
    cs_uint16*         fault_index,
    cs_boolean*        links_ready)
{
    cs_status status = CS_OK;
    cs_uint16 i = 0;
    
    /* Check that check_time is at least our absolute minimum */
    if(check_time < CS4224_MIN_LINK_GUARD)
    {
        CS_TRACE(("WARNING: link guard check_time (%ums) is too short, should be >%ums, recommend 500ms.\n", \
                  check_time, CS4224_MIN_LINK_GUARD));
    }
    
    /* By default links_ready will be false */
    *links_ready = FALSE;
    
    /* iterate through all the slices */
    for(i=0; i < length; i++)
    {
        cs_uint32        slice   = interfaces[i].slice;
        e_cs4224_mseq_id mseq_id = interfaces[i].mseq_id;
        
        cs_boolean stalled = FALSE;
        cs_uint16 data = 0;
        cs_uint16 lock_intstatus_addr;
        cs_uint16 lock_interrupt_addr;
        cs_uint16 mseq_status_addr;
        cs_uint16 altct_status_addr;
        
        *fault_index = i;
        
        status |= cs4224_get_mseq_id(slice, &mseq_id);
        
        if(mseq_id == CS4224_DPLX_LINE_MSEQ)
        {
            lock_intstatus_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS;
            lock_interrupt_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT;
            mseq_status_addr    = CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS;
            altct_status_addr   = CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_STATUS;
        }
        else
        {
            lock_intstatus_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS;
            lock_interrupt_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT;
            mseq_status_addr    = CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS;
            altct_status_addr   = CS4224_PP_HOST_SDS_COMMON_RXVCO0_ALTCT_STATUS;
        }
    
        /* check if we have lock */
        status |= cs4224_reg_get_channel(slice, lock_intstatus_addr, &data);
        if( (0xbada == data) || (data & CS_BIT6) == 0x0 )
        {
            /* not locked, do not proceed */
            return status;
        }
        
        /* check if tuning was sucessful */
        status |= cs4224_reg_get_channel(slice, altct_status_addr, &data);
        if( (0xbada == data) || (data & CS_BIT15) == 0x0 )
        {
            /* not properly tuned, do not proceed */
            return status;
        }
    
        /* Check if mseq stalled, EDC converged is only valid when mseq is running */
        status |= cs4224_query_mseq_is_stalled(slice, mseq_id, &stalled);
        if(!stalled)
        {
            /* check for EDC converged */
            status |= cs4224_reg_get_channel(slice, mseq_status_addr, &data);
            if( (0xbada == data) || (data & CS_BIT5) == 0x0 )
            {
                /* not converged, do not proceed */
                return status;
            }
        }
        
        /* clear the lock interrupt */
        status |= cs4224_reg_set_channel(slice, lock_interrupt_addr, 0xFFFF);
    }
    
    /* we're locked right now, but check the lock interrupt in a few ms */
    CS_MDELAY(check_time);
    
    for(i=0; i < length; i++)
    {
        cs_uint32        slice   = interfaces[i].slice;
        e_cs4224_mseq_id mseq_id = interfaces[i].mseq_id;
        
        cs_uint16 data = 0;
        cs_uint16 lock_interrupt_addr;
        
        *fault_index = i;
        
        status |= cs4224_get_mseq_id(slice, &mseq_id);
        
        if(mseq_id == CS4224_DPLX_LINE_MSEQ)
        {
            lock_interrupt_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT;
        }
        else
        {
            lock_interrupt_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT;
        }
    
        status |= cs4224_reg_get_channel(slice, lock_interrupt_addr, &data);
        if(0xbada == data)
        {
            return status;
        }
        if(data & CS_BIT6)
        {
            /* lost lock at some point */
            return status;
        }
    }
    
    /* lock state is constant, link should be good, check we didn't have
     * any status errors */
    if(CS_OK == status)
    {
        *links_ready = TRUE;
        /*CS_TRACE(("Lock Confirmed\n"));*/
    }
    return status;
}

/**
 * This method can be used to query the link status of multiple interfaces.
 * 
 * @{note,
 *   NOTE: Not for use with KR or FC auto-negotiation. Use their respective AN-done
 *   methods instead.
 * }
 * 
 * @{note,:
 *   NOTE: check_time should be long enough to gain confidence the link is stable. For
 *   most applications this is ~500ms. This value needs to be longer than 50ms
 *   (approximate time it takes to lock).
 * }
 * 
 * @param interfaces   [I] - A struct containing the interfaces to query
 * @param length       [I] - The length of the interface struct (num of interfaces)
 * @param check_time   [I] - The minimum duration in ms to check the link interrupt status, usually 500ms
 * @param links_status [O] - Struct containing the link status for each interface. 
 *                           Make sure length of links_status == length.
 *
 * @return CS_OK on success, CS_ERROR on failure. Does not represent lock state, 
 *   link_ready can be false while status can return CS_OK.
 * 
 * @example
 *
 *   cs4224_interface_t interfaces[8] = {0};
 *   cs_boolean         links_ready[8] = {0};
 *
 *   for(i = 0; i < 8; i++)
 *   {
 *       interfaces[i].slice = i | upper_bits;
 *       interfaces[i].mseq_id = CS4224_DPLX_LINE_MSEQ;
 *   }
 *
 *   // Query the status of all 8 line side receivers
 *   cs4224_query_links_status(interfaces, 8, 1000, &links_ready[0]);
 */
cs_status cs4224_query_links_status(
    cs4224_interface_t        interfaces[],
    cs_uint16                 length,
    cs_uint32                 check_time,
    cs4224_interface_status_t links_status[])
{
    cs_status status = CS_OK;
    cs_uint16 i = 0;
    
    /* Check that check_time is at least our absolute minimum */
    if(check_time < 300)
    {
        CS_TRACE(("WARNING: link guard check_time (%ums) is too short, should be >%ums, recommend 500ms.\n", \
                  check_time, 300));
    }
    
    /* By default links_ready will be true, we'll set it to false
       if any link fails the ready check. */
    for(i = 0; i < length; i++)
    {
        links_status[i].slice = interfaces[i].slice;
        links_status[i].mseq_id = interfaces[i].mseq_id;
        links_status[i].link_up = TRUE;
        links_status[i].rxlock = TRUE;
        links_status[i].force_lock = FALSE;
        links_status[i].edc_converged = TRUE;
        links_status[i].xgpcs_enabled = FALSE;
        links_status[i].egpcs_enabled = FALSE;
        links_status[i].gigepcs_enabled = FALSE;
        links_status[i].xgpcs_synced = FALSE;
        links_status[i].xgpcs_high_ber = FALSE;
        links_status[i].egpcs_synced = FALSE;
        links_status[i].gigepcs_synced = FALSE;
    }
    
    /* iterate through all the slices */
    for(i=0; i < length; i++)
    {
        cs_uint32        slice   = interfaces[i].slice;
        e_cs4224_mseq_id mseq_id = interfaces[i].mseq_id;
        
        cs_boolean stalled = FALSE;
        cs_uint16 data = 0;
        cs_uint16 lock_intstatus_addr;
        cs_uint16 lock_interrupt_addr;
        cs_uint16 mseq_status_addr;
        cs_uint16 altct_status_addr;
        
        status |= cs4224_get_mseq_id(slice, &mseq_id);
        
        if(mseq_id == CS4224_DPLX_LINE_MSEQ)
        {
            lock_intstatus_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS;
            lock_interrupt_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT;
            mseq_status_addr    = CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS;
            altct_status_addr   = CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_STATUS;
        }
        else
        {
            lock_intstatus_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS;
            lock_interrupt_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT;
            mseq_status_addr    = CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS;
            altct_status_addr   = CS4224_PP_HOST_SDS_COMMON_RXVCO0_ALTCT_STATUS;
        }
    
        /* check if we have lock */
        status |= cs4224_reg_get_channel(slice, lock_intstatus_addr, &data);
        if(0xbada == data)
        {
            CS_TRACE(("ERROR: lock intstatus returned 0xbada\n"));
            return CS_ERROR;
        }
        if( (data & CS_BIT6) == 0x0 )
        {
            /* not locked, do not proceed */
            links_status[i].link_up = FALSE;
            links_status[i].rxlock = FALSE;
        }
        else
        {
            /* If the Lock bit is not asserted but FiltLock is then
             * check to see if we're in force lock state where we are
             * locked to the local reference. This is stored in the
             * RXLOCKD0_CONTROL register which is at offset 3 from
             * the RXLOCKD0_INSTATUS register. */
            if(0 == (data & CS_BIT0))
            {
                status |= cs4224_reg_get_channel(slice, lock_intstatus_addr - 3, &data);
                if(CS_BIT0 == (data & CS_BIT0))
                {
                    links_status[i].force_lock = TRUE;
                }
            }
        }
        
        /* check if tuning was sucessful */
        status |= cs4224_reg_get_channel(slice, altct_status_addr, &data);
        if( (data & CS_BIT15) == 0x0 )
        {
            /* not properly tuned, do not proceed */
            links_status[i].link_up = FALSE;
        }
    
        /* Check if mseq stalled, EDC converged is only valid when mseq is running */
        status |= cs4224_query_mseq_is_stalled(slice, mseq_id, &stalled);
        if(!stalled)
        {
            /* check for EDC converged */
            status |= cs4224_reg_get_channel(slice, mseq_status_addr, &data);
            if( (data & CS_BIT5) == 0x0 )
            {
                /* not converged, do not proceed */
                links_status[i].link_up = FALSE;
                links_status[i].edc_converged = FALSE;
            }
        }

        /* If this is the line side and the PCS is enabled then check
           the PCS sync status */
        if(mseq_id == CS4224_DPLX_LINE_MSEQ)
        {
            cs_uint16 pcs_data;
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, &data);

            /* If the XGPCS is enabled then query it's status */
            if(CS_BIT2 == (data & CS_BIT2))
            {
                /* Ensure the XGPCS is out of reset */
                status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXCNTRL, &pcs_data);
                if(!(CS_BIT15 == (pcs_data & CS_BIT15)))
                {
                    links_status[i].xgpcs_enabled = TRUE;
                    links_status[i].xgpcs_synced = TRUE;
                    links_status[i].xgpcs_high_ber = FALSE;

                    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXSTATUS, &pcs_data);

                    /* If the 10G PCS is enable but synced then the link is not ready */
                    if(!(CS_BIT8 == (pcs_data & CS_BIT8)))
                    {
                        links_status[i].link_up = FALSE;
                        links_status[i].xgpcs_synced = FALSE;
                    }                        

                    /* If the 10G PCS is showing bit errors then the link is not ready */
                    if(CS_BIT9 == (pcs_data & CS_BIT9))
                    {
                        links_status[i].link_up = FALSE;
                        links_status[i].xgpcs_high_ber = TRUE;
                    }
                }
            } 
            /* Else if the 8G PCS is enabled then check it's PCS sync status */
            else if(CS_BIT1 == (data & CS_BIT1))
            {
                /* Ensure the 8G PCS is out of reset */
                status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_EGPCS_RX_MODE, &pcs_data);
                if(!(CS_BIT15 == (pcs_data & CS_BIT15)))
                {
                    links_status[i].egpcs_enabled = TRUE;
                    links_status[i].egpcs_synced = TRUE;

                    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_EGPCS_RX_INTSTATUS, &pcs_data);

                    /* If the EGPCS is not synced then the link is not ready */
                    if(!(CS_BIT0 == (pcs_data & CS_BIT0)))
                    {
                        links_status[i].link_up = FALSE;
                        links_status[i].egpcs_synced = FALSE;
                    }
                }
            }
            /* Else if the 1G PCS is enabled then check it's PCS sync status */
            else if(CS_BIT0 == (data & CS_BIT0))
            {
                /* Ensure the 1G PCS is out of reset */
                status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_GIGEPCS_LINE_CONTROL, &pcs_data);
                if(!(CS_BIT15 == (pcs_data & CS_BIT15)))
                {
                    links_status[i].gigepcs_enabled = TRUE;
                    links_status[i].gigepcs_synced = TRUE;

                    /* If the 1G PCS is not showing sync then the link isn't ready */
                    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_GIGEPCS_LINE_STATUS, &pcs_data);
                    if(!(CS_BIT2 == (pcs_data & CS_BIT2)))
                    {
                        links_status[i].link_up = FALSE;
                        links_status[i].gigepcs_synced = FALSE;
                    }
                }
            }
        }
        
        /* clear the lock interrupt */
        status |= cs4224_reg_set_channel(slice, lock_interrupt_addr, 0xFFFF);
    }

    /* we're locked right now, but check the lock interrupt in a few ms */
    CS_MDELAY(check_time);
    
    for(i=0; i < length; i++)
    {
        cs_uint32        slice   = interfaces[i].slice;
        e_cs4224_mseq_id mseq_id = interfaces[i].mseq_id;

        if(links_status[i].rxlock == TRUE)
        {
            cs_uint16 data = 0;
            cs_uint16 lock_interrupt_addr;
            
            status |= cs4224_get_mseq_id(slice, &mseq_id);
            
            if(mseq_id == CS4224_DPLX_LINE_MSEQ)
            {
                lock_interrupt_addr = CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT;
            }
            else
            {
                lock_interrupt_addr = CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT;
            }
    
            status |= cs4224_reg_get_channel(slice, lock_interrupt_addr, &data);
            if(data & CS_BIT6)
            {
                /* lost lock at some point */
                links_status[i].link_up = FALSE;
                links_status[i].rxlock = FALSE;
                continue;
            }
        }
    }
    
    return status;
}

/**
 * This method can be used to block until a link is up and ready to pass traffic
 * 
 * NOTE1: Not for use with KR or FC auto-negotiation. Use their respective AN-done
 * methods instead.
 * 
 * NOTE2: check_time should be long enough to gain confidence the link is stable. For
 * most applications this is ~500ms. This value needs to be longer than 50ms
 * (approximate time it takes to lock).
 * 
 * NOTE3: Timeout will specify the minimum time, however the actual time may be
 * much longer if link flapping is occuring.
 *
 * @param slice      [I] - The slice of the device to query
 * @param mseq_id    [I] - The interface (line/host/simplex) to query
 * @param check_time [I] - The minimum duration in ms to check the link interrupt status, usually 500ms
 * @param timeout    [O] - Minimum time in ms to poll the link state for, after which function 
 *                         will exit regardless of link state. Usually >2000ms.
 *
 * @return CS_OK if link is ready, CS_ERROR otherwise.
 * 
 * @example
 * //check_time should be large enough to allow even poor links to stabilize (~500ms)
 * //An appropriate amount of time for timeout is usually the time you are willing to wait before
 * // throwing an error and running diagnostics (~10sec)
 * status |= cs4224_wait_for_link_ready(6, CS4224_DPLX_LINE_MSEQ, 500, 10000);
 */
cs_status cs4224_wait_for_link_ready(
    cs_uint32         slice,
    e_cs4224_mseq_id  mseq_id,
    cs_uint32         check_time,
    cs_uint32         timeout)
{
    cs_status status = CS_OK;
    cs_boolean link_ready = FALSE;
    cs_uint32 i = 0;
    cs_uint32 timer = 0;
    
    timer = timeout >> 2;
    /* timer must be at least 1 */
    if(0 == timer) timer = 1;
    
    
    for(i = 0; i < timer; i++)
    {
        status |= cs4224_query_link_ready(slice, mseq_id, check_time, &link_ready);
        if(CS_OK != status)
        {
            CS_TRACE(("ERROR: query_link_ready returned error, cannot read link state\n"));
            return status;
        }
        if( link_ready )
        {
            return status;
        }
        CS_MDELAY(2);
    }
    
    /* link was never ready */
    status |= CS_ERROR;
    return status;
}

/**
 * This method can be used to block until a set of links are up and ready to pass traffic.
 * This is much more efficient for multiple interfaces than wait_for_link_ready.
 * 
 * NOTE1: Not for use with KR or FC auto-negotiation. Use their respective AN-done
 * methods instead.
 * 
 * NOTE2: check_time should be long enough to gain confidence the link is stable. For
 * most applications this is ~500ms. This value needs to be longer than 50ms
 * (approximate time it takes to lock).
 * 
 * NOTE3: Timeout will specify the minimum time, however the actual time may be
 * much longer if link flapping is occuring.
 *
 * @param interfaces [I] - A struct containing the interfaces to query
 * @param length     [I] - The length of the interface struct (num of interfaces)
 * @param check_time [I] - The minimum duration in ms to check the link interrupt status, usually 500ms
 * @param timeout    [O] - Minimum time in ms to poll the link state for, after which function 
 *                         will exit regardless of link state. Usually >2000ms.
 *
 * @return CS_OK if link is ready, CS_ERROR otherwise.
 */
cs_status cs4224_wait_for_links_ready(
    cs4224_interface_t interfaces[],
    cs_uint16          length,
    cs_uint32          check_time,
    cs_uint32          timeout)
{
    cs_status status = CS_OK;
    cs_uint16 fault = 0;
    cs_boolean links_ready = FALSE;
    cs_uint32 i = 0;
    cs_uint32 timer = 0;
    
    timer = timeout >> 2;
    /* timer must be at least 1 */
    if(0 == timer) timer = 1;
    
    /* CS_TRACE(("interf length %u | timeout %u | timer %u\n",length,timeout,timer)); */
    
    
    for(i = 0; i < timer; i++)
    {
        status |= cs4224_query_links_ready(interfaces, length, check_time, &fault, &links_ready);
        if(CS_OK != status)
        {
            CS_TRACE(("ERROR: cannot read link state. Interface fault index: %u\n", fault));
            return status;
        }
        if( links_ready )
        {
            return status;
        }
        CS_MDELAY(2);
    }
    
    /* link was never ready */
    status |= CS_ERROR;
    return status;
}

/**
 * This method is called to clear the in/out mailbox queues on a single interface
 *
 * NOTE: Even if you clear the MAIL_IN registers, they may be immediately set if the
 *       opposite interface has its MAIL_OUT registers set by the MSEQ. In that case
 *       you need to clear both sets of MAIL_OUT registers then clear both sets of
 *       MAIL_IN registers.
 * 
 * NOTE: doesn't work with 2x2 switch
 *
 * @param slice    [I] - The slice of the device to access.
 * @param mseq_id  [I] - The microsequencer ID of the outgoing mailbox, only used for duplex.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_clear_mailbox(
    cs_uint32         slice, 
    e_cs4224_mseq_id  mseq_id)
{
    cs_status status = CS_OK;
    cs_uint16 mailbox_in_addr, mailbox_out_addr;

    status |= cs4224_get_mseq_id(slice, &mseq_id);
    if(CS_OK != status)
    {
        return status;
    }
    
    if(CS4224_DPLX_LINE_MSEQ == mseq_id)
    {
        mailbox_in_addr  = CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_LSB;
        mailbox_out_addr = CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_LSB;
    }
    else
    {
        mailbox_in_addr  = CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_IN_LSB;
        mailbox_out_addr = CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_LSB;
    }
    
    cs4224_lock(slice);

    /* clear the out mail box queues in case they have a squelch/un-squelch request in them */
    status |= cs4224_reg_set_channel(slice, mailbox_out_addr,   0); 
    status |= cs4224_reg_set_channel(slice, mailbox_out_addr+1, 0); 
    /* clear the in mail box queue request */
    status |= cs4224_reg_set_channel(slice, mailbox_in_addr,    0);
    status |= cs4224_reg_set_channel(slice, mailbox_in_addr+1,  0);
    
    cs4224_unlock(slice);

    return status;
}

/**
 * This method is called to set the delay associated with
 * stalling the microsequencer. This delay is used to wait
 * for timers to complete before changing things in the
 * microsequencer MPIF space
 *
 * @param us [I] - The delay associated with stalling the
 *                 microsequencer in micro seconds.
 */
void cs4224_mseq_stall_set_delay(int us)
{
    g_cs4224_mseq_stall_delay_us = us;
}

/**
 * This method is called to get the delay associated with
 * stalling the microsequencer. This delay is used to wait
 * for timers to complete before changing things in the
 * microsequencer MPIF space
 *
 * @return The delay associated with stalling the
 *         microsequencer in micro seconds.
 */
int cs4224_mseq_stall_get_delay(void)
{
    return g_cs4224_mseq_stall_delay_us;
}

/**
 * This method is called to stall or un-stall the microsequencer
 *
 * Note: This method does not support slices configured for KR-AN.
 *
 * @param slice    [I] - The slice of the device to access.
 * @param mseq_id  [I] - The microsequencer ID, only used for duplex.
 * @param stall    [I] - TRUE to stall the microsequencer or
 *                       FALSE to start it.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_mseq_stall(
    cs_uint32         slice, 
    e_cs4224_mseq_id  mseq_id,
    cs_boolean        stall)
{
    cs_status status = CS_OK;
    cs_uint16 reg_offset = 0x0;
    cs_uint16 reg_data = 0;
    cs_uint16 bank, spare12 = 0;

    status |= cs4224_get_mseq_id(slice, &mseq_id);
    if(CS_OK != status)
    {
        return status;
    }
    
    if(CS4224_DPLX_LINE_MSEQ == mseq_id)
    {
        reg_offset  = 0x0;
    }   
    else
    {
        reg_offset  = CS4224_LINE_TO_HOST_OFFSET;
    }

    cs4224_lock(slice);
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB+reg_offset, &spare12);
    
    if(stall)
    {
        /* this enables the clocks even if the microsequencer is powered-down */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL+reg_offset,  0x8004);
        
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS+reg_offset,  0x0008);

        
        /* Delay after stalling the microsequencer to ensure any timers have expired */
        CS_UDELAY(cs4224_mseq_stall_get_delay());

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE+reg_offset,   0x0000);
        
        /* When stalling the microsequencer need to revert MSEQ_SERDES to it's default
         * value or it may get set temporarily to 0x3b by the slicer calibration */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES+reg_offset,   &reg_data);
        reg_data &= ~0xf; /* don't overwrite custom filtr */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES+reg_offset,   reg_data);
    }
    else /* un-stall */
    { 
        /* clear the SNR control reg, see youtrack cs-170 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SNR_CTRL+reg_offset, 0x0000);

        /* save the current bank */
        cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, &bank);

        /* force a bank change to trigger the clearing of the micro-sequencer power-down timer. See 
         * MSEQBANKSWAP reg for details  */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0007);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0000);

        /* if slice configured for FC-AN. Note that KR-AN does not use this stall/un-stall method */
        if (spare12 & 0x0020)
        {
            if(CS4224_DPLX_LINE_MSEQ == mseq_id)
            {
                /* In FC-AN mode the the LINE side bank select is intialized to 4 */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR, 0x0004);
            }
            else
            {
                /* In FC-AN mode the the HOST side bank select is intialized to 7 */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR, 0x0007);
            }
        }
        else /* not FC-AN */
        {
            /* Revert the bank-select in DFE mode. This will not work for protocol modes like KR-AN and FC-AN.  */
            if(3 == bank) 
            {
                /* In SR mode the bank select is fixed at 3. */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0003);
            }
            else
            {
                /* DFE modes */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0000);
            }
        }
      
        /* if the microsequencer triggered dynamic reconfig is enabled, then force the bank to 7 */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_MSB+reg_offset, &reg_data);
        if (reg_data & 0x8000)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0007);
        }

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL+reg_offset, 0x0004);

        /* Restore the datastore registers before un-stalling */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR+1+reg_offset, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR+2+reg_offset, 0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR  +reg_offset, 0x803c);

        /* reset the program counter and unstall */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_PC+reg_offset,      0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS+reg_offset, 0x0007);

    }
    
    cs4224_unlock(slice);

    return status;
}

/**
 * This method is called to stall or un-stall multiple microsequencers
 *
 * Note: This method does not support slices configured for KR-AN.
 *
 * @param interfaces   [I] - The slice and mseq_ids of each mseq that needs to be stalled/unstalled.
 * @param length       [I] - The length of the interfaces array
 * @param stall        [I] - TRUE to stall the microsequencers or
 *                           FALSE to start them
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_mseqs_stall(
    cs4224_interface_t interfaces[],
    cs_uint16          length,
    cs_boolean         stall)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data = 0;
    cs_uint16 bank, spare12_lsb = 0;
    cs_uint32 i = 0;
    
    for(i=0; i<length; i++)
    {
        cs_uint16 reg_offset = 0x0;
        cs_uint32 slice = interfaces[i].slice;
        e_cs4224_mseq_id mseq_id;
        
        /* first convert mseq_id to be either line/host, so we don't have to have this check in the next loop */
        status |= cs4224_get_mseq_id(interfaces[i].slice, &(interfaces[i].mseq_id));
        if(CS_OK != status)
        {
            CS_TRACE(("ERROR: Trying to convert interfaces[%u].mseq_id to either line or host\n",i));
            return status;
        }
        mseq_id = interfaces[i].mseq_id;
        
        if(CS4224_DPLX_LINE_MSEQ == mseq_id)
        {
            reg_offset  = 0x0;
        }
        else
        {
            reg_offset  = CS4224_LINE_TO_HOST_OFFSET;
        }

        cs4224_lock(slice);
        if(stall)
        {
            /* this enables the clocks even if the microsequencer is powered-down */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL+reg_offset,  0x8004);
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS+reg_offset,  0x0008);

            /* rest of stall code is after the loop */
        }
        else /* un-stall */
        {
            /* If the mseq is in control of squelch, set squelch right off the bat 
             * because the mseq starts off in a non EDC converged state. */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB+reg_offset, &spare12_lsb);
            if(spare12_lsb & CS_BIT2)
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH-reg_offset, 0x1); /*Tx side, so inverse the mseq side*/
            }

            /* save the current bank */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, &bank);

            /* force a bank change to trigger the clearing of the micro-sequencer power-down timer. See 
             * MSEQBANKSWAP reg for details  */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0007);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0000);

            /* if slice configured for FC-AN. Note that KR-AN does not use this stall/un-stall method */
            if (spare12_lsb & 0x0020)
            {
                if(CS4224_DPLX_LINE_MSEQ == mseq_id)
                {
                    /* In FC-AN mode the the LINE side bank select is intialized to 4 */
                    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR, 0x0004);
                }
                else
                {
                    /* In FC-AN mode the the HOST side bank select is intialized to 7 */
                    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR, 0x0007);
                }
            }
            else /* not FC-AN */
            {
                /* Revert the bank-select in DFE mode. This will not work for protocol modes like KR-AN and FC-AN.  */
                if(3 == bank) 
                {
                    /* In SR mode the bank select is fixed at 3. */
                    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0003);
                }
                else
                {
                    /* DFE modes */
                    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0000);
                }
            }

            /* if the microsequencer triggered dynamic reconfig is enabled, then force the bank to 7 */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_MSB+reg_offset, &reg_data);
            if (reg_data & 0x8000)
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR+reg_offset, 0x0007);
            }
            /* rest of unstall code after the loop */
        }
        cs4224_unlock(slice);
    }
    
    
    if(stall)
    {
        /* Delay after stalling the microsequencer to ensure any timers have expired */
        CS_UDELAY(100);
    }
    
    for(i=0; i<length; i++)
    {
        cs_uint16 reg_offset = 0x0;
        cs_uint32 slice = interfaces[i].slice;
        e_cs4224_mseq_id mseq_id = interfaces[i].mseq_id;
        
        if(CS4224_DPLX_LINE_MSEQ == mseq_id)
        {
            reg_offset  = 0x0;
        }
        else
        {
            reg_offset  = CS4224_LINE_TO_HOST_OFFSET;
        }
        
        cs4224_lock(slice);
        if(stall)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE+reg_offset,   0x0000);
            
            /* When stalling the microsequencer need to revert MSEQ_SERDES to it's default
             * value or it may get set temporarily to 0x3b by the slicer calibration */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES+reg_offset,   &reg_data);
            reg_data &= ~0xf; /* don't overwrite custom filtr */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES+reg_offset,   reg_data);
        }
        else
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL+reg_offset, 0x0004);

            /* Restore the datastore registers before un-stalling */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR+1+reg_offset, 0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR+2+reg_offset, 0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR  +reg_offset, 0x803c);

            /* reset the program counter and unstall */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_PC+reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS+reg_offset, 0x0007);
        }
        cs4224_unlock(slice);
    }
    

    return status;
}

/**
 * Initialize the global timer (fixed point math).
 *
 * @param slice        [I] - The slice or port of the device(s) being initialized
 * @param ref_clk_freq [I] - The reference clock frequency in kHz
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_global_timer_fixp(
    cs_uint32 slice, 
    cs_uint32 ref_clk_freq)
{
    cs_status status = CS_OK;
    cs_uint32  ref_clk_per;
    cs_uint32  num_clks;

    ref_clk_per = 1000000000L / ref_clk_freq;
    num_clks    = 100000000L / ref_clk_per;

    cs4224_lock(slice);

    status |= cs4224_reg_set_channel(slice, CS4224_GLOBAL_GT_10KHZ_REF_CLK_CNT0, num_clks);
    status |= cs4224_reg_set_channel(slice, CS4224_GLOBAL_GT_10KHZ_REF_CLK_CNT1, num_clks>>16);

    cs4224_unlock(slice);

    return status;
}

/**
 * Initialize the temperature thresholds for the LC VCO
 *
 * @param slice [I] - The slice of the device to initialize
 * @param intf  [I] - The interface/side of the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_lc_vco_tmp_thresh(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf)
{
    cs_status status = CS_OK;
    cs_uint16 offset;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    /* These thresholds valid for LC VCO only */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES00 + offset, 0x13a);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES01 + offset, 0x127);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES02 + offset, 0x117);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES03 + offset, 0x0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES04 + offset, 0x0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES10 + offset, 0x13f);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES11 + offset, 0x12f);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES12 + offset, 0x127);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES13 + offset, 0x0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES14 + offset, 0x0);

    return status;
}

/**
 * Initialize the temperature thresholds for the Ring Oscillator VCO
 *
 * @param slice [I] - The slice of the device to initialize
 * @param intf  [I] - The interface/side of the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_ro_vco_tmp_thresh(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf)
{
    cs_status status = CS_OK;
    cs_uint16 offset;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    /* These thresholds valid for Ring Oscillator VCO only */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES00 + offset, 0x018f);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES01 + offset, 0x015f);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES02 + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES03 + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES04 + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES10 + offset, 0x018f);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES11 + offset, 0x015f);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES12 + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES13 + offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPTHRES14 + offset, 0x0000);

    return status;
}

/**
 * Initialize the device for 5G/7.5 sub-rate operation
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host only)
 * @param rules [I] - The rules for configuring the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_5g(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    cs4224_lock(slice);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL2 + offset,  0x1000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL1 + offset,  0x7778);

    cs4224_unlock(slice);

    return status;
}

/**
 * Initialize the device for 8G operation
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host only)
 * @param rules [I] - The rules for configuring the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_8g(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;
    cs_uint16 data = 0;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    cs4224_lock(slice);

    /* Use the ring oscillator */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, &data);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, CS_SET(data,CS_BIT7));
    
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL2 + offset,  0x1000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL1 + offset,  0x7778);

    cs4224_unlock(slice);

    return status;
}

/**
 * Initialize the device for 10G operation
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host only)
 * @param rules [I] - The rules for configuring the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_10g(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    cs4224_lock(slice);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL2 + offset,  0x1000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL1 + offset,  0x0008);

    cs4224_unlock(slice);

    return status;
}

/**
 * Initialize the device for 15G operation
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host only)
 * @param rules [I] - The rules for configuring the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_15g(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    cs4224_lock(slice);
    
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL2 + offset,  0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL1 + offset,  0x0000);

    cs4224_unlock(slice);

    return status;
}

/**
 * Initialize the device for 8G FC operation
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host only)
 * @param rules [I] - The rules for configuring the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_8g_fc(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;
    cs_uint16 data = 0;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    cs4224_lock(slice);

    /* Use the ring oscillator */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, &data);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, CS_SET(data,CS_BIT7));
    
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL2 + offset,  0x1000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_DLY_CTRL1 + offset,  0x7778);

    cs4224_unlock(slice);

    return status;
}

/**
 * Initialize the device for 1/2/4G FC operation
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host only)
 * @param rules [I] - The rules for configuring the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_sub_rate_fc(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;
    cs_uint16 data = 0;

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    cs4224_lock(slice);

    /* Use the ring oscillator */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, &data);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, CS_SET(data,CS_BIT7));

    cs4224_unlock(slice);

    return status;
}

/**
 * See cs4224_config_target_application
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host/splx)
 * @param rules [I] - The rules for configuring the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_config_target_application_intf(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    status |= cs4224_get_cfg_side(slice, &intf);
    if(CS_OK != status)
    {
        return status;
    }
    
    switch (rules->application)
    {
        case CS4224_TARGET_APPLICATION_5G:
        case CS4224_TARGET_APPLICATION_7p5G:
        {
            status |= cs4224_init_5g(slice, intf, rules);
            break;
        }
        
        case CS4224_TARGET_APPLICATION_8G:
        case CS4224_TARGET_APPLICATION_8p5G:
        {
            status |= cs4224_init_8g(slice, intf, rules);
            break;
        }

        case CS4224_TARGET_APPLICATION_10G:
        case CS4224_TARGET_APPLICATION_10G_FC:
        case CS4224_TARGET_APPLICATION_10G_KR:
        case CS4224_TARGET_APPLICATION_40G_KR:
        case CS4224_TARGET_APPLICATION_KRAN:
        {
            status |= cs4224_init_10g(slice, intf, rules);
            break;
        }
        
        case CS4224_TARGET_APPLICATION_15G:
        case CS4224_TARGET_APPLICATION_16G_FC:
        {
            status |= cs4224_init_15g(slice, intf, rules);
            break;
        }
        
        case CS4224_TARGET_APPLICATION_8G_FC:
        {
            status |= cs4224_init_8g_fc(slice, intf, rules);
            break;
        }

        case CS4224_TARGET_APPLICATION_1G_FC:
        case CS4224_TARGET_APPLICATION_2G_FC:
        case CS4224_TARGET_APPLICATION_4G_FC:
        {
            status |= cs4224_init_sub_rate_fc(slice, intf, rules);
            break;
        }

        case CS4224_TARGET_APPLICATION_FCAN:
        {
            /* not intf based */
            status |= cs4224_fcan_rules_set_rate(rules);
            break;
        }

        case CS4224_TARGET_APPLICATION_OC12:
        case CS4224_TARGET_APPLICATION_1G:
        default:
        {
            break;
        }
    }
    
    return status;
}

/**
 * This method sets up rate-specific registers for the desired target application.
 *
 * @param slice [I] - The slice number of the device
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_config_target_application(
    cs_uint32 slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    if(rules->application == CS4224_TARGET_APPLICATION_FCAN)
    {
        /*FCAN is a bit different*/
        status |= cs4224_config_target_application_intf(slice, CS4224_CFG_LINE_SIDE, rules);
        return status;
    }
    
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_config_target_application_intf(slice, CS4224_CFG_LINE_SIDE, rules);
    }
    if(cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_config_target_application_intf(slice, CS4224_CFG_HOST_SIDE, rules);
    }
    
    return status;
}

/**
 * Dump the settings of the advertised and advanced kran rules
 *
 * @param slice [I] - The duplex slice of the device to initialize. 
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
void cs4224_debug_dump_kran_setup(
    cs_uint32 slice,
    cs4224_kran_config_t_s* config) 
{
    CS_PRINTF(("KR AN advertised capabilities on slice %x\n", slice));
    CS_PRINTF(("  1000Base-KX        = %s\n" ,    config->advertised.tech_kx  ? "    ON" : "   OFF"));
    CS_PRINTF(("  10GBase-KR         = %s\n" ,    config->advertised.tech_kr  ? "    ON" : "   OFF"));
    CS_PRINTF(("  40GBase-KR4        = %s\n" ,    config->advertised.tech_kr4 ? "    ON" : "   OFF"));
    CS_PRINTF(("  40GBase-CR4        = %s\n" ,    config->advertised.tech_cr4 ? "    ON" : "   OFF"));
    CS_PRINTF(("  10GBase-KX4        = %s\n" ,    config->advertised.tech_kx4 ? "    ON" : "   OFF"));
    CS_PRINTF(("  FEC Ability        = %s\n" ,    config->advertised.f0       ? "    ON" : "   OFF"));
    CS_PRINTF(("  FEC Requested      = %s\n" ,    config->advertised.f1       ? "    ON" : "   OFF"));
    CS_PRINTF(("  Remote Fault       = %s\n" ,    config->advertised.rf       ? "    ON" : "   OFF"));
    CS_PRINTF(("  Pause Ability 0    = %s\n" ,    config->advertised.pause_0  ? "    ON" : "   OFF"));
    CS_PRINTF(("  Pause Ability 1    = %s\n" ,    config->advertised.pause_1  ? "    ON" : "   OFF"));

    CS_PRINTF(("KR AN advanced settings on slice %x\n", slice));
    CS_PRINTF(("  en_adt             = %s  (Enable the AN Ability Detect Timeout)\n",                               config->advanced.en_adt        ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  en_mwt             = %s  (Enable the TP Max Wait Timer)\n",                                       config->advanced.en_mwt        ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  skip_an            = %s  (Skip Auto-Negotiation)\n",                                              config->advanced.skip_an       ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  skip_tp            = %s  (Skip Training)\n",                                                      config->advanced.skip_tp       ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  skip_phsc          = %s  (Skip Phase Calibration)\n",                                             config->advanced.skip_phsc     ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  en_lfit            = %s  (Enable Link Fail Inhibit Timer)\n",                                     config->advanced.en_lfit       ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  en_retry           = %s  (Enable AN Retries)\n",                                                  config->advanced.en_retry      ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  dis_start          = %s  (Disable AN start)\n",                                                   config->advanced.dis_start     ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  en_pwrsv           = %s  (Enable DFE Power Savings)\n",                                           config->advanced.en_pwrsv      ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  en_dfe             = %s  (Enable DFE)\n",                                                         config->advanced.en_dfe        ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  bad_mrkrs          = %s  (Count Frames with Invalid Markers)\n",                                  config->advanced.bad_mrkrs     ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  dis_sync           = %s  (Disable PCS Sync Checks in Mission Mode)\n",                            config->advanced.dis_sync      ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  sqlch_egr          = %s  (Enable the Tx squelch control in the egress (host->line) path)\n",      config->advanced.sqlch_egr     ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  sqlch_ing          = %s  (Enable the Tx squelch control in the ingress (line->host) path)\n",     config->advanced.sqlch_ing     ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  ring               = %s  (Enables the use of the ring oscillator VCO)\n",                         config->advanced.ring          ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  phase_or           = %s  (Enable the line side fixed-phase override)\n",                          config->advanced.phase_or      ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  hphase_or          = %s  (Enable the host side fixed-phase override)\n",                          config->advanced.hphase_or     ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  phase_ov           = 0x%04x  (Line side fixed-phase value, used only when phase_or is TRUE)\n",   config->advanced.phase_ov )); 
    CS_PRINTF(("  hphase_ov          = 0x%04x  (Host side fixed-phase value, used only when hphase_or is TRUE)\n",  config->advanced.phase_ov )); 
    CS_PRINTF(("  xtra_f             = % 6d  (Number of Additional Frames to Send at the Start of SEND_DATA)\n",    config->advanced.xtra_f   )); 
    CS_PRINTF(("  pcs_itr            = % 6d  (Iterations to Wait for PCS to Sync (multiply by 2^16))\n",            config->advanced.pcs_itr  )); 
    CS_PRINTF(("  lfi_10g            = 0x%04x  (10G LFI Timeout)\n",                                                config->advanced.lfi_10g  )); 
    CS_PRINTF(("  max_wait           = 0x%04x  (TP_TX maximum wait)\n",                                             config->advanced.max_wait ));
    CS_PRINTF(("  lfi_thres          = 0x%04x  (LFI Threshold)\n",                                                  config->advanced.lfi_thres)); 
    CS_PRINTF(("  lfi_1g             = 0x%04x  (1G LFI timeout)\n",                                                 config->advanced.lfi_1g   )); 
    CS_PRINTF(("  wait_tmr           = % 6d  (Override the LINK_READY wait_timer)\n",                               config->advanced.wait_tmr )); 
    CS_PRINTF(("  tpm0               = %s  (True = Main-cursor incremented to max, False=Main-cursor untouched)\n", config->advanced.tpm0          ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  tpm1               = %s  (True = Post-cursor adaptive calib, False=Post-cursor inc to max)\n",    config->advanced.tpm1          ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  tpm2               = %s  (True = Send preset command at start)\n",                                config->advanced.tpm2          ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  tpm3               = %s  (True = Send init command at start)\n",                                  config->advanced.tpm3          ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  tpm4               = %s  (True = Force local_rx_ready to True immediately)\n",                    config->advanced.tpm4          ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  tpm567             = % 6d  (Always set to 'b000)\n",                                              config->advanced.tpm567   ));
    CS_PRINTF(("  preset             = %s  (True = Enable pre/main/post Cursor Preset Values)\n",                   config->advanced.preset        ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  tpm30              = %s  (True = Skip Rx data corruption)\n",                                     config->advanced.tpm30         ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  tpm31              = %s  (True = Invert Pre and Post cursor (Leeds emulation mode))\n",           config->advanced.tpm31         ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  jmp2cal            = %s  (True = calibrate if we lose lock)\n",                                   config->advanced.jmp2cal       ? "  TRUE" : " FALSE"));
    CS_PRINTF(("  ref106             = %s  (True = ref clock freq is 106.25Mhz)\n",                                 config->advanced.ref106        ? "  TRUE" : " FALSE")); 
    CS_PRINTF(("  two_pass_mode      = %s  (True = two-pass mode for optical links enabled)\n",                     config->advanced.two_pass_mode ? "  TRUE" : " FALSE"));
    CS_PRINTF(("  fec_bypass         = %s  (True = disable FEC even when FEC is advertized and negotiated)\n",      config->advanced.fec_bypass    ? "  TRUE" : " FALSE"));
    CS_PRINTF(("  line_t_to_conv_dfe = 0x%04x  (Time to EDC converge in DFE mode, line side)\n",                    config->advanced.line_t_to_conv_dfe));
    CS_PRINTF(("  host_t_to_conv_dfe = 0x%04x  (Time to EDC converge in DFE mode, host side)\n",                    config->advanced.host_t_to_conv_dfe));
    CS_PRINTF(("\n")); 

}

/**
 * Dump the settings of the advertised and advanced fcan rules
 *
 * @param slice [I] - The duplex slice of the device to initialize. 
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
void cs4224_debug_dump_fcan_setup(
    cs_uint32        slice,
    cs4224_rules_t*  rules)
{
    CS_PRINTF(("FC AN advertised capabilities on slice %x\n", slice));
    CS_PRINTF(("  data_rates                 = 0x%04x\n", rules->fcan.data_rates)); 
    CS_PRINTF(("  speed_negotiation_support  = %s\n",     rules->fcan.speed_negotiation_support   ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  training_protocol_support  = %s\n",     rules->fcan.training_protocol_support   ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  fec_capable                = %s\n",     rules->fcan.fec_capable                 ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  fec_request                = %s\n",     rules->fcan.fec_request                 ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  transmitter_fixed          = %s\n",     rules->fcan.transmitter_fixed           ? "TRUE" : "FALSE"  )); 

    CS_PRINTF(("FC AN advanced settings on slice %x\n", slice));
    CS_PRINTF(("  enable_tp_main_tap_to_max  = %s\n",     rules->fcan.advanced.enable_tp_main_tap_to_max  ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_tp_adaptive_post    = %s\n",     rules->fcan.advanced.enable_tp_adaptive_post    ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_tp_send_preset      = %s\n",     rules->fcan.advanced.enable_tp_send_preset      ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_tp_send_init        = %s\n",     rules->fcan.advanced.enable_tp_send_init        ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_tp_frc_lcl_rx_ready = %s\n",     rules->fcan.advanced.enable_tp_frc_lcl_rx_ready ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_tp_lp_status        = %s\n",     rules->fcan.advanced.enable_tp_lp_status        ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_tp_send_hold        = %s\n",     rules->fcan.advanced.enable_tp_send_hold        ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_tp_swc_in_limits    = %s\n",     rules->fcan.advanced.enable_tp_swc_in_limits    ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_jmp_to_caldotasm    = %s\n",     rules->fcan.advanced.enable_jmp_to_caldotasm    ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  disable_fc_power_savings   = %s\n",     rules->fcan.advanced.disable_fc_power_savings   ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  disable_pcs_checks         = %s\n",     rules->fcan.advanced.disable_pcs_checks         ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  enable_no_loss             = %s\n",     rules->fcan.advanced.enable_no_loss             ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("  start_an                   = %s\n",     rules->fcan.advanced.start_an                   ? "TRUE" : "FALSE"  )); 
    CS_PRINTF(("\n")); 
}

/**
 * Initialize the device for single or multi-port KR-AN operation. 
 *
 * @param master_slice [I] - The KR master slice of the device to initialize. 
 * @param rules        [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_kran(
    cs_uint32 master_slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs4224_kran_config_t_s config; 

    /* Advertise ability */
    config.advertised.rf        = rules->kran.remote_fault_d13 ? 1 : 0; /* Remote Fault */
    config.advertised.pause_0   = rules->kran.pause_ability_c0 ? 1 : 0; /* Link Partner Pause Ability */
    config.advertised.pause_1   = rules->kran.pause_ability_c1 ? 1 : 0; /* Link Partner Pause Ability */
    config.advertised.f0        = rules->kran.fec_ability_f0   ? 1 : 0; /* FEC Ability */
    config.advertised.f1        = rules->kran.fec_requested_f1 ? 1 : 0; /* FEC Requested */

    config.advertised.tech_kr   = 0; /* 10G */
    config.advertised.tech_kx   = 0; /* 1G */
    config.advertised.tech_kr4  = 0; /* (4 x 10G) 40G Backplane */
    config.advertised.tech_cr4  = 0; /* (4 x 10G) 40G Faceplate */
    config.advertised.tech_kx4  = 0; /* (4 x 2.5G) 10G Backplane */

    /* Advertise the techability data-rate */
    if (rules->kran.data_rates & CS4224_KRAN_DATA_RATE_1G)
    {
        config.advertised.tech_kx  = 1; /* 1G */
    }
    if (rules->kran.data_rates & CS4224_KRAN_DATA_RATE_10G)
    {
        config.advertised.tech_kr  = 1; /* 10G */
    }
    if (rules->kran.data_rates & CS4224_KRAN_DATA_RATE_BP_40G)
    {
        config.advertised.tech_kr4  = 1; /* (4 x 10G) 40G Backplane */
    }
    if (rules->kran.data_rates & CS4224_KRAN_DATA_RATE_FP_40G)
    {
        config.advertised.tech_cr4  = 1; /* (4 x 10G) 40G Faceplate */
    }
    if (rules->kran.data_rates & CS4224_KRAN_DATA_RATE_BP_KX4)
    {
        config.advertised.tech_kx4  = 1; /* (4 x 2.5G) 10G Backplane */
    }
    
#if 0
    CS_PRINTF(("KR AN Advertising on PHY %x\n", master_slice));
    CS_PRINTF(("  1000Base-KX:     %s\n" , config.advertised.tech_kx  ? "ON" : "OFF"));
    CS_PRINTF(("  10GBase-KR:      %s\n" , config.advertised.tech_kr  ? "ON" : "OFF"));
    CS_PRINTF(("  40GBase-KR4:     %s\n" , config.advertised.tech_kr4 ? "ON" : "OFF"));
    CS_PRINTF(("  40GBase-CR4:     %s\n" , config.advertised.tech_cr4 ? "ON" : "OFF"));
    CS_PRINTF(("  10GBase-KX4:     %s\n" , config.advertised.tech_kx4 ? "ON" : "OFF"));
    CS_PRINTF(("  FEC Ability:     %s\n" , config.advertised.f0       ? "ON" : "OFF"));
    CS_PRINTF(("  FEC Requested:   %s\n" , config.advertised.f1       ? "ON" : "OFF"));
    CS_PRINTF(("  Remote Fault:    %s\n" , config.advertised.rf       ? "ON" : "OFF"));
    CS_PRINTF(("  Pause Ability 0: %s\n" , config.advertised.pause_0  ? "ON" : "OFF"));
    CS_PRINTF(("  Pause Ability 1: %s\n" , config.advertised.pause_1  ? "ON" : "OFF"));
#endif

    status |= cs4224_kran_init_kr_pre_an(master_slice, rules, &config);

#if 0
    if(rules->show_debug_info)
    {
        cs4224_debug_dump_kran_setup(master_slice, &config);
    }
#endif

    return status;
}

/** 
 * This is an internal method that reads the efuse data (POLY_RES_CAL_DATAx)
 * and configures itune/rtune settings based on the current settings.
 *
 * @param slice [I] - The slice of the data to configure based on the
 *                    EFUSE settings.
 * @param dir   [I] - The direction to configure the settings for.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_pgm_reg_from_efuse(cs_uint32 slice, e_cs4224_cfg_sides_t dir)
{
    cs_status status = CS_OK;
    cs_uint16 efuse_data0, efuse_data1, efuse_data2;
    cs_uint16 cml_itune, cml_rtune;
    cs_uint16 vco_itune;
    cs_uint16 driver_rtune, driver_itune;
    cs_uint16 agc_itune, agc_rtune;
    cs_uint16 drivercml_rtune, drivercml_itune;
    cs_uint16 reg_data, old_data;
    cs_uint32 die = cs4224_get_die_from_slice(slice);
    cs_uint16 reg_offset = 0x0000;
 
    cs4224_lock(slice);

    status |= cs4224_reg_get(die, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA0, &efuse_data0);
    status |= cs4224_reg_get(die, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA1, &efuse_data1);
    status |= cs4224_reg_get(die, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA2, &efuse_data2);

    if (dir == CS4224_CFG_LINE_SIDE)
    {
        reg_offset = 0;
    }
    else
    {
        reg_offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    /* assign efuse cml_itune to PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE[2:0] */
    cml_itune = efuse_data0 & 0x0070;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE + reg_offset, &reg_data);
    old_data = reg_data;
    reg_data = (reg_data & ~0x0007) | (cml_itune >> 4);
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE + reg_offset, reg_data);
    }

    /* assign vco_itune to PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE[6:4]
     * and cml_rtune to PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE[2:0] */
    vco_itune = efuse_data0 & 0x7000;
    cml_rtune = efuse_data1 & 0x7000;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE + reg_offset, &reg_data);
    old_data = reg_data;
    reg_data = (reg_data & ~0x0077) | (cml_rtune >> 12) | (vco_itune >> 8);
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE + reg_offset, reg_data);
    }

    /* assign efuse agc_itune to CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2[6:4] */
    agc_itune = efuse_data0 & 0x0007;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2 + reg_offset, &reg_data);
    old_data = reg_data;
    reg_data = (reg_data & ~0xFF8F) | (agc_itune << 4);
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2 + reg_offset, reg_data);
    }

    /* assign driver_rtune to CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_TUNE[10:8]
     * and    driver_itune to CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_TUNE[2:0] */
    driver_rtune = efuse_data2 & 0x0070;
    driver_itune = efuse_data1 & 0x0007;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_TUNE - reg_offset, &reg_data);
    old_data = reg_data;
    reg_data = (reg_data & ~0x0707) | (driver_rtune << 4) | (driver_itune >> 0);
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_TUNE - reg_offset, reg_data);
    }

    /* assign drivercml_rtune to CS4224_PP_LINE_SDS_COMMON_STX0_DRIVERCML_TUNE[10:8]
      and    drivercml_itune to CS4224_PP_LINE_SDS_COMMON_STX0_DRIVERCML_TUNE[2:0] */
    drivercml_rtune = efuse_data2 & 0x0700;
    drivercml_itune = efuse_data1 & 0x0070;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVERCML_TUNE - reg_offset, &reg_data);
    old_data = reg_data;
    reg_data = (reg_data & ~0x0707) | (drivercml_rtune << 0) | (drivercml_itune >> 4);
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVERCML_TUNE - reg_offset, reg_data);
    }

    /* assign efuse agc_itune to CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE[2:0] */
    agc_rtune = efuse_data1 & 0x0700;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE + reg_offset, &reg_data);
    old_data = reg_data;
    reg_data = (reg_data & ~0x0007) | (agc_rtune >> 8);
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE + reg_offset, reg_data);
    }

    /* the value for the dfe i/rtune should not be based on the E-Fuse setting */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + reg_offset,    0x1910);

    /* over-ride efuse data with registers */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN + reg_offset,          0x0006);

    cs4224_unlock(slice);

    return status;
}

/**
 * Set the pre-equalizer settings for the application.
 *
 * @param slice      [I] - The slice of the device to set the mode for
 * @param reg_offset [I] - Line or host register address offset, 0 or 0x800
 * @param traceloss  [I] - Traceloss setting, see e_cs4224_trace_loss enum
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_update_pre_equalizer(
    cs_uint32 slice, 
    cs_uint16 reg_offset, 
    e_cs4224_trace_loss traceloss) 
{
    cs_status status = CS_OK;
    cs_uint16 lim_eqadj;
    cs_uint16 pass_eqadj1;
    cs_uint16 pass_eqadj2;

    switch(traceloss)
    {
        case CS_HSIO_TRACE_LOSS_0dB:
        {
            lim_eqadj   = 0x0100;
            pass_eqadj1 = 0x0001;
            pass_eqadj2 = 0x070F;
            break;
        }
        case CS_HSIO_TRACE_LOSS_1dB:
        {
            lim_eqadj   = 0x0100;
            pass_eqadj1 = 0x0000;
            pass_eqadj2 = 0x070F;
            break;
        }
        case CS_HSIO_TRACE_LOSS_2dB:
        {
            lim_eqadj   = 0x0100;
            pass_eqadj1 = 0x0001;
            pass_eqadj2 = 0x070F;
            break;
        }
        case CS_HSIO_TRACE_LOSS_3dB:
        {
            lim_eqadj   = 0x0100;
            pass_eqadj1 = 0x0004;
            pass_eqadj2 = 0x070F;
            break;
        }
        case CS_HSIO_TRACE_LOSS_4dB:
        {
            lim_eqadj   = 0x0100;
            pass_eqadj1 = 0x0005;
            pass_eqadj2 = 0x070F;
            break;
        }
        case CS_HSIO_TRACE_LOSS_5dB:
        {
            lim_eqadj   = 0x0100;
            pass_eqadj1 = 0x0006;
            pass_eqadj2 = 0x070F;
            break;
        }
        case CS_HSIO_TRACE_LOSS_6dB:
        {
            lim_eqadj   = 0x0100;
            pass_eqadj1 = 0x0007;
            pass_eqadj2 = 0x070F;
            break;
        }
        default:
        {
            return CS_OK;
        } 
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_MISC + reg_offset,    lim_eqadj);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + reg_offset, pass_eqadj1);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + reg_offset, pass_eqadj2);

    return status;
}

/**
 * This method is called to save the current EDC mode that the device is operating in.
 * 
 * NOTE: Currently, the edc_mode is saved in the Rdiv FracN stage 2 preload 0 register
 *
 * @param slice    [I] - The input slice to query the EDC mode for.
 * @param mseq_id  [I] - The microsequencer in the receiver to query.
 * @param edc_mode [I] - The current EDC mode configured.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_save_edc_mode(
    cs_uint32 slice,
    cs_uint16 reg_offset,
    e_cs4224_edc_mode edc_mode)
{
    cs_status status = CS_OK;
    cs_uint16 saved_edc_mode;

    switch (edc_mode)
    {
        case CS_HSIO_EDC_MODE_DISABLED:
          saved_edc_mode = 0;
          break;
        case CS_HSIO_EDC_MODE_CX1:
          saved_edc_mode = 1;
          break;
        case CS_HSIO_EDC_MODE_SR:
          saved_edc_mode = 2;
          break;
        case CS_HSIO_EDC_MODE_ZR:
          saved_edc_mode = 3;
          break;
        case CS_HSIO_EDC_MODE_DWDM:
          saved_edc_mode = 4;
          break;
        case CS_HSIO_EDC_MODE_10G_BP:
          saved_edc_mode = 5;
          break;
        case CS_HSIO_EDC_MODE_15G_BP:
          saved_edc_mode = 6;
          break;
        case CS_HSIO_EDC_MODE_5G_BP:
          saved_edc_mode = 7;
          break;
        case CS_HSIO_EDC_MODE_7p5G_BP:
          saved_edc_mode = 8;
          break;
        case CS_HSIO_EDC_MODE_8p5G_BP:
          saved_edc_mode = 9; 
          break;
        case CS_HSIO_EDC_MODE_FCAN:
          saved_edc_mode = 10; 
          break;
        case CS_HSIO_EDC_MODE_15G_BP_27dB:
          saved_edc_mode = 11;
          break;
        case CS_HSIO_EDC_MODE_SMLRM:
          saved_edc_mode = 12;
          break;

        default:
          CS_TRACE(("ERROR: cs4224_save_edc_mode: slice = %d, unknown EDC mode = %d\n", slice, edc_mode));
          status |= CS_ERROR;
          saved_edc_mode = 1;
          break;
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_STAGE2PRELOAD0 + reg_offset, saved_edc_mode);

    return status;
}

/**
 * This method is called to query the current EDC mode that the device is operating in.
 * 
 * NOTE: Currently, the edc_mode is fetched from the Rdiv FracN stage 2 preload 0 register
 *
 * @param slice    [I] - The input slice to query the EDC mode for.
 * @param mseq_id  [I] - The microsequencer in the receiver to query.
 * @param edc_mode [O] - The current EDC mode configured.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_query_edc_mode(
    cs_uint32          slice,
    e_cs4224_mseq_id   mseq_id,
    e_cs4224_edc_mode *edc_mode)
{
    cs_status status = CS_OK;
    cs_uint16 saved_edc_mode = 0;
    /* offset used for accessing host addresses over line ones */
    cs_uint16 reg_offset = 0x0000;

    /* init to disabled */
    *edc_mode = CS_HSIO_EDC_MODE_DISABLED;
    
    status |= cs4224_get_mseq_id(slice, &mseq_id);
    if(CS_OK != status)
    {
        return status;
    }
    
    if (mseq_id == CS4224_DPLX_LINE_MSEQ)
    {
        reg_offset = 0x0000;
    }
    else
    {
        reg_offset = CS4224_LINE_TO_HOST_OFFSET;
    }

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_STAGE2PRELOAD0 + reg_offset, &saved_edc_mode);

    switch (saved_edc_mode)
    {
        /* Note, edc mode enum uses too many bits, hense the custom mapping here */
        
        /* If the EDC version has never been initialized then the preloader will have the h/w
         * reset value of 0xCCCC. Report this as EDC disabled */
        case 0:
        case 0xCCCC:
            *edc_mode = CS_HSIO_EDC_MODE_DISABLED;
            break;
        case 1:
            *edc_mode = CS_HSIO_EDC_MODE_CX1;
            break;
        case 2:
            *edc_mode = CS_HSIO_EDC_MODE_SR;
            break;
        case 3:
            *edc_mode = CS_HSIO_EDC_MODE_ZR;
            break;
        case 4:
            *edc_mode = CS_HSIO_EDC_MODE_DWDM;
            break;
        case 5:
            *edc_mode = CS_HSIO_EDC_MODE_10G_BP;
            break;
        case 6:
            *edc_mode = CS_HSIO_EDC_MODE_15G_BP;
            break;
        case 7:
            *edc_mode = CS_HSIO_EDC_MODE_5G_BP;
            break;
        case 8:
            *edc_mode = CS_HSIO_EDC_MODE_7p5G_BP;
            break;
        case 9: 
            *edc_mode = CS_HSIO_EDC_MODE_8p5G_BP;
            break;
        case 10: 
            *edc_mode = CS_HSIO_EDC_MODE_FCAN;
            break;
        case 11:
            *edc_mode = CS_HSIO_EDC_MODE_15G_BP_27dB;
            break;
        case 12:
            *edc_mode = CS_HSIO_EDC_MODE_SMLRM;
            break;

        default:
            CS_TRACE(("ERROR: slice = %x, unknown saved EDC mode = %x\n", slice, saved_edc_mode));
            status |= CS_ERROR;
            break;
    }
    return status;
}

/**
 * Set the EDC mode for the application on a specific interface.
 *
 * @param slice    [I] - The slice of the device to set the mode for
 * @param rules    [I] - The rules for configuring the device.
 * @param intf     [I] - The mseq interface of the device.
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_init_edc_mode_intf(
    cs_uint32       slice,
    cs4224_rules_t* rules,
    e_cs4224_mseq_id intf)
{
    cs_status status = CS_OK;
    e_cs4224_edc_mode mode;
    e_cs4224_trace_loss traceloss;
    /* offset used for accessing host addresses over line ones */
    cs_uint16 reg_offset = 0x0000;
    /* flags for fc or 8g apps */
    cs_uint16 reg_data = 0x0000;

    cs4224_lock(slice);

    if (cs4224_is_hw_simplex(slice))
    {
        mode      = rules->rx_if.splx_edc_mode;
        traceloss = rules->rx_if.splx_eq.traceloss;

        if (cs4224_line_rx_to_host_tx_dir(slice))
        {
            intf = CS4224_DPLX_LINE_MSEQ;
            reg_offset = 0x0000;
        }
        else
        {
            intf = CS4224_DPLX_HOST_MSEQ;
            reg_offset = CS4224_LINE_TO_HOST_OFFSET;
        }
    }
    else if (cs4224_is_hw_duplex(slice))
    {
        if (intf == CS4224_DPLX_LINE_MSEQ)
        {
            reg_offset = 0x0000;

            mode      = rules->rx_if.dplx_line_edc_mode;
            traceloss = rules->rx_if.dplx_line_eq.traceloss;
        }
        else if (intf == CS4224_DPLX_HOST_MSEQ)
        {
            reg_offset = CS4224_LINE_TO_HOST_OFFSET;

            mode      = rules->rx_if.dplx_host_edc_mode;
            traceloss = rules->rx_if.dplx_host_eq.traceloss;
        }
        else
        {
            CS_TRACE(("ERROR: Invalid interface. intf=%d\n",intf));
            return CS_ERROR;
        }
    }
    else
    {
        /* error in the API checks for SKU... */
        CS_TRACE(("ERROR: unknown hardware id\n"));
        return CS_ERROR;
    }

    /* reset reset count */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_LSB + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_MSB + reg_offset, 0x0000);

    /* Reset MSEQ datastore register between mode switches */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0 + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1 + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR + reg_offset, 0x803c);
    
    /* function number */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0 + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1 + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR + reg_offset, 0x800E);

    /* Reset some MSEQ registers to defaults between mode switches (may be overwritten below) */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG4 + reg_offset, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG4_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB + reg_offset, 0x3000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES + reg_offset, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_RESOLUTION + reg_offset, 0x0001);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE13_LSB + reg_offset, 0x0008);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE13_MSB + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_BIAS1 + reg_offset, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_BIAS1_dft); 
    
    status |= cs4224_save_edc_mode(slice, reg_offset, mode);

    switch (mode)
    {
        case CS_HSIO_EDC_MODE_SR:
        {
            /* only set the SR bit, everything else is off by default */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + reg_offset,     0x0001);

            /* set spare1[0] = 1 to speed up locking in SR mode */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE1_LSB + reg_offset,      0x0001);
            
            /* power down is set differently from the scripts since spare12 is also different */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,  0x0065);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_MSB + reg_offset,  0x0000);
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR + reg_offset,   0x0003);
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,       0x0099);
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + reg_offset,  0x0004);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + reg_offset,   0x0441);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + reg_offset,  0xDFFF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + reg_offset,  0x000D);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL + reg_offset,    0x001E);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN + reg_offset,         0x0000);

            /* function number set to 1 for SR only */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0 + reg_offset,         0x0001);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1 + reg_offset,         0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR + reg_offset,         0x800E);
            
            /* apply pre-equalizer settings */
            status |= cs4224_update_pre_equalizer(slice, reg_offset, traceloss);

            break;
        }

        case CS_HSIO_EDC_MODE_CX1:
        case CS_HSIO_EDC_MODE_SMLRM:
        {
            /* differs from script, don't enable power savings or auto squelch by default */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + reg_offset,      0x0B00);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + reg_offset,      0x0C09);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x001F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,        0x0099);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + reg_offset,   0x0005); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + reg_offset,   0x8F00); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + reg_offset,   0x000c); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x0000); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + reg_offset,    0x0008); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + reg_offset,    0x000B); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR + reg_offset,    0x0000); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_LSB + reg_offset,       0x00FF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_MSB + reg_offset,       0x0030);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_LSB + reg_offset,       0x000F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB + reg_offset,       0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_LSB + reg_offset,       0x2350);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_MSB + reg_offset,       0x1650);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_MSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_LSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_MSB + reg_offset,      0x07FF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_LSB + reg_offset,      0xFFFE);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_LSB + reg_offset,       0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_MSB + reg_offset,       0x0030);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_FLOAT + reg_offset,   0x8001);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB + reg_offset,       0x001D);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_MSB + reg_offset,       0x000A);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB + reg_offset,       0x3000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_MSB + reg_offset,       0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG4 + reg_offset,   0x85f0);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset,      0x000A);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE0_1 + reg_offset,             0x00F0);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE1_1 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE2_1 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE3_1 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE4_1 + reg_offset,             0x0000);

            /* Read efuse data (POLY_RES_CAL_DATAx) and configure itune/rtune settings */
            if (intf == CS4224_DPLX_LINE_MSEQ)
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_LINE_SIDE);
            }
            else
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_HOST_SIDE);
            }

            if (mode == CS_HSIO_EDC_MODE_CX1)
            {
                /* the following sets the data slicer offset. 0x80 for CX1, 0x90 for ZR, DWDM TBD */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + reg_offset, 0x0080);
                /* max PHASE_SELECT+1 */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,   0x0023);
            }
            else
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + reg_offset, 0x0040);
                /* max PHASE_SELECT+1 */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,   0x0020);
            }
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE + reg_offset,     0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2 + reg_offset,   0x0000);

            break;
        }

        case CS_HSIO_EDC_MODE_DWDM:
        case CS_HSIO_EDC_MODE_ZR:
        {
            /* differs from script, don't enable power savings or auto squelch by default */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + reg_offset,      0x0B00);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x001F); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,        0x00BB); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + reg_offset,   0x0005); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + reg_offset,   0x8F00); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + reg_offset,   0x000c); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x0000); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + reg_offset,    0x0008); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + reg_offset,    0x000B);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR + reg_offset,    0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_LSB + reg_offset,       0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_MSB + reg_offset,       0x0005);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_LSB + reg_offset,       0x000F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB + reg_offset,       0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_LSB + reg_offset,       0x2250);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_MSB + reg_offset,       0x1B50);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_MSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_LSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_MSB + reg_offset,      0x07FF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_LSB + reg_offset,      0xFFFE);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB + reg_offset,       0x0024);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_MSB + reg_offset,       0x0007);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_LSB + reg_offset,       0x0014);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_MSB + reg_offset,       0x0020);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_FLOAT + reg_offset,   0x8001);
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,      0x0027);
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB + reg_offset,       0x3000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_MSB + reg_offset,       0x0000); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_MSB + reg_offset,      0x0000); 

            /* the following sets the data slicer offset. 0x80 for CX1, 0x90 for ZR, DWDM 0x9a */
            if (mode == CS_HSIO_EDC_MODE_DWDM)
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + reg_offset,0x0096);
            }
            else
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + reg_offset,0x008C);
            }
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + reg_offset,      0x2009);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE0_1 + reg_offset,             0x00F0);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE1_1 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE2_1 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE3_1 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE4_1 + reg_offset,             0x0000);

            /* Read efuse data (POLY_RES_CAL_DATAx) and configure itune/rtune settings */
            if (intf == CS4224_DPLX_LINE_MSEQ)
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_LINE_SIDE);
            }
            else
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_HOST_SIDE);
            }

            break;
        }
        case CS_HSIO_EDC_MODE_10G_BP:
        {
            /* differs from script, don't enable power savings or auto squelch by default */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + reg_offset,      0x0B00);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + reg_offset,      0x0C09);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x001F); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,        0x0099); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + reg_offset,   0x0005); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + reg_offset,   0x8F00); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + reg_offset,   0x000c); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x0000); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + reg_offset,    0x0008);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + reg_offset,    0x000B);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR + reg_offset,    0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_LSB + reg_offset,       0x00FF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_MSB + reg_offset,       0x0030);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_LSB + reg_offset,       0x000F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB + reg_offset,       0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_LSB + reg_offset,       0x2350);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_MSB + reg_offset,       0x1B50);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_MSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_LSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_MSB + reg_offset,      0x007F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_LSB + reg_offset,      0xFFFE);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_LSB + reg_offset,       0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_MSB + reg_offset,       0x0030);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_FLOAT + reg_offset,   0x8001);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB + reg_offset,       0x001D);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_MSB + reg_offset,       0x000A);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB + reg_offset,       0x2500);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_MSB + reg_offset,       0x0000);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset,      0x000A);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,      0x0023);

            /* the following sets the data slicer offset. 0x80 for CX1, 0x90 for ZR, DWDM TBD */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + reg_offset,    0x0080);

            /* Read efuse data (POLY_RES_CAL_DATAx) and configure itune/rtune settings */
            if (intf == CS4224_DPLX_LINE_MSEQ)
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_LINE_SIDE);
            }
            else
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_HOST_SIDE);
            }

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE + reg_offset,     0x0000);

            break;
        }
        case CS_HSIO_EDC_MODE_15G_BP:
        case CS_HSIO_EDC_MODE_15G_BP_27dB:
        {
            /* differs from script, don't enable power savings or auto squelch by default */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + reg_offset,      0x0600);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + reg_offset,      0x000B);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x001F);
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,        0x00AA);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + reg_offset,   0x0005);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + reg_offset,   0x8F00);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + reg_offset,   0x000c);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + reg_offset,    0x0008);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + reg_offset,    0x000B);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR + reg_offset,    0x0000);

            if (mode == CS_HSIO_EDC_MODE_15G_BP_27dB)
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_LSB + reg_offset,   0x00FF);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB + reg_offset,   0x001C);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_MSB + reg_offset,   0x000F);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset,  0x0000);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,  0x0027);
            } 
            else
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_LSB + reg_offset,   0x00FB);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB + reg_offset,   0x001A);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_MSB + reg_offset,   0x000F);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset,  0x0000);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,  0x0023);
            }
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_MSB + reg_offset,       0x0030);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_LSB + reg_offset,       0x000F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB + reg_offset,       0x0000);

            if (mode == CS_HSIO_EDC_MODE_15G_BP_27dB)
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_LSB + reg_offset,   0x2650);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_MSB + reg_offset,   0x1800);
            }
            else
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_LSB + reg_offset,   0x8250);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_MSB + reg_offset,   0x5000);
            }
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_MSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_LSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_MSB + reg_offset,      0x807F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_LSB + reg_offset,      0xFFFE);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_LSB + reg_offset,       0x0005);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_MSB + reg_offset,       0x0025);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_FLOAT + reg_offset,   0x8003);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB + reg_offset,       0x2500);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_MSB + reg_offset,       0x0000);
            
            
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE0_1 + reg_offset,             0x00E0);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE1_1 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE2_1 + reg_offset,             0x001E);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE3_1 + reg_offset,             0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE4_1 + reg_offset,             0x0010);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE0_0 + reg_offset,             0x00D0);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE1_0 + reg_offset,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE2_0 + reg_offset,             0x002E);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE3_0 + reg_offset,             0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_IC_DFE4_0 + reg_offset,             0x0010);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_BIAS1 + reg_offset,     0xFF55);    

            /* the following sets the data slicer offset. 0x90 for ZR. DWDM TBD */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + reg_offset,    0x0080);

            /* Read efuse data (POLY_RES_CAL_DATAx) and configure itune/rtune settings */
            if (intf == CS4224_DPLX_LINE_MSEQ)
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_LINE_SIDE);
            }
            else
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_HOST_SIDE);
            }

            /* the value for the dfe i/rtune should not be based on the E-Fuse setting */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + reg_offset,    0x1F70);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE + reg_offset,     0x0000);

            break;
        }
        case CS_HSIO_EDC_MODE_5G_BP:
        case CS_HSIO_EDC_MODE_7p5G_BP:
        case CS_HSIO_EDC_MODE_8p5G_BP:
        {
            if ((CS_HSIO_EDC_MODE_5G_BP == mode) || (CS_HSIO_EDC_MODE_7p5G_BP == mode))
            {
                /* slightly different from the 8p5G_BP modes */
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset,  0x0000);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,  0x0020);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB + reg_offset,   0x001f);
            }
            else
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_LSB + reg_offset,  0x0000);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE21_MSB + reg_offset,  0x0024);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB + reg_offset,   0x001C);
            }
            /* differs from script, don't enable power savings or auto squelch by default */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + reg_offset,      0x0B00);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + reg_offset,      0x0009);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x001F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,        0x0099); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1 + reg_offset,   0x0005); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + reg_offset,   0x8F00); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + reg_offset,   0x000C);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ1 + reg_offset,    0x0008); 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_EQADJ2 + reg_offset,    0x000B);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR + reg_offset,    0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_LSB + reg_offset,       0x00FF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE9_MSB + reg_offset,       0x0030);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_LSB + reg_offset,       0x000F);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB + reg_offset,       0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_LSB + reg_offset,       0x2250);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE2_MSB + reg_offset,       0x1B50);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_MSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE18_LSB + reg_offset,      0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_MSB + reg_offset,      0x07FF);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE11_LSB + reg_offset,      0xFFFE);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_LSB + reg_offset,       0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE7_MSB + reg_offset,       0x0030);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_COEF_DSP_FLOAT + reg_offset,   0x8001);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_MSB + reg_offset,       0x0007);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB + reg_offset,       0x2500);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_MSB + reg_offset,       0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE13_LSB + reg_offset,      0x0008);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE13_MSB + reg_offset,      0x0000);

            /* the following sets the data slicer offset. 0x80 for CX1, 0x90 for ZR, DWDM TBD */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_SLICER + reg_offset,    0x0080);

            /* Read efuse data (POLY_RES_CAL_DATAx) and configure itune/rtune settings */
            if (intf == CS4224_DPLX_LINE_MSEQ)
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_LINE_SIDE);
            }
            else
            {
                status |= cs4224_pgm_reg_from_efuse(slice, CS4224_CFG_HOST_SIDE);
            }

            /* the value for the dfe i/rtune should not be based on the E-Fuse setting */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG + reg_offset,    0x1B30);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE + reg_offset,     0x0000);

            break;
        }
        case CS_HSIO_EDC_MODE_DISABLED:
        {
            /* un-rail the driver charge pump current */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,        0x0099);

            /* power everything up */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x001f);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset,   0x0000);

            /* un-squelch the driver */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH - reg_offset,       0x0000);

            /* apply pre-equalizer settings */
            status |= cs4224_update_pre_equalizer(slice, reg_offset, traceloss);

            break;
        }
        default:
        {
            status |= cs4224_save_edc_mode(slice, reg_offset, CS_HSIO_EDC_MODE_DISABLED); 

            CS_TRACE(("ERROR: Invalid application mode. Application = %d\n", mode));
            status |= CS_ERROR;
            return status;
        }
    }

    /* if the ring oscillator VCO is used, override some of these values */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + reg_offset, &reg_data);
    if (reg_data & CS_BIT7)
    {
        /* the ring oscillator requires the charge pump to be set to 0x44 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset,            0x0044);

        /* when using the ring oscillator, override srx_cml_rtune=0, srx_vco_itune=2 and srx_cml_itune=0 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE + reg_offset,     0x0020);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE + reg_offset,     0);
    }

    /* although not ideal, the OC12 special rate needs some extra configuration */
    if(rules->application == CS4224_TARGET_APPLICATION_OC12)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES + reg_offset, &reg_data);
        reg_data &= ~0xf0; /* reset SRX_FILTR */
        reg_data |= 0xf0;  /* set SRX_FILTR */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES + reg_offset, reg_data);
        
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset, 0xDD);
    }
    if(rules->application == CS4224_TARGET_APPLICATION_1G)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA + reg_offset, 0xDD);
    }

    if(rules->advanced.phsel_bypass)
    {
        status |= cs4224_diags_set_phsel_mseq(slice, intf, rules->advanced.phsel_bypass_value);
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * Set the EDC mode for the application.
 *
 * @param slice    [I] - The slice of the device to set the mode for
 * @param rules    [I] - The rules for configuring the device.
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_init_edc_mode_set(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    if (cs4224_is_hw_simplex(slice))
    {
        status |= cs4224_init_edc_mode_intf(slice, rules, CS4224_SPLX_MSEQ);
    }
    else if (cs4224_is_hw_duplex(slice))
    {
        if (rules->application != CS4224_TARGET_APPLICATION_FCAN)
        {
            /* the FC-AN ucode configures the line side DFE mode, don't do it here... */
            status |= cs4224_init_edc_mode_intf(slice, rules, CS4224_DPLX_LINE_MSEQ);
        }
        status |= cs4224_init_edc_mode_intf(slice, rules, CS4224_DPLX_HOST_MSEQ);
    }
    else
    {
        /* error in the API checks for SKU... */
        CS_TRACE(("ERROR: init_edc_mode_set: unknown hardware id"));
        return CS_ERROR;
    }

    return status;
}

/**
 * This method will return the approx VCO rate (close enough anyways)
 * 
 * @since 3.6
 * 
 * @param rules [I] - The rules for configuring the device.
 * 
 * @return VCO rate in kHz
 * 
 * @private
 */
cs_uint32 cs4224_query_vco_rate(
    const cs4224_rules_t* rules)
{
    /* ref_clk_rate is in KHz */
    cs_uint32 ref_clk_rate = 0;
    /* rdiv from clkdiv rules */
    cs_uint32 rdiv = 0;
    /* calculated (approx) vco rate */
    cs_uint32 vco_rate = 0;
    
#if defined(CS_HAS_FLOATING_POINT)
    /* if we're using floating point then the ref_clk is in MHz, multiply up to get KHz
     * and scrap the decimal */
    ref_clk_rate = rules->ref_clk_rate * 1000;
#else
    /* if we're not using floating point, then ref_clk_rate is already in KHz */
    ref_clk_rate = rules->ref_clk_rate;
#endif
    
    /* decode clkdiv.rdiv for use in the calc */
    switch(rules->clkdiv.rdiv)
    {
        case CS4224_RDIV_DIV64:
            rdiv = 64;
            break;
        case CS4224_RDIV_DIV66:
            rdiv = 66;
            break;
        case CS4224_RDIV_DIV80:
            rdiv = 80;
            break;
        case CS4224_RDIV_DIV100:
            rdiv = 100;
            break;
        case CS4224_RDIV_DIV128:
            rdiv = 128;
            break;
        default:
            /* doesn't matter then, we might be out of range or using the FRACn */
            rdiv = 0;
            break;
    }
    
    if(rules->clkdiv.enable)
    {
        /* we're just trying to find the VCO rate, not the data-rate, so ignore ddiv */
        vco_rate = ref_clk_rate * rdiv;
    }
    
    /* if using the clkdiv (for ddiv) AND the fracn, then this if statement must
     * come last */
    if(rules->fracdiv.enable)
    {
        cs_uint64 frac_part = (cs_uint64)(ref_clk_rate) * (rules->fracdiv.numerator);
        /* decimate the 'fractional' part, left with int KHz */
        frac_part = frac_part >> 21;
        vco_rate = (ref_clk_rate * 8 * rules->fracdiv.divisor) + (cs_uint32)frac_part;
    }
    /* CS_TRACE(("VCO rate: %u\n",vco_rate)); */
    return vco_rate;
}

/**
 * This method will return the approx data-rate (close enough anyways)
 * 
 * NOTE: Should work but currently un-tested, more for debugging than anything
 * 
 * @since 3.6
 * 
 * @param rules [I] - The rules for configuring the device.
 * 
 * @return Data rate in kHz
 * 
 * @private
 */
cs_uint32 cs4224_query_data_rate(
    const cs4224_rules_t* rules)
{
    cs_uint32 vco_rate = cs4224_query_vco_rate(rules);
    cs_uint32 data_rate = vco_rate;
    
    if(rules->clkdiv.enable)
    {
        switch(rules->clkdiv.ddiv)
        {
            case CS4224_RULE_DISABLED:
                /* not sure how this happened, but ignore it */
                break;
            default:
                /* shift by the enum, since the divide amount == 2**(enum) */
                data_rate = vco_rate >> (cs_uint16)(rules->clkdiv.ddiv);
                break;
        }
    }
    return data_rate;
}

/**
 * This method will return true if the VCO (NOT the datarate) from rules is 
 * approximately 11.3 to 12.5Gbps. This is to determine whether we force the low LC VCO
 * or not.
 * 
 * @since 3.6
 *
 * @param rules [I] - The rules for configuring the device.
 *
 * @return TRUE if VCO freq is approx 11.3 to 12.5G, FALSE otherwise
 *
 * @private
 *
 */
cs_boolean cs4224_need_low_lc_vco(
    const cs4224_rules_t* rules)
{
    cs_uint32 vco_rate = cs4224_query_vco_rate(rules);
    
    /* the 'real' range is 11.3G to 12.5G, but we'll fudge it a bit in case our
     * fracn calcs have some rounding errors */
    if((vco_rate >= 11280000) && (vco_rate <= 12520000))
    {
        return TRUE;
    }
    
    return FALSE;
}

/**
 * Force usage of the low LC VCO on a particular interface.
 * Low LC VCO has the lowest jitter for rates 11.3G to 12.5G (and their sub-rates)
 * 
 * @since 3.6 
 * 
 * @param slice        [I] - Slice to use
 * @param intf         [I] - line or host dir, cannot be simplex
 * @param force_enable [I] - True to force, false to not force (revert to default)
 * 
 * @return CS_OK on success, CS_ERROR otherwise
 * 
 * @private
 */
cs_status cs4224_force_low_lc_vco_intf(
    cs_uint32 slice,
    e_cs4224_datapath_dir_t intf,
    cs_boolean force_enable)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;
    
    if(CS4224_LINE_RX_TO_HOST_TX_DIR == intf)
    {
        offset = 0;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }
    
    if(force_enable)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_LIMIT_HI+offset, 0x40);
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_LIMIT_HI+offset, CS4224_PP_LINE_SDS_COMMON_RXVCO0_ALTCT_LIMIT_HI_dft);
    }
    
    return status;
}

/**
 * Force usage of the low LC VCO and then re-init the VCO
 * Low LC VCO has the lowest jitter for rates 11.3G to 12.5G (and their sub-rates)
 * 
 * @since 3.6 
 * 
 * @param slice        [I] - Slice to use
 * @param force_enable [I] - True to force, false to not force (revert to default)
 * 
 * @return CS_OK on success, CS_ERROR otherwise
 * 
 * @private
 * 
 * @example
 * for(slice=0; slice<CS4224_MAX_NUM_SLICES(0); slice++) {
 *     status |= cs4224_force_and_init_low_lc_vco(slice, TRUE);
 *     if(CS_OK != status) break;
 * }
 * 
 */
cs_status cs4224_force_and_init_low_lc_vco(
    cs_uint32 slice,
    cs_boolean force_enable)
{
    cs_status status = CS_OK;
    
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_force_low_lc_vco_intf(slice, CS4224_LINE_RX_TO_HOST_TX_DIR, force_enable);
        status |= cs4224_init_vco(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_CONTROL);
    }

    if(cs4224_is_hw_duplex(slice) || (!cs4224_line_rx_to_host_tx_dir(slice)))
    {
        status |= cs4224_force_low_lc_vco_intf(slice, CS4224_HOST_RX_TO_LINE_TX_DIR, force_enable);
        status |= cs4224_init_vco(slice, CS4224_PP_HOST_SDS_COMMON_RXVCO0_CONTROL);
    }
    
    return status;
}

/**
 * Just force usage of the low LC VCO, don't re-initialize the VCO
 * Low LC VCO has the lowest jitter for rates 11.3G to 12.5G (and their sub-rates)
 * 
 * @since 3.6 
 * 
 * @param slice        [I] - Slice to use
 * @param force_enable [I] - True to force, false to not force (revert to default)
 * 
 * @return CS_OK on success, CS_ERROR otherwise
 * 
 * @private
 */
cs_status cs4224_force_low_lc_vco(
    cs_uint32 slice,
    cs_boolean force_enable)
{
    cs_status status = CS_OK;
    
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_force_low_lc_vco_intf(slice, CS4224_LINE_RX_TO_HOST_TX_DIR, force_enable);
    }

    if(cs4224_is_hw_duplex(slice) || (!cs4224_line_rx_to_host_tx_dir(slice)))
    {
        status |= cs4224_force_low_lc_vco_intf(slice, CS4224_HOST_RX_TO_LINE_TX_DIR, force_enable);
    }
    
    return status;
}

/**
 * Setup the Alternate Coarse Tuning mode for the application.
 *
 * @param slice    [I] - The slice of the device to set the mode for
 * @param rules    [I] - The rules for configuring the device.
 * @param intf     [I] - The interface/side of the device.
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_init_alt_coarse_tuning_intf(
    cs_uint32       slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data = 0;
    cs_uint16 offset = 0x0000;
    /* flag to say whether we should force the low lc vco or not */
    cs_boolean force_low_lc_vco = FALSE;

    status |= cs4224_get_cfg_side(slice, &intf);
    if(CS_OK != status)
    {
        return status;
    }
    
    cs4224_lock(slice);

    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else if (intf == CS4224_CFG_HOST_SIDE)
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }
    else
    {
        CS_TRACE(("ERROR: Invalid interface. intf=%d\n",intf));
        return CS_ERROR;
    }
    
    /* level 4d00 is approx 77 deg C */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPLVL3 + offset,    0x4d00);
    /* level 4100 is approx 65 deg C */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPLVL2 + offset,    0x4100);
    /* level 3900 is approx 30 deg C */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPLVL1 + offset,    0x3900);
    /* level 2d00 is approx 0 deg C */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_TMPLVL0 + offset,    0x2d00);
    
    /* ring oscillator config reg */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + offset, &reg_data);
    
    if (reg_data & CS_BIT7)
    {
        /* if the 8G ring oscillator VCO is used */
        status |= cs4224_init_ro_vco_tmp_thresh(slice, intf);
    }
    else
    {
        /* the LC VCO */
        status |= cs4224_init_lc_vco_tmp_thresh(slice, intf);
        
        /* determine if we need to force the low LC VCO */
        force_low_lc_vco = cs4224_need_low_lc_vco(rules);
    }
    
    status |= cs4224_force_low_lc_vco(slice, force_low_lc_vco);

    cs4224_unlock(slice);

    return status;
}

/**
 * Setup the Alternate Coarse Tuning mode for the application.
 *
 * @param slice    [I] - The slice of the device to set the mode for
 * @param rules    [I] - The rules for configuring the device.
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_init_alt_coarse_tuning(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_init_alt_coarse_tuning_intf(slice, CS4224_CFG_LINE_SIDE, rules);
    }
    if(cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_init_alt_coarse_tuning_intf(slice, CS4224_CFG_HOST_SIDE, rules);
    }

    return status;
}

/**
 * Disables the line/host Tx driver, if requested
 *
 * @param slice    [I] - The slice of the device to access.
 * @param rules    [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_disable_tx_driver_if_req(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    cs4224_lock(slice);

    /* Disable the transmitters if requested */
    if (cs4224_is_hw_simplex(slice))
    {
        if(rules->tx_if.splx_disable == TRUE)
        {
            if (cs4224_line_rx_to_host_tx_dir(slice))
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, 0x0800);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, 0);
            }
            else
            {
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, 0x0800);
                status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, 0);
            }
        }
    }
    else /* duplex */
    {
        if(rules->tx_if.dplx_line_disable == TRUE)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, 0x0800);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, 0);
        }
        if(rules->tx_if.dplx_host_disable == TRUE)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, 0x0800);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, 0);
        }
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * Converts the traceloss parameter into ctrla/b values for the driver settings,
 * and applies those default settings.
 * 
 * These settings provide example configurations of the trace loss
 * measured on the eval board in the Cortina lab. The settings used
 * may not match the TX calculator spreadsheet settings on CCS
 * but are within an acceptable range of tolerence.
 *
 * These are default settings and generally must be tuned for
 * a customers application.
 *
 * @param slice    [I] - The slice of the device to access.
 * @param intf     [I] - The interface/direction of the device, can only be line or host
 * @param rules    [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_driver_trace_loss_intf(
    cs_uint32       slice,
    e_cs4224_datapath_dir_t intf,
    e_cs4224_trace_loss trace_loss)
{
    cs_status status = CS_OK;
    cs_uint16 ctrla = 0;
    cs_uint16 ctrlb = 0;
    e_cs4224_tx_driver_interface driver;
    
    if(intf == CS4224_LINE_RX_TO_HOST_TX_DIR)
    {
        driver = CS4224_TX_HOST_INTERFACE;
    }
    else if(intf == CS4224_HOST_RX_TO_LINE_TX_DIR)
    {
        driver = CS4224_TX_LINE_INTERFACE;
    }
    else
    {
        CS_TRACE(("ERROR: intf must be line or host, not simplex\n"));
        return CS_ERROR;
    }
    
    switch(trace_loss)
    {
        case CS_HSIO_TRACE_LOSS_0dB:
        case CS_HSIO_TRACE_LOSS_1dB:
        {
            ctrla = 0x814; ctrlb = 0x4;
            break;
        }
        case CS_HSIO_TRACE_LOSS_2dB:
        {
            ctrla = 0x3810; ctrlb = 0x5;
            break;
        }
        case CS_HSIO_TRACE_LOSS_3dB:
        {
            ctrla = 0x4818; ctrlb = 0x9;
            break;
        }
        case CS_HSIO_TRACE_LOSS_4dB:
        {
            ctrla = 0x4818; ctrlb = 0xb;
            break;
        }
        case CS_HSIO_TRACE_LOSS_5dB:
        {
            ctrla = 0x4818; ctrlb = 0xd;
            break;
        }
        case CS_HSIO_TRACE_LOSS_6dB:
        {
            ctrla = 0x4818; ctrlb = 0xe;
            break;
        }
        case CS_HSIO_TRACE_LOSS_15dB:
        {
            ctrla = 0x782B; ctrlb = 0x4;
            break;
        }
        case CS_HSIO_TRACE_LOSS_27dB:
        {
            ctrla = 0x7828; ctrlb = 0x80A;
            break;
        }
        case CS_HSIO_TRACE_LOSS_CR4:
        {
            ctrla = 0x5827; ctrlb = 0x6;
            break;
        }
        case CS_HSIO_TRACE_LOSS_LAB:
        {
            ctrla = 0x0813; ctrlb = 0x1;
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Unsupported trace loss setting %d\n", trace_loss));
            return CS_ERROR;
        }
    }
    
    status |= cs4224_init_driver_settings(slice, driver, ctrla, ctrlb);
    
    return status; 
}

/**
 * Initializes the the microsequencer triggered dynamic reconfig
 * feature. This feature is turned on with the mseq_dyn_reconfig
 * rule (default is False). Setting this rule to True allows the microprecessor
 * to trigger a data-rate, DFE mode or trace-loss settings
 * change by writing to SPARE registers. 
 *
 * @param slice    [I] - The slice of the device to access.
 * @param offset   [I] - The register offset 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_mseq_dyn_reconfig_intf(
    cs_uint32  slice,
    cs_uint16  offset)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data;

    /* SPARE12[30] tells the DFE mission mode code mseq_dyn_reconfig is being used and to
     * back to the mseq_dyn_reconfig code once each mission mode loop is done.
     */   
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + offset, &reg_data);
    reg_data |= 0x4000;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB + offset, reg_data);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_MSB + offset, 0x4000);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE24_MSB + offset, 0x4000);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_MSB + offset, 0x801e);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB + offset,  0x0d80);

    return status;
}

/**
 * Initializes the the microsequencer triggered dynamic reconfig feature. This feature is 
 * turned on with the mseq_dyn_reconfig rule (default is False). Setting this rule to True 
 * allows the microprocessor to trigger a data-rate, DFE mode or trace-loss settings
 * change by writing to SPARE registers. 
 *
 * IMPORTANT NOTE: 
 * This feature is not compatible with KRAN or FCAN applications. Also, this feature is 
 * only available when the microsequencer is running KR microcode. The FC microcode is 
 * loaded only when the FCAN application is selected. The KR microcode is loaded by default. 
 *
 * Not compatible with simplex devices.
 * 
 * The SPARE registers involved are:
 *
 * - SPARE22_MSB[15]: 
 *      '1' indicates 1.25 Gbps is desired, '0' then 10.3125 Gbps is desired. 
 *      SPARE24_LSB[0] needs to be asserted to trigger any change to the interface.
 *
 * - SPARE24_LSB[15:0]: 
 *      The DAC, SR, ZR or DWDM DFE mode and trace-loss settings encoding is 
 *      exactly the same as for the KR image.
 *      SPARE24_LSB[0]     Asserted to trigger any change to the interface.
 *      SPARE24_LSB[0]     Cleared by the microcode.
 *      SPARE24_LSB[5:1]   (Tech): 00010 is CX1, 00100 is SR, 01000 is ZR and 10000 is DWDM.
 *      SPARE24_LSB[10:8]  (Rx Loss): Rx trace loss in dB from 0 to 6 inclusive in 1 dB steps, 
 *                         see bit 11 for usage.
 *      SPARE24_LSB[11]    1 = Apply receiver trace loss specified in bits 10..8; 0b = use 2 dB 
 *                         regardless of bits 10..8.
 *      SPARE24_LSB[15:12] (Tx Loss): Tx trace loss in dB from 0.5 to 6.0 inclusive in 0.5 dB steps, 
 *                          0000b is special. The encoding is:
 *          0000b indicates transmitter should not be adjusted.
 *          0001b = 0.5 dB
 *          0010b = 1.0 dB
 *          0011b = 1.5 dB
 *          ...
 *          1011b = 5.5 dB
 *          1100b = 6.0 dB
 *          1101..1111 are reserved, do not use
 *
 * @param slice    [I] - The slice of the device to access.
 * @param rules    [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_mseq_dyn_reconfig(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data;

    if (rules->mseq_dyn_reconfig == TRUE)
    {
        /* The mseq_dyn_reconfig feature is not compatible with the FC microcode */
        status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_VERSION_KR, &reg_data);
        if (reg_data == 0)
        {
            CS_TRACE(("ERROR: The mseq_dyn_reconfig feature requires KR microcode\n"));
            return CS_ERROR;
        }
        if ((rules->application == CS4224_TARGET_APPLICATION_KRAN) ||
            (rules->application == CS4224_TARGET_APPLICATION_FCAN))
        {
            CS_TRACE(("ERROR: The mseq_dyn_reconfig feature not compatible with KRAN and FCAN applications\n"));
            return CS_ERROR;
        }

        status |= cs4224_init_mseq_dyn_reconfig_intf(slice, 0);
        status |= cs4224_init_mseq_dyn_reconfig_intf(slice, CS4224_LINE_TO_HOST_OFFSET);

    }

    return status;
}

/**
 * Initializes the line/host Tx driver trace loss settings. These
 * settings provide example configurations of the trace loss
 * measured on the eval board in the Cortina lab. The settings used
 * may not match the TX calculator spreadsheet settings on CCS
 * but are within an acceptable range of tolerence.
 *
 * These are default settings and generally must be tuned for
 * a customers application.
 *
 * @param slice    [I] - The slice of the device to access.
 * @param rules    [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_init_driver_trace_loss(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status            status = CS_OK;
    e_cs4224_trace_loss  host_traceloss, line_traceloss;

    if (cs4224_is_hw_simplex(slice))
    {
        host_traceloss = rules->tx_if.splx_driver.traceloss;
        line_traceloss = rules->tx_if.splx_driver.traceloss;
    }
    else
    {
        host_traceloss = rules->tx_if.dplx_host_driver.traceloss;
        line_traceloss = rules->tx_if.dplx_line_driver.traceloss;
    }
    
    if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_init_driver_trace_loss_intf(slice, CS4224_LINE_RX_TO_HOST_TX_DIR, host_traceloss);
    }

    if (cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_init_driver_trace_loss_intf(slice, CS4224_HOST_RX_TO_LINE_TX_DIR, line_traceloss);
    }

    return status; 
}

/**
 * Configures the Tx driver CTRLA/CTRLB settings
 * 
 * @param slice    [I] - The slice of the device to access.
 * @param intf     [I] - The Tx driver interface to configure
 * @param ctrla    [I] - The Tx driver ctrla settings
 * @param ctrlb    [I] - The Tx driver ctrlb settings
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_init_driver_settings(
    cs_uint32                    slice,
    e_cs4224_tx_driver_interface intf,
    cs_uint16                    ctrla,
    cs_uint16                    ctrlb)
{
    cs_status status = CS_OK;
    cs_uint16 offset = 0;

    if(cs4224_is_hw_simplex(slice) && intf == CS4224_TX_SIMPLEX_INTERFACE)
    {
        /* figure out which driver we need to change */
        if(cs4224_line_rx_to_host_tx_dir(slice))
        {
            intf = CS4224_TX_HOST_INTERFACE;
        }
        else
        {
            intf = CS4224_TX_LINE_INTERFACE;
        }
    }
    else if(intf == CS4224_TX_SIMPLEX_INTERFACE)
    {
        CS_TRACE(("ERROR: duplex slice cannot use intf = CS4224_TX_SIMPLEX_INTERFACE\n"));
        return CS_ERROR;
    }
    
    if(intf == CS4224_TX_HOST_INTERFACE)
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }
    else
    {
        offset = 0;
    }
    
    cs4224_lock(slice);
    
    /* update CTRLA/CTRLB registers */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA+offset, ctrla);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB+offset, ctrlb);
    
    cs4224_unlock(slice);

    return status; 
}

/**
 * This method will return true if the data rate from rules is significantly
 * less than 10G. This is really only used to turn off power savings.
 *
 * @param rules [I] - The rules for configuring the device.
 *
 * @return TRUE if data rate is less than 10G, FALSE otherwise
 *
 * @deprecated No longer relevant and not tested, so don't use this method
 * 
 * @private
 *
 */
cs_boolean cs4224_datarate_less_than_10G(
    cs4224_rules_t* rules)
{
    cs_uint32 data_rate = cs4224_query_data_rate(rules);
    
    if(data_rate < 10000000)
    {
        return TRUE;
    }
    
    return FALSE;
}

/**
 * See cs4224_update_clkdiv_ctrl
 *
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The interface to change (line/host/splx)
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_update_clkdiv_ctrl_intf(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data, old_data;
    cs_uint16 offset = 0;

    status |= cs4224_get_cfg_side(slice, &intf);
    if(CS_OK != status)
    {
        return status;
    }
    
    if (intf == CS4224_CFG_LINE_SIDE)
    {
        offset = 0x0000;
    }
    else
    {
        offset = CS4224_LINE_TO_HOST_OFFSET;
    }
    
    cs4224_lock(slice);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL + offset, &reg_data);
    old_data = reg_data;
    
    if (rules->clkdiv.enable)
    {
        if (rules->clkdiv.rdiv != CS4224_RULE_DISABLED) 
        {
            reg_data &= ~0x000f;
            reg_data |= rules->clkdiv.rdiv;
        }
        if (rules->clkdiv.ddiv != CS4224_RULE_DISABLED) 
        {
            reg_data &= ~0x0070;
            reg_data |= (rules->clkdiv.ddiv << 4);
        }
        if (rules->clkdiv.fastdiv != CS4224_RULE_DISABLED) 
        {
            reg_data &= ~0xf000;
            reg_data |= (rules->clkdiv.fastdiv << 12);
        }
    }
    else
    {
        /* Only time clkdiv rule is not enabled is when using the fracdiv without
         * any integer divide (so ~10G rates, etc). In that case reset it to defaults.
         * LINE dft == HOST dft
         */
        reg_data = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL_dft;
    }
    
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL + offset, reg_data);
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * This method configures the Serdes Clock Divider Control register, if required
 *
 * @param slice [I] - The slice number of the device
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_update_clkdiv_ctrl(
    cs_uint32 slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_update_clkdiv_ctrl_intf(slice, CS4224_CFG_LINE_SIDE, rules);
    }
    if(cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_update_clkdiv_ctrl_intf(slice, CS4224_CFG_HOST_SIDE, rules);
    }
    
    return status;
}

/**
 * This method is called to initialize the CDR Fractional Divider
 *
 * This method programs the CDR FracN block with a divisor and numerator passed
 * in as arguments. Prior to configuring the CDR FracN, the datapath must be 
 * programmed to tune to a specific data rate. The Rx VCO coarse tuner 
 * frequency is sub-divided by the FracN to match the reference clock.
 * 
 * @param slice          [I] - The slice or port of the device to initialize
 * @param dir            [I] - The direction of the datapath
 * @param divisor        [I] - The divisor
 * @param numerator      [I] - The numerator
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 * 
 */
cs_status cs4224_fracdiv_cdr_init(
    cs_uint32               slice,
    e_cs4224_datapath_dir_t dir,    
    cs_uint16               divisor,
    cs_uint32               numerator)
{
    cs_status status = CS_OK;
    cs_uint16 reg_data, old_data;

    cs_uint16 frac0_reset_addr;
    cs_uint16 clkdiv_ctrl_addr;
    cs_uint16 frac0_width_addr;
    cs_uint16 frac0_intdiv_addr;
    cs_uint16 frac0_numerator0_addr;
    cs_uint16 frac0_numerator1_addr;
    cs_uint16 frac0_stage1preload0_addr;
    cs_uint16 frac0_stage1preload1_addr;
    cs_uint16 frac0_dither_addr;
    cs_uint16 frac0_stage_en_addr;
    cs_uint16 frac0_power_down_addr;
    cs_uint16 mseq_options_addr;
    cs_uint16 mseq_options;      
    e_cs4224_mseq_id mseq_id;

    /* sides and datapath_dir are the same enum */
    status |= cs4224_get_cfg_side(slice, &dir);
    if(CS_OK != status)
    {
        return status;
    }
    
    if (CS4224_LINE_RX_TO_HOST_TX_DIR == dir)
    {
        frac0_reset_addr          = CS4224_PP_LINE_SDS_COMMON_FRAC0_RESET;
        clkdiv_ctrl_addr          = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
        frac0_width_addr          = CS4224_PP_LINE_SDS_COMMON_FRAC0_WIDTH;
        frac0_intdiv_addr         = CS4224_PP_LINE_SDS_COMMON_FRAC0_INTDIV;
        frac0_numerator0_addr     = CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_NUMERATOR0;
        frac0_numerator1_addr     = CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_NUMERATOR1;
        frac0_stage1preload0_addr = CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_STAGE1PRELOAD0;
        frac0_stage1preload1_addr = CS4224_PP_LINE_SDS_COMMON_RDIVFRAC0_STAGE1PRELOAD1;
        frac0_dither_addr         = CS4224_PP_LINE_SDS_COMMON_FRAC0_DITHER;
        frac0_stage_en_addr       = CS4224_PP_LINE_SDS_COMMON_FRAC0_STAGE_EN;
        frac0_power_down_addr     = CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_options_addr         = CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW;
        mseq_id                   = CS4224_DPLX_LINE_MSEQ;
    } 
    else
    {
        frac0_reset_addr          = CS4224_PP_HOST_SDS_COMMON_FRAC0_RESET;
        clkdiv_ctrl_addr          = CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL;
        frac0_width_addr          = CS4224_PP_HOST_SDS_COMMON_FRAC0_WIDTH;
        frac0_intdiv_addr         = CS4224_PP_HOST_SDS_COMMON_FRAC0_INTDIV;
        frac0_numerator0_addr     = CS4224_PP_HOST_SDS_COMMON_RDIVFRAC0_NUMERATOR0;
        frac0_numerator1_addr     = CS4224_PP_HOST_SDS_COMMON_RDIVFRAC0_NUMERATOR1;
        frac0_stage1preload0_addr = CS4224_PP_HOST_SDS_COMMON_RDIVFRAC0_STAGE1PRELOAD0;
        frac0_stage1preload1_addr = CS4224_PP_HOST_SDS_COMMON_RDIVFRAC0_STAGE1PRELOAD1;
        frac0_dither_addr         = CS4224_PP_HOST_SDS_COMMON_FRAC0_DITHER;
        frac0_stage_en_addr       = CS4224_PP_HOST_SDS_COMMON_FRAC0_STAGE_EN;
        frac0_power_down_addr     = CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB;
        mseq_options_addr         = CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW;
        mseq_id                   = CS4224_DPLX_HOST_MSEQ;
    }

    cs4224_lock(slice);

    /* find out if microsequencer is running */
    status |= cs4224_reg_get_channel(slice, mseq_options_addr, &mseq_options);

    /* if microsequencer is running */
    if (0 == (0x0008 & mseq_options)) 
    {
        /* stall the microsequencer */
        status |= cs4224_mseq_stall(slice, mseq_id, TRUE);
    }

    status |= cs4224_reg_get_channel(slice, frac0_power_down_addr, &reg_data);
    old_data = reg_data;
    reg_data &= ~0x0010; /* power-up FracN for configuration */
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, frac0_power_down_addr, reg_data);
    }

    status |= cs4224_reg_get_channel(slice, frac0_reset_addr, &reg_data);
    old_data = reg_data;
    reg_data &= ~0x0001; /* pull out of reset CDR fracn */
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, frac0_reset_addr, reg_data);
    }

    status |= cs4224_reg_get_channel(slice, clkdiv_ctrl_addr, &reg_data);
    old_data = reg_data;
    reg_data &= ~0x000f;
    reg_data |= 0x9; /* Set the RDIV_SEL field to Fractional-N */
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, clkdiv_ctrl_addr, reg_data);
    }

    status |= cs4224_reg_get_channel(slice, frac0_width_addr, &reg_data);
    old_data = reg_data;
    reg_data &= ~0x0003; /* Setup to use a 24 bit accumulator */
    reg_data |= CS4224_FRACDIV_ACCUM_WIDTH_24BIT;
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, frac0_width_addr, reg_data);
    }
    
    status |= cs4224_reg_get_channel(slice, frac0_intdiv_addr, &reg_data);
    old_data = reg_data;
    reg_data &= ~0x00ff;
    reg_data |= (divisor & 0xff);  /* Configure the denominator value */
    if(old_data != reg_data)
    {
        status |= cs4224_reg_set_channel(slice, frac0_intdiv_addr, reg_data);
    }

    /* Configure the numerator value */
    status |= cs4224_reg_set_channel(slice, frac0_numerator0_addr, numerator & 0xFFFF);
    status |= cs4224_reg_set_channel(slice, frac0_numerator1_addr, (numerator >> 16) & 0xFF);

    /* Configure the stage 1 preload value */
    status |= cs4224_reg_set_channel(slice, frac0_stage1preload0_addr, 0x5DC6);
    status |= cs4224_reg_set_channel(slice, frac0_stage1preload1_addr, 0x0034);

    status |= cs4224_reg_set_channel(slice, frac0_dither_addr, 0x0000);
    
    /* Enable stage1 only */
    status |= cs4224_reg_set_channel(slice, frac0_stage_en_addr, 0x0408);

    status |= cs4224_reg_get_channel(slice, frac0_reset_addr, &reg_data);
    reg_data |= 0x0001; /* reset CDR fracn */
    status |= cs4224_reg_set_channel(slice, frac0_reset_addr, reg_data);
    reg_data &= ~0x0001; /* pull out of reset CDR fracn */
    status |= cs4224_reg_set_channel(slice, frac0_reset_addr, reg_data);

    /* if microsequencer was running */
    if (0 == (0x0008 & mseq_options)) 
    {
        /* un-stall the microsequencer */
        status |= cs4224_mseq_stall(slice, mseq_id, FALSE);
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * This method configures the CDR Fractional-Divider, if required
 *
 * @param slice [I] - The slice number of the device
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_update_cdr_fracn(
    cs_uint32 slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    if (rules->fracdiv.enable)
    {
        /* enable the fractional divider */

        if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
        {
            status |= cs4224_fracdiv_cdr_init(slice, CS4224_LINE_RX_TO_HOST_TX_DIR, 
                                             rules->fracdiv.divisor, 
                                             rules->fracdiv.numerator);
        }

        if (cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
        {
            status |= cs4224_fracdiv_cdr_init(slice, CS4224_HOST_RX_TO_LINE_TX_DIR, 
                                             rules->fracdiv.divisor, 
                                             rules->fracdiv.numerator);
        }
    }
    /* clkdiv rdiv will control the use of the fracn, so we never have to reset 
     * the fracn settings as long as the clkdiv is re-programmed
     */

    return status;
}

/**
 * This method gets the FEC statistics
 *
 * @param slice     [I] - The slice number of the device
 * @param fec_stats [O] - The FEC statistics structure pointer
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_get_fec_stats(
    cs_uint32 slice, 
    cs4224_fec_stats_t* fec_stats)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    /* Before fetching the counters, trigger the capture of the FEC statistics. */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_CONTROL, 0x0001);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_KR_FEC_TX_STATS_CONTROL, 0x0001);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_CONTROL, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_KR_FEC_TX_STATS_CONTROL, 0x0000);

    /* accumulate the stats */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_TX_STATS_TX_BLK_TOTAL0, &data);
    fec_stats->tx_blk_total = data;
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_TX_STATS_TX_BLK_TOTAL1, &data);
    fec_stats->tx_blk_total += (data << 16);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BLK_TOTAL0, &data);
    fec_stats->rx_blk_total = data;
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BLK_TOTAL1, &data);
    fec_stats->rx_blk_total += (data << 16);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BLK_CORR0, &data);
    fec_stats->rx_blk_corr = data;
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BLK_CORR1, &data);
    fec_stats->rx_blk_corr += (data << 16);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BLK_UNCORR0, &data);
    fec_stats->rx_blk_uncorr = data;
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BLK_UNCORR1, &data);
    fec_stats->rx_blk_uncorr += (data << 16);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BIT_ZERO_ERRS0, &data);
    fec_stats->rx_zero_errs = data;
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BIT_ZERO_ERRS1, &data);
    fec_stats->rx_zero_errs += (data << 16);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BIT_ONE_ERRS0, &data);
    fec_stats->rx_one_errs = data;
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATS_RX_BIT_ONE_ERRS1, &data);
    fec_stats->rx_one_errs += (data << 16);

    return status;
}

/**
 * This method sets up the polarity inversion for a duplex/simplex slice.
 *
 * Below is a diagram showing the internal inversion points that can be configured.
 * 
 * @{pre,
 *           Line             Host
 *         +-----------------------+
 *         |                     C |
 *     Rx >+---+->--Analog--->-+-+-+> Tx ingress
 *         |   |               |   |
 *         |  A+->--Digital-->-+B  |
 *         |                       |
 *         |  E+-<--Digital--<-+D  |
 *         |   |               |   |
 *     Tx <+-+-+-<--Analog---<-+---+< Rx egress
 *         | F                     |
 *         +-----------------------+
 *              
 *                  Legend:
 *   - Ingress - line Rx to host Tx:
 *     - A: Digital Line Rx
 *     - B: Digital Host Tx
 *     - C: Analog  Host Tx
 *   - Egress - host Rx to line Tx:
 *     - D: Digital Host Rx
 *     - E: Digital Line Tx
 *     - F: Analog  Line Tx
 * }
 * 
 * The digital path has inversion points on the Rx and Tx to the digital block, 
 * however the analog path only has an invert on the Tx. As seen in the diagram,
 * the analog invert effects both the analog and digital Tx paths.
 * 
 * To understand how to use the inversion points, let's use the following diagram:
 * 
 * @{pre,
 *                        Line     Host
 *          +------+       +---------+       +------+
 *  ingress | Line |--X1-->| Cortina |--X2-->| Host |
 *   egress | ASIC |<-X4---|   EDC   |<-X3---| ASIC |
 *          +------+       +---------+       +------+
 * }
 * 
 * The possible external ingress inversion points are X1 and X2, the egress
 * inversion points are X3 and X4.
 * 
 * An inversion at either X1 or X3 are Rx inversion points (with respect to the
 * Cortina EDC). Many digial blocks (FEC, PCS frame locker, etc) require
 * the correct polarity, so an inversion at X1 or X3 must be corrected at the Rx
 * to the digial block. However the digital path isn't always being used, and it
 * can be difficult to determine when it will be used over the analog path.
 * Therefore, the easiest thing to do is to invert it at the Rx and Tx of the digial
 * path, as well as the Tx of the analog path. That way the signal will always
 * be inverted on the Tx of the Cortina EDC regardless of whether the digital or
 * analog path is used.
 * 
 * An inversion at either X2 or X4 are Tx inversion points (w.r.t the Cortina EDC).
 * This can be corrected either in the Rx of the external ASICs, or at the analog 
 * Tx of the Cortina EDC.
 * 
 * Below is a table explaining the different combinations and which inversion
 * points should be set.
 * 
 * @{pre,
 *    | X1 | X2 | X3 | X4 |   truth table:    X1 | X2 | ABC
 * ------------------------                    0    0
 *  A | 1  | 0  | 0  | 0  |                    0    1     C
 *  B | 1  | 0  | 0  | 0  |                    1    0   ABC
 *  C | 1  | 1  | 0  | 0  |                    1    1   AB
 *  D | 0  | 0  | 1  | 0  |                   
 *  E | 0  | 0  | 1  | 0  |                   
 *  F | 0  | 0  | 1  | 1  |                   
 * }
 * 
 * In terms of binary logic, AB = X1, C = X1 ^ X2
 *    
 * @param slice [I] - The slice number of the device
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 * // for inversion at X3
 * cs_uint16 inv_points = CS4224_LL_INV_DIGITAL_HOST_RX | CS4224_LL_INV_DIGITAL_LINE_TX \
 *                        CS4224_LL_INV_ANALOG_LINE_TX;
 * cs4224_config_polarity_inv_points(0, inv_points);
 *
 * @private
 */
cs_status cs4224_config_polarity_inv_points(
    cs_uint32 slice,
    cs_uint16 inv_points)
{
    /* A: Digital Line Rx
     * B: Digital Host Tx
     * C: Analog  Host Tx
     * D: Digital Host Rx
     * E: Digital Line Tx
     * F: Analog  Line Tx
     */
    cs_status status = CS_OK;
    cs_uint16 data = 0;
    
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, &data);
        if (inv_points & CS4224_LL_INV_DIGITAL_LINE_RX) /* A */
        {
            /*CS_TRACE(("A - Digital Line Rx Inversion\n"));*/
            data |= CS_BIT2;
        }
        else
        {
            data &= ~CS_BIT2;
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, data);
        
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config, &data);
        if (inv_points & CS4224_LL_INV_DIGITAL_HOST_TX) /* B */
        {
            /*CS_TRACE(("B - Digital Host Tx Inversion\n"));*/
            data |= CS_BIT2;
        }
        else
        {
            data &= ~CS_BIT2;
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config, data);
        
        /* yes, this register is correct... */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &data);
        if (inv_points & CS4224_LL_INV_ANALOG_HOST_TX) /* C */
        {
            /*CS_TRACE(("C - Analog Host Tx Inversion\n"));*/
            data |= CS_BIT11;
        }
        else
        {
            data &= ~CS_BIT11;
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, data);
    }
    
    if(cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config, &data);
        if (inv_points & CS4224_LL_INV_DIGITAL_HOST_RX) /* D */
        {
            /*CS_TRACE(("D - Digital Host Rx Inversion\n"));*/
            data |= CS_BIT2;
        }
        else
        {
            data &= ~CS_BIT2;
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config, data);
        
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config, &data);
        if (inv_points & CS4224_LL_INV_DIGITAL_LINE_TX) /* E */
        {
            /*CS_TRACE(("E - Digital Line Tx Inversion\n"));*/
            data |= CS_BIT2;
        }
        else
        {
            data &= ~CS_BIT2;
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config, data);
        
        /* yes, this register is correct... */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &data);
        if (inv_points & CS4224_LL_INV_ANALOG_LINE_TX) /* F */
        {
            /*CS_TRACE(("F - Analog Line Tx Inversion\n"));*/
            data |= CS_BIT11;
        }
        else
        {
            data &= ~CS_BIT11;
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, data);
    }
    
    return status;
}

/**
 * This method configures the polarity inversion for a particular slice
 * 
 * Consider the possible inversion points for a single slice below:
 * 
 * @{pre,
 *                        Line     Host
 *          +------+       +---------+       +------+
 *  ingress | Line |--X1-->| Cortina |--X2-->| Host |
 *   egress | ASIC |<-X4---|   EDC   |<-X3---| ASIC |
 *          +------+       +---------+       +------+
 * 
 *   X1: Line Rx
 *   X2: Host Tx
 *   X3: Host Rx
 *   X4: Line Tx
 * }
 * 
 * Multiple inversions can be OR'ed together to allow for any and all possible
 * inversion points.
 * 
 * @param slice [I] - The slice number of the device
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 * // for inversion at X3 and X4 on a duplex part
 * rules.polarity_inv = CS4224_POLARITY_INV_DPLX_HOST_RX | \
 *                      CS4224_POLARITY_INV_DPLX_LINE_TX;
 * cs4224_enable_polarity_inv(0, &rules);
 *
 */
cs_status cs4224_enable_polarity_inv(
    cs_uint32 slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    /* from the following truth table:
     * X1 | X2 | ABC
     *  0    0
     *  0    1     C
     *  1    0   ABC
     *  1    1   AB
     * 
     * A, Digital Line Rx
     * B, Digital Host Tx
     * C, Analog  Host Tx
     * D, Digital Host Rx
     * E, Digital Line Tx
     * F, Analog  Line Tx
     * 
     * AB = X1
     * C = X1 ^ X2
     * DE = X3
     * F = X3 ^ X4
     */
    cs_uint16 inv_points = CS4224_LL_INV_NONE;

    cs_boolean X1 = FALSE;
    cs_boolean X2 = FALSE;
    cs_boolean X3 = FALSE;
    cs_boolean X4 = FALSE;
    
    cs_boolean AB = FALSE;
    cs_boolean C  = FALSE;
    cs_boolean DE = FALSE;
    cs_boolean F  = FALSE;
    
    /* setup low-level polarity config */
    if(cs4224_is_hw_duplex(slice))
    {
        X1 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_DPLX_LINE_RX);
        X2 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_DPLX_HOST_TX);
        X3 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_DPLX_HOST_RX);
        X4 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_DPLX_LINE_TX);
    }
    else
    {
        /* only have one half of the truth table */
        if (cs4224_line_rx_to_host_tx_dir(slice))
        {
            /* ingress */
            X1 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_SPLX_RX);
            X2 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_SPLX_TX);
        }
        else
        {
            /* egress */
            X3 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_SPLX_RX);
            X4 = CS_IF_SET(rules->polarity_inv,CS4224_POLARITY_INV_SPLX_TX);
        }
    }
    
    AB = X1;
    C  = X1 ^ X2;
    DE = X3;
    F  = X3 ^ X4;
    
    if (AB)
    {
        inv_points |= CS4224_LL_INV_DIGITAL_LINE_RX | CS4224_LL_INV_DIGITAL_HOST_TX;
    }
    if (C)
    {
        inv_points |= CS4224_LL_INV_ANALOG_HOST_TX;
    }
    if (DE)
    {
        inv_points |= CS4224_LL_INV_DIGITAL_HOST_RX | CS4224_LL_INV_DIGITAL_LINE_TX;
    }
    if (F)
    {
        inv_points |= CS4224_LL_INV_ANALOG_LINE_TX;
    }
    status |= cs4224_config_polarity_inv_points(slice, inv_points);
    
    return status;
}

/**
 * This method gets the current polarity inversion state
 * 
 * @param slice      [I] - The slice being queried
 * @param inv_points [O] - inversion points defined via e_cs4224_ll_inv_t
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_query_polarity_inv(
    cs_uint32 slice,
    cs_uint16 *inv_points)
{
    cs_status status = CS_OK;
    cs_uint16 data = 0;
    *inv_points = CS4224_LL_INV_NONE;
    
    /* - Ingress - line Rx to host Tx:
     *   - A: Digital Line Rx
     *   - B: Digital Host Tx
     *   - C: Analog  Host Tx
     * - Egress - host Rx to line Tx:
     *   - D: Digital Host Rx
     *   - E: Digital Line Tx
     *   - F: Analog  Line Tx
     */
    
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, &data);
        if (data & CS_BIT2) /* A */
        {
            *inv_points |= CS4224_LL_INV_DIGITAL_LINE_RX;
        }
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config, &data);
        if (data & CS_BIT2) /* B */
        {
            *inv_points |= CS4224_LL_INV_DIGITAL_HOST_TX;
        }
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, &data);
        if (data & CS_BIT11) /* C */
        {
            *inv_points |= CS4224_LL_INV_ANALOG_HOST_TX;
        }
    }
    if(cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
            status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config, &data);
        if (data & CS_BIT2) /* D */
        {
            *inv_points |= CS4224_LL_INV_DIGITAL_HOST_RX;
        }
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config, &data);
        if (data & CS_BIT2) /* E */
        {
            *inv_points |= CS4224_LL_INV_DIGITAL_LINE_TX;
        }
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG, &data);
        if (data & CS_BIT11) /* F */
        {
            *inv_points |= CS4224_LL_INV_ANALOG_LINE_TX;
        }
    }
    
    return status;
}

/**
 * This method prints out the current polarity inversion state
 * 
 * @param slice      [I] - The slice being queried
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_debug_dump_polarity_inv(
    cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs_boolean set = FALSE;
    cs_uint16 inv_points = CS4224_LL_INV_NONE;
    
    
#if 0
    CS_PRINTF(("Duplex slice inversions map:\n"));
    CS_PRINTF(("                          \n \
     Line             Host                \n \
    +-----------------------+             \n \
    |                     C |             \n \
Rx >+---+->--Analog--->-+-+-+> Tx ingress \n \
    |   |               |   |             \n \
    |  A+->--Digital-->-+B  |             \n \
    |                       |             \n \
    |  E+-<--Digital--<-+D  |             \n \
    |   |               |   |             \n \
Tx <+-+-+-<--Analog---<-+---+< Rx egress  \n \
    | F                     |             \n \
    +-----------------------+             \n\n"));
#endif
    
    /* - Ingress - line Rx to host Tx:
     *   - A: Digital Line Rx
     *   - B: Digital Host Tx
     *   - C: Analog  Host Tx
     * - Egress - host Rx to line Tx:
     *   - D: Digital Host Rx
     *   - E: Digital Line Tx
     *   - F: Analog  Line Tx
     */
    
    status |= cs4224_query_polarity_inv(slice, &inv_points);
    
    CS_PRINTF(("Slice %x enabled inversions:\n",slice));
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        CS_PRINTF(("  Ingress - line Rx to host Tx:\n"));
        if (inv_points & CS4224_LL_INV_DIGITAL_LINE_RX) /* A */
        {
            CS_PRINTF(("    A - Digital Line Rx\n"));
            set = TRUE;
        }
        if (inv_points & CS4224_LL_INV_DIGITAL_HOST_TX) /* B */
        {
            CS_PRINTF(("    B - Digital Host Tx\n"));
            set = TRUE;
        }
        if (inv_points & CS4224_LL_INV_ANALOG_HOST_TX) /* C */
        {
            CS_PRINTF(("    C - Analog Host Tx\n"));
            set = TRUE;
        }
        if(!set)
        {
            CS_PRINTF(("    None\n"));
        }
    }
    set = FALSE;
    if(cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        CS_PRINTF(("  Egress - host Rx to line Tx:\n"));
        if (inv_points & CS4224_LL_INV_DIGITAL_HOST_RX) /* D */
        {
            CS_PRINTF(("    D - Digital Host Rx\n"));
            set = TRUE;
        }
        if (inv_points & CS4224_LL_INV_DIGITAL_LINE_TX) /* E */
        {
            CS_PRINTF(("    E - Digital Line Tx\n"));
            set = TRUE;
        }
        if (inv_points & CS4224_LL_INV_ANALOG_LINE_TX) /* F */
        {
            CS_PRINTF(("    F - Analog Line Tx\n"));
            set = TRUE;
        }
        if(!set)
        {
            CS_PRINTF(("    None\n"));
        }
    }

    return status;
}

/**
 * This method enables/disables the line side PCS monitor. The EGPCS or
 * XGPCS monitor is enabled/disabled depending on the setting of the pcs_device flag.
 *
 * Note: 
 *   When enabling the PCS monitor, this method disables power-savings, 
 *   clocks the PCS block and turns on the line side demux.
 * 
 *   When disabling the PCS monitor, this method enables power-savings, 
 *   removes the clocks to the PCS block and turns off the line side demux.
 *
 *   This feature is supported on the line side of duplex parts only.
 *
 * @since 3.7
 *
 * @param slice      [I] - The slice number of the device
 * @param pcs_device [I] - The PCS monitoring device
 * @param enable     [I] - Enable/Disable flag, one of TRUE or FALSE
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_enable_pcs_monitor(
    cs_uint32 slice, 
    e_cs4224_pcs_monitor_device pcs_device,
    cs_boolean enable)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    if (CS4224_PCS_MONITOR_XGPCS == pcs_device)
    {
        if (enable)
        {
            /* power savings must be turned off */
            status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, FALSE);

            /* CS_PRINTF(("Enabling XGPCS rx on slice = %x, PCS device = %d\n", slice, pcs_device)); */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   &data);
            data |= 0x0004;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   data);
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  &data);
            data |= 0x0004;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  data);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXCNTRL, 0x5000);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, 0x0010);

            /* turn on the Rx demux */
            status |= cs4224_demux_enable(slice, CS4224_CFG_LINE_SIDE, TRUE);
        }
        else /* XGPCS disable */
        {
            /* re-enable power savings */
            status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, TRUE);

            /* CS_PRINTF(("Disabling XGPCS rx on slice = %x, PCS device = %d\n", slice, pcs_device)); */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   &data);
            data &= ~0x0004;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   data);
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  &data);
            data &= ~0x0004;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  data);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXCNTRL, 0xd000);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, 0x0018);

            /* turn off the Rx demux */
            status |= cs4224_demux_enable(slice, CS4224_CFG_LINE_SIDE, FALSE);
        }
    }
    else if (CS4224_PCS_MONITOR_EGPCS == pcs_device)
    {
        if (enable)
        {
            /* power savings must be turned off */
            status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, FALSE);

            /* CS_PRINTF(("Enabling EGPCS rx on slice = %x, PCS device = %d\n", slice, pcs_device)); */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   &data);
            data |= 0x0002;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   data);
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  &data);
            data |= 0x0002;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  data);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_EGPCS_RX_MODE,    0x0002);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, 0x0010);

            /* turn on the Rx demux */
            status |= cs4224_demux_enable(slice, CS4224_CFG_LINE_SIDE, TRUE);
        }
        else /* EGPCS disable */
        {
            /* re-enable power savings */
            status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, TRUE);

            /* CS_PRINTF(("Disabling EGPCS rx on slice = %x, PCS device = %d\n", slice, pcs_device)); */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   &data);
            data &= ~0x0002;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,   data);
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  &data);
            data &= ~0x0002;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,  data);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_EGPCS_RX_MODE,    0x8003);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config, 0x0018);

            /* turn off the Rx demux */
            status |= cs4224_demux_enable(slice, CS4224_CFG_LINE_SIDE, FALSE);
        }
    }
    else
    {
        CS_PRINTF(("ERROR: Invalid PCS monitoring device = %d\n", pcs_device));
        return CS_ERROR;
    }

    return status;
}

/**
 * This method retrieves the line side PCS monitor status. The EGPCS or
 * XGPCS monitor status is retrieved depending on the setting of the pcs_device flag.
 * 
 * Note: 
 *   This feature is supported on the line side of duplex parts only.
 *
 * @since 3.7
 *
 * @param slice      [I] - The slice number of the device
 * @param pcs_device [I] - The PCS monitoring device
 * @param pcs_status [O] - Pointer to the PCS status structure
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_query_pcs_monitor_status(
    cs_uint32 slice, 
    e_cs4224_pcs_monitor_device pcs_device,
    cs4224_pcs_monitor_status_t *pcs_status) 
{
    cs_status status = CS_OK;
    cs_uint16 data;

    pcs_status->sync     = FALSE;
    pcs_status->high_ber = FALSE;

    if (CS4224_PCS_MONITOR_XGPCS == pcs_device)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXSTATUS, &data);
        if (data != 0xbada)
        {
            if (data & 0x0100)
            {
                pcs_status->sync = TRUE;
            }
            if (data & 0x0200)
            {
                pcs_status->high_ber = TRUE;
            }
        }
    }
    else if (CS4224_PCS_MONITOR_EGPCS == pcs_device)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_EGPCS_RX_INTSTATUS, &data);
        if (data != 0xbada)
        {
            if (data & 0x0001)
            {
                pcs_status->sync = TRUE;
            }
        }
    }
    else
    {
        CS_PRINTF(("ERROR: Invalid PCS monitoring device = %d\n", pcs_device));
        return CS_ERROR;
    }

    return status;
}

/**
 * This method displays the line side PCS monitor status.
 * 
 * Note:
 *   This feature is supported on the line side of duplex parts only.
 *
 * @since 3.7
 *
 * @param slice      [I] - The slice number of the device
 * @param pcs_device [I] - The PCS monitoring device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_dump_pcs_monitor_status(
    cs_uint32 slice, 
    e_cs4224_pcs_monitor_device pcs_device)
{
    cs_status status = CS_OK;
    cs4224_pcs_monitor_status_t pcs_status; 

    status |= cs4224_query_pcs_monitor_status(slice, pcs_device, &pcs_status);

    if (pcs_status.sync == TRUE)
    {
        CS_PRINTF(("PCS monitoring device on slice %x is in sync\n", slice));
    }
    else
    {
        CS_PRINTF(("PCS monitoring device on slice %x not in sync\n", slice));
    }

    if (pcs_status.high_ber == TRUE)
    { 
        CS_PRINTF(("PCS monitoring device on slice %x is in a high bit error state\n", slice));
    }

    return status;
}

/**
 * This method enables/disables the FEC.
 * 
 * Note that this turns off power savings.
 *
 * @param slice [I] - The slice number of the device
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 *
 */
cs_status cs4224_enable_fec(
    cs_uint32 slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    if (rules->enable_fec)
    {
        /* enable the FEC Rx and Tx at the same time */
        if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
        {
            if(cs4224_is_hw_simplex(slice))
            {
                cs_uint32 mate = 0xFF;
                /* check to see if this simplex slice has a mate */
                if(CS_OK == cs4224_simplex_mate_slice(slice, &mate))
                {
                    /* if there is a mate simplex slice, then warn that we'll be messing with its Tx */
                    CS_TRACE(("WARNING: Enabling FEC Rx on simplex slice %x  *AND*  FEC Tx on mate simplex slice %x\n", slice, mate));
                }
            }
            /* power savings must be turned off */
            status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
            status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_HOST_MSEQ, FALSE);

            /* power everything up */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x001f);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x001f);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);

            /* clock the Rx & Tx FEC */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,              &data);
            data   |= CS_BIT5 | CS_BIT13; 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,              data);

            /* function enable the Rx & Tx FEC */
            status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,             &data);
            data   |= CS_BIT5 | CS_BIT13; 
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN,             data);

            /* de-assert resets */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_KR_FEC_RX_RESET,             0x0000);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_KR_FEC_TX_RESET,             0x0000);

            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config,       0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config,       0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config,       0x0010);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config,       0x0010);

            status |= cs4224_mux_enable(slice,   CS4224_CFG_HOST_SIDE, TRUE);
            status |= cs4224_demux_enable(slice, CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_mux_enable(slice,   CS4224_CFG_LINE_SIDE, TRUE);
            status |= cs4224_demux_enable(slice, CS4224_CFG_HOST_SIDE, TRUE);
        }
        else if (cs4224_is_hw_simplex(slice) && !cs4224_line_rx_to_host_tx_dir(slice))
        {
            CS_TRACE(("WARNING: FEC cannot be enabled on simplex slice %x (host Rx). FEC is only available on line interfaces.\n",slice));
        }
    }
    return status;
}

/**
 * This method is called to backout Bug #38832 where the unused slices
 * were powered down as part of the workarounds. We must restore these
 * registers to their default values prior to configuring the slice.
 * 
 * Note that we should optimize this so as not to update registers if 
 * they do not require it.
 *
 * @param slice [I] - The slice number of the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_restore_powered_down_regs(
    cs_uint32 slice) 
{
    cs_status status = CS_OK;

    if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC,
                                                CS4224_PP_HOST_SDS_COMMON_STX0_MISC_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1,
                                                CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG,
                                                CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG_dft );
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB,
                                                CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB,
                                                CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG,
                                                CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_VCO_CONFIG,
                                                CS4224_PP_LINE_SDS_COMMON_SRX0_VCO_CONFIG_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB,
                                                CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB_dft);
    }                                                                                                                             
    if (cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC,
                                                CS4224_PP_LINE_SDS_COMMON_STX0_MISC_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1,
                                                CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG,
                                                CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG_dft );
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DAC_ENB_LSB,
                                                CS4224_PP_HOST_SDS_COMMON_SRX0_DAC_ENB_LSB_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DAC_ENB_MSB,
                                                CS4224_PP_HOST_SDS_COMMON_SRX0_DAC_ENB_MSB_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG,
                                                CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG,
                                                CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG_dft);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB,
                                                CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB_dft);
    }
    return status;
}

/**
 * This method is called to power down a single slice. This can be called
 * anytime to put the slice into its lowest power mode. This method follows
 * the procedure outlined in Bug #38832.
 *
 * @param slice [I] - The slice number of the device
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_slice_power_down(
    cs_uint32 slice)
{
    cs_status status = CS_OK;

    if ((cs4224_is_hw_simplex(slice) && cs4224_line_rx_to_host_tx_dir(slice)) ||
        (cs4224_is_hw_duplex(slice)))
    {
        /* stall the microsequencer */
        status |= cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, TRUE);

        /* STX_PD=1, STX_PD_MUX=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC       , 0x8033);
        /* SRX_AGC_ENB_LIMAMP=0 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1, 0x0004);
        /* SRX_DFE_BYPASS_EN=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG , 0x0441);
        /* SRX_DAC_ENB<19:0>=0xfffff */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB, 0xffff);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB, 0x000f);
        /* SRX_AMP_PD=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG  , 0x0044);
        /* SRX_VCO_EN=0, SRX_VCO_PDMUX_EN=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_VCO_CONFIG , 0x0705);
        /* SRX_CLKDIV_PD=1, SRX_PD_DEMUX=7 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x03ff);
    }
    if ((cs4224_is_hw_simplex(slice) && !cs4224_line_rx_to_host_tx_dir(slice)) ||
        (cs4224_is_hw_duplex(slice)))
    {
        /* stall the microsequencer */
        status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, TRUE);

        /* STX_PD=1, STX_PD_MUX=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_MISC       , 0x8033);
        /* SRX_AGC_ENB_LIMAMP=0 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG1, 0x0004);
        /* SRX_DFE_BYPASS_EN=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG , 0x0441);
        /* SRX_DAC_ENB<19:0>=0xfffff */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DAC_ENB_LSB, 0xffff);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DAC_ENB_MSB, 0x000f);
        /* SRX_AMP_PD=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG  , 0x0044);
        /* SRX_VCO_EN=0, SRX_VCO_PDMUX_EN=1 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_VCO_CONFIG , 0x0705);
        /* SRX_CLKDIV_PD=1, SRX_PD_DEMUX=7 */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x03ff);
    }

    return status;
}

/**
 * This method is called on startup to power down all slices on a die. This
 * is done after applying any workarounds and loading the microcode in order
 * to put the device into its lowest power mode. This method also marks the 
 * workarounds as complete by writing to the GLOBAL_SCRATCH6 register.
 *
 * NOTE: MSEQs must be stalled prior to calling this method
 * 
 * @param die [I] - The die to apply power down settings to
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_apply_workarounds_power_down(
    cs_uint32 die)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    cs4224_lock(die);
    
    /* get scratch 6 value from die to determine if we have already applied workarounds */
    status |= cs4224_reg_get(die, CS4224_GLOBAL_SCRATCH6, &data);
    if(CS_IF_SET(data,CS_BIT0))
    {
        /* workarounds already applied, bail out. note default is 0x0000 */
        return CS_OK;
    }
    
    /* make sure the mseqs are stalled, can't use broadcast otherwise! */
    status |= cs4224_reg_get(die, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW, &data);
    if(CS_IF_CLR(data, CS_BIT3))
    {
        CS_TRACE(("ERROR: MSEQs on die 0x%x are not stalled.\n"
                  "This method is being used incorrectly. Contact your Cortina AE for support\n", die));
        return CS_ERROR;
    }
    
    /* Apply workarounds to all port-pairs (PP) on the die, see Bugzilla #37471 */
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST, 0x80);
    {
        /* power-down all slices as per Bug #38832 */
        /* STX_PD=1, STX_PD_MUX=1 */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_STX0_MISC, 0x8033);
        /* SRX_AGC_ENB_LIMAMP=0 */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG1, 0x0004);
        /* SRX_DFE_BYPASS_EN=1 */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG, 0x0441);
        /* SRX_DAC_ENB<19:0>=0xfffff */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB, 0xffff);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB, 0x000f);
        /* SRX_AMP_PD=1 */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG, 0x0044);
        /* SRX_VCO_EN=0, SRX_VCO_PDMUX_EN=1 */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_VCO_CONFIG, 0x0705);
        /* SRX_CLKDIV_PD=1, SRX_PD_DEMUX=7 */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x03ff);
    }
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST, 0x0);

#if 0
    /* now update registers that require read/modify/writes here
     * because reads are not allowed when broadcast enabled */
    for (offset=0; offset < 0x4000; offset+=0x1000)
    {
        /* here we want to power-down the loop amplifier (SRX_AMP_PD) without changing the power-down
         * state of the entire receive slice (SRX_PD). SRX_PD is asserted in hard_reset_die and may
         * be cleared in power_up_pp, see Youtrack k2-292 */
        status |= cs4224_reg_get(die, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG+offset,   &data);
        data |= 0x0044; /* SRX_AMP_PD=1, do not touch SRX_PD */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG+offset,   data);
        status |= cs4224_reg_get(die, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG+offset,   &data);
        data |= 0x0044;
        status |= cs4224_reg_set(die, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CONFIG+offset,   data);
    }
#endif
    /* Mark all of the workarounds as complete */
    status |= cs4224_reg_get(die, CS4224_GLOBAL_SCRATCH6, &data);
    status |= cs4224_reg_set(die, CS4224_GLOBAL_SCRATCH6, CS_SET(data,CS_BIT0));
    
    cs4224_unlock(die);

    return status;
}

/**
 * This method is called to reset the PP registers on a single slice interface.
 * 
 * NOTE: There will be a momentary glitch in the PRBS checker on the other interface, 
 *       ex: run this on the line Rx and you'll see a glitch on the host Rx's PRBS checker.
 *       This glitch is on the PRBS checker ONLY, and does not effect through traffic.
 * 
 * @param slice [I] - The slice to apply the soft reset to
 * @param intf  [I] - The side to reset (cannot be simplex)
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_slice_soft_reset_intf(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf)
{
    cs_status status = CS_OK;
    cs_status tmp_status = CS_OK;
    cs_uint16 data = 0;
    cs_uint16 reg_offset = 0;
    e_cs4224_mseq_id mseq_id = CS4224_DPLX_LINE_MSEQ;
    e_cs4224_mseq_id other_mseq_id = CS4224_DPLX_HOST_MSEQ;
    cs_uint32 mate_slice = 0xFF;
    cs_boolean stalled = FALSE;
    cs_boolean power_savings = FALSE;
    cs_uint16 other_power_down = 0x0;

    if(CS4224_CFG_LINE_SIDE == intf)
    {
        reg_offset = 0;
        mseq_id = CS4224_DPLX_LINE_MSEQ;
        other_mseq_id = CS4224_DPLX_HOST_MSEQ;
    }
    else if(CS4224_CFG_HOST_SIDE == intf)
    {
        reg_offset = CS4224_LINE_TO_HOST_OFFSET;
        mseq_id = CS4224_DPLX_HOST_MSEQ;
        other_mseq_id = CS4224_DPLX_LINE_MSEQ;
    }
    else
    {
        CS_TRACE(("ERROR: intf must be line or host, not simplex. intf=%d\n",intf));
        return CS_ERROR;
    }
    
    /* make sure mseq is stalled on this interface, if not, then stall and don't unstall after the reset */
    status |= cs4224_query_mseq_is_stalled(slice, mseq_id, &stalled);
    if(!stalled)
    {
        status |= cs4224_mseq_stall(slice, mseq_id, TRUE);
    }
    
    /* we need to control the power_down on both line and host interfaces. In simplex, the other interface's
     * mseq may be running, so turn off power savings so we can mess around with power_down without affecting
     * traffic
     */
    tmp_status |= cs4224_simplex_mate_slice(slice, &mate_slice);
    if((mate_slice & 0xFF) == 0xFF)
    {
        /* doesn't have a mate slice, which means the other slice is not configured nor running */
        power_savings = FALSE;
    }
    else if(tmp_status != CS_OK)
    {
        /* some other kind of error, not good */
        CS_TRACE(("ERROR getting mate slice\n"));
        status |= tmp_status;
        return status;
    }
    else
    {
        /* we do have a mate slice, or on duplex it's the same slice, either way check power savings */
        status |= cs4224_query_mseq_power_savings(mate_slice, other_mseq_id, &power_savings);
        if(power_savings)
        {
            status |= cs4224_mseq_enable_power_savings(mate_slice, other_mseq_id, FALSE);
        }
    }
    
    cs4224_lock(slice);

    /* clock and power up everything */
    if(CS4224_CFG_LINE_SIDE == intf)
    {
        /* only touch Rx stuff */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, &data);
        data |= 0x00ff;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN ,data);
        
        /* host-side reg doesn't have Tx settings */
    }
    else
    {
        /* only touch Rx stuff */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_CLKEN, 0x0041);
        
        /* only touch Tx stuff on the other side */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, &data);
        data |= 0xff00;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN ,data);
    }

    /* save the other-side's power down so we can restore it later */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB - reg_offset, &other_power_down);
    
    /* stagger power up */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset, 0x001F);
    /* stagger power up only if we won't kill anything, this works because if it's already on (cleared to 0) then this
     * won't turn it off trying to write 0x1F into the reg
     * 
     * NOTE: There is an issue (maybe?) in the PRBS checker that when you clear bit6 you will get a momenary loss of PRBS sync
     *       this does not effect traffic through the device, only the PRBS checker
     */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB - reg_offset, (other_power_down & 0x001F));
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB - reg_offset, 0x0000);

    /* reset most of the Rx settings */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_SOFT_RESET        + reg_offset, 0x0031);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MPIF_RESET_DOTREG + reg_offset, 0x0003);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_SOFT_RESET        + reg_offset, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MPIF_RESET_DOTREG + reg_offset, 0x0000);

    /* some stuff isn't hit by those resets, so reset those manually */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_CONTROL + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_CONTROL_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_RX0_Config_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXELST0_Control + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_RXELST0_Control_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKOUT_CTRL_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG_EYEMON + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG_EYEMON_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_MONCTRL + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_SRX0_MONCTRL_dft);

    /* RX_CONFIG on the RX side has a Tx side Tx bit for some horrible  reason. Yes this register is correct, so the LINE_SDRX0_RX_CONFIG
     * will contain the analog host Tx polarity inversion bit */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG_dft);
#if 0
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + reg_offset, &data);
    data = CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG_dft | (data & 0x0020); /* do not clobber the SRX_PD bit, see Youtrack k2-292 */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CONFIG + reg_offset, data);
#endif    
    /* Reset some Tx registers that weren't hit by the Rx soft reset
     * These are mostly just registers not touched by cs4224_slice_enter_operational_state */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config - reg_offset, /* inverted reg_offset */
                                            CS4224_PP_HOST_SDS_COMMON_TX0_Config_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_TXELST0_Control - reg_offset,
                                            CS4224_PP_HOST_SDS_COMMON_TXELST0_Control_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG - reg_offset,
                                            CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_CONFIG_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_TUNE - reg_offset,
                                            CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_TUNE_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVERCML_TUNE - reg_offset,
                                            CS4224_PP_HOST_SDS_COMMON_STX0_DRIVERCML_TUNE_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_MISC - reg_offset,
                                            CS4224_PP_HOST_SDS_COMMON_STX0_MISC_dft);
    
    /* Reset some stuff that's normally reset in cs4224_restore_powered_down_regs */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_LSB_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_SRX0_DAC_ENB_MSB_dft);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_VCO_CONFIG + reg_offset,
                                            CS4224_PP_LINE_SDS_COMMON_SRX0_VCO_CONFIG_dft);
    
    /* Unfortunately the soft reset wipes out the per-port workarounds on this slice, so re-apply them */
    /* NOTE: Sync this block of writes with those in the cs4224_apply_workarounds method */
    {
        /* Adjust the LC-VCO bias current because the defaults are wrong. See bugzilla #36619,39270 for details */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_VCOBIAS   + reg_offset, 0x0907);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL00 + reg_offset, 0x3222);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL01 + reg_offset, 0x4444);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL02 + reg_offset, 0x5555);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL03 + reg_offset, 0x6666);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL10 + reg_offset, 0x7654);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL11 + reg_offset, 0x8877);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL12 + reg_offset, 0xa999);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL13 + reg_offset, 0xccba);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL      + reg_offset, 0x001e);
        
        /* clear bit 13 (bug 37471) */
        data = CS_CLR(CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE_dft, CS_BIT13);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE       + reg_offset, data);

        /* clear common_tx_sr reset */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_SOFT_RESET            + reg_offset, 0x0000);

        /* force driver charge pump high (to rail) to eliminate cross-talk */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA         + reg_offset, 0x80dd);

        /* DATAPATH_CTRL is different between line and host, but the host bits 
         * that are different are reserved so it doesn't matter if we try to write them
         */
        data = CS_SET(CS4224_PP_LINE_LINEMISC_DATAPATH_CTRL_dft, CS_BIT1);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_DATAPATH_CTRL         + reg_offset, data);
    }
    
    /* Reset power-down and clken before proceeding */
    if(CS4224_CFG_LINE_SIDE == intf)
    {
        /* reset Rx stuff */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, &data);
        data &= 0xff00;
        data |= 0x0060;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, data);
        /* no Tx stuff in host reg */
    }
    else
    {
        /* reset Rx stuff */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_CLKEN, 0x0000);
        
        /* reset Tx stuff on other side */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, &data);
        data &= 0x00ff;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN, data);
    }

    /* set power down to default on this interface */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + reg_offset, 
                                            CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB_dft);
    
    if(!power_savings)
    {
        /* restore power down on the other interface */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB - reg_offset, other_power_down);
    }
    
    cs4224_unlock(slice);
   
    /* re-enable power savings on the other interface if needed */
    if(power_savings)
    {
        status |= cs4224_mseq_enable_power_savings(mate_slice, other_mseq_id, TRUE);
    }
    
    return status;
}

/**
 * This method is called to reset the PP registers on a single slice.
 * 
 * Note: this resets most of the configuration for that slice and needs to be 
 * reapplied via cs4224_slice_enter_operational_state.
 * 
 * NOTE: On simplex devices there will be a momentary glitch in the PRBS checker 
 *       on the mate slice (determined via cs4224_simplex_mate_slice)
 *       ex: run this on slice 0 and you'll see a glitch on slice 5's PRBS checker.
 *       This glitch is on the PRBS checker ONLY, and does not effect through traffic.
 * 
 * @param slice [I] - The slice to apply the soft reset to
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 */
cs_status cs4224_slice_soft_reset(
    cs_uint32 slice)
{
    cs_status status = CS_OK;
    
    if(cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_slice_soft_reset_intf(slice, CS4224_CFG_LINE_SIDE);
    }
    if(cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_slice_soft_reset_intf(slice, CS4224_CFG_HOST_SIDE);
    }
    
    return status;
}

/**
 * This method is called on startup to apply various workarounds to all 
 * slices of a die. The workarounds will be applied only the first time a 
 * slice is configured on a die.
 * 
 * NOTE: MSEQs must be stalled prior to calling this
 * 
 * @param die [I] - The die to apply the configuration to
 *
 * @return CS_OK on success, CS_ERROR on failure.
 * 
 * @private
 */
cs_status cs4224_apply_workarounds(
    cs_uint32 die)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    cs4224_lock(die);

    /* get scratch 6 value from die to determine if we have already applied workarounds */
    status |= cs4224_reg_get(die, CS4224_GLOBAL_SCRATCH6, &data);
    if(CS_IF_SET(data, CS_BIT0))
    {
        /* workarounds already applied, bail out. note default is 0x0000 */
        return CS_OK;
    }
    
    /* make sure the mseqs are stalled, can't use broadcast otherwise! */
    status |= cs4224_reg_get(die, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW, &data);
    if(CS_IF_CLR(data, CS_BIT3))
    {
        CS_TRACE(("ERROR: MSEQs on die 0x%x are not stalled.\n"
                  "This method is being used incorrectly. Contact your Cortina AE for support\n", die));
        return CS_ERROR;
    }
    
    /* At this point, the device is essentially right out of reset */
    
    /* Change the temperature and voltage monitors to poll */
    status |= cs4224_enable_monitor_sense_points(die, FALSE);

    /* Increase MDIO timeout as per Bugzilla 35875 */
    status |= cs4224_reg_set(die, CS4224_GLOBAL_MDIO_CONFIG, CS4224_GLOBAL_MDIO_CONFIG_pref);
    
    /* load the 0.9v monitor calibration constant */
    status |= cs4224_reg_get(die, CS4224_EFUSE_PDF_MON_GAIN_DATA,        &data);
    status |= cs4224_reg_set(die, CS4224_MONITOR_CAL_OVERRIDE,           data);

    /* load the 1.8v monitor calibration constant */
    status |= cs4224_reg_get(die, CS4224_EFUSE_PDF_MON_LUT15,            &data);
    status |= cs4224_reg_set(die, CS4224_MONITOR_LUT_VALUE0,             data);
    
    /* make use of the temperature and 0.9v voltage calibration constants */
    status |= cs4224_reg_set(die, CS4224_MONITOR_CAL_CONST_OVERRIDE_ENA, 0x0004);
    status |= cs4224_reg_set(die, CS4224_MONITOR_CAL_CONST_APPLY,        0x0005);

    /* make use of the 1.8v voltage calibration constant */
    status |= cs4224_reg_set(die, CS4224_MONITOR_LUT_RANGE0,             0xffff);
    status |= cs4224_reg_set(die, CS4224_MONITOR_LUT_SELECT,             0x0000);
    status |= cs4224_reg_set(die, CS4224_MONITOR_LUT_LOCAL_SELECT,       0x0040);
    status |= cs4224_reg_set(die, CS4224_MONITOR_LUT_APPLY,              0x0040);

    /* Apply workarounds to all port-pairs (PP) on the die */
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST, 0x80);
    {
        /* CS_PRINTF(("...Applying workarounds to die %d, stride 0x%04x\n", die, stride));*/
        /* Adjust the LC-VCO bias current because the defaults are wrong. See bugzilla #36619,39270 for details */
        /* NOTE: Sync these values with those in the cs4224_slice_soft_reset method */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_VCOBIAS, 0x0907);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL00, 0x3222);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL01, 0x4444);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL02, 0x5555);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL03, 0x6666);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL10, 0x7654);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL11, 0x8877);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL12, 0xa999);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_RXVCO0_LC_BIASVAL13, 0xccba);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL, 0x001e);

        /* clear bit 13 (bug 37471) */
        data = CS_CLR(CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE_dft, CS_BIT13);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_SPARE, data);

        /* clear common_tx_sr reset */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_SOFT_RESET, 0x0);

        /* force driver charge pump high (to rail) to eliminate cross-talk */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA, 0x80dd);

        /* DATAPATH_CTRL is different between line and host, but the host bits 
         * that are different are reserved so it doesn't matter if we try to write them
         */
        data = CS_SET(CS4224_PP_LINE_LINEMISC_DATAPATH_CTRL_dft, CS_BIT1);
        status |= cs4224_reg_set(die, CS4224_PP_LINE_LINEMISC_DATAPATH_CTRL, data);
    }
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST, 0x0);

    cs4224_unlock(die);

    return status;
}

/**
 * This method is called after the microcode download to apply various workarounds 
 * to all slices of a die. This is to backout any changes the microcode may have done
 * that would cancel out the changes made in cs4224_apply_workarounds method.
 *
 * NOTE: MSEQs MUST be stalled before calling this
 * 
 * @param die [I] - The device to configure
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_apply_post_ucode_dwld_workarounds(
    cs_uint32 die) 
{
    cs_status status = CS_OK;
    cs_uint16 data;

    cs4224_lock(die);

    /* make sure the mseqs are stalled, can't use broadcast otherwise! */
    status |= cs4224_reg_get(die, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW, &data);
    if(CS_IF_CLR(data, CS_BIT3))
    {
        CS_TRACE(("ERROR: MSEQs on die 0x%x are not stalled.\n"
                  "This method is being used incorrectly. Contact your Cortina AE for support\n", die));
        return CS_ERROR;
    }
    
    /* Apply workarounds to all port-pairs (PP) on the die, see Bugzilla #37471 */
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST, 0x80);
    {
        /* force driver charge pump high (to rail) to elimitnate cross-talk */
        status |= cs4224_reg_set(die, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA, 0x80dd);
    }
    status |= cs4224_reg_set(die, CS4224_GLOBAL_BROADCAST, 0x0);

    cs4224_unlock(die);

    return status;
}

/**
 * @private
 */
cs_status cs4224_dump_debug_info(
    cs_uint32 slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    e_cs4224_hardware_id hw_id = cs4224_hw_id(slice);

    const char* app = cs4224_translate_app_mode(rules->application);
    
    const char* edc_mode;
    const char* edc_mode2;
    
    char data_rate_str[15] = "";
    
    if(rules->application == CS4224_TARGET_APPLICATION_KRAN)
    {
        CS_SNPRINTF((data_rate_str, sizeof(data_rate_str)/sizeof(data_rate_str[0]), "0x%04x", rules->kran.data_rates ));
    }
    else
    {
        CS_SNPRINTF((data_rate_str, sizeof(data_rate_str)/sizeof(data_rate_str[0]), "%uMbps", (cs4224_query_data_rate(rules) / 1000) ));
    }
    
    if(cs4224_is_hw_simplex(slice))
    {
        edc_mode = cs4224_translate_edc_mode(rules->rx_if.splx_edc_mode);
        edc_mode2 = edc_mode;
    }
    else
    {
        edc_mode  = cs4224_translate_edc_mode(rules->rx_if.dplx_line_edc_mode);
        edc_mode2 = cs4224_translate_edc_mode(rules->rx_if.dplx_host_edc_mode);
    }
    
    switch(hw_id)
    { 
        case CS4224_HW_CS4223: /*  4 port duplex   */
        
            CS_PRINTF(("\nK2 configured for Duplex CS4223, Max ports = %d\n", cs4224_max_num_ports));
            CS_PRINTF(("slice = %x, die = %x, PP offset = 0x%05x\n", 
                slice & 0xff, 
                cs4224_get_die_from_slice(slice), 
                cs4224_adj_pp(slice, 0) ));
            CS_PRINTF(("application = %s, data rate = %s, line edc_mode = %s, host edc_mode = %s\n",
                app,
                data_rate_str,
                edc_mode,
                edc_mode2 ));
            
            break;

        case CS4224_HW_CS4224: /* 16 port simplex  */
        
            CS_PRINTF(("\nK2 configured for Simplex CS4224, Max ports = %d\n", cs4224_max_num_ports));
            CS_PRINTF(("slice = %x, die = %x, PP offset = 0x%05x, dir = %s\n", 
                slice & 0xff, 
                cs4224_get_die_from_slice(slice), 
                cs4224_adj_pp(slice, 0),
                (cs4224_line_rx_to_host_tx_dir(slice) ? "Line to Host" : "Host to Line") ));
            CS_PRINTF(("application = %s, data rate = %s, edc_mode = %s\n",
                app,
                data_rate_str,
                edc_mode ));
         
            break;

        case CS4224_HW_CS4343: /*  8 port duplex   */
        
            CS_PRINTF(("\nK2 configured for Duplex CS4343, Max ports = %d\n", cs4224_max_num_ports));
            CS_PRINTF(("slice = %x, die = %x, PP offset = 0x%05x\n", 
                slice & 0xff, 
                cs4224_get_die_from_slice(slice), 
                cs4224_adj_pp(slice, 0) ));
            CS_PRINTF(("application = %s, data rate = %s, line edc_mode = %s, host edc_mode = %s\n",
                app,
                data_rate_str,
                edc_mode,
                edc_mode2 ));
         
            break;

        case CS4224_HW_CS4221: /* 10 port simplex */
        
            CS_PRINTF(("\nK2 configured for Simplex CS4221, Max ports = %d\n", cs4224_max_num_ports));
            CS_PRINTF(("slice = %x, die = %x, PP offset = 0x%05x, dir = %s\n", 
                slice & 0xff, 
                cs4224_get_die_from_slice(slice), 
                cs4224_adj_pp(slice, 0), 
                (cs4224_line_rx_to_host_tx_dir(slice) ? "Line to Host" : "Host to Line") ));
            CS_PRINTF(("application = %s, data rate = %s, edc_mode = %s\n",
                app,
                data_rate_str,
                edc_mode ));

            break;

        case CS4224_HW_CS4227: /*  2 port duplex   */
        
            CS_PRINTF(("\nK2 configured for Duplex CS4227, Max ports = %d\n", cs4224_max_num_ports));
            CS_PRINTF(("slice = %x, die = %x, PP offset = 0x%05x\n", 
                slice & 0xff, 
                cs4224_get_die_from_slice(slice), 
                cs4224_adj_pp(slice, 0) ));
            CS_PRINTF(("application = %s, data rate = %s, line edc_mode = %s, host edc_mode = %s\n",
                app,
                data_rate_str,
                edc_mode,
                edc_mode2 ));

            break;

        case CS4224_HW_CS4210: /* 16 port simplex  */
        
            CS_PRINTF(("\nK2 configured for Simplex CS4210 (15G), Max ports = %d\n", cs4224_max_num_ports));
            CS_PRINTF(("slice = %x, die = %x, PP offset = 0x%05x, dir = %s\n", 
                slice & 0xff, 
                cs4224_get_die_from_slice(slice), 
                cs4224_adj_pp(slice, 0),
                (cs4224_line_rx_to_host_tx_dir(slice) ? "Line to Host" : "Host to Line") ));
            CS_PRINTF(("application = %s, data rate = %s, edc_mode = %s\n",
                app,
                data_rate_str,
                edc_mode ));
         
            break;

        case CS4224_HW_CS4341: /*  8 port duplex   */
        
            CS_PRINTF(("\nK2 configured for Duplex CS4341 (10G), Max ports = %d\n", cs4224_max_num_ports));
            CS_PRINTF(("slice = %x, die = %x, PP offset = 0x%05x\n", 
                slice & 0xff, 
                cs4224_get_die_from_slice(slice), 
                cs4224_adj_pp(slice, 0) ));
            CS_PRINTF(("application = %s, data rate = %s, line edc_mode = %s, host edc_mode = %s\n",
                app,
                data_rate_str,
                edc_mode,
                edc_mode2 ));
         
            break;

        default:
            CS_PRINTF(("\nERROR: K2 Efuse SKU not configured\n\n"));
            status = CS_ERROR;

            break;

    }

    return status;
}

/**
 * This method determines if the EEPROM has finished loading.
 *
 * @param die     [I] - The die of the device to wait for the EEPROM
 *                      to finish on.
 *
 * @return TRUE when finished, FALSE otherwise
 *
 * @private
 */
cs_boolean cs4224_is_eeprom_finished(
    cs_uint32 die) 
{
    cs_uint16  efuse_general_status;
    cs_uint16  global_pin_status;
    cs_uint16  eeprom_loader_status;

    cs4224_reg_get(die, CS4224_EFUSE_GENERAL_STATUS, &efuse_general_status); 
    if (efuse_general_status != 0x0001) 
    {
        /* EFUSE has not finished loading */
        return FALSE;
    }
    
    cs4224_reg_get(die, CS4224_GLOBAL_PIN_STATUS,    &global_pin_status); 
    /* 0xf00d means the eeprom loader is still running
     * 0xffff means the refclk isn't stable */
    if (global_pin_status == 0xf00d || global_pin_status == 0xffff || global_pin_status == 0xbada)
    {
        return FALSE;
    }
    else if ((global_pin_status & 0x4000) == 0 )
    {
        /* EEPROM not present */
        return TRUE;
    }
    
    cs4224_reg_get(die, CS4224_EEPROM_LOADER_STATUS, &eeprom_loader_status); 
    if (eeprom_loader_status == 0xbada)
    {
        return FALSE;
    }
    if ((eeprom_loader_status & 0x0007) != 0) 
    {
        /* EEPROM load abort, load failed, or load done */
        return TRUE;
    }

    return FALSE;
}

/**
 * This method is called to wait for the EEPROM loader to finish
 * running during power on or after resetting the device. This will
 * busy wait until the EEPROM loader has completed. If there is no
 * EEPROM loader present then this should time out in X microseconds.
 *
 * @param die                         [I] - The die of the device to wait for the EEPROM
 *                                          to finish on.
 * @param max_iterations              [I] - The max number of iterations to poll
 *                                          the EEPROM status for.
 * @param ms_delay_between_iterations [I] - The number of milli-seconds to delay between
 *                                          each iteration (0 for default delay)
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @attributes has_busy_wait
 */
cs_status cs4224_wait_for_eeprom_finished(
    cs_uint32 die,
    cs_uint32 max_iterations,
    cs_uint32 ms_delay_between_iterations)
{
    cs_status status = CS_OK;
    cs_boolean finished = FALSE;
    cs_uint32 attempt = 0;

    
    do
    {
        finished = cs4224_is_eeprom_finished(die);
        
        if(!finished)
        {
            
            if(ms_delay_between_iterations == 0)
            {
                CS_MDELAY(1);
            }
            else
            {
                CS_MDELAY(ms_delay_between_iterations);
            }
        }
    } while ((attempt++ < max_iterations) && (finished == FALSE));

    if (finished == TRUE)
    {
        status = CS_OK;
    }
    else
    {
        CS_TRACE(("ERROR: EEPROM never finished loading, die=%x\n", die));
        status = CS_ERROR;
    }
  
    return status;

}

/**
 * Will increment GLOBAL_SCRATCH registers based on which slice is being configured.
 * Useful to tell if dynamic reconfig is being used, and whether slices had
 * cs4224_slice_enter_operational_state run on them.
 * 
 * @private
 */
cs_status cs4224_update_scratch_regs(
    cs_uint32 slice)
{
    cs_status status = CS_OK;
    cs_uint16 reg_addr = 0x0;
    cs_uint16 inc = 0x0;
    cs_uint16 counter = 0x0;
    cs_uint8  local_slice = slice & 0xff;
    
    /* which scratch you use is based off of the PP, ex PP2 is GLOBAL_SCRATCH2 */
    reg_addr = CS4224_GLOBAL_SCRATCH0 + (cs4224_adj_pp(slice, 0x0) >> 12);
    
    /* increment is based off of the die, ex slice 2 is die 1 which is the upper bits
     * of GLOBAL_SCRATCH2, so inc will be 0x0100. 
     * See global_scratch_allocation.txt for more info */
    inc = (cs4224_get_die_from_slice(local_slice) == 1) ? 0x0100 : 0x0001;

    cs4224_lock(slice);

    status |= cs4224_reg_get_channel(slice, reg_addr, &counter);
    counter += inc;
    status |= cs4224_reg_set_channel(slice, reg_addr, counter);

    cs4224_unlock(slice);

    return status;
}

/**
 * This method is used to check the rules for possible errors in configuration.
 *
 * @param slice [I] - Used to check hw for simplex or duplex
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_check_rules(cs_uint32 slice, cs4224_rules_t *rules)
{
    cs_status status = CS_OK;
    /*simple bool to make things cleaner */
    cs_boolean bad_state = FALSE;
    /* list of the valid edc modes */
    cs4224_edc_modes valid_edc_modes = 0;

    switch (rules->application)
    {
        case CS4224_TARGET_APPLICATION_OC12:
        case CS4224_TARGET_APPLICATION_1G:
        case CS4224_TARGET_APPLICATION_1G_FC:
        case CS4224_TARGET_APPLICATION_2G_FC:
        case CS4224_TARGET_APPLICATION_4G_FC:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC mode SR\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_5G:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR |
                              CS_HSIO_EDC_MODE_5G_BP;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC modes SR and 5G_BP\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_7p5G:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR |
                              CS_HSIO_EDC_MODE_7p5G_BP;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC modes SR and 7p5G_BP\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_8G_FC:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR     |
                              CS_HSIO_EDC_MODE_8p5G_BP|
                              CS_HSIO_EDC_MODE_DWDM   |
                              CS_HSIO_EDC_MODE_ZR;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC modes SR, 8p5G_BP, DWDM, and ZR\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_10G_FC:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR     |
                              CS_HSIO_EDC_MODE_10G_BP |
                              CS_HSIO_EDC_MODE_CX1    |
                              CS_HSIO_EDC_MODE_SMLRM  |
                              CS_HSIO_EDC_MODE_DWDM   |
                              CS_HSIO_EDC_MODE_ZR;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC modes SR, 10G_BP, CX1, DWDM, and ZR\n",
                          cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_10G:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR     |
                              CS_HSIO_EDC_MODE_10G_BP |
                              CS_HSIO_EDC_MODE_CX1    |
                              CS_HSIO_EDC_MODE_SMLRM  |
                              CS_HSIO_EDC_MODE_DWDM   |
                              CS_HSIO_EDC_MODE_ZR;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC modes SR, 10G_BP, CX1, DWDM, and ZR\n",
                          cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_16G_FC:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR         |
                              CS_HSIO_EDC_MODE_15G_BP     |
                              CS_HSIO_EDC_MODE_15G_BP_27dB|
                              CS_HSIO_EDC_MODE_DWDM       |
                              CS_HSIO_EDC_MODE_ZR;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC modes SR, 15G_BP, DWDM, and ZR\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_15G:
        {
            valid_edc_modes = CS_HSIO_EDC_MODE_SR         |
                              CS_HSIO_EDC_MODE_SMLRM      |
                              CS_HSIO_EDC_MODE_15G_BP     |
                              CS_HSIO_EDC_MODE_15G_BP_27dB;
            if (cs4224_is_hw_simplex(slice))
            {
                bad_state = !(rules->rx_if.splx_edc_mode & valid_edc_modes);
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports EDC modes SR, 15G_BP\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_10G_KR:
        case CS4224_TARGET_APPLICATION_40G_KR:
        case CS4224_TARGET_APPLICATION_KRAN:   
        {
            /* valid HOST side modes, line can only be 10G_BP */
            valid_edc_modes = CS_HSIO_EDC_MODE_SR     |
                              CS_HSIO_EDC_MODE_10G_BP |
                              CS_HSIO_EDC_MODE_CX1    |
                              CS_HSIO_EDC_MODE_SMLRM  |
                              CS_HSIO_EDC_MODE_DWDM   |
                              CS_HSIO_EDC_MODE_ZR;
            if (cs4224_is_hw_simplex(slice))
            {
                CS_TRACE(("ERROR: %s doesn't support simplex devices\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            else
            {
                if( !(rules->rx_if.dplx_host_edc_mode & CS_HSIO_EDC_MODE_SR) )
                {
                    /* SR is actual SR mode
                     * All the other modes will setup the host in the correct mode (CX1/DWDM/etc.) however it turns off
                     *   the dynamic calibration. This means if you unplug the host cable and plug in another different cable
                     *   without reinitializing the slice, the calibration will be off. There may be ways of getting around
                     *   this, contact your Cortina AE to find out more
                     */
                    CS_TRACE(("WARNING: In KRAN host edc_mode should only be SR, contact your Cortina AE for more info.\n"));
                }
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & CS_HSIO_EDC_MODE_10G_BP) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s host only supports EDC mode SR, line only supports EDC mode 10G_BP\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            if(rules->kran.advanced.two_pass_mode && rules->kran.advanced.ref106)
            {
                CS_TRACE(("ERROR: Cannot use two_pass_mode and ref106 at the same time\n"));
                status |= CS_ERROR;
            }
            break;
        }
        case CS4224_TARGET_APPLICATION_FCAN:
        {
            cs4224_edc_modes valid_line_edc_modes = 0;
            cs4224_edc_modes valid_host_edc_modes = 0;

            /* check fcan rates */
            status |= cs4224_fcan_check_rates(rules->fcan.data_rates);

            /* line can only be sr or FCAN 'DFE' mode */
            valid_line_edc_modes = CS_HSIO_EDC_MODE_SR     |
                                   CS_HSIO_EDC_MODE_FCAN;

            /* host can  be sr or any 'DFE' mode */
            valid_host_edc_modes = CS_HSIO_EDC_MODE_SR         |
                                   CS_HSIO_EDC_MODE_10G_BP     |
                                   CS_HSIO_EDC_MODE_15G_BP     |
                                   CS_HSIO_EDC_MODE_15G_BP_27dB|
                                   CS_HSIO_EDC_MODE_CX1        |
                                   CS_HSIO_EDC_MODE_SMLRM      |
                                   CS_HSIO_EDC_MODE_DWDM       |
                                   CS_HSIO_EDC_MODE_8p5G_BP    |
                                   CS_HSIO_EDC_MODE_ZR;

            if (cs4224_is_hw_simplex(slice))
            {
                CS_TRACE(("ERROR: %s doesn't support simplex devices\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }
            else
            {
                bad_state = !( (rules->rx_if.dplx_host_edc_mode & valid_host_edc_modes) &&
                               (rules->rx_if.dplx_line_edc_mode & valid_line_edc_modes) );
            }
            if (bad_state)
            {
                CS_TRACE(("ERROR: %s only supports FCAN EDC mode and SR on the line side\n", cs4224_translate_app_mode(rules->application)));
                status |= CS_ERROR;
            }

            break;
        }
        /* These rates haven't been tested yet */
        case CS4224_TARGET_APPLICATION_8G:
        case CS4224_TARGET_APPLICATION_8p5G:
        {
            CS_TRACE(("ERROR: Application mode '%s' not supported yet\n", cs4224_translate_app_mode(rules->application)));
            status |= CS_ERROR;
            break;
        }
    }

    /* validate simplex/duplex rules */
    if (cs4224_is_hw_simplex(slice))
    {
        /* These traceloss settings are for the driver only */
        bad_state = rules->rx_if.splx_eq.traceloss == CS_HSIO_TRACE_LOSS_15dB ||
                    rules->rx_if.splx_eq.traceloss == CS_HSIO_TRACE_LOSS_27dB ||
                    rules->rx_if.splx_eq.traceloss == CS_HSIO_TRACE_LOSS_CR4  ||
                    rules->rx_if.splx_eq.traceloss == CS_HSIO_TRACE_LOSS_LAB;
        if (bad_state)
        {
            CS_TRACE(("ERROR: Traceloss settings of 15/27dB or CR4/LAB are for the tx_if.*_driver.traceloss setting only.\n"));
            status |= CS_ERROR;
        }

        /* FEC available for simplex parts only */
        bad_state = rules->enable_fec;
        if (bad_state)
        {
            CS_TRACE(("ERROR: FEC not supported on simplex parts.\n"));
            status |= CS_ERROR;
        }
    }
    else
    {
        /* These traceloss settings are for the driver only */
        bad_state = rules->rx_if.dplx_host_eq.traceloss == CS_HSIO_TRACE_LOSS_15dB ||
                    rules->rx_if.dplx_host_eq.traceloss == CS_HSIO_TRACE_LOSS_27dB ||
                    rules->rx_if.dplx_host_eq.traceloss == CS_HSIO_TRACE_LOSS_CR4  ||
                    rules->rx_if.dplx_host_eq.traceloss == CS_HSIO_TRACE_LOSS_LAB  ||
                    rules->rx_if.dplx_line_eq.traceloss == CS_HSIO_TRACE_LOSS_15dB ||
                    rules->rx_if.dplx_line_eq.traceloss == CS_HSIO_TRACE_LOSS_27dB ||
                    rules->rx_if.dplx_line_eq.traceloss == CS_HSIO_TRACE_LOSS_CR4  ||
                    rules->rx_if.dplx_line_eq.traceloss == CS_HSIO_TRACE_LOSS_LAB;
        if (bad_state)
        {
            CS_TRACE(("ERROR: Traceloss settings of 15/27dB or CR4/LAB are for the tx_if.*_driver.traceloss setting only.\n"));
            status |= CS_ERROR;
        }
    }

    /* validate the refclk is correct */
    if((rules->ref_clk_rate > 180000) || (rules->ref_clk_rate < 50000))
    {
        /* ref clk can only be 50-180MHz */
        CS_TRACE(("ERROR: ref_clk_rate is the internal reference clock rate, which can only be between 50MHz and 180MHz.\n"
                  "If you are using the REFDIV2_ENB pin then divide your refclk rate by two for the ref_clk_rate value\n"));
        status |= CS_ERROR;
    }

    if (status != CS_OK)
    {
        CS_TRACE(("ERROR: bad rules config on slice %x\n",slice));
    }
    return status;
}

/**
 * This method is called to put slice(s) into KR single or multi-port operational state.
 *
 * @param master_slice [I] - The KR master slice number, range: 0 to CS4224_MAX_NUM_PORTS()
 * @param rules        [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_slice_enter_operational_state_kran(
    cs_uint32 master_slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    e_cs4224_kran_an_status_t  kran_done = CS4224_KRAN_AN_NOT_DONE;
    cs4224_kran_results_t_s    an_results;
    cs_uint32 base_slice;
    cs_uint32 die = cs4224_get_die_from_slice(master_slice);
    cs_uint16 data = 0;

    if ((rules->application != CS4224_TARGET_APPLICATION_10G_KR) &&
        (rules->application != CS4224_TARGET_APPLICATION_40G_KR) &&
        (rules->application != CS4224_TARGET_APPLICATION_KRAN))
    {
        CS_TRACE(("ERROR: This method used for KR-AN applications only, use cs4224_slice_enter_operational_state instead\n"));
        status |= CS_ERROR;
        return status;
    }

    /* force the application to KRAN */
    rules->application = CS4224_TARGET_APPLICATION_KRAN;

    /* force this rule to false as it is incompatible with KR */
    rules->mseq_dyn_reconfig = FALSE;

    /* Before we do anything, do some sanity checking of the rules */
    status |= cs4224_check_rules(master_slice, rules);
    if (status != CS_OK)
    {
        return status;
    }

    /* Before configuring the device, the die MUST have been reset and the EEPROM
     * must already be loaded (if an EEPROM is available). Otherwise this method
     * will exit immediately because it's unsafe to configure the device in this
     * state.
     */
    status |= cs4224_reg_get(die, CS4224_GLOBAL_SCRATCH6, &data);
    if(CS_IF_CLR(data, CS_BIT1))
    {
        CS_TRACE(("ERROR: cs4224_hard_reset method has not been run on die 0x%x before attempting to configure.\n"
                  "Please read the documentation 'How to Initialize the Device', this *MUST* be done prior to configuration.\n"
                  "Exiting cs4224_slice_enter_operational_state prematurely\n", die));
        return CS_ERROR;
    }
    if( !cs4224_is_eeprom_finished(die) )
    {
        CS_TRACE(("ERROR: EEPROM is still loading on die 0x%x while attempting to configure.\n"
                  "This should never happen while using the API correctly; please contact your Cortina AE for support.\n"
                  "Exiting cs4224_slice_enter_operational_state prematurely\n", die));
        return CS_ERROR;
    }
    
    /* identify the base slice of the die (in case were doing multi-port KR) */
    if ((master_slice & 0x000000FF) < 4)
    {
        base_slice = (master_slice & 0xFFFFFF00) + 0;
    }
    else
    {
        base_slice = (master_slice & 0xFFFFFF00) + 4;
    }

    /* if advertising multi-port KR (and possibly a single port) */
    if ((rules->kran.data_rates & CS4224_KRAN_DATA_RATE_FP_40G) ||
        (rules->kran.data_rates & CS4224_KRAN_DATA_RATE_BP_40G) ||
        (rules->kran.data_rates & CS4224_KRAN_DATA_RATE_BP_KX4))
    {
        /* configure the 4 data-paths */
        status |= cs4224_slice_enter_operational_state(base_slice + 0, rules);
        status |= cs4224_slice_enter_operational_state(base_slice + 1, rules);
        status |= cs4224_slice_enter_operational_state(base_slice + 2, rules);
        status |= cs4224_slice_enter_operational_state(base_slice + 3, rules);
    }
    else /* advertising only single-port KR (no multi-port) */
    {
        /* configure the 1 data-path */
        status |= cs4224_slice_enter_operational_state(master_slice, rules);
    }

    status |= cs4224_init_kran(master_slice, rules);

    if (rules->kran.wait_for_an_done == TRUE)
    {
        if(rules->kran.poll_kran_callback.fcn_ptr != NULL)
        {
            kran_done = ((CS4224_KRAN_CALLBACK)(rules->kran.poll_kran_callback.fcn_ptr))(master_slice, &an_results, NULL);
        }
        else 
        {
            kran_done = cs4224_kran_wait_for_an(master_slice, &an_results, NULL);
            if (status != CS_OK)
            {
                CS_TRACE(("ERROR: KR-AN not done\n"));
            }
        }

        if (kran_done == CS4224_KRAN_AN_DONE)
        {
            /* if multi-port KR negotiated */
            if ((an_results.bp_10gkx4) || (an_results.bp_40gcr4) || (an_results.bp_40gkr4))
            {
                /* post-configure the 4 data-paths */
                status |= cs4224_kran_init_kr_post_an(base_slice + 0, rules, &an_results);
                status |= cs4224_kran_init_kr_post_an(base_slice + 1, rules, &an_results);
                status |= cs4224_kran_init_kr_post_an(base_slice + 2, rules, &an_results);
                status |= cs4224_kran_init_kr_post_an(base_slice + 3, rules, &an_results);
            }
            else /* single-port KR negotiated */
            {
                /* post-configure the 1 data-path */
                status |= cs4224_kran_init_kr_post_an(master_slice, rules, &an_results);
            }
            if (status != CS_OK)
            {
                CS_TRACE(("ERROR: KR-AN Post-AN returned error\n"));
            }
        }
        else
        {
            CS_TRACE(("ERROR: KR-AN not Done\n"));
            status = CS_ERROR;
        }
    }

    return status;
}

/**
 * This method is called to put 4 slices into KR 40G operational state.
 *
 * @param master_slice [I] - The KR master slice number, range: 0 to CS4224_MAX_NUM_PORTS()
 * @param rules        [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @deprecated
 *    This method has been deprecated. Use the cs4224_slice_enter_operational_state_kran() method
 *    instead.
 */
cs_status cs4224_slice_enter_operational_state_kran_40g(
    cs_uint32 master_slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    status = cs4224_slice_enter_operational_state_kran(master_slice, rules);
  
    return status;
}

/**
 * This method is called to manage the programming of the microcode to the device. The
 * microcode is split between FC and KR images due to limiations in the size of the
 * on-board program store.
 *
 * DEBUG BRAD:
 *    This method should check the existing microcode and determine whether
 *    it needs to be reprogrammed (FC vs. KR) and whether die broadcast can
 *    be enabled. In the future it will likely need to be updated to handle
 *    FC vs. KR on a per micro-sequencer basis.
 *
 * @private
 */
cs_status cs4224_manage_ucode_download(
    cs_uint32       slice,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;

    cs_uint16       timestamp[2] = {0xffff, 0xffff};
    cs_uint16       yyyy, mmdd, hhmm;
    cs_uint32       die, other_die;
    cs_boolean      die_broadcast = FALSE;
    cs_uint16       version_kr, version_fc;
    const char*     ucode_path   = NULL;
    unsigned short* ucode_image  = NULL;
    cs_uint32       size_image   = 0;
    cs_boolean      stalled = FALSE;
    e_cs4224_ucode_image  required_image = CS4224_UCODE_IMAGE_ANY;
    e_cs4224_ucode_image  loaded_image   = CS4224_UCODE_IMAGE_NONE;

    /* die being programmed */
    die = cs4224_get_die_from_slice(slice);
    /* the other die */
    other_die = die ^ 0x1;
    
    cs4224_lock(slice);

    /* Check to see if the microcode has already been programmed */
    status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_TIMESTAMP0, &timestamp[0]);
    status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_VERSION_KR, &version_kr);
    status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_VERSION_FC, &version_fc);

    if (cs4224_max_num_dies == 2)
    {
        status |= cs4224_reg_get(other_die, CS4224_GLOBAL_UCODE_TIMESTAMP0, &timestamp[1]);
    }
    cs4224_unlock(slice);

    /* decide if we should broadcast ucode to both dies */
    if (rules->enable_die_broadcast && \
        (cs4224_max_num_dies == 2) && \
        (timestamp[0] == 0) && (timestamp[1] == 0) )
    {
        die_broadcast = TRUE;
    }

    /* apply die workarounds, if necessary */
    status |= cs4224_apply_workarounds(die);
    if(die_broadcast)
    {
        status |= cs4224_apply_workarounds(other_die);
    }
    if(CS_OK != status)
    {
        return status;
    }

    
    /* determine what our microcode requirements are */
    if(CS4224_TARGET_APPLICATION_KRAN == rules->application)
    {
        required_image = CS4224_UCODE_IMAGE_KR;
    }
    else if(CS4224_TARGET_APPLICATION_FCAN == rules->application)
    {
        required_image = CS4224_UCODE_IMAGE_FC;
    }

    /* determine what is currently loaded */
    if (version_kr != 0)
    {
        loaded_image = CS4224_UCODE_IMAGE_KR;
    } 
    else if (version_fc != 0)
    {
        loaded_image = CS4224_UCODE_IMAGE_FC;
    } 

    /* if the currently loaded ucode is not what we need */
    if ((loaded_image & required_image) == 0)
    {
        if(required_image == CS4224_UCODE_IMAGE_FC)
        {
#if defined(CS_HAS_FILESYSTEM)
            ucode_path = rules->ucode_fc_path;
#endif /* CS_HAS_FILESYSTEM */
            ucode_image = cs4224_fc_ucode_image;
            size_image  = sizeof(cs4224_fc_ucode_image)/sizeof(unsigned short);
        }
        else 
        {
#if defined(CS_HAS_FILESYSTEM)
            ucode_path = rules->ucode_kr_path;
#endif
            ucode_image = cs4224_kr_ucode_image;
            size_image  = sizeof(cs4224_kr_ucode_image)/sizeof(unsigned short);
        }
    
        if (die_broadcast)
        {
            /* If the path is not NULL then load from file instead of inlined
               microcode */
            if(ucode_path != NULL)
            {
                CS_TRACE(("ERROR: Cannot currently broadcast program ucode from file\n"));
                return CS_ERROR;
            }
            else
            { 
                CS_PRINTF(("Broadcasting image\n"));
                /* broadcast to both dies */
                status |= cs4224_ucode_data_prgm_image_broadcast(
                    slice,
                    ucode_image,
                    size_image);
            }
        }
        else /* unicast */ 
        {
            /* If the path is not NULL then load from file instead of inlined
               microcode */
            if(ucode_path != NULL)
            {
#if defined(CS_HAS_FILESYSTEM)
                status |= cs4224_ucode_data_prgm_from_file(slice, ucode_path);
#else
                CS_TRACE(("ERROR: File system support not defined, please define CS_HAS_FILESYSTEM to load ucode from file\n"));
                return CS_ERROR;
#endif
            }
            else
            {
                CS_PRINTF(("Unicasting image\n"));
                /* only broadcast to single die */
                status |= cs4224_ucode_data_prgm_image(
                    slice,
                    ucode_image,
                    size_image);
            }
        }
        
        /* check that the ucode programmed correctly */
        if(CS_OK != status)
        {
            CS_TRACE(("ERROR downloading microcode to device, exiting early\n"));
            return status;
        }
        
        /* check if post-setup in the ucode image unstalled the mseqs (it shouldn't)
         * Note you can check any mseq on this die, since they should all be configured
         * equally
         */
        status |= cs4224_query_mseq_is_stalled(slice, CS4224_DPLX_LINE_MSEQ, &stalled);
        if(!stalled)
        {
            /* Iterate over all the slices on this die */
            cs_uint32 first_slice = 0;
            cs_uint32 last_slice = 0;
            cs_uint32 mid_slice = CS4224_MAX_NUM_SLICES(slice) / 2;
            cs_uint32 upper_bits = slice & 0xffffff00;
            cs_uint8 i = 0;
            cs_uint32 slice_i = 0;
            
            
            if(die_broadcast || CS4224_MAX_NUM_DIES(slice) == 1)
            {
                /* reset all the slices */
                first_slice = 0;
                last_slice = CS4224_MAX_NUM_SLICES(slice) - 1;
            }
            else
            {
                /* only reset mseqs on this die */
                if(slice < mid_slice)
                {
                    first_slice = 0;
                    last_slice = mid_slice - 1;
                }
                else
                {
                    first_slice = mid_slice;
                    last_slice = CS4224_MAX_NUM_SLICES(slice) - 1;
                }
            }
            
            for(i = first_slice; i <= last_slice; i++)
            {
                slice_i = upper_bits | i;
                
                /* stall the microsequencer(s) again */
                if (cs4224_is_hw_simplex(slice_i))
                {
                    status |= cs4224_mseq_stall(slice_i, CS4224_SPLX_MSEQ, TRUE);
                }
                else
                {
                    status |= cs4224_mseq_stall(slice_i, CS4224_DPLX_LINE_MSEQ, TRUE);
                    status |= cs4224_mseq_stall(slice_i, CS4224_DPLX_HOST_MSEQ, TRUE);
                }
            }
        } /* stall mseq block */
        
        /* re-apply some die workarounds that got removed in the ucode download */
        status |= cs4224_apply_post_ucode_dwld_workarounds(die);
        if(die_broadcast)
        {
            status |= cs4224_apply_post_ucode_dwld_workarounds(other_die);
        }
        
    } /* pgm ucode block */
    
    if (rules->show_debug_info)
    {
        /* Get the timestamp of the loaded microcode */
        status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_TIMESTAMP1, &yyyy);
        status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_TIMESTAMP0, &mmdd);
        status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_TIMESTAMP2, &hhmm);
        status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_VERSION_KR, &version_kr);
        status |= cs4224_reg_get(die, CS4224_GLOBAL_UCODE_VERSION_FC, &version_fc);
        /* Note that for now both KR and FC versions are set to 1 */
        if ((version_kr !=0) && (version_fc != 0))
        {
            CS_TRACE(("ERROR: Microcode version is both KR and FC, KR(v.%04x), FC(v.%04x) built on (yyyy/mmdd/hhmm) = %04x/%04x/%04x\n", 
                        version_kr, version_fc, yyyy, mmdd, hhmm));
            return CS_ERROR;
        }
        if (version_kr != 0)
        {
            CS_PRINTF(("Microcode image on die %x is KR(v.%04x), built on (yyyy/mmdd/hhmm) = %04x/%04x/%04x\n", die, version_kr, yyyy, mmdd, hhmm));
        }
        if (version_fc != 0)
        {
            CS_PRINTF(("Microcode image on die %x is FC(v.%04x), built on (yyyy/mmdd/hhmm) = %04x/%04x/%04x\n", die, version_fc, yyyy, mmdd, hhmm));
        }
        if (cs4224_max_num_dies == 2 && die_broadcast)
        {
            /* Get the timestamp of the other loaded microcode */
            status |= cs4224_reg_get(other_die, CS4224_GLOBAL_UCODE_TIMESTAMP1, &yyyy);
            status |= cs4224_reg_get(other_die, CS4224_GLOBAL_UCODE_TIMESTAMP0, &mmdd);
            status |= cs4224_reg_get(other_die, CS4224_GLOBAL_UCODE_TIMESTAMP2, &hhmm);
            status |= cs4224_reg_get(other_die, CS4224_GLOBAL_UCODE_VERSION_KR, &version_kr);
            status |= cs4224_reg_get(other_die, CS4224_GLOBAL_UCODE_VERSION_FC, &version_fc);
            if (version_kr != 0)
            {
                CS_PRINTF(("Microcode image on die %x is KR(v.%04x), built on (yyyy/mmdd/hhmm) = %04x/%04x/%04x\n", other_die, version_kr, yyyy, mmdd, hhmm));
            }
            if (version_fc != 0)
            {
                CS_PRINTF(("Microcode image on die %x is FC(v.%04x), built on (yyyy/mmdd/hhmm) = %04x/%04x/%04x\n", other_die, version_fc, yyyy, mmdd, hhmm));
            }
        }

    }

    /* power down all slices for bug #38832, only done if it hasn't been applied yet */
    status |= cs4224_apply_workarounds_power_down(die);
    if(die_broadcast)
    {
        status |= cs4224_apply_workarounds_power_down(other_die);
    }

    return status;
}

/**
 * This special method is used to change the rate of a single interface without
 * effecting the other interface, regardless of whether the slice is duplex or simplex.
 * 
 * 99% of the time you will want to just call cs4224_slice_enter_operational_state
 * to change slice configuration, since that method will handle ALL of the config.
 * 
 * This method is primarily used to change the rate of a single Rx interface for use with
 * multi-rate switching, where one slice is running at one rate and the mate slice running
 * at another different rate.
 * 
 * - Not tested for all configurations.
 * - Does not support FCAN or KRAN.
 * 
 * Contact your Cortina AE for proper usage.
 * 
 * @param slice [I] - The slice number of the device
 * @param intf  [I] - The line, host, or simplex Rx interface to change
 * @param rules [I] - The rules struct for configuring the device, will only look at clocking config
 * 
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_slice_change_rate_intf(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t intf,
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    e_cs4224_mseq_id mseq_id;
    cs_uint16 offset = 0;
    cs_uint16 data = 0;
    cs_boolean stalled = FALSE;
    e_cs4224_datapath_dir_t dir = CS4224_LINE_RX_TO_HOST_TX_DIR;
    e_cs4224_trace_loss trace_loss;
    cs_boolean auto_squelch = FALSE;
    cs_boolean power_savings = FALSE;
    
    e_cs4224_switch_action_t switch_mode;
    cs_boolean low_latency_mode;
    cs_uint32 other_slice = slice ^ 0x1;
    cs_uint32 base_slice = slice & ~0x1;
    e_cs4224_edc_mode edc_mode;

    status |= cs4224_get_cfg_side(slice, &intf);
    if(CS_OK != status)
    {
        return status;
    }
    
    /* simplex rules are different than duplex rules */
    if(cs4224_is_hw_simplex(slice))
    {
        trace_loss = rules->tx_if.splx_driver.traceloss;
        edc_mode   = rules->rx_if.splx_edc_mode;
    }
    else if(CS4224_CFG_LINE_SIDE == intf)
    {
        trace_loss = rules->tx_if.dplx_host_driver.traceloss;
        edc_mode   = rules->rx_if.dplx_line_edc_mode;
    }
    else
    {
        trace_loss = rules->tx_if.dplx_line_driver.traceloss;
        edc_mode   = rules->rx_if.dplx_host_edc_mode;
    }
    
    /* intf gets translated to line/host by cs4224_get_cfg_side */
    if(CS4224_CFG_LINE_SIDE == intf)
    {
        mseq_id    = CS4224_DPLX_LINE_MSEQ;
        offset     = 0;
        dir        = CS4224_LINE_RX_TO_HOST_TX_DIR;
    }
    else
    {
        mseq_id    = CS4224_DPLX_HOST_MSEQ;
        offset     = CS4224_LINE_TO_HOST_OFFSET;
        dir        = CS4224_HOST_RX_TO_LINE_TX_DIR;
    }
    
    if(rules->show_debug_info)
    {
        CS_PRINTF(("Changing rate to %s with %s on %s Rx slice %x\n", \
                    cs4224_translate_app_mode(rules->application), \
                    cs4224_translate_cfg_side((e_cs4224_cfg_sides_t)dir), \
                    cs4224_translate_edc_mode(edc_mode), \
                    slice));
    }
    
    /* does not support FCAN/KRAN */
    if(    rules->application == CS4224_TARGET_APPLICATION_KRAN
        || rules->application == CS4224_TARGET_APPLICATION_10G_KR
        || rules->application == CS4224_TARGET_APPLICATION_FCAN
        || rules->application == CS4224_TARGET_APPLICATION_40G_KR )
    {
        CS_TRACE(("ERROR: This method does not support KRAN or FCAN.\n"));
        return CS_ERROR;
    }
    
    /* determine what switch mode we are in. That will determine how the driver settings get updated */
    status |= cs4224_switch_query_mode(base_slice, &switch_mode, &low_latency_mode);
    
    /* in certain broadcast configs you will break things if you call this method on the wrong
     * interfaces. Check those conditions now before doing anything */
    switch(switch_mode)
    {
        case CS4224_SWITCH_DISABLE:
        case CS4224_SWITCH_DUPLEX_SWITCH_2x2:
        {
            break;
        }
        case CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0:
        case CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1:
        {
            if(slice != base_slice && intf == CS4224_CFG_HOST_SIDE)
            {
                CS_TRACE(("WARNING: mate-slice %x host-side Rx is disabled in 0-X broadcast, you cannot call this method on that intf. See the multi-rate switch example!\n",slice));
                return CS_OK;
            }
            break;
        }
        case CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0:
        case CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1:
        {
            if(slice == base_slice && intf == CS4224_CFG_HOST_SIDE)
            {
                CS_TRACE(("WARNING: base-slice %x host-side Rx is disabled in 1-X broadcast, you cannot call this method on that intf. See the multi-rate switch example!\n",slice));
                return CS_OK;
            }
            break;
        }
        default:
        {
            CS_TRACE(("ERROR: Unsupported switch mode %s\n", cs4224_switch_translate_state(switch_mode)));
            return CS_ERROR;
            break;
        }
    }
    
    status |= cs4224_query_mseq_is_stalled(slice, mseq_id, &stalled);
    if(!stalled)
    {
        status |= cs4224_mseq_stall(slice, mseq_id, TRUE);
    }
    
    /* get some config, and re-apply it after we're done here */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB + offset, &data);
    auto_squelch = CS_IF_SET(data,CS_BIT2);
    power_savings = CS_IF_SET(data,CS_BIT1);
    
    status |= cs4224_config_target_application_intf(slice, intf, rules);
    
    status |= cs4224_update_clkdiv_ctrl_intf(slice, intf, rules);
    
    if(rules->fracdiv.enable)
    {
        /* function is a bit outdated, doesn't have checks for fracdiv.enable */
        status |= cs4224_fracdiv_cdr_init(slice, intf, rules->fracdiv.divisor, rules->fracdiv.numerator);
    }
    
    status |= cs4224_init_edc_mode_intf(slice, rules, mseq_id);

    /* changing the EDC mode overwrites a lot of config, undo those changes */
    status |= cs4224_mseq_squelch_ctrl(slice, dir, auto_squelch);
    status |= cs4224_mseq_enable_power_savings(slice, mseq_id, power_savings);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + offset, 0x0000);

    status |= cs4224_init_alt_coarse_tuning_intf(slice, intf, rules);

    /* set power_down temporarily */
    /* status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + offset, &data); */
    data = 0;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + offset, 0x01e7);
    CS_UDELAY(100);
    /* init VCOs after power down */
    status |= cs4224_init_vco(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_CONTROL + offset);
    /* if too much stuff needs to be powered up, then stagger it to reduce supply spikes */
    if ((data & 0x1c0) != 0x1c0)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + offset, (data | 0x1f));
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB + offset, data);

    switch(switch_mode)
    {
        case CS4224_SWITCH_DISABLE:
        {
            status |= cs4224_init_driver_trace_loss_intf(slice, dir, trace_loss);
            break;
        }
        case CS4224_SWITCH_DUPLEX_SWITCH_2x2:
        {
            status |= cs4224_init_driver_trace_loss_intf(other_slice, dir, trace_loss);
            break;
        }
        case CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0:
        {
            if(slice == base_slice)
            {
                status |= cs4224_init_driver_trace_loss_intf(slice, dir, trace_loss);
                if(intf == CS4224_CFG_HOST_SIDE)
                {
                    /* host Rx goes to both line Tx's */
                    status |= cs4224_init_driver_trace_loss_intf(other_slice, dir, trace_loss);
                }
            }
            break;
        }
        case CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1:
        {
            if(slice == base_slice && intf == CS4224_CFG_HOST_SIDE)
            {
                /* host Rx goes to both line Tx's */
                status |= cs4224_init_driver_trace_loss_intf(other_slice, dir, trace_loss);
                status |= cs4224_init_driver_trace_loss_intf(slice, dir, trace_loss);
            }
            else if (slice != base_slice && intf == CS4224_CFG_LINE_SIDE)
            {
                status |= cs4224_init_driver_trace_loss_intf(other_slice, dir, trace_loss);
            }
            break;
        }
        case CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0:
        {
            if(slice != base_slice && intf == CS4224_CFG_HOST_SIDE)
            {
                /* host Rx goes to both line Tx's */
                status |= cs4224_init_driver_trace_loss_intf(other_slice, dir, trace_loss);
                status |= cs4224_init_driver_trace_loss_intf(slice, dir, trace_loss);
            }
            else if(slice == base_slice && intf == CS4224_CFG_LINE_SIDE)
            {
                status |= cs4224_init_driver_trace_loss_intf(other_slice, dir, trace_loss);
            }
            break;
        }
        case CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1:
        {
            if(slice != base_slice)
            {
                status |= cs4224_init_driver_trace_loss_intf(slice, dir, trace_loss);
                if(intf == CS4224_CFG_HOST_SIDE)
                {
                    /* host Rx goes to both line Tx's */
                    status |= cs4224_init_driver_trace_loss_intf(other_slice, dir, trace_loss);
                }
            }
            break;
        }
        default:
        {
            /* already handled above, but error out here just in case */
            return CS_ERROR;
        }
    }

    if(!stalled)
    {
        status |= cs4224_mseq_stall(slice, mseq_id, FALSE);
    }

    return status;
}

/**
 * This method is called to put a slice or channel of the device into
 * operational state or to dynamically switch between applications (i.e. from 1G to 10G).
 * This is the main initialization method of the API. It configures the
 * channel of the device and manages programming the microcode when required.
 *
 * *Microcode Programming:*
 * =======================
 * The microcode is programmed on a per-die basis. The programming
 * is managed automatically by this method. If it is not already programmed
 * by a previous call to this method (or loaded from an external EEPROM)
 * it is possible that the first call to this method may delay as it
 * programs the microcode. Please refer to the data sheet for the expected
 * duration of the microcode programming.
 *
 * @param slice [I] - The slice number of the device to access
 *
 *                        range: 0..15 simplex or 0..7 duplex.
 * @param rules [I] - The rules for configuring the device.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 *
 *   cs4224_rules_t rules;
 *
 *   // Default the rules for applications in the 10G range.
 *   cs4224_rules_set_default(CS4224_TARGET_APPLICATION_10G, &rules);
 *
 *   // Customize the rules to support OC48 traffic from
 *   // a 155.52MHz reference.
 *   rules.clkdiv.enable = TRUE;
 *   rules.clkdiv.rdiv = CS4224_RDIV_DIV64;
 *   rules.clkdiv.ddiv = CS4224_DDIV_DIV2;
 *
 *   // Put the device into operational state
 *   cs4224_slice_enter_operational_state(slice, &rules);
 *
 */
cs_status cs4224_slice_enter_operational_state(
    cs_uint32 slice, 
    cs4224_rules_t* rules)
{
    cs_status status = CS_OK;
    cs_uint32 die = cs4224_get_die_from_slice(slice); /* will initialize the sku */
    cs_uint16 data = 0;
    cs_uint16 mate_sel_0;
    cs_uint16 mate_sel_1;

    cs4224_sku_hw_id = CS4224_HW_UNDEF;

    /* Before we do anything, do some sanity checking of the rules */
    status |= cs4224_check_rules(slice, rules);
    if(CS_OK != status)
    {
        return status;
    }

    /* Before configuring the device, the die MUST have been reset and the EEPROM
     * must already be loaded (if an EEPROM is available). Otherwise this method
     * will exit immediately because it's unsafe to configure the device in this
     * state.
     */
    status |= cs4224_reg_get(die, CS4224_GLOBAL_SCRATCH6, &data);
    if(CS_IF_CLR(data, CS_BIT1))
    {
        CS_TRACE(("ERROR: cs4224_hard_reset method has not been run on die 0x%x before attempting to configure.\n"
                  "Please read the documentation 'How to Initialize the Device', this *MUST* be done prior to configuration.\n"
                  "Exiting cs4224_slice_enter_operational_state prematurely\n", die));
        return CS_ERROR;
    }
    if( !cs4224_is_eeprom_finished(die) )
    {
        CS_TRACE(("ERROR: EEPROM is still loading on die 0x%x while attempting to configure.\n"
                  "This should never happen while using the API correctly; please contact your Cortina AE for support.\n"
                  "Exiting cs4224_slice_enter_operational_state prematurely\n", die));
        return CS_ERROR;
    }
    
   

    /* Program the API version number */
    status |= cs4224_init_api_version(slice);

    /* Increment the slice configure count */
    status |= cs4224_update_scratch_regs(slice);
    
    /* Reset any static state stored by the slice */
    cs4224_reset_static_state_for_slice(slice);
    
    /* stall the microsequencer(s), always */
    if (cs4224_is_hw_simplex(slice))
    {
        status |= cs4224_mseq_stall(slice, CS4224_SPLX_MSEQ, TRUE);
    }
    else
    {
        status |= cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, TRUE);
        status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, TRUE);
    }
    
    /* Re-assert the squelch after stalling the microsequencer if it is not
     * already squelched */
    if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH, 0x0001);

    }
    if (cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH, 0x0001);
    }
    
    if ((cs4224_is_hw_simplex(slice) && (rules->rx_if.splx_edc_mode      == CS_HSIO_EDC_MODE_DISABLED)) ||
        (cs4224_is_hw_duplex(slice)  && (rules->rx_if.dplx_line_edc_mode == CS_HSIO_EDC_MODE_DISABLED)) ||
        (cs4224_is_hw_duplex(slice)  && (rules->rx_if.dplx_host_edc_mode == CS_HSIO_EDC_MODE_DISABLED)))
    {
        /* When using an eeprom image the mseq can set the squelch bit before we
         * are able to stall it. This will force the bit high if we're in 
         * disabled mode and the mseq won't be unstalled.
         */
        rules->unsquelch_driver = TRUE;
    }

    /* dump out debug info */
    if (rules->show_debug_info == TRUE)
    {
        status |= cs4224_dump_debug_info(slice, rules);
    }

    /* Apply post-reset configuration and program the microcode */
    status |= cs4224_manage_ucode_download(slice, rules);
    if(CS_OK != status)
    {
        /* ucode download has a lot of potential to go wrong, exit early */
        CS_TRACE(("ERROR: Ucode download on slice %x failed, exiting early...\n",slice));
        return status;
    }

    /* Apply a soft reset to put the slice in a known state. This only really helps dynamic reconfig.
     */
    if(rules->application != CS4224_TARGET_APPLICATION_FCAN)
    {
        status |= cs4224_slice_soft_reset(slice);
    }
    else /* app == FCAN */
    {
        /* only soft reset FCAN if no digital switch applied since we don't want to blow away the switch config
        */
        status |= cs4224_reg_get_channel(slice,   CS4224_PP_HOST_HOSTMISC_MATE_SELECT, &mate_sel_0);
        status |= cs4224_reg_get_channel(slice+1, CS4224_PP_HOST_HOSTMISC_MATE_SELECT, &mate_sel_1);

        if ((mate_sel_0 == 0) && (mate_sel_1 == 0))
        {
            /* no switch applied */
            status |= cs4224_slice_soft_reset(slice);
        } 
        else
        {
            /* cs4224_slice_soft_reset will automatically back out slice power down workarounds,
             * so if we don't reset then backout those workarounds directly (Bug #38832)
             */
            status |= cs4224_restore_powered_down_regs(slice);
        }
    }

    
    
    status |= cs4224_config_target_application(slice, rules);

    status |= cs4224_update_clkdiv_ctrl(slice, rules);

    status |= cs4224_init_driver_trace_loss(slice, rules);

    status |= cs4224_init_edc_mode_set(slice, rules);

    status |= cs4224_update_cdr_fracn(slice, rules);

    if (cs4224_is_hw_simplex(slice))
    {
        status |= cs4224_mseq_enable_power_savings(slice, CS4224_SPLX_MSEQ, rules->enable_power_savings);
    }
    else
    {
        if (rules->application != CS4224_TARGET_APPLICATION_FCAN)
        {
            /* the FC-AN ucode configures the line side DFE mode, do not muck around with power savings here... */
            status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_LINE_MSEQ, rules->enable_power_savings);
        }
        status |= cs4224_mseq_enable_power_savings(slice, CS4224_DPLX_HOST_MSEQ, rules->enable_power_savings);
    }

    status |= cs4224_init_alt_coarse_tuning(slice, rules);

    status |= cs4224_disable_tx_driver_if_req(slice, rules);

    status |= cs4224_init_synce(slice, rules);

    status |= cs4224_init_ac_decoupling_caps(slice, rules);

    status |= cs4224_enable_fec(slice, rules);

    status |= cs4224_enable_polarity_inv(slice, rules);

    status |= cs4224_init_mseq_dyn_reconfig(slice, rules);

    cs4224_lock(slice);

    /* Enable then trigger VCO coarse tuning */
    if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, &data);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x01e7);
        CS_MDELAY(1);
        /* init_vco has built-in delays after coarse tuning */
        status |= cs4224_init_vco(slice, CS4224_PP_LINE_SDS_COMMON_RXVCO0_CONTROL);
        if ((data & 0x1c0) != 0x1c0)
        {
            /* demux enabled, needs staggared power up */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, (data | 0x1f));
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, data);
    }
    if (cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, &data);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x01e7);
        CS_MDELAY(1);
        /* init_vco has built-in delays after coarse tuning */
        status |= cs4224_init_vco(slice, CS4224_PP_HOST_SDS_COMMON_RXVCO0_CONTROL);
        if ((data & 0x1c0) != 0x1c0)
        {
            /* demux enabled, needs staggared power up */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, (data | 0x1f));
        }
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, data);
    }
    
    if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_mseq_squelch_ctrl(slice, CS4224_LINE_RX_TO_HOST_TX_DIR, rules->tx_auto_squelch);
    }
    if (cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
    {
        status |= cs4224_mseq_squelch_ctrl(slice, CS4224_HOST_RX_TO_LINE_TX_DIR, rules->tx_auto_squelch);
    }
    
    /* Unsquelching before the microcode is unstalled to prevent ordering
     * issues. See bug #41747 for details. */
    if (rules->unsquelch_driver)
    {
        if (cs4224_is_hw_duplex(slice) || cs4224_line_rx_to_host_tx_dir(slice))
        {
            /* remove any pending squelch requests, it will be handled manually */
            status |= cs4224_clear_mailbox(slice, CS4224_DPLX_LINE_MSEQ);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH, 0x0000);
        }
        if (cs4224_is_hw_duplex(slice) || !cs4224_line_rx_to_host_tx_dir(slice))
        {
            /* remove any pending squelch requests, it will be handled manually */
            status |= cs4224_clear_mailbox(slice, CS4224_DPLX_HOST_MSEQ);
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH, 0x0000);
        }
    }
    

    /* do not start microsequencer if protocol running on the line side */
    if ((rules->application != CS4224_TARGET_APPLICATION_10G_KR) &&
        (rules->application != CS4224_TARGET_APPLICATION_40G_KR) &&
        (rules->application != CS4224_TARGET_APPLICATION_KRAN)   &&
        (rules->application != CS4224_TARGET_APPLICATION_FCAN) )
    {
        /* un-stall the microsequencer(s), if required */
        if (cs4224_is_hw_simplex(slice))
        {
            if (rules->rx_if.splx_edc_mode != CS_HSIO_EDC_MODE_DISABLED)
            {
                status |= cs4224_mseq_stall(slice, CS4224_SPLX_MSEQ, FALSE);
            }
        }
        else /* duplex */
        {
            if (rules->rx_if.dplx_line_edc_mode != CS_HSIO_EDC_MODE_DISABLED)
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_LINE_MSEQ, FALSE);
            }
            if (rules->rx_if.dplx_host_edc_mode != CS_HSIO_EDC_MODE_DISABLED)
            {
                status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, FALSE);
            }
        }
    }

    cs4224_unlock(slice);

    if (rules->application == CS4224_TARGET_APPLICATION_FCAN)
    {
        e_cs4224_fcan_an_status_t fcan_done;

        status |= cs4224_fcan_init_fc_pre_an(slice, rules);
        cs4224_debug_dump_fcan_setup(slice, rules);

        if (rules->fcan.wait_for_an_done == TRUE)
        {
            /* call the FC-AN callback method to wait for AN to complete */
            if(rules->fcan.poll_fcan_callback.fcn_ptr != NULL)
            {
                fcan_done = ((CS4224_FCAN_CALLBACK)(rules->fcan.poll_fcan_callback.fcn_ptr))(
                                                        slice, 
                                                        &(rules->fcan.negotiated_rate),
                                                        rules->fcan.poll_fcan_callback.user_data);
            }
            else
            {
                /* wait for 10s while the link tries to negotiate */
                fcan_done = cs4224_fcan_wait_for_an(slice, &(rules->fcan.negotiated_rate));
            }
            if (fcan_done == CS4224_FCAN_AN_DONE)
            {
                status |= cs4224_fcan_init_fc_post_an(slice, rules);
            }
            else
            {
                CS_TRACE(("WARNING: FCAN Link not established on slice %d after 10 seconds\n", (slice&0xFF)));
                status |= CS_ERROR;
            }
        }
    }

    return status;
}

/**
 *
 * This method accepts a slice argument and returns the die number
 * associated with it.
 *
 *  @param slice      [I] -  The slice number of the device
 *
 *  @return die, range 0, 1
 *
 *  @private
 *
 */

cs_uint32 cs4224_get_die_from_slice(
    cs_uint32 slice)
{
    cs_uint32 die = 0;
    e_cs4224_hardware_id hw_id = cs4224_hw_id(slice);
    
    /* Save the upper bits to pass thru to the die parameter */
    cs_uint32 upper_bits = slice & 0xffffff00;

    /* Re-map the channel to the appropriate physical die of
     * the device:
     *
     * CS4224/CS4210 (16 port simplex):
     *     channel/slice 0-7  are on die 1
     *     channel/slice 8-15 are on die 0
     *
     * CS4221 (10 port simplex):
     *     channel/slice 0-4 are on die 1
     *     channel/slice 5-9 are on die 0
     *
     * CS4343/CS4341 (8 port duplex):
     *     channel/slice 0-3 are on die 1
     *     channel/slice 4-7 are on die 0
     *
     * CS4223 (4 port duplex):
     *     channel/slice 0-3 are on die 0
     *
     * CS4227 (2 port duplex):
     *     channel/slice 0-1 are on die 0
     */

    switch(hw_id)
    { 
        case CS4224_HW_CS4223: /*  4 port duplex   */
        case CS4224_HW_CS4227: /*  2 port duplex   */
  
            die = 0;
            break;

        case CS4224_HW_CS4343: /*  8 port duplex   */
        case CS4224_HW_CS4341:
         
            /* Only the lower 8 bits belong to the API. They represent
             * the duplex channel (0-7) of the device. */
            if((slice & 0xFF) > 3)
            {
                die = 0;
            }
            else
            {
                die = 1;
            }
            break;

        case CS4224_HW_CS4224: /* 16 port simplex  */
        case CS4224_HW_CS4210:
         
            /* Only the lower 8 bits belong to the API. They represent
             * the simplex channel (0-15) of the device. */
            if((slice & 0xFF) > 7)
            {
                die = 0;
            }
            else
            {
                die = 1;
            }
            break;

        case CS4224_HW_CS4221: /* 10 port simplex */
         
            /* Only the lower 8 bits belong to the API. They represent
             * the duplex channel (0-9) of the device. */
            if((slice & 0xFF) > 4)
            {
                die = 0;
            }
            else
            {
                die = 1;
            }
            break;

        default:
            CS_TRACE(("ERROR: HW ID not valid, cannot return die. hw_id = %x\n", hw_id));
            die = 0;
            break;

    }

    return die | upper_bits;
}

/**
 * This method provides access a particular channel or port of
 * the device (simplex or duplex). This method should be used
 * instead of underlying cs4224_reg_get() method as it automatically handles
 * mapping of a channel/slice to the appropriate register in
 * the address map.
 *
 * *Port Pair Registers:*
 * ======================
 * When accessing a register in the port pair space such as
 * PP_LINE_SDS_COMMON_RX0_Config this method automatically
 * selects the appropriate die and port-pair instance of the register
 * based on the channel/slice.
 *
 * *Global Registers:*
 * ===================
 * When accessing a global register it automatically selects the
 * appropriate die of the package that the channel belongs to.
 *
 * @param slice [I] - The slice of the device being accessed. The
 *                    least significant bits represent the port 
 *                    or channel being accessed (simplex or duplex).
 *                    The upper bits are passed through to the lower
 *                    level APIs to access multiple devices.
 * @param addr  [I] - The address of the device to access.
 * @param data  [O] - The data returned from the register read.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 *
 * cs_uint16 reg_data = 0;
 *
 * // Read the RX0_Config register for slice/channel 2. Internally
 * // the API will select the correct port pair instance on the
 * // correct die of the package for this channel.
 * cs4224_reg_get_channel(2, CS4224_PP_LINE_SDS_COMMON_RX0_Config, &reg_data);
 *
 * // When reading a global register from slice/channel 2 this method
 * // automatically selects the appropriate die of the package.
 * cs4224_reg_get_channel(2, CS4224_GLOBAL_CHIP_ID_LSB, &reg_data);
 *
 */
cs_status cs4224_reg_get_channel(
    cs_uint32 slice, 
    cs_uint32 addr, 
    cs_uint16* data)
{
    cs_uint32 die = 0;
    cs_status status = CS_OK;
    
    /* If the address has not already been adjusted
     * then do the port pair adjustment here */
    if((addr >= 0x1000) && (addr < 0x5000))
    {
        /* CS_PRINTF(("before slice = %d, addr = %x\n", slice, addr)); */

        /* Mask out the upper bits if they have
         * already been adjusted */
        addr = (addr | 0x3000) & 0x1fff;

        /* guard against reading from bad SDS_DSP_MSEQ_IX...BASE3_INST registers */
        if (!cs4224_diags_register_can_read((cs_uint16) addr))
        {
            *data = 0xbeef; /* return 0xbeef to make it obvious this doesn't come from the chip */
            return CS_OK;
        }

        /* Now adjust them to access the proper
         * port pair */
        addr = cs4224_adj_pp(slice, addr); 
        
        /* CS_PRINTF(("after slice = %d, addr = %x\n", slice, addr));*/
    }
    /* Handle the MSEQ_PS space */
    else if((addr >= 0x300) && (addr < 0x500))
    {
        /* Mask out any upper bits if they have already been adjusted */
        addr = (addr | 0x300) & 0x3ff;

        addr = cs4224_adj_mseq(slice, addr);
    }

    /* get the die associated with this slice */
    die = cs4224_get_die_from_slice(slice);
    /* CS_PRINTF(("Get: slice=%d, die=%d, addr_old=0x%04x,addr_new=0x%04x\n", slice, die, addr_old, addr));*/

    /* Set the die but make sure to pass the upper 24 bits of the
     * slice parameter through to the lower level API. These are
     * used by the customer to address multiple devices */
    status |= cs4224_reg_get(die | (slice >> 8 << 8), addr, data);
    
    return status;
}

/**
 * This is a wrapper method around the cs4224_reg_get_channel()
 * method. It simply discards the return value and
 * returns the register value directly.
 *
 * @param slice [I] - The slice or port of the device to access
 * @param addr  [I] - The register address to read.
 *
 * @return The register value when successful, 0xDEAD when encountering an error
 * 
 */
cs_uint16 cs4224_reg_read(
    cs_uint32 slice,
    cs_uint32 addr)
{
    cs_uint16 data;
    cs_status status = CS_OK;

    status |= cs4224_reg_get_channel(slice, addr, &data);
    if(CS_OK != status)
    {
        CS_TRACE(("ERROR: reg get failed with return status %x, returning 0xDEAD\n",status));
        data = 0xDEAD;
    }

    return data;
}

/**
 * This method provides access a particular channel or port of
 * the device (simplex or duplex). This method should be used instead
 * of the underlying cs4224_reg_set() method as it automatically handles
 * the mapping of a channel/slice to the appropriate register in the
 * address map.
 *
 * *Port Pair Registers:*
 * ======================
 * When accessing a register in the port pair space such as
 * PP_LINE_SDS_COMMON_RX0_Config this method automatically
 * selects the appropriate die and port-pair instance of the register
 * based on the channel/slice.
 *
 * *Global Registers:*
 * ===================
 * When accessing a global register it automatically selects the
 * appropriate die of the package that the channel belongs to.
 *
 * @param slice [I] - The slice of the device being accessed. The
 *                    least significant bits represent the port 
 *                    or channel being accessed (simplex or duplex).
 *                    The upper bits are passed through to the lower
 *                    levels to access multiple devices.
 * @param addr  [I] - The address of the device to access.
 * @param data  [O] - The data returned from the register read.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @example
 *
 * cs_uint16 reg_data = 0;
 *
 * // Set the RX0_Config register for slice/channel 2. Internally
 * // the API will select the correct port pair instance on the
 * // correct die of the package for this channel.
 * cs4224_reg_set_channel(2, CS4224_PP_LINE_SDS_COMMON_RX0_Config, reg_data);
 *
 * // When write a global register from slice/channel 2 this method
 * // automatically selects the appropriate die of the package.
 * cs4224_reg_set_channel(2, CS4224_GLOBAL_SCRATCH, reg_data);
 */
cs_status cs4224_reg_set_channel(
    cs_uint32 slice, 
    cs_uint32 addr, 
    cs_uint16 data)
{
    cs_uint32 die = 0;

    /* If the PP address has not already been adjusted
     * then do the port pair adjustment here */
    if((addr >= 0x1000) && (addr < 0x5000))
    {
        /*CS_PRINTF(("before slice = %d, addr = %x\n", slice, addr));*/

        /* Mask out the upper bits if they have
         * already been adjusted */
        addr = (addr | 0x3000) & 0x1fff;

        /* Now adjust them to access the proper
         * port pair */
        addr = cs4224_adj_pp(slice, addr); 

        /*CS_PRINTF(("after slice = %d, addr = %x\n", slice, addr));*/
    }
    /* Handle the MSEQ_PS space */
    else if((addr >= 0x300) && (addr < 0x500))
    {
        /* Mask out any upper bits if they have already been adjusted */
        addr = (addr | 0x300) & 0x3ff;

        addr = cs4224_adj_mseq(slice, addr);
    }

    /* get the die associated with this slice */
    die = cs4224_get_die_from_slice(slice);
    /* CS_PRINTF(("Set: slice=%d, die=%d, addr_old=0x%04x,addr_new=0x%04x\n", slice, die, addr_old, addr));*/

    /* Set the die but make sure to pass the upper 24 bits of the
     * slice parameter through to the lower level API. These are
     * used by the customer to address multiple devices */
    return cs4224_reg_set(die | (slice >> 8 << 8), addr, data);
}

/**
 * This method will use the reg_get_channel and reg_set_channel functions to
 *  write to, and then veryify a register. It's used in the case where MSEQ
 *  could potentially overwrite a register without it being obvious to the user.
 *
 * @param slice [I] - The slice of the device being accessed. The
 *                    least significant bits represent the port 
 *                    or channel being accessed (simplex or duplex).
 *                    The upper bits are passed through to the lower
 *                    levels to access multiple devices.
 * @param addr  [I] - The address of the device to access.
 * @param data  [O] - The data returned from the register read.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 */
cs_status cs4224_reg_set_chk_channel(
    cs_uint32 slice, 
    cs_uint32 addr, 
    cs_uint16 data)
{
    cs_status status = CS_OK;
    cs_uint16 get_data = 0;

    status |= cs4224_reg_set_channel(slice, addr, data);
    status |= cs4224_reg_get_channel(slice, addr, &get_data);
    if(get_data != data)
    {
        CS_TRACE(("ERROR: Data was not correctly written to register\n"));
        CS_PRINTF(("reg addr: %4x data written: %4x data read: %4x\n", addr, data, get_data));
        status |= CS_ERROR;
    }
    return status;
}

/**
 * This method prints detailed info about the microcode load
 * 
 *  @param slice       [I] -  The slice number of the device to access.
 */
void cs4224_debug_ucode_show_version(
    cs_uint32 slice)
{
  cs_uint16 version_sr;
  cs_uint16 version_cx1;
  cs_uint16 version_kr;
  cs_uint16 version_zr;
  cs_uint16 version_fc;
  cs_uint16 timestamp0;
  cs_uint16 timestamp1;
  cs_uint16 timestamp2;
  cs_uint16 checksum_hw;
  cs_uint16 checksum_sw;
  cs_uint32 die;

  die = cs4224_get_die_from_slice(slice);

  cs4224_lock(slice);

  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_VERSION_SR,  &version_sr);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_VERSION_CX1, &version_cx1);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_VERSION_KR,  &version_kr);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_VERSION_ZR,  &version_zr);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_VERSION_FC,  &version_fc);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP0,  &timestamp0);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP1,  &timestamp1);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP2,  &timestamp2);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_DWNLD_CHECKSUM_HW, &checksum_hw);
  cs4224_reg_get_channel(slice, CS4224_GLOBAL_DWNLD_CHECKSUM_SW, &checksum_sw);

  cs4224_unlock(slice);

  CS_PRINTF(("+--------------------------+---------\n"));
  CS_PRINTF(("| uCode Registers (die=%x)  |   data\n", die));
  CS_PRINTF(("+--------------------------+---------\n"));
  CS_PRINTF(("| Compile year      (yyyy) |   %04x\n", timestamp1));
  CS_PRINTF(("| Compile month/day (mmdd) |   %04x\n", timestamp0));
  CS_PRINTF(("| Compile time      (hhmm) |   %04x\n", timestamp2));
  CS_PRINTF(("| HW calc checksum         | 0x%04x\n", checksum_hw));
  CS_PRINTF(("| SW calc checksum         | 0x%04x\n", checksum_sw));
  CS_PRINTF(("| SR  version              |   %4x\n",  version_sr));
  CS_PRINTF(("| CX1 version              |   %4x\n",  version_cx1));
  CS_PRINTF(("| KR  version              |   %4x\n",  version_kr));
  CS_PRINTF(("| ZR  version              |   %4x\n",  version_zr));
  CS_PRINTF(("| FC  version              |   %4x\n",  version_fc));
  CS_PRINTF(("+--------------------------+---------\n"));
}

/**
 * This method is called to translate an EDC mode into a human readable
 * string.
 *
 * @param edc_mode [I] - the mode to translate.
 *
 * @return The EDC mode as a string.
 */
const char* cs4224_translate_edc_mode(e_cs4224_edc_mode edc_mode)
{
    switch(edc_mode)
    {
        case CS_HSIO_EDC_MODE_DISABLED:
        {
            return "CS_HSIO_EDC_MODE_DISABLED";
        }
        case CS_HSIO_EDC_MODE_CX1:
        {
            return "CS_HSIO_EDC_MODE_CX1";
        }
        case CS_HSIO_EDC_MODE_SR:
        {
            return "CS_HSIO_EDC_MODE_SR";
        }
        case CS_HSIO_EDC_MODE_ZR:
        {
            return "CS_HSIO_EDC_MODE_ZR";
        }
        case CS_HSIO_EDC_MODE_DWDM:
        {
            return "CS_HSIO_EDC_MODE_DWDM";
        }
        case CS_HSIO_EDC_MODE_10G_BP:
        {
            return "CS_HSIO_EDC_MODE_10G_BP";
        }
        case CS_HSIO_EDC_MODE_15G_BP:
        {
            return "CS_HSIO_EDC_MODE_15G_BP";
        }
        case CS_HSIO_EDC_MODE_15G_BP_27dB:
        {
            return "CS_HSIO_EDC_MODE_15G_BP_27dB";
        }
        case CS_HSIO_EDC_MODE_5G_BP:
        {
            return "CS_HSIO_EDC_MODE_5G_BP";
        }
        case CS_HSIO_EDC_MODE_7p5G_BP:
        {
            return "CS_HSIO_EDC_MODE_7p5G_BP";
        }
        case CS_HSIO_EDC_MODE_8p5G_BP:
        {
            return "CS_HSIO_EDC_MODE_8p5G_BP";
        }
        case CS_HSIO_EDC_MODE_FCAN:
        {
            return "CS_HSIO_EDC_MODE_FCAN";
        }
        case CS_HSIO_EDC_MODE_SMLRM:
        {
            return "CS_HSIO_EDC_MODE_SMLRM";
        }

    }

    return "UNKNOWN EDC MODE";
}

/**
 * This method is called to translate an application mode into a human readable
 * string.
 *
 * @param app_mode [I] - the mode to translate.
 *
 * @return The app mode as a string.
 */
const char* cs4224_translate_app_mode(e_cs4224_target_application app_mode)
{
    switch (app_mode)
    {
        case CS4224_TARGET_APPLICATION_1G:
        {
            return "CS4224_TARGET_APPLICATION_1G";
        }
        case CS4224_TARGET_APPLICATION_5G:
        {
            return "CS4224_TARGET_APPLICATION_5G";
        }
        case CS4224_TARGET_APPLICATION_7p5G:
        {
            return "CS4224_TARGET_APPLICATION_7p5G";
        }
        case CS4224_TARGET_APPLICATION_8G:
        {
            return "CS4224_TARGET_APPLICATION_8G";
        }
        case CS4224_TARGET_APPLICATION_8p5G:
        {
            return "CS4224_TARGET_APPLICATION_8p5G";
        }
        case CS4224_TARGET_APPLICATION_10G:
        {
            return "CS4224_TARGET_APPLICATION_10G";
        }
        case CS4224_TARGET_APPLICATION_15G:
        {
            return "CS4224_TARGET_APPLICATION_15G";
        }
        case CS4224_TARGET_APPLICATION_10G_KR:
        {
            return "CS4224_TARGET_APPLICATION_10G_KR";
        }
        case CS4224_TARGET_APPLICATION_40G_KR:
        {
            return "CS4224_TARGET_APPLICATION_40G_KR";
        }
        case CS4224_TARGET_APPLICATION_KRAN:
        {
            return "CS4224_TARGET_APPLICATION_KRAN";
        }
        case CS4224_TARGET_APPLICATION_FCAN:
        {
            return "CS4224_TARGET_APPLICATION_FCAN";
        }
        case CS4224_TARGET_APPLICATION_16G_FC:
        {
            return "CS4224_TARGET_APPLICATION_16G_FC";
        }
        case CS4224_TARGET_APPLICATION_10G_FC:
        {
            return "CS4224_TARGET_APPLICATION_10G_FC";
        }
        case CS4224_TARGET_APPLICATION_8G_FC:
        {
            return "CS4224_TARGET_APPLICATION_8G_FC";
        }
        case CS4224_TARGET_APPLICATION_4G_FC:
        {
            return "CS4224_TARGET_APPLICATION_4G_FC";
        }
        case CS4224_TARGET_APPLICATION_2G_FC:
        {
            return "CS4224_TARGET_APPLICATION_2G_FC";
        }
        case CS4224_TARGET_APPLICATION_1G_FC:
        {
            return "CS4224_TARGET_APPLICATION_1G_FC";
        }
        case CS4224_TARGET_APPLICATION_OC12:
        {
            return "CS4224_TARGET_APPLICATION_OC12";
        }
    }

    return "UNKNOWN APP MODE";
}

/**
 * This method can be called to translate the switch mode/state into a
 * human readable format.
 *
 * @param state [I] - The input switch state to translate
 * 
 * @return The translated switch state
 */
const char* cs4224_switch_translate_state(e_cs4224_switch_action_t state)
{
    switch(state)
    {
        case CS4224_SWITCH_DISABLE:
            return "CS4224_SWITCH_DISABLE";
        case CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1:
            return "CS4224_SWITCH_DUPLEX_BROADCAST_1_to_1";
        case CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0:
            return "CS4224_SWITCH_DUPLEX_BROADCAST_0_to_0";
        case CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1:
            return "CS4224_SWITCH_DUPLEX_BROADCAST_0_to_1";
        case CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0:
            return "CS4224_SWITCH_DUPLEX_BROADCAST_1_to_0";
        case CS4224_SWITCH_DUPLEX_SWITCH_2x2:
            return "CS4224_SWITCH_DUPLEX_SWITCH_2x2";
        case CS4224_SWITCH_SIMPLEX_SWITCH_2x2:
            return "CS4224_SWITCH_SIMPLEX_SWITCH_2x2";
        case CS4224_SWITCH_SIMPLEX_BROADCAST:
            return "CS4224_SWITCH_SIMPLEX_BROADCAST";
        
        default:
            break;
    }
    
    return "???";
}

/**
 * This method can be called to translate the cfg side into a human readable format.
 * 
 * @param side [I] - The side to translate
 * 
 * @return The translated side
 */
const char* cs4224_translate_cfg_side(e_cs4224_cfg_sides_t side)
{
    switch(side)
    {
        case CS4224_CFG_HOST_SIDE:
            return "host";
        case CS4224_CFG_LINE_SIDE:
            return "line";
        case CS4224_CFG_SIMPLEX:
            return "splx";
        default:
            break;
    }
    return "????";
}
/** @file cs4224_io.c
 ****************************************************************************
 *
 * @brief
 *    This module contains methods for configuring the GPIO inputs
 *    and outputs on the device.
 *
 ****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ***************************************************************************/

/* The address map for GPIO configuration registers */
cs_uint32 g_cs4224_gpio_addr_map[5] =
{
    CS4224_GPIO_INTERR,
    CS4224_GPIO_GPIO1,
    CS4224_GPIO_GPIO2,
    CS4224_GPIO_GPIO3,
    CS4224_GPIO_GPIO4,
};

/* Address macros for GPIO configuration registers */
#define CS4224_GPIO_CFG_ADDR(n)     (g_cs4224_gpio_addr_map[n])
#define CS4224_GPIO_OUT_CFG_ADDR(n) (g_cs4224_gpio_addr_map[n] + 1)
#define CS4224_GPIO_DRIVE_ADDR(n)   (g_cs4224_gpio_addr_map[n] + 2)
#define CS4224_GPIO_VALUE_ADDR(n)   (g_cs4224_gpio_addr_map[n] + 3)
#define CS4224_GPIO_TOGGLE_ADDR(n)  (g_cs4224_gpio_addr_map[n] + 4)
#define CS4224_GPIO_DELAY_ADDR(n)   (g_cs4224_gpio_addr_map[n] + 5)

/**
 * This method is called to determine the port (slice) the GPIO 
 * gets its signal from when configured as an output.
 *
 * The following table shows the slice to port mapping.
 *
 *                 Simplex Simplex  Duplex        Duplex     
 * Port            Slice   Slice    Slice         Slice      
 * Value Symbol    Die 1   Die 0    Die 1         Die 0     
 *
 *   0   PORT0     5       13       0 host Rx     7 host Rx  
 *   1   PORT1     0        8       0 line Rx     7 line Rx  
 *   2   PORT2     3       14       1 host Rx     6 host Rx 
 *   3   PORT3     1       10       1 line Rx     6 line Rx  
 *   4   PORT4     7       12       2 host Rx     5 host Rx
 *   5   PORT5     4        9       2 line Rx     5 line Rx
 *   6   PORT6     6       15       3 host Rx     4 host Rx
 *   7   PORT7     2       11       3 line Rx     4 line Rx
 *   8   COMMON    n/a     n/a      n/a           n/a        
 *
 * @param slice    [I] - The slice of the device for which the GPIO is being configured.
 * @param side     [I] - Identifies the line or host side.
 *
 * @returns the port number
 *
 * @private
 */

cs_uint16 cs4224_gpio_get_signal_source_port(
    cs_uint32 slice,
    e_cs4224_cfg_sides_t side)
{
    cs_uint16 port = 0;
    
    if (cs4224_is_hw_duplex(slice))
    {
        switch (slice & 7)
        {
            case 0:
            case 7:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 0;
                }
                else
                {
                    port = 1;
                }
                break;
            case 1:
            case 6:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 2;
                }
                else
                {
                    port = 3;
                }
                break;
            case 2:
            case 5:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 4;
                }
                else
                {
                    port = 5;
                }
                break;
            case 3:
            case 4:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 6;
                }
                else
                {
                    port = 7;
                }
                break;
        }
    }
    else /* simplex*/
    {
        switch (slice & 0xf)
        {
            case 0:
            case 5:
            case 8:
            case 13:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 0;
                }
                else
                {
                    port = 1;
                }
                break;
            case 1:
            case 3:
            case 10:
            case 14:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 2;
                }
                else
                {
                    port = 3;
                }
                break;
            case 4:
            case 7:
            case 9:
            case 12:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 4;
                }
                else
                {
                    port = 5;
                }
                break;
            case 2:
            case 6:
            case 11:
            case 15:
                if (side == CS4224_CFG_HOST_SIDE)
                {
                    port = 6;
                }
                else
                {
                    port = 7;
                }
                break;
        }
    }

    return port;
}

/**
 * This method is called to configure the GPIOs on the device. The GPIOs can be
 * configured as inputs or outputs. 
 *
 * The GPIO INPUT0 thru INPUT3 registers are only available on the duplex packages 
 * since the inputs are mapped to port pair EXT_LOS signals on both the line and 
 * host sides. 
 * 
 * Notes on GPIO support for the packages:
 * 
 * CS4223, 4 port duplex: There are 5 GPIOs available, GPIO1 thru GPIO4 and INTERR.
 * 
 * CS4343, 8 port duplex: There are a total of 10 GPIOs available. One instance of 
 * GPIO1 thru GPIO4 and INTERR per die. Note that the GPIO INTERR pin is shared between
 * both dies however, they do get configured separately.
 * 
 * CS4224, 16 port simplex: There are a total of 6 GPIOs available. One instance of
 * GPIO1, GPIO2 and INTERR per die. Note that the GPIO INTERR pin is shared between
 * both dies however, they do get configured separately. 
 * 
 * @param slice    [I] - The slice of the device for which the GPIO is being configured.
 * @param gpio_num [I] - Which of the GPIOs to configure  
 * @param cfg      [I] - Data structure containing the configuration for the GPIO 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_gpio_init(
    cs_uint32 slice, 
    cs_uint8 gpio_num, 
    cs4224_gpio_cfg_t* cfg)
{
    cs_status status = CS_OK;
    CS4224_GPIO_GPIO1_t gpio_cfg;
    cs_uint32 out_cfg;
    cs_uint32 source_port;

    if (cs4224_is_hw_simplex(slice))
    {
        if ((gpio_num == CS4224_GPIO3) ||  
            (gpio_num == CS4224_GPIO4))    
        {
            CS_TRACE(("ERROR: GPIO3 and GPIO4 not available on simplex package.\n")); 
            return CS_ERROR;
        }
    }

    /* Setup the GPIO_GPIO[n] register to configure the mode */
    gpio_cfg.bf.output_src_sel = cfg->output_src_sel;
    gpio_cfg.bf.invert_output  = cfg->invert_output;
    gpio_cfg.bf.invert_input   = cfg->invert_input;
    gpio_cfg.bf.iovddsel_1v2   = cfg->iovddsel_1v2;
    gpio_cfg.bf.outen_ovr      = cfg->outen_ovr;
    gpio_cfg.bf.outen          = cfg->outen;
    gpio_cfg.bf.pullup_1k      = cfg->pullup_1k;
    gpio_cfg.bf.pullup_10k     = cfg->pullup_10k;

    if ((cfg->out_fcn >= CS4224_GPIO_OUT_FCN_COMMON_LOGIC_0) &&
        (cfg->out_fcn <= CS4224_GPIO_OUT_FCN_COMMON_GBL_CLKMON_CLK))
    {
        /* common function */
        source_port = 8;
    }
    else
    {
        /* port function */
        source_port = cs4224_gpio_get_signal_source_port(slice, cfg->side);
    }
    out_cfg = (cfg->out_fcn & 0xf) | (source_port << 4);

    status |= cs4224_reg_set_channel(slice, CS4224_GPIO_CFG_ADDR(gpio_num),     gpio_cfg.wrd);
    status |= cs4224_reg_set_channel(slice, CS4224_GPIO_OUT_CFG_ADDR(gpio_num), out_cfg);
    status |= cs4224_reg_set_channel(slice, CS4224_GPIO_TOGGLE_ADDR(gpio_num),  cfg->toggle_rate);
    status |= cs4224_reg_set_channel(slice, CS4224_GPIO_DELAY_ADDR(gpio_num),   cfg->on_delay);
#if 0
    CS_PRINTF(("\n\nin cs4224_gpio_init method\n"));
    CS_PRINTF(("  slice               = %d\n", slice));
    CS_PRINTF(("  gpio_num            = %d\n", gpio_num));
    CS_PRINTF(("  source_port         = %d\n", source_port));
    CS_PRINTF(("  CS4224_GPIO_CFG     = 0x%04x\n", gpio_cfg.wrd));
    CS_PRINTF(("  CS4224_GPIO_OUT_CFG = 0x%04x\n", out_cfg));
    CS_PRINTF(("  CS4224_GPIO_IN_CFG  = 0x%04x\n", cfg->in_fcn));
    CS_PRINTF(("  CS4224_GPIO_TOGGLE  = 0x%04x\n", cfg->toggle_rate));
    CS_PRINTF(("  CS4224_GPIO_DELAY   = 0x%04x\n", cfg->on_delay));
    CS_PRINTF(("  CS4224_GPIO_IN_CFG  = 0x%04x\n", cfg->in_fcn));
    CS_PRINTF(("\n\n"));
#endif
    /* Allow the mapping of a GPIO input to an external optical LOS signal */
    if (cfg->in_fcn != CS4224_GPIO_IN_FCN_EXT_LOGIC_0)
    {
        cs_uint16 input;

        /* Input mapping not available on simplex package because inputs are 
           mapped to port pair EXT_LOS signals which are not tied to a specific 
           direction ie. ingress or egress. 
        */
        if (cs4224_is_hw_simplex(slice))
        {
            CS_TRACE(("ERROR: GPIO input mapping not available on simplex package.\n")); 
            return CS_ERROR;
        }

        /* input register is port-pair */
        input = slice % 3;
    
        switch(gpio_num)
        {
            case CS4224_GPIO1:  
                status |= cs4224_reg_set_channel(slice, 
                                                 CS4224_GPIO_GPIO_INPUT0+input, 
                                                 CS4224_GPIO_IN_FCN_EXT_GPIO1_LOS);
#if 0
                CS_PRINTF(("Input:%d, GPIO1: Writing to reg: 0x%04x, value 0x%04x\n", input, 
                                                                                      CS4224_GPIO_GPIO_INPUT0+input, 
                                                                                      CS4224_GPIO_IN_FCN_EXT_GPIO1_LOS ));
#endif
                break;
    
            case CS4224_GPIO2:  
                status |= cs4224_reg_set_channel(slice, 
                                                 CS4224_GPIO_GPIO_INPUT0+input, 
                                                 CS4224_GPIO_IN_FCN_EXT_GPIO2_LOS);
#if 0
                CS_PRINTF(("Input:%d, GPIO2: Writing to reg: 0x%04x, value 0x%04x\n", input, 
                                                                                      CS4224_GPIO_GPIO_INPUT0+input, 
                                                                                      CS4224_GPIO_IN_FCN_EXT_GPIO2_LOS ));
#endif
                break;
    
            case CS4224_GPIO3:  
                status |= cs4224_reg_set_channel(slice, 
                                                 CS4224_GPIO_GPIO_INPUT0+input, 
                                                 CS4224_GPIO_IN_FCN_EXT_GPIO3_LOS);
#if 0
                CS_PRINTF(("Input:%d, GPIO3: Writing to reg: 0x%04x, value 0x%04x\n", input, 
                                                                                      CS4224_GPIO_GPIO_INPUT0+input, 
                                                                                      CS4224_GPIO_IN_FCN_EXT_GPIO3_LOS ));
#endif
                break;
    
            case CS4224_GPIO4:  
                status |= cs4224_reg_set_channel(slice, 
                                                 CS4224_GPIO_GPIO_INPUT0+input, 
                                                 CS4224_GPIO_IN_FCN_EXT_GPIO4_LOS);
#if 0
                CS_PRINTF(("Input:%d, GPIO4: Writing to reg: 0x%04x, value 0x%04x\n", input, 
                                                                                      CS4224_GPIO_GPIO_INPUT0+input, 
                                                                                      CS4224_GPIO_IN_FCN_EXT_GPIO4_LOS ));
#endif
                break;
    
            case CS4224_GPIOINTERR:  
                status |= cs4224_reg_set_channel(slice, 
                                                 CS4224_GPIO_GPIO_INPUT0+input, 
                                                 CS4224_GPIO_IN_FCN_EXT_INTERR);
#if 0
                CS_PRINTF(("Input:%d, INTERR: Writing to reg: 0x%04x, value 0x%04x\n", input, 
                                                                                      CS4224_GPIO_GPIO_INPUT0+input, 
                                                                                      CS4224_GPIO_IN_FCN_EXT_INTERR ));
#endif
                break;
        }
    }
    
    return status;
}

/**
 * This method is used to setup the defaults required to configure a GPIO
 * as an output. It does not write any configuration to the chip but updates
 * the cfg structure describing the configuration of the GPIO.
 *
 * @param cfg     [O] - The updated configuration structure for the GPIO input.
 * @param out_fcn [I] - The desired configuration for the GPIO output.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_gpio_cfg_output(
    cs4224_gpio_cfg_t* cfg, 
    e_cs4224_gpio_out_fcn out_fcn)
{
    cs_status status = CS_OK;

    /* Configure the GPIO as an output. Use the defaults for most settings */
    if(out_fcn == CS4224_GPIO_OUT_FCN_DIRECT_DRIVE)
    {
        cfg->output_src_sel = 0;
    }
    else
    {
        cfg->output_src_sel = 3;
    }

    cfg->invert_output = 0;
    cfg->invert_input  = 0;
    cfg->iovddsel_1v2  = 0;
    cfg->outen_ovr     = 0;
    cfg->outen         = 1;
    cfg->pullup_1k     = 0;
    cfg->pullup_10k    = 0;
    cfg->toggle_rate   = 0;
    cfg->on_delay      = 0;

    cfg->out_fcn       = out_fcn;
    cfg->in_fcn        = CS4224_GPIO_IN_FCN_EXT_LOGIC_0;
    
    /* line side is the default */
    cfg->side          = CS4224_CFG_LINE_SIDE;

    return status;
}

/**
 * This method is used to setup the mapping of a GPIO input to an external
 * module optical LOS signal for a port-pair.
 * It does not write any configuration to the chip but updates
 * the cfg structure describing the configuration of the GPIO.
 *
 * @param cfg    [O] - The updated configuration structure for the GPIO input.
 * @param in_fcn [I] - The internal function the GPIO input is being mapped to.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_gpio_cfg_input(
    cs4224_gpio_cfg_t* cfg, 
    e_cs4224_gpio_in_fcn in_fcn)
{
    cs_status status = CS_OK;

    /* Configure the GPIO as an input. Use the defaults for most settings */
    cfg->output_src_sel = 0;
    cfg->invert_output  = 0;
    cfg->invert_input   = 0;
    cfg->iovddsel_1v2   = 0;
    cfg->outen_ovr      = 0;
    cfg->outen          = 0; 
    cfg->pullup_1k      = 1;
    cfg->pullup_10k     = 1;
    cfg->toggle_rate    = 0;
    cfg->on_delay       = 0;

    cfg->out_fcn        = CS4224_GPIO_OUT_FCN_DISABLED;
    cfg->in_fcn         = in_fcn;

    /* line side is the default */
    cfg->side           = CS4224_CFG_LINE_SIDE;

    return status;
}

/**
 * This method is called to set the value of a GPIO pin on the device if it is configured 
 * as an output. 
 *
 * @param slice     [I] -  The slice to the port of the device to access 
 * @param gpio_num  [I] -  The GPIO being driven 
 * @param val       [I] -  The value to set it to (1 or 0). 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_gpio_set(
    cs_uint32 slice, 
    cs_uint8 gpio_num, 
    cs_uint8 val)
{
    cs_status status = CS_OK;
    cs_uint16 data;
    cs_uint8 output_mode;
    cs_uint8 outen_override;
    cs_uint8 outen;

    status |= cs4224_reg_get_channel(slice, CS4224_GPIO_CFG_ADDR(gpio_num), &data);
    output_mode = (data >> 9) & 0x7;
    outen_override = (data >> 5) & 0x1;
    outen = (data >> 4) & 0x1;

    /* Determine whether or not the GPIO is an output or not before
     * attempting to drive it.
     */
    if(outen_override == 1 || (outen_override == 0 && outen == 1))
    {
        if((output_mode == CS4224_GPIO_SEL_DRIVE || 
            output_mode == CS4224_GPIO_SEL_DELAY))
        {
            /* Drive the output GPIO in DRIVE or DELAY modes */
            status |= cs4224_reg_set_channel(slice, CS4224_GPIO_DRIVE_ADDR(gpio_num), val & 0x1);
            return status;
        }
    }
            
    return CS_ERROR;
}

/**
 * This method is called to get the current value of a GPIO pin on the device 
 *
 * @param slice     [I] -  The slice to the port of the device to access 
 * @param gpio_num  [I] -  The GPIO being read 
 * @param val       [O] -  The value the pin is set to 
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_gpio_get(
    cs_uint32 slice, 
    cs_uint8 gpio_num, 
    cs_uint8* val)
{
    cs_status status = CS_OK;
    cs_uint16 data;

    status |= cs4224_reg_get_channel(slice, CS4224_GPIO_VALUE_ADDR(gpio_num), &data);

    *val = data & 0x1;

    return status;
}
/** @file cs4224_irq.c
 *****************************************************************************
 *
 * @brief
 *    This module contains methods for managing interrupts on the
 *    Leeds device.
 *
 *****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ****************************************************************************/
#if defined(CS_HAS_INTERRUPTS)

#if defined(_WINDOWS)
#    include <string.h>
#endif

/**
 * The block ID used for locking interrupts. This isn't used yet
 * for CS4321.
 *
 * @private
 */  
typedef enum {
  /** The IRQ chain */
  CS4224_ID_IRQ = 1,
} cs4224_block_id_t;

/* This is the top-most interrupt in the tree */
#define CS4224_IRQ_TOP CS4224_IRQ_NODE_GLOBAL_GLOBAL_INTERRUPT

#define CS4224_IRQ_NO_STATUS 0

/**
 * This method is called to enable or disable an interrupt
 * in the interrupt hierarchy.
 *
 * @param slice        [I] - The slice or port of the device to enable/disable an
 *                           interrupt for.
 * @param node         [I] - The interrupt node in the hierarchy to enable/disable
 * @param enable_bits  [I] - '1' in enable_bits bit positions will enable the interrupt
 *                           by writing '1' in those bit positions
 * @param disable_bits [I] - '1' in disable_bits bit positions will disable the
 *                           interrupts by writing '0' in those bit positions
 * @param dir          [I] - The direction to walk in the interrupt tree. For
 *                           more information refer to the e_cs4224_irq_tree_dir enumeration.
 *
 * @return CS_ERROR will be returned if there are '1' bits in both enable_bits and disable_bits
 */
cs_status cs4224_irq_enable_disable(
    cs_uint32            slice,
    cs4224_irq_node_ptr   node,
    cs_uint16            enable_bits,
    cs_uint16            disable_bits,
    e_cs4224_irq_tree_dir dir)
{
    cs_uint32             enable_reg_addr;
    cs_uint16             enable_reg_data;
    cs_boolean            enable;
    cs_uint16             i;
    cs4224_irq_node_parent_t parent;
    cs4224_irq_node_ptr      child;
    cs_status             status;

    if(node == NULL)
    {
        return CS_ERROR;
    }

    if (enable_bits)
        if (disable_bits) return CS_ERROR;
        else enable = TRUE;
    else if (disable_bits) enable = FALSE;
    /* If there are no bits set in either then there's nothing to do */
    else return CS_OK;

    enable_reg_addr = node->ereg;

    cs4224_lock(slice);
    enable_reg_data = cs4224_reg_read(slice, enable_reg_addr);
    enable_reg_data |= enable_bits;             /* enable the selected bits */
    enable_reg_data &= ~disable_bits;           /* disable the selected bits */
    enable_reg_data &= node->mask;              /* don't modify unused or reserved bits */
    status = cs4224_reg_set_channel(slice, enable_reg_addr, enable_reg_data);
    cs4224_unlock(slice);
    if (status == CS_ERROR)
        return CS_ERROR;
    enable_reg_addr += node->stride;

    /* Recurse up the tree */
    if (node->parents != CS4224_IRQ_NODE_NO_NODE)
    {
        cs_uint16 mask;
        parent = (*(node->parents))[0];
        mask = parent.mask;

        /* If this node has multiple slices but it's parent
         * only has a single slice then we need to offset the
         * bitmask in the parent register for this port pair instance */
        if(node->slices > 1 && parent.parent->slices == 1)
        {
            /* If this is a Port Pair register handle the offset */
            if(enable_reg_addr >= 0x1000 && enable_reg_addr <= 0x5000)
            {
                /* Figure out the port pair offset for this slice */
                cs_uint32 pp_offset = cs4224_adj_pp(slice, 0)/0x1000;
                mask <<= pp_offset;
            }
            else
            {
                /* Figure out the port pair offset for this slice */
                cs_uint32 mseq_offset = cs4224_adj_mseq(slice, 0)/0x100;
                mask <<= mseq_offset;
            }
        }

        if (dir == CS4224_IRQ_DIR_UP || dir == CS4224_IRQ_DIR_BOTH)
        {
            CS4224_IRQ_RET_IF_ERROR(cs4224_irq_enable_disable(slice,
                                                            parent.parent,
                                                            enable ? mask : 0,
                                                            enable ? 0 : mask,
                                                            dir), CS_ERROR);
        }
    }

    /* Recurse down the tree */
    if (node->children != CS4224_IRQ_NODE_NO_NODE)
    {
        if (dir == CS4224_IRQ_DIR_DOWN || dir == CS4224_IRQ_DIR_BOTH)
        {
            for (i=0; i<=15; i++)
            {
                /* Only enable those children whose enable bits are set and disable bits are clear */
                if ((1<<i) & (enable_bits | disable_bits))
                {
                    /* children is a variable-length array; check the index against the length */
                    if (i < node->num_children)
                    {
                        child = (*node->children)[i].child;
                        if (child != CS4224_IRQ_NODE_NO_NODE)
                        {
                            CS4224_IRQ_RET_IF_ERROR(cs4224_irq_enable_disable(slice,
                                                                            child,
                                                                            enable ? 0xffff : 0,
                                                                            enable ? 0 : 0xffff,
                                                                            dir), CS_ERROR);
                        }
                    }
                }
            }
        }
    }
    return (CS_OK);
}

/**
 *
 * Enables interrupts at the device level (rather than the
 * module level). Can be used to enable interrupts in Module A
 * or Module B with care; all slices will be enabled when going
 * down the tree.
 * The [enable_bits] parameter is specified as:
 *                1 = enable the bit
 *                0 = leave the bit as-is
 * The [dir] parameter is specified as:
 *                CS4224_IRQ_DIR_ONLY = 0 enables this node only
 *                CS4224_IRQ_DIR_UP   = 1 enables this node and up
 *                                     the tree
 *                CS4224_IRQ_DIR_DOWN = 2 enables this node and
 *                                     down the tree
 *                CS4224_IRQ_DIR_BOTH = 3 enables this node and up
 *                                     and down the tree
 * This function is useful for enabling all interrupts in the
 * device:
 *   cs4224_irq_enable(dev_id,
 *     ptr CS4224_IRQ_NODE_MPIF_GLOBAL_INTERRUPT,
 *     0xffff, CS4224_IRQ_DIR_DOWN)
 * It can also be used to enable individual intermediate or
 * leaf nodes without going up or down the tree by setting dir
 * to CS4224_IRQ_DIR_ONLY.
 *
 * @param slice       [I] - The slice/port of the device being accessed. 
 * @param node        [I] - Pointer to the interrupt node being enabled.
 * @param enable_bits [I] - The bitmask of the register bits to enable.
 * @param dir         [I] - The direction to enable (up or down the tree)
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_irq_enable(cs_uint32          slice,
                             cs4224_irq_node_ptr   node,
                             cs_uint16            enable_bits,
                             e_cs4224_irq_tree_dir dir)
{
    return cs4224_irq_enable_disable(slice, node, enable_bits, 0, dir);
}

/**
 * Disables interrupts at the device level (rather than the
 * module level). Can be used to disable interrupts in Module A
 * or Module B with care; all slices will be disabled when
 * going down the tree.
 * The [disable_bits] parameter is specified as:
 *                1 = disable the bit
 *                0 = leave the bit as-is
 * The [dir] parameter is specified as:
 *                CS4224_IRQ_DIR_ONLY = 0 disables this node only
 *                CS4224_IRQ_DIR_UP   = 1 disables this node and
 *                                     up the tree
 *                CS4224_IRQ_DIR_DOWN = 2 disables this node and
 *                                     down the tree
 *                CS4224_IRQ_DIR_BOTH = 3 disables this node and
 *                                     up and down the tree
 * This function is useful for disabling all interrupts in the
 * device:
 *   cs4224_irq_disable(dev_id,
 *     ptr CS4224_IRQ_NODE_MPIF_GLOBAL_INTERRUPT,
 *     0xffff, CS4224_IRQ_DIR_DOWN)
 * It can also be used to disable individual intermediate or
 * leaf nodes without going up or down the tree by setting dir
 * to CS4224_IRQ_DIR_ONLY.
 *
 * @param slice        [I] - The slice or port of the device.
 * @param node         [I] - Pointer to an interrupt node
 * @param disable_bits [I] - Bitmask of the register bits to disable
 * @param dir          [I] - Direction to disable (up or down the tree)
 */
cs_status cs4224_irq_disable(cs_uint32 slice,
                              cs4224_irq_node_ptr   node,
                              cs_uint16          disable_bits,
                              e_cs4224_irq_tree_dir dir)
{
    return cs4224_irq_enable_disable(slice, node, 0, disable_bits, dir);
}

/**
 * This method is called to walk an interrupt node
 *
 * @param slice     [I] - The slice or port of the device
 * @param node      [I] - Pointer to the interrupt node.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_irq_walk_node(cs_uint32 slice, cs4224_irq_node_ptr node)
{
    cs_uint32 interrupt_reg_address;
    cs_uint16 interrupt_reg_data;
    cs_uint32 enable_reg_address;
    cs_uint16 enable_reg_data;
    cs_uint16 masked_interrupt_data;
    cs4224_irq_node_ptr       child;
    int                    i;
    cs4224_irq_handler_data_t handler_data;

    cs_boolean             call_handler = FALSE;
#ifdef CS4224_IRQ_LOCK_INTERRUPT_WALKER
    cs_boolean             locked = FALSE;
#endif
    cs_uint16              status_reg_data = 0;

    interrupt_reg_address = node->ireg;
    enable_reg_address    = node->ereg;
#ifdef CS4224_IRQ_LOCK_INTERRUPT_WALKER
    cs4224_lock(slice);
    locked = TRUE;
#endif

    interrupt_reg_data = cs4224_reg_read(slice, interrupt_reg_address);
    
    /* Don't bother reading the enable register if there's nothing to look for here */
    if (interrupt_reg_data != 0)
    {
        enable_reg_data = cs4224_reg_read(slice, enable_reg_address);
        masked_interrupt_data = interrupt_reg_data & enable_reg_data;

        for (i=0; i<16; i++)
        {
            if (masked_interrupt_data & 1)
            {
                /* Is this a leaf ot intermediate node? The entire register could be a leaf,
                 * or just the bit in question */
                if ((node->children == CS4224_IRQ_NODE_NO_NODE) ||
                    ((i < node->num_children) && (*node->children)[i].child == CS4224_IRQ_NODE_NO_NODE))
                {
                    /* This is a leaf */
#if CS4224_IRQ_PRINT_INTERRUPTS
                    /* child_name is a variable-length array; make sure we don't go beyond the end of it */
                    if (i <= node->last_child)
                        CS_PRINTF(("ISR '%s : %s' fired at address 0x%05X bit %d\n",
                            node->name, node->child_name[i],
                            interrupt_reg_address, i));
#endif
                    call_handler = TRUE;
                }
                else
                {
                    /* children is a variable-length array; check the index against the length */
                    if (i < node->num_children)
                    {
                        child = (*node->children)[i].child;

#ifdef CS4224_IRQ_LOCK_INTERRUPT_WALKER
                        if (locked)
                        {
                            cs4224_unlock(slice);
                            locked = FALSE;
                        }
#endif
                        /* Bug 20186 start */
                        if (child != CS4224_IRQ_NODE_NO_NODE)
                        /* Bug 20186 end */
                            cs4224_irq_walk_node(slice, child);
                    }
                }
            }
            masked_interrupt_data >>= 1;
        }

        /* If this is a leaf node and an interrupt was set */
        if (call_handler)
        {
            if (node->sreg)
            {
                status_reg_data = cs4224_reg_read(slice, node->sreg);
            }

            /* All interrupt registers RW1C so write a '1' to clear the interrupt */
            /* Bug 12558: Disabled interrupts should not be automatically cleared
             *            Previously, all interrupts were cleared.
             *            Now, only enabled interrupts are cleared. */
            cs4224_reg_set_channel(slice, interrupt_reg_address, interrupt_reg_data & enable_reg_data);

#ifdef CS4224_IRQ_LOCK_INTERRUPT_WALKER
            if (locked)
            {
                cs4224_unlock(slice);
                locked = FALSE;
            }
#endif
            /* Call any registered interrupt handlers */
            if (node->handler != CS4224_IRQ_NO_HANDLER)
            {
                handler_data.handle    = slice;
                handler_data.node      = node;
                handler_data.ireg_data = interrupt_reg_data;
                handler_data.ereg_data = enable_reg_data;
                handler_data.sreg_data = status_reg_data;       /* This will be 0 if there is no status register for this node */
                (*(node->handler))(handler_data);
            }
        }
    }
#ifdef CS4224_IRQ_LOCK_INTERRUPT_WALKER
    if (locked)
    {
        cs4224_unlock(slice);
        locked = FALSE;
    }
#endif
    return CS_OK;
}

/**
 * This method is used to walk the interrupt tree
 *
 * @param slice [I] - The slice or port of the device to walk the
 *                    interrupt tree.
 *
 * @return Currently always CS_OK
 *
 */
cs_status cs4224_irq_walk_tree(cs_uint32 slice)
{
    /* Start at the global interrupt and walk the tree to all leaves */
    cs4224_irq_walk_node(slice, &CS4224_IRQ_TOP);
    return CS_OK;
}

/**
 * Walk the interrupt tree and call any registered handlers for
 * interrupt nodes that have both active and enabled
 * interrupts. Interrupts that are active but not enabled will
 * be ignored. Registered interrupt handlers will be called as
 * soon as their node has been polled in the tree traversal.
 * Active and enabled interrupts at that node will be cleared
 * before the handler is called. The handler will be passed all
 * relevant information in a cs4224_irq_handler_data_t, including
 * the active and enabled interrupts. Interrupt handlers should not return anything.
 *
 * @param slice [I] - The slice or port of the device(s)
 * 
 * @returns CS_OK or CS_ERROR
 */
cs_status cs4224_irq_isr(cs_uint32 slice)
{
    return cs4224_irq_walk_tree(slice);
}

/**
 * Register a user-supplied interrupt handler against any
 * interrupt node (intermediate node or leaf node).
 * An interrupt register is a node and is in the form
 * CS4224_IRQ_NODE_{register name}; e.g.
 * CS4224_IRQ_NODE_MPIF_GLOBAL_INTERRUPT
 * The handler will be called if any interrupt bit at that node
 * is both enabled and active. The handler will not be called
 * if an interrupt is active but not enabled.
 * The handler will be passed a pointer to a
 * cs4224_irq_handler_data_t that will be populated with all of
 * the interrupt information. 
 * Only one handler may be registered for any node; CS_ERROR
 * will be returned if the node already has a registered 
 * handler.
 * Example:
 *   cs4224_irq_register_handler(
 *     dev_id, ptr CS4224_IRQ_NODE_GFEC10G_FRX_INTR,  ptr handler)
 * Unregister a handler by using CS4224_IRQ_NO_HANDLER as the
 * handler. CS_ERROR will be returned if there is no handler
 * registered. 
 *
 * @param node    [I] - Pointer to the interrupt node
 * @param handler [I] - Pointer to the interrupt handler or
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_irq_register_handler(
                                   cs4224_irq_node_ptr  node,
                                   cs4224_irq_handler_t handler)
{
    /* Don't allow a registration when a handler is already registered */
    if ((      handler != CS4224_IRQ_NO_HANDLER) &&
        (node->handler != CS4224_IRQ_NO_HANDLER))
        return CS_ERROR;

    /* Flag an error if unregistering a non-existent handler */
    if ((      handler == CS4224_IRQ_NO_HANDLER) &&
        (node->handler == CS4224_IRQ_NO_HANDLER))
        return CS_ERROR;

    node->handler = handler;

    return CS_OK;
}

/**
 * Check to see if a register handler already exists. This
 * is useful when registering a handler to determine if one has
 * previously been registered.
 *
 * @param node    [I] - Pointer to the interrupt node
 * 
 * @return TRUE if a handler is registered, FALSE if one
 *         has not been registered.
 */
cs_boolean cs4224_irq_register_handler_exists(cs4224_irq_node_ptr node)
{
    if(node->handler == CS4224_IRQ_NO_HANDLER)
    {
        return FALSE;
    }

    return TRUE;
}

/**
 * This function is called recursively to print all of the enabled leaf interrupts
 *
 * @param slice [I] - The slice/port of the device.
 * @param node  [I] - The current node.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_irq_walk_node_print_enabled(
    cs_uint32          slice,
    cs4224_irq_node_ptr node)
{
    cs_uint32              enable_reg_address;
    cs_uint16              enable_reg_data;
    cs4224_irq_node_ptr     child;
    int                    i;

    enable_reg_address = node->ereg;
    enable_reg_data = cs4224_reg_read(slice, enable_reg_address);
    for (i=0; i<16; i++)
    {
        if (enable_reg_data & 1)
        {
            /* Is this a leaf of intermediate node? The entire register could be a leaf,
              * or just the bit in question */
            if ((node->children == CS4224_IRQ_NODE_NO_NODE) ||
                ((i < node->num_children) && (*node->children)[i].child == CS4224_IRQ_NODE_NO_NODE))
            {
                /* This is a leaf */
#if CS4224_IRQ_PRINT_INTERRUPTS
                    /* child_name is a variable-length array; make sure we don't go beyond the end of it */
/*
                    CS_PRINTF(("PROCESSING node->name %s\n", node->name));
                    CS_PRINTF(("PROCESSING          i %d\n", i));
                    CS_PRINTF(("PROCESSING node->child_name[i] '%s'\n", node->child_name[i]));
*/
                    if ((i <= node->last_child)  && (CS_STRLEN(node->child_name[i]) > 0))
                        CS_PRINTF(("Interrupt '%s : %s' is enabled at address 0x%05X bit %d\n",
                            node->name, node->child_name[i],
                            enable_reg_address, i));
#endif
            }
            else
            {
                /* children is a variable-length array; check the index against the length */
                if (i < node->num_children)
                {
                    child = (*node->children)[i].child;
                    
                    /* Bug 20186 start */
                    if (child != CS4224_IRQ_NODE_NO_NODE)
                    /* Bug 20186 end */
                        cs4224_irq_walk_node_print_enabled(slice, child);
                }
            }
        }
        enable_reg_data >>= 1;
    }
    return CS_OK;
}

/**
 * This method walks the interrupt tree and displays any
 * leave interrupts that are enabled. Enabled means that the
 * interrupt is unmasked. It does not meant that the interrupt is
 * asserted or fired.
 *
 * @param slice [I] - The slice of the device to print the
 *                    list of enabled interrupts for.
 *
 * @return CS_OK on succcess, CS_ERROR on failure.
 */
cs_status cs4224_irq_print_enabled_interrupts(cs_uint32 slice)
{
    return cs4224_irq_walk_node_print_enabled(slice, &CS4224_IRQ_TOP);
}

#endif /* CS_HAS_INTERRUPTS */

/** @file cs4224_irq_tree.c
 *****************************************************************************
 *
 * @brief
 *
 * The interrupt tree
 * 
 * This file is auto generated and should not be modified.
 *
 *****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ****************************************************************************/

#if defined(CS_HAS_INTERRUPTS)

/*
 * This file defines the interrupt tree so that interrupts can be enabled/disabled from
 * any node up and/or down the tree. It implements a double-linked-list of interrupt nodes.
 */

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_GLOBAL_GLOBAL_INTERRUPT = {
    { &CS4224_IRQ_NODE_GLOBAL_DATAPATH_INTERRUPT, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { &CS4224_IRQ_NODE_GPIO_GPIO_INPUT_INT, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { &CS4224_IRQ_NODE_MSEQ_PS_INT, 0 },
    { &CS4224_IRQ_NODE_MSEQ_PS_INT, 1 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

/* ID = 39 */
cs4224_irq_node_t CS4224_IRQ_NODE_GLOBAL_GLOBAL_INTERRUPT = {
    CS4224_GLOBAL_GLOBAL_INTERRUPT, CS4224_GLOBAL_GLOBAL_INTE, CS4224_IRQ_NO_STATUS,
    1, 0, 6,
    0x003F,
    &CS4224_IRQ_NODE_CHILDREN_GLOBAL_GLOBAL_INTERRUPT,
    CS4224_IRQ_NODE_NO_NODE,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "GLOBAL_GLOBAL_INTERRUPT",
    5,
    {
        "datapathI",

        ""

,
        "gpio_inputI",

        ""

,
        "mseq_ps0I",
        "mseq_ps1I"
    }
#endif
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_MSEQ_PS_INT = {
    { &CS4224_IRQ_NODE_GLOBAL_GLOBAL_INTERRUPT, 0x10 }
};

/* ID = 392 */
cs4224_irq_node_t CS4224_IRQ_NODE_MSEQ_PS_INT = {
    CS4224_MSEQ_PS_INT, CS4224_MSEQ_PS_INTE, CS4224_MSEQ_PS_INTO,
    2, 256, 0,
    0x0003,
    CS4224_IRQ_NODE_NO_NODE,
    &CS4224_IRQ_NODE_PARENTS_MSEQ_PS_INT,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "MSEQ_PS_INT",
    1,
    {
        "ps_mem_ecc_single",
        "ps_mem_ecc_double"
    }
#endif
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_GPIO_GPIO_INPUT_INT = {
    { &CS4224_IRQ_NODE_GLOBAL_GLOBAL_INTERRUPT, 0x4 }
};

/* ID = 80 */
cs4224_irq_node_t CS4224_IRQ_NODE_GPIO_GPIO_INPUT_INT = {
    CS4224_GPIO_GPIO_INPUT_INT, CS4224_GPIO_GPIO_INPUT_INTE, CS4224_GPIO_GPIO_INPUT_INTS,
    1, 0, 0,
    0x001F,
    CS4224_IRQ_NODE_NO_NODE,
    &CS4224_IRQ_NODE_PARENTS_GPIO_GPIO_INPUT_INT,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "GPIO_GPIO_INPUT_INT",
    4,
    {
        "interr",
        "gpio1",
        "gpio2",
        "gpio3",
        "gpio4"
    }
#endif
};

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_GLOBAL_DATAPATH_INTERRUPT = {
    { &CS4224_IRQ_NODE_PP_LINE_LINEMISC_INTERRUPT, 0 },
    { &CS4224_IRQ_NODE_PP_LINE_LINEMISC_INTERRUPT, 1 },
    { &CS4224_IRQ_NODE_PP_LINE_LINEMISC_INTERRUPT, 2 },
    { &CS4224_IRQ_NODE_PP_LINE_LINEMISC_INTERRUPT, 3 },
    { &CS4224_IRQ_NODE_PP_HOST_HOSTMISC_INTERRUPT, 0 },
    { &CS4224_IRQ_NODE_PP_HOST_HOSTMISC_INTERRUPT, 1 },
    { &CS4224_IRQ_NODE_PP_HOST_HOSTMISC_INTERRUPT, 2 },
    { &CS4224_IRQ_NODE_PP_HOST_HOSTMISC_INTERRUPT, 3 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_GLOBAL_DATAPATH_INTERRUPT = {
    { &CS4224_IRQ_NODE_GLOBAL_GLOBAL_INTERRUPT, 0x1 }
};

/* ID = 41 */
cs4224_irq_node_t CS4224_IRQ_NODE_GLOBAL_DATAPATH_INTERRUPT = {
    CS4224_GLOBAL_DATAPATH_INTERRUPT, CS4224_GLOBAL_DATAPATH_INTE, CS4224_IRQ_NO_STATUS,
    1, 0, 8,
    0x00FF,
    &CS4224_IRQ_NODE_CHILDREN_GLOBAL_DATAPATH_INTERRUPT,
    &CS4224_IRQ_NODE_PARENTS_GLOBAL_DATAPATH_INTERRUPT,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "GLOBAL_DATAPATH_INTERRUPT",
    7,
    {
        "line0I",
        "line1I",
        "line2I",
        "line3I",
        "host0I",
        "host1I",
        "host2I",
        "host3I"
    }
#endif
};

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_PP_HOST_HOSTMISC_INTERRUPT = {
    { &CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_Int, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_HOST_HOSTMISC_INTERRUPT = {
    { &CS4224_IRQ_NODE_GLOBAL_DATAPATH_INTERRUPT, 0x10 }
};

/* ID = 1130 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_HOST_HOSTMISC_INTERRUPT = {
    CS4224_PP_HOST_HOSTMISC_INTERRUPT, CS4224_PP_HOST_HOSTMISC_INTENABLE, CS4224_IRQ_NO_STATUS,
    4, 4096, 3,
    0x0007,
    &CS4224_IRQ_NODE_CHILDREN_PP_HOST_HOSTMISC_INTERRUPT,
    &CS4224_IRQ_NODE_PARENTS_PP_HOST_HOSTMISC_INTERRUPT,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_HOST_HOSTMISC_INTERRUPT",
    2,
    {
        "sdsI",

        ""

,

        ""

    }
#endif
};

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_PP_HOST_SDS_COMMON_Int = {

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { &CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_RXLOCKDi, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_HOST_SDS_COMMON_Int = {
    { &CS4224_IRQ_NODE_PP_HOST_HOSTMISC_INTERRUPT, 0x1 }
};

/* ID = 1286 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_Int = {
    CS4224_PP_HOST_SDS_COMMON_Int, CS4224_PP_HOST_SDS_COMMON_IntEn, CS4224_IRQ_NO_STATUS,
    4, 4096, 12,
    0x0C0F,
    &CS4224_IRQ_NODE_CHILDREN_PP_HOST_SDS_COMMON_Int,
    &CS4224_IRQ_NODE_PARENTS_PP_HOST_SDS_COMMON_Int,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_HOST_SDS_COMMON_Int",
    11,
    {

        ""

,
        "RXLOCKDi",

        ""

,

        ""

,
        "",
        "",
        "",
        "",
        "",
        "",

        ""

,

        ""

    }
#endif
};

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_PP_HOST_SDS_COMMON_RXLOCKDi = {
    { &CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_HOST_SDS_COMMON_RXLOCKDi = {
    { &CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_Int, 0x2 }
};

/* ID = 1299 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_RXLOCKDi = {
    CS4224_PP_HOST_SDS_COMMON_RXLOCKDi, CS4224_PP_HOST_SDS_COMMON_RXLOCKDe, CS4224_IRQ_NO_STATUS,
    4, 4096, 1,
    0x0001,
    &CS4224_IRQ_NODE_CHILDREN_PP_HOST_SDS_COMMON_RXLOCKDi,
    &CS4224_IRQ_NODE_PARENTS_PP_HOST_SDS_COMMON_RXLOCKDi,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_HOST_SDS_COMMON_RXLOCKDi",
    0,
    {
        "RXLOCKD0i"
    }
#endif
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT = {
    { &CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_RXLOCKDi, 0x1 }
};

/* ID = 1191 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT = {
    CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTENABLE, CS4224_IRQ_NO_STATUS,
    4, 4096, 0,
    0x00FF,
    CS4224_IRQ_NODE_NO_NODE,
    &CS4224_IRQ_NODE_PARENTS_PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_HOST_SDS_COMMON_RXLOCKD0_INTERRUPT",
    7,
    {
        "LOCKi",
        "BAD_VCO_CLKi",
        "SHORT_FILTPNi",
        "DATA_DETi",
        "CIDZEROi",
        "CIDONEi",
        "FILT_LOCKi",
        "CLKLESS_STATUSi"
    }
#endif
};

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_PP_LINE_LINEMISC_INTERRUPT = {
    { &CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_Int, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_LINE_LINEMISC_INTERRUPT = {
    { &CS4224_IRQ_NODE_GLOBAL_DATAPATH_INTERRUPT, 0x1 }
};

/* ID = 417 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_LINE_LINEMISC_INTERRUPT = {
    CS4224_PP_LINE_LINEMISC_INTERRUPT, CS4224_PP_LINE_LINEMISC_INTENABLE, CS4224_IRQ_NO_STATUS,
    4, 4096, 14,
    0x3F3F,
    &CS4224_IRQ_NODE_CHILDREN_PP_LINE_LINEMISC_INTERRUPT,
    &CS4224_IRQ_NODE_PARENTS_PP_LINE_LINEMISC_INTERRUPT,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_LINE_LINEMISC_INTERRUPT",
    13,
    {
        "sdsI",

        ""

,

        ""

,

        ""

,

        ""

,

        ""

,
        "",
        "",

        ""

,

        ""

,

        ""

,

        ""

,

        ""

,

        ""

    }
#endif
};

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_PP_LINE_SDS_COMMON_Int = {

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { &CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_RXLOCKDi, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,

    { CS4224_IRQ_NODE_NO_NODE, 0 }
,
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_LINE_SDS_COMMON_Int = {
    { &CS4224_IRQ_NODE_PP_LINE_LINEMISC_INTERRUPT, 0x1 }
};

/* ID = 573 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_Int = {
    CS4224_PP_LINE_SDS_COMMON_Int, CS4224_PP_LINE_SDS_COMMON_IntEn, CS4224_IRQ_NO_STATUS,
    4, 4096, 12,
    0x0C0F,
    &CS4224_IRQ_NODE_CHILDREN_PP_LINE_SDS_COMMON_Int,
    &CS4224_IRQ_NODE_PARENTS_PP_LINE_SDS_COMMON_Int,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_LINE_SDS_COMMON_Int",
    11,
    {

        ""

,
        "RXLOCKDi",

        ""

,

        ""

,
        "",
        "",
        "",
        "",
        "",
        "",

        ""

,

        ""

    }
#endif
};

cs4224_irq_node_children_t CS4224_IRQ_NODE_CHILDREN_PP_LINE_SDS_COMMON_RXLOCKDi = {
    { &CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 },
    { CS4224_IRQ_NODE_NO_NODE, 0 }
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_LINE_SDS_COMMON_RXLOCKDi = {
    { &CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_Int, 0x2 }
};

/* ID = 586 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_RXLOCKDi = {
    CS4224_PP_LINE_SDS_COMMON_RXLOCKDi, CS4224_PP_LINE_SDS_COMMON_RXLOCKDe, CS4224_IRQ_NO_STATUS,
    4, 4096, 1,
    0x0001,
    &CS4224_IRQ_NODE_CHILDREN_PP_LINE_SDS_COMMON_RXLOCKDi,
    &CS4224_IRQ_NODE_PARENTS_PP_LINE_SDS_COMMON_RXLOCKDi,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_LINE_SDS_COMMON_RXLOCKDi",
    0,
    {
        "RXLOCKD0i"
    }
#endif
};

cs4224_irq_node_parents_t CS4224_IRQ_NODE_PARENTS_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT = {
    { &CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_RXLOCKDi, 0x1 }
};

/* ID = 478 */
cs4224_irq_node_t CS4224_IRQ_NODE_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT = {
    CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTENABLE, CS4224_IRQ_NO_STATUS,
    4, 4096, 0,
    0x00FF,
    CS4224_IRQ_NODE_NO_NODE,
    &CS4224_IRQ_NODE_PARENTS_PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT,
    CS4224_IRQ_NO_HANDLER,
#if CS4224_IRQ_PRINT_INTERRUPTS
    "PP_LINE_SDS_COMMON_RXLOCKD0_INTERRUPT",
    7,
    {
        "LOCKi",
        "BAD_VCO_CLKi",
        "SHORT_FILTPNi",
        "DATA_DETi",
        "CIDZEROi",
        "CIDONEi",
        "FILT_LOCKi",
        "CLKLESS_STATUSi"
    }
#endif
};

#endif /* CS_HAS_INTERRUPTS */

/** @file cs4224_kran.c
 ****************************************************************************
 *
 * @brief
 *     This module contains methods for configuring the KR-AN feature.
 *
 *     Testing notes: 
 *       - This file sync'd with file widgetkr.cpp CVS version 1.23
 *
 *       - This API sync'd with ucode built on (or after): 2014-03-14
 *
 *       - The GUI KR code can be found:
 *
 *          Linux:
 *            /home/rmarchan/code_k2/design/sw/drivers/HSIO/gui/controllers/hsio/k2_controller/widgets/widgetkr.cpp
 *
 *          QT hierarchy:
 *            gui\k2_controller\sources\widgets
 *
 *     This is an example of the sequence of events when bringing-up a KR link. Note that this
 *     example is for when 1 and 10G are advertised, 1G negotiated:
 * 
 *       - The host asic supplies 10G traffic to the K2 host side.
 *       - KR ucode starts AN.
 *       - For AN, the ucode sets up the host-side receiver in 1G PFD mode.
 *       - KR ucode advertises 1G or 10G.
 *       - If 10G negotiated, there is nothing to do now or after tear down/re-negotiate.
 *       - If 1G negotiated, the ucode leaves its host-side in 1G PFD mode.
 *       - Once 1G PCS source becomes available at the host asic, the API switches the host-side 
 *            to PD mode, starts up the GEPCS unit and clears SPARE25[1]
 *       - If 1G KR link tears down and SPARE25[1] is cleared, AN will be re-run staying PD mode instead
 *            of going to PFD mode. This means there is nothing to do after tear down/re-negotiate. 
 *            This would be fine so long as 1G is re-negotiated however since we advertised 1G and 10G, 
 *            we must prepare as if 10G will be negotiated. The host asic may supply 10G traffic to the K2 host 
 *            side in the hopes of negotiating 10G therefore a call to enter_operational_state is required.
 *       - In post-AN, If host side setup for DFE mode and 1G negotiated,
 *            Post-AN must call edc_mode_set to configure the host to SR EDC mode.
 *
 ****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ***************************************************************************/

extern cs_uint32 cs4224_max_num_dies;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 prev3          :4;
    cs_uint16 prev2          :4;
    cs_uint16 prev1          :4;
    cs_uint16 current        :4;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :4;
    cs_uint16 prev1          :4;
    cs_uint16 prev2          :4;
    cs_uint16 prev3          :4;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_AN_TX_ARBITRATOR_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :1;
    cs_uint16 prev4          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev4          :3;
    cs_uint16 rsrvd1         :1;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_TP_TX_TRAINING_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :1;
    cs_uint16 prev4          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev4          :3;
    cs_uint16 rsrvd1         :1;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_TP_TX_ENCODER_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :1;
    cs_uint16 prev4          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 prev4          :3;
    cs_uint16 rsrvd1         :1;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_TP_RX_FRAME_LOCK_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :4;
    cs_uint16 prev3          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev1          :3;
    cs_uint16 current        :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 current        :3;
    cs_uint16 prev1          :3;
    cs_uint16 prev2          :3;
    cs_uint16 prev3          :3;
    cs_uint16 rsrvd1         :4;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_TP_RX_FM_DETECT_STATE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :13;
    cs_uint16 rtune_override :1;
    cs_uint16 itune_override :1;
    cs_uint16 tx_eq_override :1;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 tx_eq_override :1;
    cs_uint16 itune_override :1;
    cs_uint16 rtune_override :1;
    cs_uint16 rsrvd1         :13;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_LINEMISC_OVERRIDE_EN_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 SNR_ZEROS_lsb  :16;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 SNR_ZEROS_lsb  :16;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_DSP_MSEQ_SNR_ZEROS_LSB_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :9;
    cs_uint16 DSP_CAL_DATA_SEL:1;
    cs_uint16 DSP_ERROR_POLARITY_SEL:1;
    cs_uint16 DSP_ERROR_PATH_SEL:1;
    cs_uint16 SRX_DFE_ERROR_POLARITY_SEL:1;
    cs_uint16 SRX_DFE_ERROR_PATH_SEL:1;
    cs_uint16 UCODELDOVR     :1;
    cs_uint16 UCODELDVAL     :1;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 UCODELDVAL     :1;
    cs_uint16 UCODELDOVR     :1;
    cs_uint16 SRX_DFE_ERROR_PATH_SEL:1;
    cs_uint16 SRX_DFE_ERROR_POLARITY_SEL:1;
    cs_uint16 DSP_ERROR_PATH_SEL:1;
    cs_uint16 DSP_ERROR_POLARITY_SEL:1;
    cs_uint16 DSP_CAL_DATA_SEL:1;
    cs_uint16 rsrvd1         :9;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_DSP_MSEQ_ENABLE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 SRX_AGC_LPBK_SEL_POLE:3;
    cs_uint16 rsrvd1         :5;
    cs_uint16 SRX_AGC_LPBK_SEL_LPF:1;
    cs_uint16 SRX_AGC_ITUNE  :3;
    cs_uint16 rsrvd2         :4;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 rsrvd2         :4;
    cs_uint16 SRX_AGC_ITUNE  :3;
    cs_uint16 SRX_AGC_LPBK_SEL_LPF:1;
    cs_uint16 rsrvd1         :5;
    cs_uint16 SRX_AGC_LPBK_SEL_POLE:3;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :13;
    cs_uint16 SRX_CML_ITUNE  :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 SRX_CML_ITUNE  :3;
    cs_uint16 rsrvd1         :13;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :3;
    cs_uint16 SRX_DFE_T6_EN  :1;
    cs_uint16 SRX_DFE_T5_EN  :1;
    cs_uint16 SRX_DFE_RTUNE  :3;
    cs_uint16 rsrvd2         :1;
    cs_uint16 SRX_DFE_ITUNE  :3;
    cs_uint16 rsrvd3         :2;
    cs_uint16 SRX_DFE_SUBRATE_SEL:1;
    cs_uint16 SRX_DFE_BYPASS_EN:1;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 SRX_DFE_BYPASS_EN:1;
    cs_uint16 SRX_DFE_SUBRATE_SEL:1;
    cs_uint16 rsrvd3         :2;
    cs_uint16 SRX_DFE_ITUNE  :3;
    cs_uint16 rsrvd2         :1;
    cs_uint16 SRX_DFE_RTUNE  :3;
    cs_uint16 SRX_DFE_T5_EN  :1;
    cs_uint16 SRX_DFE_T6_EN  :1;
    cs_uint16 rsrvd1         :3;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :9;
    cs_uint16 SRX_VCO_ITUNE  :3;
    cs_uint16 rsrvd2         :1;
    cs_uint16 SRX_CML_RTUNE  :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 SRX_CML_RTUNE  :3;
    cs_uint16 rsrvd2         :1;
    cs_uint16 SRX_VCO_ITUNE  :3;
    cs_uint16 rsrvd1         :9;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :5;
    cs_uint16 STX_DRIVER_RTUNE:3;
    cs_uint16 rsrvd2         :5;
    cs_uint16 STX_DRIVER_ITUNE:3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 STX_DRIVER_ITUNE:3;
    cs_uint16 rsrvd2         :5;
    cs_uint16 STX_DRIVER_RTUNE:3;
    cs_uint16 rsrvd1         :5;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_STX0_DRIVER_TUNE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :5;
    cs_uint16 STX_DRIVERCML_RTUNE:3;
    cs_uint16 rsrvd2         :5;
    cs_uint16 STX_DRIVERCML_ITUNE:3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 STX_DRIVERCML_ITUNE:3;
    cs_uint16 rsrvd2         :5;
    cs_uint16 STX_DRIVERCML_RTUNE:3;
    cs_uint16 rsrvd1         :5;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_STX0_DRIVERCML_TUNE_t;

typedef union {
  struct {
#   ifdef CS_BIG_ENDIAN
    cs_uint16 rsrvd1         :13;
    cs_uint16 SRX_AGC_RTUNE  :3;

#   else /* CS_LITTLE_ENDIAN */
    cs_uint16 SRX_AGC_RTUNE  :3;
    cs_uint16 rsrvd1         :13;

#   endif
    } bf ;
    cs_uint16     wrd ;
} CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE_t;

/* forward declare just in case the ordering is different */
cs_status cs4224_diags_clear_interrupts(cs_uint32 slice);

cs_uint16 reg_get(
    cs_uint32 slice, 
    cs_uint16 addr)
{
    cs_uint16 data;

    cs4224_reg_get_channel(slice, addr, &data);

    return data;
}

/**
 * Dump out state information while waiting for AN to complete
 *
 * @param slice     [I] - The slice or port of the device(s) being initialized
 * @param loopcount [I] - The number of times this method is called
 *
 * @return void
 *
 * @private
 */
void cs4224_kran_dump_regs(
    cs_uint32 slice,
    cs_uint32 loop_count)
{

    CS4224_KRAN_HIDDEN_PP_LINE_AN_TX_ARBITRATOR_STATE_t arb_state;
    cs_uint16 prev_retries;

    /* print the header */
    if (0 == (loop_count % 20))
    {
        CS_PRINTF(("---- Slice 0x%08x -------------------------LINE------------------------------ -----------------------HOST---------------------\n", slice));
    /*  CS_PRINTF(("---- Slice 0x12345678 -------------------------LINE------------------------------ -----------------------HOST---------------------\n", slice));*/
        CS_PRINTF(("Reg: CurSta,ArbSta,BPstat,MseqSt,ResetC,BankSl,Squelc,Sp14LS,Sp15MS,PrevRt,CurrRt Sp14LS,Sp15MS,BankSl,MseqSt,Squelc,MseqEn,ClkDiv\n"));
        CS_PRINTF(("Add: 0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x 0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x\n",
                CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE,
                CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE,
                CS4224_PP_LINE_AN_TX_BP_STATUS,
                CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS,
                CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_LSB,
                CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR,
                CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH,
                CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE14_LSB,
                CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE15_MSB,
                CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB,
                CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB,
                CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE14_LSB,
                CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE15_MSB,                  
                CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR,
                CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS,
                CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH,
                CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE,
                CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL));

        CS_PRINTF(("--------------------------------------------------------------------------------- ------------------------------------------------\n"));
    }

    /* print the register values */
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB, &prev_retries);
    cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE, &(arb_state.wrd));

    CS_PRINTF(("Val: "));
    switch(arb_state.bf.current)
    {
        case 0:  CS_PRINTF(("AnEnab,")); break;
        case 1:  CS_PRINTF(("TxDisa,")); break;
        case 2:  CS_PRINTF(("AbDetc,")); break;
        case 3:  CS_PRINTF(("AkDetc,")); break;
        case 4:  CS_PRINTF(("CpAckn,")); break;
        case 5:  CS_PRINTF(("NxPgWt,")); break;
        case 6:  CS_PRINTF(("AnGchk,")); break;
        case 7:  CS_PRINTF(("AnGood,")); break;
        case 8:  CS_PRINTF(("LnStck,")); break;
        case 9:  CS_PRINTF(("PaDetc,")); break;
        default: CS_PRINTF(("Garbag,")); break;
    }

    CS_PRINTF(("0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,",
                reg_get(slice,CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE),
                reg_get(slice,CS4224_PP_LINE_AN_TX_BP_STATUS),
                reg_get(slice,CS4224_PP_LINE_SDS_DSP_MSEQ_STATUS),
                reg_get(slice,CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_LSB),
                reg_get(slice,CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR),
                reg_get(slice,CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH),
                reg_get(slice,CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE14_LSB),
                reg_get(slice,CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE15_MSB)));
    CS_PRINTF(("0x%04x,0x%04x ",prev_retries, reg_get(slice,CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB)));
    CS_PRINTF(("0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x,0x%04x\n",
                reg_get(slice,CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE14_LSB),
                reg_get(slice,CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE15_MSB),                  
                reg_get(slice,CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR),
                reg_get(slice,CS4224_PP_HOST_SDS_DSP_MSEQ_STATUS),
                reg_get(slice,CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH),
                reg_get(slice,CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE),
                reg_get(slice,CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL)));
}

/**
 * Initialize the KRAN advanced settings prior to configuring KR 
 *
 * @param config   [I] - Pointer to the KR specific configuration data
 * @param rules    [I] - The default initialization rules for the specified
 *                       application.
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */

cs_status cs4224_kran_init_advanced(
    cs4224_kran_config_t_s* config,
    cs4224_rules_t*         rules)
{
    cs_status status = CS_OK;

    config->advanced.phase_or           = rules->kran.advanced.phase_or;
    config->advanced.hphase_or          = rules->kran.advanced.hphase_or;
    config->advanced.en_adt             = rules->kran.advanced.en_adt;
    config->advanced.en_mwt             = rules->kran.advanced.en_mwt;
    config->advanced.skip_an            = rules->kran.advanced.skip_an;
    config->advanced.skip_tp            = rules->kran.advanced.skip_tp;
    config->advanced.skip_phsc          = rules->kran.advanced.skip_phsc;
    config->advanced.en_lfit            = rules->kran.advanced.en_lfit;
    config->advanced.en_retry           = rules->kran.advanced.en_retry;
    config->advanced.dis_start          = rules->kran.advanced.dis_start;
    config->advanced.en_pwrsv           = rules->kran.advanced.en_pwrsv;
    config->advanced.en_dfe             = rules->kran.advanced.en_dfe;
    config->advanced.bad_mrkrs          = rules->kran.advanced.bad_mrkrs;
    config->advanced.dis_sync           = rules->kran.advanced.dis_sync;
    config->advanced.sqlch_egr          = rules->kran.advanced.sqlch_egr;
    config->advanced.sqlch_ing          = rules->kran.advanced.sqlch_ing;
    config->advanced.ring               = rules->kran.advanced.ring;      
    config->advanced.phase_ov           = rules->kran.advanced.phase_ov;
    config->advanced.hphase_ov          = rules->kran.advanced.hphase_ov;
    config->advanced.xtra_f             = rules->kran.advanced.xtra_f;
    config->advanced.pcs_itr            = rules->kran.advanced.pcs_itr;
    config->advanced.lfi_10g            = rules->kran.advanced.lfi_10g;
    config->advanced.lfi_thres          = rules->kran.advanced.lfi_thres;
    config->advanced.lfi_1g             = rules->kran.advanced.lfi_1g;
    config->advanced.wait_tmr           = rules->kran.advanced.wait_tmr;
    config->advanced.tpm0               = rules->kran.advanced.tpm0; 
    config->advanced.tpm1               = rules->kran.advanced.tpm1; 
    config->advanced.tpm2               = rules->kran.advanced.tpm2; 
    config->advanced.tpm3               = rules->kran.advanced.tpm3; 
    config->advanced.tpm4               = rules->kran.advanced.tpm4; 
    config->advanced.tpm567             = rules->kran.advanced.tpm567;
    config->advanced.preset             = rules->kran.advanced.preset;
    config->advanced.tpm30              = rules->kran.advanced.tpm30;
    config->advanced.tpm31              = rules->kran.advanced.tpm31;
    config->advanced.two_pass_mode      = rules->kran.advanced.two_pass_mode;
    config->advanced.max_wait           = rules->kran.advanced.max_wait;
    config->advanced.jmp2cal            = rules->kran.advanced.jmp2cal;
    config->advanced.fec_bypass         = rules->kran.advanced.fec_bypass;
    config->advanced.line_t_to_conv_dfe = rules->kran.advanced.line_t_to_conv_dfe;
    config->advanced.host_t_to_conv_dfe = rules->kran.advanced.host_t_to_conv_dfe;
    
    if (rules->ref_clk_rate == CS4224_REF_CLK_106p25)
    {
        config->advanced.ref106   = TRUE;
    }
    else
    {
        config->advanced.ref106   = FALSE;
    }

    return status;
}

const char* cs4224_kran_get_an_arb_state_str(
    int state) 
{

    switch(state) {
        case 0: return  " AN_ENABLE"; break;
        case 1: return  "TRANS_DISA"; break;
        case 2: return  "ABILTY_DET"; break;
        case 3: return  "ACK_DETECT"; break;
        case 4: return  "  COMP_ACK"; break;
        case 5: return  "   NP_WAIT"; break;
        case 6: return  "AN_GOODCHK"; break;
        case 7: return  "   AN_GOOD"; break;
        case 8: return  "LNK_STACHK"; break;
        case 9: return  "PAR_DT_FLT"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

const char* cs4224_kran_get_tp_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "      INIT"; break;
        case 1: return  "SEND_TRAIN"; break;
        case 2: return  "TRAIN_LOCL"; break;
        case 3: return  "TRAIN_FAIL"; break;
        case 4: return  "TRAIN_REMO"; break;
        case 5: return  "LINK_READY"; break;
        case 6: return  " SEND_DATA"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

const char* cs4224_kran_get_tp_fm_detect_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "OUT_OF_SYN"; break;
        case 1: return  "   DO_SLIP"; break;
        case 2: return  "NEW_MARKER"; break;
        case 3: return  "MRKR_FOUND"; break;
        case 4: return  "COEF_UPDAT"; break;
        case 5: return  "STATUS_REP"; break;
        case 6: return  "TRAIN_PATT"; break;
        case 7: return  "FRAME_MARK"; break;
        case 8: return  "BAD_MARKER"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

const char* cs4224_kran_get_tp_fm_lock_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "OUT_OF_FRM"; break;
        case 1: return  "RESET_COUN"; break;
        case 2: return  "GET_NEW_MA"; break;
        case 3: return  "TEST_MARKR"; break;
        case 4: return  "VALID_MARK"; break;
        case 5: return  "INVALID_MA"; break;
        case 6: return  "  IN_FRAME"; break;
        case 7: return  "      SLIP"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

const char* cs4224_kran_get_tp_encoder_state_str(
    int state) 
{
    switch(state) {
        case 0: return  "      IDLE"; break;
        case 1: return  "FRAME_MARK"; break;
        case 2: return  "COEFF_UPDA"; break;
        case 3: return  "STATUS_REP"; break;
        case 4: return  "        TP"; break;
        default: return "     UNDEF"; break;
    }
    return "    UNDEF";
}

/**
 * Dump out the status of the KR session
 *
 * @param slice       [I] - The slice of the KR session
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_kran_status(
    cs_uint32 slice) 
{
    cs_status status = CS_OK;
    int i;
    cs_uint32 temp;
    cs_uint16 data, data_host, addr, msb, lsb;
    /* Convert the fetched data into bitfields (if necessary) */
    CS4224_KRAN_HIDDEN_PP_LINE_AN_TX_ARBITRATOR_STATE_t     arb_state;
    CS4224_KRAN_HIDDEN_PP_LINE_LINEMISC_OVERRIDE_EN_t       tx_eq_ovr;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_DSP_MSEQ_SNR_ZEROS_LSB_t snr;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_DSP_MSEQ_ENABLE_t        mseq_enable;
    CS4224_PP_LINE_AN_TX_COMPLETE_STATUS_t                  cmplt_status;
    CS4224_PP_LINE_AN_TX_MAIN_INTS_t                        main_ints;
    CS4224_PP_LINE_AN_TX_BP_STATUS_t                        bp_status;
    CS4224_PP_LINE_AN_RX_LP_ABILITY_1_t                     lp_ability_1;
    CS4224_PP_LINE_TP_TX_TRAINING_INTS_t                    trn_ints;
    CS4224_PP_LINE_TP_RX_FRAME_LOCK_INTS_t                  frm_lck;
    CS4224_KRAN_HIDDEN_PP_LINE_TP_TX_TRAINING_STATE_t       trn_state;
    CS4224_PP_LINE_TP_TX_PRE_COEFF_t                        pre_coeff;
    CS4224_PP_LINE_TP_TX_MAIN_COEFF_t                       main_coeff;
    CS4224_PP_LINE_TP_TX_POST_COEFF_t                       post_coeff;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA_t        ctrla;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB_t        ctrlb;
    CS4224_PP_LINE_KR_FEC_TX_STATUS_t                       tx_status;
    CS4224_PP_LINE_KR_FEC_RX_STATUS_t                       rx_status;
    CS4224_PP_LINE_XGPCS_RX_RXSTATUS_t                      xgpcs_rx_status;
    CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS_t          rxlockd_status;
    CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR_t             bankselect;
    CS4224_PP_LINE_SDS_DSP_MSEQ_PC_SHADOW_t                 pc_shadow;
    CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW_t            options_shadow;
    CS4224_PP_LINE_GIGEPCS_INT_LINE_PCS1GE_INTSTATUS_t      line_pcs1ge;
    CS4224_PP_HOST_GIGEPCS_INT_HOST_PCS1GE_INTSTATUS_t      host_pcs1ge;
    cs_uint16                                               spare22_lsb;
    cs4224_fec_stats_t                                      fec_stats;
    cs_uint16                                               upd;
    cs_uint32                                               rstc;
    cs_uint16                                               pin_status;
    cs_uint16                                               link_partner;
    cs_uint16                                               host_rxlockd0;
    
    /* Writes required to do reads of the datastore training_loop_cnt register.*/
    /* Technically-speaking the micro-sequencer should have first been stalled. */

    /* For the KR interface. */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_MAIN_INTS                  , &(main_ints.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE           , &(arb_state.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
    /* instead of AN_RX_LP_ABILITY_1, ucode shadows it into link fail timeout reg so as not to read 0xbada */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_LINK_FAIL_TIMEOUT0         , &(lp_ability_1.wrd     ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE20_LSB         , &(upd                  ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_TX_TRAINING_INTS              , &(trn_ints.wrd         ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_RX_FRAME_LOCK_INTS            , &(frm_lck.wrd          ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF                  , &(pre_coeff.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF                 , &(main_coeff.wrd       ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF                 , &(post_coeff.wrd       ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA  , &(ctrla.wrd            ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB  , &(ctrlb.wrd            ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN             , &(tx_eq_ovr.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SNR_ZEROS_LSB       , &(snr.wrd              ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_TX_STATUS                 , &(tx_status.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_KR_FEC_RX_STATUS                 , &(rx_status.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_XGPCS_RX_RXSTATUS                , &(xgpcs_rx_status.wrd  ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_ENABLE              , &(mseq_enable.wrd      ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS    , &(rxlockd_status.wrd   ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR       , &(bankselect.wrd       ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_PC_SHADOW           , &(pc_shadow.wrd        ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW      , &(options_shadow.wrd   ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_GIGEPCS_INT_LINE_PCS1GE_INTSTATUS, &(line_pcs1ge.wrd      ));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_GIGEPCS_INT_HOST_PCS1GE_INTSTATUS, &(host_pcs1ge.wrd      ));

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_LSB     , &(data));
    rstc = data;
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_RESET_COUNT_MSB     , &(data));
    rstc += (data << 16);
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB , &(spare22_lsb));
    
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_PIN_STATUS, &pin_status);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_RX_LP_ABILITY_2, &link_partner);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS, &host_rxlockd0);
    
    /* Display the results */

    CS_PRINTF(("KR-AN Status for K2 Slice %x\n", slice));
    CS_PRINTF(("============================\n"));
    CS_PRINTF(("ASIC Status\n"));
    CS_PRINTF(("    pin_status:    %4x ", pin_status));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_CHIP_ID_MSB,      &data);
    CS_PRINTF(("    asic_rev:      %4x\n", data));
    
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_SCRATCH7,         &data);
    CS_PRINTF(("    api_version:   %4x ", data));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP0, &data);
    CS_PRINTF(("    ucode_vers:    %02x/%02x/", data & 0xff, (data >> 8) & 0xff));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP1, &data);
    CS_PRINTF(("%04x\n", data));
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_FUNCEN, &data);
    CS_PRINTF(("    line_func_en:  %-4x ", data));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_HOSTMISC_FUNCEN, &data);
    CS_PRINTF(("    host_func_en:  %-4x\n", data));
    
    
    
    CS_PRINTF(("Clause 73 Auto-Negotiation                   AN State Machine History\n"));
    
    CS_PRINTF(("    AN Good Check:      %s", cmplt_status.bf.an_good_check         ? "True " : "False" ));
    CS_PRINTF(("                    Current:            %s\n", cs4224_kran_get_an_arb_state_str(arb_state.bf.current)));
    CS_PRINTF(("    AN Good:            %s", cmplt_status.bf.an_complete           ? "True " : "False" ));
    CS_PRINTF(("                    Previous 1:         %s\n", cs4224_kran_get_an_arb_state_str(arb_state.bf.prev1)));
    CS_PRINTF(("    AN Failure:         %s", main_ints.bf.link_fail_inhibit_timerS ? "True " : "False" ));
    CS_PRINTF(("                    Previous 2:         %s\n", cs4224_kran_get_an_arb_state_str(arb_state.bf.prev2)));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_ENABLE, &data);
    CS_PRINTF(("    Enabled:            %-3s                      Previous 3:         %s\n",
        ((data & 1) == 1) ? "yes" : "no",
        cs4224_kran_get_an_arb_state_str(arb_state.bf.prev3)));

    CS_PRINTF(("Clause 72 Startup/Training Protocol          Training State Machine History\n"));
    CS_PRINTF(("    TP Failure:         %s", trn_ints.bf.training_failureS ?  "True " : "False"));
    CS_PRINTF(("                    Current:            %s\n", cs4224_kran_get_tp_state_str(trn_state.bf.current)));
    CS_PRINTF(("    TP Complete:        %s", trn_ints.bf.training_completeS ? "True " : "False"));
    CS_PRINTF(("                    Previous 1:         %s\n", cs4224_kran_get_tp_state_str(trn_state.bf.prev1)));
    CS_PRINTF(("    TP Frame Lock:      %s", frm_lck.bf.frame_lockS ?         "True " : "False"));
    CS_PRINTF(("                    Previous 2:         %s\n", cs4224_kran_get_tp_state_str(trn_state.bf.prev2)));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_TX_ENABLE, &data);
    CS_PRINTF(("    Enabled:            %-3s                      Previous 3:         %s\n",
        ((data & 1) == 1) ? "yes" : "no",
        cs4224_kran_get_tp_state_str(trn_state.bf.prev3)));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_TX_TRAINING, &data);
    CS_PRINTF(("    In Progress:        %-3s                      Previous 4:         %s\n",
        data == 1 ? "yes" : "no",
        cs4224_kran_get_tp_state_str(trn_state.bf.prev4)));

    CS_PRINTF(("AN Negotiated Results:\n"));
    CS_PRINTF((    "  AN retries:   %d (SPARE22_LSB)  ", spare22_lsb));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_RX_PAGE_RECEIVED, &data);
    CS_PRINTF((    "  AN page received:   %s\n", data == 1 ? "Yes" : data == 0xBADA ? "Unknown" : "No"));
    
    CS_PRINTF(("  Results:\n"));
        
    if (cmplt_status.bf.an_complete)
    {
        CS_PRINTF(("    1000Base-KX:        %s\n" ,  bp_status.bf.bp_1000kx ?       "ON" : "OFF"));
        CS_PRINTF(("    10GBase-KR:         %s\n" ,  bp_status.bf.bp_10gkr ?        "ON" : "OFF"));
        CS_PRINTF(("    40GBase-KR4:        %s\n" ,  bp_status.bf.bp_40gkr4 ?       "ON" : "OFF"));
        CS_PRINTF(("    40GBase-CR4:        %s\n" ,  bp_status.bf.bp_40gcr4 ?       "ON" : "OFF"));
        CS_PRINTF(("    10GBase-KX4:        %s\n" ,  bp_status.bf.bp_10gkx4 ?       "ON" : "OFF"));
        CS_PRINTF(("    FEC Ability:        %s\n" ,  bp_status.bf.bp_fec ?          "ON" : "OFF"));
        CS_PRINTF(("    Parallel Detect:    %s\n" ,  bp_status.bf.parallel_detect ? "ON" : "OFF"));
        CS_PRINTF(("    Remote Fault:       %s\n" ,  lp_ability_1.bf.rf?            "ON" : "OFF"));
        CS_PRINTF(("    Pause:              0x%x\n", lp_ability_1.bf.pause));
        
        if(link_partner != 0xBADA)
        {
            CS_PRINTF(("    Link Partner Advertised:\n"));
            CS_PRINTF(("        1000Base-KX:    %s\n", (link_partner >> 5) & 0x1 ? "ON" : "OFF"));
            CS_PRINTF(("        10GBase-KX4:    %s\n", (link_partner >> 6) & 0x1 ? "ON" : "OFF"));
            CS_PRINTF(("        10GBase-KR:     %s\n", (link_partner >> 7) & 0x1 ? "ON" : "OFF"));
            CS_PRINTF(("        40GBase-KR4:    %s\n", (link_partner >> 8) & 0x1 ? "ON" : "OFF"));
            CS_PRINTF(("        40GBase-CR4:    %s\n", (link_partner >> 9) & 0x1 ? "ON" : "OFF"));
            CS_PRINTF(("        100GBase-CR10:  %s\n", (link_partner >> 10) & 0x1 ? "ON" : "OFF"));
        }
    }
    else  
    {
        CS_PRINTF(("    No Negotiated Results\n"));
    }

    

    CS_PRINTF(("Tap Values:\n"));
    if (tx_eq_ovr.bf.tx_eq_override)
    {
        CS_PRINTF(("    Override enabled:   %2x\n", tx_eq_ovr.wrd & 0x1));
        CS_PRINTF(("    Pre:                %2d (PP_LINE_TP_TX_PRE_COEFF)\n", pre_coeff.bf.value));
        CS_PRINTF(("    Main:               %2d (PP_LINE_TP_TX_MAIN_COEFF)\n", main_coeff.bf.value));
        CS_PRINTF(("    Post:               %2d (PP_LINE_TP_TX_POST_COEFF)\n", post_coeff.bf.value));
    }
    else  
    {
        CS_PRINTF(("    Override enabled:   %2x\n", tx_eq_ovr.wrd & 0x1));
        CS_PRINTF(("    Pre:                %2d (CTRLB.STX_PRE_PEAK)\n", ctrlb.bf.STX_PRE_PEAK));
        CS_PRINTF(("    Main:               %2d (CTRLA.STX_LEVEL)\n", ctrla.bf.STX_LEVEL));
        CS_PRINTF(("    Post:               %2d (CTRLB.STX_POST_PEAK)\n", ctrlb.bf.STX_POST_PEAK));
    }
    CS_PRINTF(("Performance:\n"));
    CS_PRINTF(("    SNR:                %d\n", snr.bf.SNR_ZEROS_lsb));
    status |= cs4224_mon_temp_read_fixp(slice, &temp);
    CS_PRINTF(("    Temp:               %05d milli-degrees C\n", temp));
    CS_PRINTF(("    CMODE_RES:          %d\n", ctrla.bf.STX_CMODE_RES));
    CS_PRINTF(("    ResetCounter:       %d\n", rstc));

    CS_PRINTF(("Clause 74 FEC:\n"));
    CS_PRINTF(("    FEC Tx Sync:        %s\n", tx_status.bf.fec_sync_detected ? "True" : "False"));
    CS_PRINTF(("    FEC Rx Sync:        %s\n", rx_status.bf.fec_sync_detected ? "True" : "False"));
    CS_PRINTF(("    10G PCS Rx Sync:    %s\n", xgpcs_rx_status.bf.syncdetS ?    "True" : "False"));
    CS_PRINTF(("    10G PCS Rx BER:     %s\n", xgpcs_rx_status.bf.berhighS ?    "True" : "False"));

    CS_PRINTF(("Statistics:\n"));
    if ((cmplt_status.bf.an_complete) && (bp_status.bf.bp_fec))
    {
        status = cs4224_get_fec_stats(slice, &fec_stats);

        CS_PRINTF(("    Tx Total Blocks:    %-10u\n", fec_stats.tx_blk_total));
        CS_PRINTF(("    Rx Total Blocks:    %-10u\n", fec_stats.rx_blk_total));
        CS_PRINTF(("    Rx Corr. Blocks:    %-10u\n", fec_stats.rx_blk_corr));
        CS_PRINTF(("    Rx Uncorr. Blocks:  %-10u\n", fec_stats.rx_blk_uncorr));
        CS_PRINTF(("    Rx Zero Bit Blocks: %-10u\n", fec_stats.rx_zero_errs));
        CS_PRINTF(("    Rx One Bit Blocks:  %-10u\n", fec_stats.rx_one_errs));
    }
    else
    {
        CS_PRINTF(("    FEC Not Negotiated, No FEC Stats\n"));
    }

    CS_PRINTF(("Device Status:\n"));
    
    CS_PRINTF(("             Line                  Host\n"));
    CS_PRINTF(("             --------              --------\n"));
    
    CS_PRINTF(("    Lock:    %-5s (%4x)          %-5s (%4x)\n",
             ((rxlockd_status.wrd & 0x0041) == 0x0041) ? "True" : "False", rxlockd_status.wrd,
             ((host_rxlockd0 & 0x0040) == 0x0040) ? "True" : "False", host_rxlockd0));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR, &data);
    CS_PRINTF(("    Bank:    %-4d                  %-4d\n",
               bankselect.bf.bank_select_reg,
               data));
    
    CS_PRINTF(("    PC:      %04x", pc_shadow.wrd));
    for(i = 0; i < 3; i++)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_PC_SHADOW, &pc_shadow.wrd);
        CS_PRINTF((",%04x", pc_shadow.wrd));
    }
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_PC_SHADOW, &pc_shadow.wrd);
    CS_PRINTF(("   %04x", pc_shadow.wrd));
    for(i = 0; i < 4; i++)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_PC_SHADOW, &pc_shadow.wrd);
        CS_PRINTF((",%04x", pc_shadow.wrd));
    }
    CS_PRINTF(("\n"));
    
    CS_PRINTF(("    Stalled: %5s", (options_shadow.bf.OPTIONS_state & 0x0008) ? "True" : "False"));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW, &options_shadow.wrd);
    CS_PRINTF(("                 %5s\n", (options_shadow.bf.OPTIONS_state & 0x0008) ? "True" : "False"));
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH, &data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH, &data_host);
    
    CS_PRINTF(("    Squelch: %-4x                  %-4x\n", data, data_host));
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, &data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL, &data_host);
    CS_PRINTF(("    ClkDiv:  %-4x                  %-4x\n", data, data_host));
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB, &data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB, &data_host);
    
    CS_PRINTF(("    SquelEn: %-4s                  %-4s\n",
        ((data >> 2) & 0x1) == 1 ? "ON" : "OFF",
        ((data_host >> 2) & 0x1) == 1 ? "ON" : "OFF"));
    CS_PRINTF(("    PwrSav:  %-4s                  %-4s\n",
        ((data >> 1) & 0x1) == 1 ? "ON" : "OFF",
        ((data_host >> 1) & 0x1) == 1 ? "ON" : "OFF"));    
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, &data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, &data_host);
    CS_PRINTF(("    PwrDown: %-4x                  %-4x\n", data, data_host));
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA, &data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA, &data_host);
    CS_PRINTF(("    RX_CPA:  %-4x                  %-4x\n", data, data_host));
    
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES, &data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SERDES, &data_host);
    CS_PRINTF(("    MS_SRDS: %-4x                  %-4x\n", data, data_host));
    
    CS_PRINTF(("Line Side MSEQ Spare Registers:"));
    addr = CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE0_LSB;
    for (i = 0; i < 29; i++) 
    {
        if ((i % 5) == 0)
        {
            CS_PRINTF(("\n    SPAREnn=(MSW/LSW) "));
        }
        status |= cs4224_reg_get_channel(slice, addr++, &lsb);
        status |= cs4224_reg_get_channel(slice, addr++, &msb);
        CS_PRINTF(("%02d=(0x%04x/0x%04x) ", i, msb, lsb));
    }

    CS_PRINTF(("\nHost Side MSEQ Spare Registers:"));
    addr = CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE0_LSB;
    for (i = 0; i < 29; i++) 
    {
        if ((i % 5) == 0)
        {
            CS_PRINTF(("\n    SPAREnn=(MSW/LSW) "));
        }
        status |= cs4224_reg_get_channel(slice, addr++, &lsb);
        status |= cs4224_reg_get_channel(slice, addr++, &msb);
        CS_PRINTF(("%02d=(0x%04x/0x%04x) ", i, msb, lsb));
    }
    
    CS_PRINTF(("\n\n"));

    return status;
}

/**
 * Dump out the KR status summary for all slices
 *
 * @param slice       [I] - The slice of the KR session
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_kran_status_summary(
    cs_uint32 slice) 
{
    cs_status          status = CS_OK;
    cs_uint16          i, data, yyyy, mmdd, hhmm;
    /* keep only the asic portion of the slice arg */
    cs_uint32          upper_bits = slice & 0xFFFFFF00;
    cs4224_fec_stats_t fec_stats;
    cs_uint32          temp;

    /* Convert the fetched data into bitfields (if necessary) */
    CS4224_KRAN_HIDDEN_PP_LINE_AN_TX_ARBITRATOR_STATE_t     arb_state;
    CS4224_KRAN_HIDDEN_PP_LINE_TP_TX_TRAINING_STATE_t       trn_state;
    CS4224_KRAN_HIDDEN_PP_LINE_TP_TX_ENCODER_STATE_t        trn_encoder_state;
    CS4224_KRAN_HIDDEN_PP_LINE_TP_RX_FM_DETECT_STATE_t      trn_fm_detect_state;
    CS4224_KRAN_HIDDEN_PP_LINE_TP_RX_FRAME_LOCK_STATE_t     trn_fm_lock_state;
    CS4224_KRAN_HIDDEN_PP_LINE_LINEMISC_OVERRIDE_EN_t       tx_eq_ovr;
    CS4224_PP_LINE_AN_TX_COMPLETE_STATUS_t                  cmplt_status;
    CS4224_PP_LINE_AN_TX_MAIN_INTS_t                        main_ints;
    CS4224_PP_LINE_AN_TX_BP_STATUS_t                        bp_status;
    CS4224_PP_LINE_AN_RX_LP_ABILITY_1_t                     lp_ability_1;
    CS4224_PP_LINE_TP_TX_TRAINING_INTS_t                    trn_ints;
    CS4224_PP_LINE_TP_RX_FRAME_LOCK_INTS_t                  frm_lck;
    CS4224_PP_LINE_KR_FEC_TX_STATUS_t                       tx_status;
    CS4224_PP_LINE_KR_FEC_RX_STATUS_t                       rx_status;
    CS4224_PP_LINE_XGPCS_RX_RXSTATUS_t                      xgpcs_rx_status;
    CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS_t          rxlockd_status;
    CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR_t             bankselect;
    CS4224_PP_LINE_SDS_DSP_MSEQ_PC_SHADOW_t                 pc_shadow;
    CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW_t            options_shadow;
    CS4224_PP_LINE_TP_TX_PRE_COEFF_t                        pre_coeff;
    CS4224_PP_LINE_TP_TX_MAIN_COEFF_t                       main_coeff;
    CS4224_PP_LINE_TP_TX_POST_COEFF_t                       post_coeff;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA_t        ctrla;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB_t        ctrlb;
    CS4224_PP_LINE_SDS_COMMON_RX0_Config_t                  rx0_config;

    CS_PRINTF(("\nKR-AN Status"));
    CS_PRINTF(("\n============"));
    CS_PRINTF(("\nASIC Status"));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_PIN_STATUS,  &data);
    CS_PRINTF(("\n  Pin Status:    0x%04x", data));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_CHIP_ID_MSB, &data);
    CS_PRINTF(("\n  Asic Rev:      0x%04x", data));
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_SCRATCH7,    &data);
    CS_PRINTF(("\n  Api Version:   0x%04x", data));
    status |= cs4224_mon_temp_read_fixp(upper_bits + CS4224_MAX_NUM_SLICES(slice), &temp);
    CS_PRINTF(("\n  Die 0 Temp:    %05d milli-degrees C", temp));
    if (2 == cs4224_max_num_dies)
    {
        status |= cs4224_mon_temp_read_fixp(upper_bits, &temp);
        CS_PRINTF(("\n  Die 1 Temp:    %05d milli-degrees C", temp));
    }
    /* Get the timestamp of the loaded microcode */
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP1, &yyyy);
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP0, &mmdd);
    status |= cs4224_reg_get_channel(slice, CS4224_GLOBAL_UCODE_TIMESTAMP2, &hhmm);
    CS_PRINTF(("\n  ucode Version: (yyyy/mmdd/hhmm)%04x/%04x/%04x", yyyy, mmdd, hhmm));

    if (2 == CS4224_MAX_NUM_SLICES(slice))
    {
        CS_PRINTF(("\nSlices                         0          1"));
    }
    else if (4 == CS4224_MAX_NUM_SLICES(slice))
    {
        CS_PRINTF(("\nSlices                         0          1          2          3"));
    }
    else if (8 == CS4224_MAX_NUM_SLICES(slice))
    {
        CS_PRINTF(("\nSlices                         0          1          2          3          4          5          6          7"));
    }

    CS_PRINTF(("\nAN Negotiated Results"));
    CS_PRINTF(("\n  1000Base-KX:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  bp_status.bf.bp_1000kx ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  10GBase-KR:        " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  bp_status.bf.bp_10gkr  ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  40GBase-KR4:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  bp_status.bf.bp_40gkr4 ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  40GBase-CR4:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  bp_status.bf.bp_40gcr4 ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  10GBase-KX4:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  bp_status.bf.bp_10gkx4 ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  FEC Ability:       " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  bp_status.bf.bp_fec ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  Parallel Detect:   " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  bp_status.bf.parallel_detect ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }

    CS_PRINTF(("\n  Remote Fault:      " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_LINK_FAIL_TIMEOUT0         , &(lp_ability_1.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  lp_ability_1.bf.rf ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  Pause:             " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_LINK_FAIL_TIMEOUT0         , &(lp_ability_1.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF((" %s" ,  lp_ability_1.bf.pause ?       "        ON" : "       OFF"));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }

    CS_PRINTF(("\nClause 73 Auto-Negotiation"));
    CS_PRINTF(("\n  AN Good Check:     " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        CS_PRINTF((" %s", cmplt_status.bf.an_good_check         ? "      True" : "     False" ));
    }
    CS_PRINTF(("\n  AN Good:           "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        CS_PRINTF((" %s", cmplt_status.bf.an_complete           ? "      True" : "     False" ));
    }
    CS_PRINTF(("\n  AN Failure:        "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_MAIN_INTS                  , &(main_ints.wrd        ));
        CS_PRINTF((" %s", main_ints.bf.link_fail_inhibit_timerS ? "      True" : "     False" ));
    }
    CS_PRINTF(("\n  AN Enabled:        "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_ENABLE                  , &data);
        CS_PRINTF((" %s", ((data & 1) == 1) ? "      True" : "     False" ));
    }
    CS_PRINTF(("\n  AN Pages Received: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_RX_PAGE_RECEIVED                  , &data);
        CS_PRINTF((" %s", ((data & 1) == 1) ? "       Yes" : (data == 0xbada) ? "   Unknown" : "     False" ));
    }

    CS_PRINTF(("\n  AN Retries:        " ));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB         , &data);
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        if (cmplt_status.bf.an_complete)
        {
            CS_PRINTF(("       %04d" ,  data));
        }
        else  
        {
            CS_PRINTF(("        n/a"));
        }
    }

    CS_PRINTF(("\nAN State Machine History"));
    CS_PRINTF(("\n  AN SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE           , &(arb_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_an_arb_state_str(arb_state.bf.current)));
    }
    CS_PRINTF(("\n  AN SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE           , &(arb_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_an_arb_state_str(arb_state.bf.prev1)));
    }
    CS_PRINTF(("\n  AN SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE           , &(arb_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_an_arb_state_str(arb_state.bf.prev2)));
    }
    CS_PRINTF(("\n  AN SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_ARBITRATOR_STATE           , &(arb_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_an_arb_state_str(arb_state.bf.prev3)));
    }
    CS_PRINTF(("\nClause 72 Startup/Training Protocol"));
    CS_PRINTF(("\n  TP Failure:        "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_INTS              , &(trn_ints.wrd         ));
        CS_PRINTF((" %s", trn_ints.bf.training_failureS ?  "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP Complete:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_INTS              , &(trn_ints.wrd         ));
        CS_PRINTF((" %s", trn_ints.bf.training_completeS ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP FRAME Lock:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_INTS            , &(frm_lck.wrd          ));
        CS_PRINTF((" %s", frm_lck.bf.frame_lockS ?         "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP Enabled:        "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENABLE            , &data);
        CS_PRINTF((" %s", ((data & 1) == 1) ?         "      True" : "     False"));
    }
    CS_PRINTF(("\n  TP In Progress:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_RX_PAGE_RECEIVED            , &data);
        CS_PRINTF((" %s", ((data & 1) == 1) ?         "      True" : "     False"));
    }

    CS_PRINTF(("\nTraining Tx State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_state_str(trn_state.bf.current)));
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_state_str(trn_state.bf.prev1)));
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_state_str(trn_state.bf.prev2)));
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_state_str(trn_state.bf.prev3)));
    }
    CS_PRINTF(("\n  TP SM Prev 4:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_TRAINING_STATE             , &(trn_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_state_str(trn_state.bf.prev4)));
    }

    CS_PRINTF(("\nTraining Tx Encoder State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_encoder_state_str(trn_encoder_state.bf.current)));
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_encoder_state_str(trn_encoder_state.bf.prev1)));
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_encoder_state_str(trn_encoder_state.bf.prev2)));
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_encoder_state_str(trn_encoder_state.bf.prev3)));
    }
    CS_PRINTF(("\n  TP SM Prev 4:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_ENCODER_STATE             , &(trn_encoder_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_encoder_state_str(trn_encoder_state.bf.prev4)));
    }

    CS_PRINTF(("\nTraining Rx Frame Marker Detect State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.current)));
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.prev1)));
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.prev2)));
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FM_DETECT_STATE            , &(trn_fm_detect_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_detect_state_str(trn_fm_detect_state.bf.prev3)));
    }

    CS_PRINTF(("\nTraining Rx Frame Lock State Machine"));
    CS_PRINTF(("\n  TP SM Current:     "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.current)));
    }
    CS_PRINTF(("\n  TP SM Prev 1:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev1)));
    }
    CS_PRINTF(("\n  TP SM Prev 2:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev2)));
    }
    CS_PRINTF(("\n  TP SM Prev 3:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev3)));
    }
    CS_PRINTF(("\n  TP SM Prev 4:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_RX_FRAME_LOCK_STATE            , &(trn_fm_lock_state.wrd        ));
        CS_PRINTF((" %s", cs4224_kran_get_tp_fm_lock_state_str(trn_fm_lock_state.bf.prev4)));
    }

    CS_PRINTF(("\nTap Values"));
    CS_PRINTF(("\n  Override enabled:  "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN             , &(tx_eq_ovr.wrd        ));
        CS_PRINTF((" %s", (tx_eq_ovr.wrd & 0x1) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Pre:               "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN             , &(tx_eq_ovr.wrd        ));
        if (!tx_eq_ovr.bf.tx_eq_override)
        {
            status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB  , &(ctrlb.wrd            ));
            CS_PRINTF(("      %05d", ctrlb.bf.STX_PRE_PEAK));
        }
        else  
        {
            status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_PRE_COEFF                  , &(pre_coeff.wrd        ));
            CS_PRINTF(("      %05d", pre_coeff.bf.value));
        }
    }
    CS_PRINTF(("\n  Main:              "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN             , &(tx_eq_ovr.wrd        ));
        if (!tx_eq_ovr.bf.tx_eq_override)
        {
            status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA  , &(ctrla.wrd            ));
            CS_PRINTF(("      %05d", ctrla.bf.STX_LEVEL));
        }
        else  
        {
            status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_MAIN_COEFF                  , &(main_coeff.wrd        ));
            CS_PRINTF(("      %05d", main_coeff.bf.value));
        }
    }
    CS_PRINTF(("\n  Post:              "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN             , &(tx_eq_ovr.wrd        ));
        if (!tx_eq_ovr.bf.tx_eq_override)
        {
            status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB  , &(ctrlb.wrd            ));
            CS_PRINTF(("      %05d", ctrlb.bf.STX_POST_PEAK));
        }
        else  
        {
            status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_TP_TX_POST_COEFF                  , &(post_coeff.wrd        ));
            CS_PRINTF(("      %05d", post_coeff.bf.value));
        }
    }
    CS_PRINTF(("\nClause 74 FEC"));
    CS_PRINTF(("\n  FEC Tx Sync:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_TX_STATUS                 , &(tx_status.wrd        ));
        CS_PRINTF((" %s", tx_status.bf.fec_sync_detected ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  FEC Rx Sync:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_KR_FEC_RX_STATUS                 , &(rx_status.wrd        ));
        CS_PRINTF((" %s", rx_status.bf.fec_sync_detected ? "      True" : "     False"));
    }

    CS_PRINTF(("\n  10G PCS Rx Sync:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_XGPCS_RX_RXSTATUS                , &(xgpcs_rx_status.wrd  ));
        CS_PRINTF((" %s", xgpcs_rx_status.bf.syncdetS  ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  10G PCS Rx BER:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_XGPCS_RX_RXSTATUS                , &(xgpcs_rx_status.wrd  ));
        CS_PRINTF((" %s", xgpcs_rx_status.bf.berhighS  ? "      True" : "     False"));
    }

    CS_PRINTF(("\nFEC Statistics"));
    CS_PRINTF(("\n  Tx Total Blocks:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));

        if ((cmplt_status.bf.an_complete) && (bp_status.bf.bp_fec))
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.tx_blk_total));;
        }
        else
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  Rx Total Blocks:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));

        if ((cmplt_status.bf.an_complete) && (bp_status.bf.bp_fec))
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_blk_total));;
        }
        else
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  Rx Corr. Blocks:   "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));

        if ((cmplt_status.bf.an_complete) && (bp_status.bf.bp_fec))
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_blk_corr));;
        }
        else
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  Rx Uncorr. Blocks: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));

        if ((cmplt_status.bf.an_complete) && (bp_status.bf.bp_fec))
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_blk_uncorr));;
        }
        else
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  Rx Zero Bit Er Bks:"));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));

        if ((cmplt_status.bf.an_complete) && (bp_status.bf.bp_fec))
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_zero_errs));;
        }
        else
        {
            CS_PRINTF(("        n/a"));
        }
    }
    CS_PRINTF(("\n  Rx One Bit Er Bks: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_COMPLETE_STATUS            , &(cmplt_status.wrd     ));
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_AN_TX_BP_STATUS                  , &(bp_status.wrd        ));

        if ((cmplt_status.bf.an_complete) && (bp_status.bf.bp_fec))
        {
            status = cs4224_get_fec_stats(upper_bits+i, &fec_stats);
            CS_PRINTF((" %10u", fec_stats.rx_one_errs));;
        }
        else
        {
            CS_PRINTF(("        n/a"));
        }
    }

    CS_PRINTF(("\nLine Device Status"));
    CS_PRINTF(("\n  CDR Lock:          "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_RXLOCKD0_INTSTATUS    , &(rxlockd_status.wrd   ));
        CS_PRINTF((" %s", ((rxlockd_status.wrd & 0x0041) == 0x0041) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  MSEQ Bank:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR       , &(bankselect.wrd       ));
        CS_PRINTF(("          %01d", bankselect.bf.bank_select_reg));
    }
    CS_PRINTF(("\n  MSEQ PC:           "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_PC_SHADOW           , &(pc_shadow.wrd        ));
        CS_PRINTF(("      0x%03x", pc_shadow.bf.PC_state));
    }
    CS_PRINTF(("\n  MSEQ Stalled:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS_SHADOW      , &(options_shadow.wrd   ));
        CS_PRINTF((" %s", (options_shadow.bf.OPTIONS_state & 0x0008) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched Enabled: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 4) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH      , &data  );
        CS_PRINTF((" %s", (data & 1) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Power Saving Enab: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 2) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  RX Bitswap (False):"));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_RX0_Config, &(rx0_config.wrd));
        CS_PRINTF((" %s", (rx0_config.bf.bitswap) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  TX Bitswap (False):"));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_TX0_Config, &data);
        CS_PRINTF((" %s", (data & CS_BIT2) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  POWER_DOWN_LSB:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  RX_CPA:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CPA      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  MSEQ_SERDES:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_DSP_MSEQ_SERDES      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  FUNCEN:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_LINEMISC_FUNCEN      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  CLKDIV_CTRL:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_CLKDIV_CTRL      , &data);
        CS_PRINTF(("     0x%04x", data));
    }

    CS_PRINTF(("\nHost Device Status"));
    CS_PRINTF(("\n  CDR Lock:          "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_RXLOCKD0_INTSTATUS    , &(rxlockd_status.wrd   ));
        CS_PRINTF((" %s", ((rxlockd_status.wrd & 0x0041) == 0x0041) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  MSEQ Bank:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR       , &(bankselect.wrd       ));
        CS_PRINTF(("          %01d", bankselect.bf.bank_select_reg));
    }
    CS_PRINTF(("\n  MSEQ PC:           "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_PC_SHADOW           , &(pc_shadow.wrd        ));
        CS_PRINTF(("      0x%03x", pc_shadow.bf.PC_state));
    }
    CS_PRINTF(("\n  MSEQ Stalled:      "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS_SHADOW      , &(options_shadow.wrd   ));
        CS_PRINTF((" %s", (options_shadow.bf.OPTIONS_state & 0x0008) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched Enabled: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 4) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Squelched:         "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH      , &data  );
        CS_PRINTF((" %s", (data & 1) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  Power Saving Enab: "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB      , &data  );
        CS_PRINTF((" %s", (data & 2) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  RX Bitswap (False):"));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_RX0_Config, &(rx0_config.wrd));
        CS_PRINTF((" %s", (rx0_config.bf.bitswap) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  TX Bitswap (False):"));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_LINE_SDS_COMMON_TX0_Config, &data);
        CS_PRINTF((" %s", (data & CS_BIT2) ? "      True" : "     False"));
    }
    CS_PRINTF(("\n  POWER_DOWN_LSB:    "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  RX_CPA:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CPA      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  MSEQ_SERDES:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_DSP_MSEQ_SERDES      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  FUNCEN:            "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_HOSTMISC_FUNCEN      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n  CLKDIV_CTRL:       "));
    for (i = 0; i < CS4224_MAX_NUM_SLICES(slice); i++)
    {
        status |= cs4224_reg_get_channel(upper_bits+i, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_CLKDIV_CTRL      , &data);
        CS_PRINTF(("     0x%04x", data));
    }
    CS_PRINTF(("\n"));

    return status;
}

/**
 * Copies the tune settings
 *
 * @param slice    [I] - The slice of the KR session
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */

cs_status cs4224_kran_host_copy_tune_from_efuse(
    cs_uint32 slice)
{
    cs_status    status = CS_OK;
    cs_uint16    efuse_data0, efuse_data1, efuse_data2;
    CS4224_KRAN_HIDDEN_PP_LINE_LINEMISC_OVERRIDE_EN_t override_en;
    cs_uint16    reg_data;
    cs_uint16    agc_itune;
    cs_uint16    cml_itune;
    cs_uint16    dfe_itune;
    cs_uint16    vco_itune;
    cs_uint16    driver_itune;
    cs_uint16    drivercml_itune;
    cs_uint16    agc_rtune;
    cs_uint16    cml_rtune;
    cs_uint16    dfe_rtune;
    cs_uint16    driver_rtune;
    cs_uint16    drivercml_rtune;

    /* Copy the tune settings stored in the efuse locally so they
     * can be overridden.  This is done by default on the line-side
     * but if the host-side is in SR mode (which is likely) this
     * will not automatically be done.
     */

    /* Read efuse data. */
    status |= cs4224_reg_get_channel(slice, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA0, &efuse_data0);
    status |= cs4224_reg_get_channel(slice, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA1, &efuse_data1);
    status |= cs4224_reg_get_channel(slice, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA2, &efuse_data2);

    /* Unpack efuse data. */
    agc_itune       = (efuse_data0 & 0x0007) >>  0;
    cml_itune       = (efuse_data0 & 0x0070) >>  4;
    dfe_itune       = (efuse_data0 & 0x0700) >>  8;
    vco_itune       = (efuse_data0 & 0x7000) >> 12;
    driver_itune    = (efuse_data1 & 0x0007) >>  0;
    drivercml_itune = (efuse_data1 & 0x0070) >>  4;
    agc_rtune       = (efuse_data1 & 0x0700) >>  8;
    cml_rtune       = (efuse_data1 & 0x7000) >> 12;
    dfe_rtune       = (efuse_data2 & 0x0007) >>  0;
    driver_rtune    = (efuse_data2 & 0x0070) >>  4;
    drivercml_rtune = (efuse_data2 & 0x0700) >>  8;

    /* Update register itune/rtune bitfields, skip if already being overridden. */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_HOSTMISC_OVERRIDE_EN, (cs_uint16*)&override_en.wrd);
    if(!override_en.bf.itune_override)
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG2,    &reg_data);
        reg_data = (reg_data & ~(0x0007 << 4)) | (agc_itune << 4) ;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_CONFIG2,     reg_data);

        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_IBIAS_TUNE,  &reg_data);
        reg_data = (reg_data & ~(0x0007 << 0)) | (cml_itune << 0);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_IBIAS_TUNE,   reg_data);

        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG,     &reg_data);
        reg_data = (reg_data & ~(0x0007 << 4)) | (dfe_itune << 4);
        reg_data = (reg_data & ~(0x0007 << 8)) | (dfe_rtune << 8);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_DFE_CONFIG,      reg_data);

        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_RBIAS_TUNE,  &reg_data);
        reg_data = (reg_data & ~(0x0007 << 4)) | (vco_itune << 4);
        reg_data = (reg_data & ~(0x0007 << 0)) | (cml_rtune << 0);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_RBIAS_TUNE,   reg_data);

        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_TUNE,    &reg_data);
        reg_data = (reg_data & ~(0x0007 << 0)) | (driver_itune << 0);
        reg_data = (reg_data & ~(0x0007 << 8)) | (driver_rtune << 8);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVER_TUNE,     reg_data);

        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVERCML_TUNE, &reg_data);
        reg_data = (reg_data & ~(0x0007 << 0)) | (drivercml_itune << 0);
        reg_data = (reg_data & ~(0x0007 << 8)) | (drivercml_rtune << 8);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_DRIVERCML_TUNE,  reg_data);

        status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_RTUNE,      &reg_data);
        reg_data = (reg_data & ~(0x0007 << 0)) | (agc_rtune << 0);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_AGC_RTUNE,       reg_data);

        /* Over-ride efuse data with registers. */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_OVERRIDE_EN, 0x0006);
    }

    /* Copy the contents of RX_RBIAS_TUNE into SPARE25_MSB for microcode. */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_SRX0_RX_RBIAS_TUNE, &reg_data);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE25_MSB,       reg_data);

    return status;
}

/**
 * This method applies a fix to the Bug #37924.
 *
 * This bug applied in order to avoid a step size problem when the driver's cursor 
 * level goes from 31 to 32 the current solution is to have the minimum cursor setting=32.
 * For this to happen & meet KR specs the local efuse registers need to be changed.
 *
 * @param slice       [I] - The slice of the KR session
 * @param tech_cr4    [I] - Flag set if 40G Faceplate/Cable advertised
 * @param preset      [I] - Flag to enable pre/main/post Cursor Preset Values 
 *                          Needed when no loss on cable, Rosenberger to Rosenberger
 * @param tpm31       [I] - Flag to invert Pre and Post cursor orientation (Leeds emulation mode)
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_kran_bug_37924(
    cs_uint32  slice,
    cs_uint16  tech_cr4,
    cs_boolean preset,
    cs_boolean tpm31)
{
    cs_status status = CS_OK;
    CS4224_KRAN_HIDDEN_PP_LINE_LINEMISC_OVERRIDE_EN_t            override_en_t;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2_t     agc_config2_t;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE_t   rx_ibias_tune_t;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG_t      dfe_config_t;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE_t   rx_rbias_tune_t;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_STX0_DRIVER_TUNE_t     driver_tune_t;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_STX0_DRIVERCML_TUNE_t  drivercml_tune_t;
    CS4224_KRAN_HIDDEN_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE_t       agc_rtune_t;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA_t             ctrla;
    CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB_t             ctrlb;
    cs_uint16 poly_res_cal_0, poly_res_cal_1, poly_res_cal_2;
    cs_uint64 poly_res_cal;
    cs_uint16 agc_itune;     
    cs_uint16 cml_itune;     
    cs_uint16 dfe_itune;     
    cs_uint16 vco_itune;     
    cs_uint16 driver_itune;  
    cs_uint16 drivercml_itune;
    cs_uint16 agc_rtune;     
    cs_uint16 cml_rtune;     
    cs_uint16 dfe_rtune;     
    cs_uint16 driver_rtune;  
    cs_uint16 drivercml_rtune;

    /* First Thing: Override some SerDes configuration default values */
    ctrla.wrd = CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA_dft;
    ctrlb.wrd = CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB_dft;

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, &(ctrla.wrd));
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, &(ctrlb.wrd));

    if(tech_cr4)
    {
        ctrla.bf.STX_CMODE_RES     = 7;
        ctrla.bf.STX_DRV_LOWER_CM  = 8;
        ctrlb.bf.STX_SLEW_RATE_ADJ = 0;
    }
    else
    {
        ctrla.bf.STX_CMODE_RES     = 5;
        ctrla.bf.STX_DRV_LOWER_CM  = 8;
        ctrlb.bf.STX_SLEW_RATE_ADJ = 0;
    }

/* TODO: multi-threaded support */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, ctrla.wrd);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, ctrlb.wrd);

    /* First Thing: Override some SerDes configuration default values for the three main taps */
    /* From the Bugzilla, take the pre-min invert it into pre-max   */
    /*                             post-min invert it into post-max */
    /*                             pre-max invert it into pre-min   */
    /*                             post-max invert it into post-min */
    if(tech_cr4)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_MIN_LIMIT, tpm31 ? 0x0020 : 0x0020); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_MIN_LIMIT, tpm31 ? 0x0000 : 0x001d); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_MIN_LIMIT,  tpm31 ? 0x0000 : 0x0011); 

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_MAX_LIMIT, tpm31 ? 0x0031 : 0x0031); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_MAX_LIMIT, tpm31 ? 0x0022 : 0x003f); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_MAX_LIMIT,  tpm31 ? 0x000e : 0x001f); 

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_INIT,      tpm31 ? 0x0020 : 0x0020); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_INIT,      tpm31 ? 0x0020 : 0x001f); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_INIT,       tpm31 ? 0x0004 : 0x001b); 

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_PRESET,    tpm31 ? 0x0031 : 0x0031); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_PRESET,    tpm31 ? 0x0000 : 0x003f); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_PRESET,     tpm31 ? 0x0000 : 0x001f); 

        if (preset)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_START, tpm31 ? 0x0031 : 0x0031); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_START, tpm31 ? 0x0000 : 0x003f); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_START,  tpm31 ? 0x0000 : 0x001f); /* same as preset */
        }
        else
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_START, tpm31 ? 0x0020 : 0x0020); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_START, tpm31 ? 0x0020 : 0x001f); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_START,  tpm31 ? 0x0004 : 0x001b); /* same as preset */
        }
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_MIN_LIMIT, tpm31 ? 0x0020 : 0x0020); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_MIN_LIMIT, tpm31 ? 0x0001 : 0x001c); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_MIN_LIMIT,  tpm31 ? 0x0000 : 0x0011); 

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_MAX_LIMIT, tpm31 ? 0x002b : 0x002b); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_MAX_LIMIT, tpm31 ? 0x0023 : 0x003e); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_MAX_LIMIT,  tpm31 ? 0x000e : 0x001f); 

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_INIT,      tpm31 ? 0x0020 : 0x0020); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_INIT,      tpm31 ? 0x0017 : 0x0028); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_INIT,       tpm31 ? 0x0004 : 0x001b); 

        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_PRESET,    tpm31 ? 0x0020 : 0x002b); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_PRESET,    tpm31 ? 0x0001 : 0x003e); 
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_PRESET,     tpm31 ? 0x0000 : 0x001f); 

        if (preset)
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_START, tpm31 ? 0x002b : 0x002b); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_START, tpm31 ? 0x0001 : 0x003e); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_START,  tpm31 ? 0x0000 : 0x001f); /* same as preset */
        }
        else
        {
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAIN_COEFF_START, tpm31 ? 0x0020 : 0x0020); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_POST_COEFF_START, tpm31 ? 0x0017 : 0x0028); /* same as preset */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRE_COEFF_START,  tpm31 ? 0x0004 : 0x001b); /* same as preset */
        }
    }

    /* Second Thing: Adjust the driver itune and rtune values */
    /* Need to adjust an itune and rtune value. */
    /* They can either be overridden locally in the SDS */
    /* otherwise taken from the efuse. */

    /* First fetch the data from the efuse whether it is used or not. */
    status |= cs4224_reg_get_channel(slice, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA0, &poly_res_cal_0);
    status |= cs4224_reg_get_channel(slice, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA1, &poly_res_cal_1);
    status |= cs4224_reg_get_channel(slice, CS4224_EFUSE_PDF_POLY_RES_CAL_DATA2, &poly_res_cal_2);
    poly_res_cal = ((cs_uint64)poly_res_cal_2 << 32) + ((cs_uint64)poly_res_cal_1 << 16) + (cs_uint64)poly_res_cal_0;
    agc_itune       = (poly_res_cal >>  0) & 0x7;
    cml_itune       = (poly_res_cal >>  4) & 0x7;
    dfe_itune       = (poly_res_cal >>  8) & 0x7;
    vco_itune       = (poly_res_cal >> 12) & 0x7;
    driver_itune    = (poly_res_cal >> 16) & 0x7;
    drivercml_itune = (poly_res_cal >> 20) & 0x7;
    agc_rtune       = (poly_res_cal >> 24) & 0x7;
    cml_rtune       = (poly_res_cal >> 28) & 0x7;
    dfe_rtune       = (poly_res_cal >> 32) & 0x7;
    driver_rtune    = (poly_res_cal >> 36) & 0x7;
    drivercml_rtune = (poly_res_cal >> 40) & 0x7;

    /* Check whether the efuse values are overriden, and fetch the values in case they are */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN          , (cs_uint16*)&override_en_t.wrd);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2   , (cs_uint16*)&agc_config2_t.wrd);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE , (cs_uint16*)&rx_ibias_tune_t.wrd);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG    , (cs_uint16*)&dfe_config_t.wrd);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE , (cs_uint16*)&rx_rbias_tune_t.wrd);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_TUNE   , (cs_uint16*)&driver_tune_t.wrd);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVERCML_TUNE, (cs_uint16*)&drivercml_tune_t.wrd);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE     , (cs_uint16*)&agc_rtune_t.wrd);

    /* Now, if itune override is enabled then replace the tune values above. */
    if (override_en_t.bf.itune_override) 
    {
        agc_itune       = agc_config2_t.bf.SRX_AGC_ITUNE;
        cml_itune       = rx_ibias_tune_t.bf.SRX_CML_ITUNE;
        dfe_itune       = dfe_config_t.bf.SRX_DFE_ITUNE;
        vco_itune       = rx_rbias_tune_t.bf.SRX_VCO_ITUNE;
        driver_itune    = driver_tune_t.bf.STX_DRIVER_ITUNE;
        drivercml_itune = drivercml_tune_t.bf.STX_DRIVERCML_ITUNE;
    }
    /* If rtune override is enabled then replace the tune values above. */
    if (override_en_t.bf.rtune_override) 
    {
        agc_rtune       = agc_rtune_t.bf.SRX_AGC_RTUNE;
        cml_rtune       = rx_rbias_tune_t.bf.SRX_CML_RTUNE;
        dfe_rtune       = dfe_config_t.bf.SRX_DFE_RTUNE;
        driver_rtune    = driver_tune_t.bf.STX_DRIVER_RTUNE;
        drivercml_rtune = drivercml_tune_t.bf.STX_DRIVERCML_RTUNE;
    }

    /* Apply the bug now */
    driver_itune = 7;
    
    /* the cs4224_bug_37924_done flag has been removed. This means that we will always apply 
       this driver_rtune adjustment. It's ok cause config_an is called from enter_operational_state
       which is non re-entrant */
    if (driver_rtune > 0) 
    { 
        driver_rtune = driver_rtune - 1;
    }
    /* Write the values to the SDS, enabling the override (regardless of whether it was previously enabled or not) */

    if (!tech_cr4)
    {
        agc_config2_t.bf.SRX_AGC_ITUNE          = agc_itune;
        rx_ibias_tune_t.bf.SRX_CML_ITUNE        = cml_itune;
        dfe_config_t.bf.SRX_DFE_ITUNE           = dfe_itune;
        rx_rbias_tune_t.bf.SRX_VCO_ITUNE        = vco_itune;
        driver_tune_t.bf.STX_DRIVER_ITUNE       = driver_itune;
        drivercml_tune_t.bf.STX_DRIVERCML_ITUNE = drivercml_itune;
        agc_rtune_t.bf.SRX_AGC_RTUNE            = agc_rtune;
        rx_rbias_tune_t.bf.SRX_CML_RTUNE        = cml_rtune;
        dfe_config_t.bf.SRX_DFE_RTUNE           = dfe_rtune;
        driver_tune_t.bf.STX_DRIVER_RTUNE       = driver_rtune;
        drivercml_tune_t.bf.STX_DRIVERCML_RTUNE = drivercml_rtune;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_CONFIG2,    agc_config2_t.wrd);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_IBIAS_TUNE,  rx_ibias_tune_t.wrd);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_DFE_CONFIG,     dfe_config_t.wrd);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_RX_RBIAS_TUNE,  rx_rbias_tune_t.wrd);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVER_TUNE,    driver_tune_t.wrd);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_DRIVERCML_TUNE, drivercml_tune_t.wrd);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_SRX0_AGC_RTUNE,      agc_rtune_t.wrd);
        /* Enable the override */
        override_en_t.bf.itune_override = 1;
        override_en_t.bf.rtune_override = 1;
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_OVERRIDE_EN, override_en_t.wrd);
    }

    return status;
}

/**
 * Configures the slice for KR auto-negotiation
 *
 * @param slice    [I] - The slice of the KR session
 * @param rules    [I] - The set of rules to use to initialize the port.
 * @param config   [I] - Pointer to the KR specific configuration data
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_kran_config_an(
    cs_uint32 slice,
    cs4224_rules_t* rules,
    cs4224_kran_config_t_s* config) 
{
    cs_status status = CS_OK;
    cs_uint16 en_40g = 0;
    cs_uint16 data;
    cs_uint16 tech;
    cs_uint16 adv_ability;
    cs_uint16 spare26_msb;
    CS4224_PP_LINE_TP_RX_REMOTE_RX_READY_t rx_ready;
    cs_uint16 spare27_lsb, spare27_msb, lfi_thresh;
    cs_uint16 val_low, val_high;

    /* Define some constants */
    cs_uint16 LINE_USEC_STARTING_BANK         = 2;
    cs_uint16 HOST_USEC_STARTING_BANK         = 7;
    cs_uint16 DATA_STORE_PCCR_ADDR            = 0x4b - 0x40;
    cs_uint16 DATA_STORE_BANK_JUMP1_ADDR      = 0x62 - 0x40;
    cs_uint16 DATA_STORE_BANK_JUMP2_ADDR      = 0x63 - 0x40;
    cs_uint16 DATA_STORE_FUNCTION_NUMBER_ADDR = 0x4e - 0x40;
    cs_uint16 DATA_STORE_wait_vco_ADDR        = 0x46 - 0x40;
    cs_uint16 DATA_STORE_wait_cal_ADDR        = 0x47 - 0x40;
    cs_uint16 DATA_STORE_wait_taps_ADDR       = 0x48 - 0x40;
    cs_uint16 DATA_STORE_wait_mission_ADDR    = 0x49 - 0x40;
    cs_uint16 DATA_STORE_wait_arbitrary_ADDR  = 0x4A - 0x40;
    cs_uint16 DATA_STORE_tx_mux_ADDR          = 0x50 - 0x40;
    cs_uint16 DATA_STORE_tx_eye_or_2x2_ADDR   = 0x51 - 0x40;
    /* TODO: Calculate these via the rules.ref_clk_rate instead of assuming 156.25 */
    cs_uint32 DATA_STORE_wait_vco_VAL         = 0x00020000;      /* 0x0002_0000 =  3.4 ms (post 10G VCO tuning) */
    cs_uint32 DATA_STORE_wait_cal_VAL         = 0x00100000;      /* 0x0010_0000 = 26.8 ms (post cal.asm LOL monitoring) */
    cs_uint32 DATA_STORE_wait_taps_VAL        = 0x00010000;      /* 0x0001_0000 =  1.7 ms (delay between train_taps updates) */
    cs_uint32 DATA_STORE_wait_mission_VAL     = 0x00000100;      /* 0x0000_0100 =  6.6 us (pause between mission.asm loops) */
    cs_uint32 DATA_STORE_wait_arbitrary_VAL   = 0x00020000;      /* 0x0002_0000 =  3.4 ms (arbitrary delays) */

    if ((config->advertised.tech_cr4) || (config->advertised.tech_kr4) || (config->advertised.tech_kx4))
    {
        en_40g = 1;
    }

    if(rules->show_debug_info)
    {
        CS_PRINTF(("KR, Configuring slice %x(%d) for AN, en_40g=%d\n", slice, slice & 0xff, en_40g ));
    }

/* TODO: multi-threaded support */
    
    if (rules->rx_if.dplx_host_edc_mode == CS_HSIO_EDC_MODE_DISABLED)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE20_MSB, 0x8000);
    }
    if (rules->rx_if.dplx_host_edc_mode == CS_HSIO_EDC_MODE_SR)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE20_MSB, 0x0000);
    }
    else /* EDC DFE mode */
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE20_MSB, 0x4000);
    }

    /* Start up the clocks so that registers can be written */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,              0xffff);   /* release clock gating - line */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_CLKEN,              0xffff);   /* release clock gating - host */

    /* Release digital registers from reset. */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_SOFT_RESET,         0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_SOFT_RESET,         0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MPIF_RESET_DOTREG,  0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_MPIF_RESET_DOTREG,  0x0000);

    /* Power up the microsequencer. */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL,        0x8004);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_MSEQCLKCTRL,        0x8004);

    /* The host-side will likely be in SR mode which means the tune setting come
     * directly from the EFUSE.  However, in two-pass mode the microcode needs
     * to alter the tune settings to use the ring VCO for 10G PFD.  So, set up
     * the device to use the overrides to prepare for that.
     */
    if(config->advanced.two_pass_mode) 
    {
        status |= cs4224_kran_host_copy_tune_from_efuse(slice);
    }

    /* Release transmitter squelching done in pre_setup.txt */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_STX0_SQUELCH,     0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_STX0_SQUELCH,     0x0000);

    /* The post_setup.txt file gives the host microsequencer control of lock, undo this */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE,         0x0000);

    /* Need to force host and line usec to the correct bank.  First stall them. */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS,        0x0008);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS,        0x0008);

    /* Set usec to correct banks */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_BANK_SELECTOR, LINE_USEC_STARTING_BANK);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR, HOST_USEC_STARTING_BANK);

    /* Reset the program counters */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_PC,             0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_PC,             0x0000);

    /* Reset the line-side BANK_JUMP data store registers (usec is already stalled) */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1,        0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0,        0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR,        0x8000 | DATA_STORE_BANK_JUMP1_ADDR); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR,        0x8000 | DATA_STORE_BANK_JUMP2_ADDR); 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR,        0x8000 | DATA_STORE_FUNCTION_NUMBER_ADDR); 

    /* Initialise the PCCR data store register */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x0000);
    if(config->advanced.two_pass_mode)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0002);
    }
    else
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0000);
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_PCCR_ADDR);

    if (config->advanced.ref106) 
    {
        DATA_STORE_wait_vco_VAL       = (DATA_STORE_wait_vco_VAL       * 680) / 1000; /* wait_vco_VAL       * 106.25 / 156.25 */ 
        DATA_STORE_wait_cal_VAL       = (DATA_STORE_wait_cal_VAL       * 680) / 1000; /* wait_cal_VAL       * 106.25 / 156.25 */
        DATA_STORE_wait_taps_VAL      = (DATA_STORE_wait_taps_VAL      * 680) / 1000; /* wait_taps_VAL      * 106.25 / 156.25 */
        DATA_STORE_wait_mission_VAL   = (DATA_STORE_wait_mission_VAL   * 680) / 1000; /* wait_mission_VAL   * 106.25 / 156.25 */
        DATA_STORE_wait_arbitrary_VAL = (DATA_STORE_wait_arbitrary_VAL * 680) / 1000; /* wait_arbitrary_VAL * 106.25 / 156.25 */
    }

    val_low = DATA_STORE_wait_vco_VAL; val_high = DATA_STORE_wait_vco_VAL >> 16;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x8000 | val_high);   /* needs MSB set */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, val_low);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_wait_vco_ADDR);

    val_low = DATA_STORE_wait_cal_VAL; val_high = DATA_STORE_wait_cal_VAL >> 16;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, val_high);            /* do not set MSB */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, val_low);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_wait_cal_ADDR);

    val_low = DATA_STORE_wait_taps_VAL; val_high = DATA_STORE_wait_taps_VAL >> 16;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, val_high);            /* do not set MSB */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, val_low);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_wait_taps_ADDR);

    val_low = DATA_STORE_wait_mission_VAL; val_high = DATA_STORE_wait_mission_VAL >> 16;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x8000 | val_high);   /* needs MSB set */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, val_low);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_wait_mission_ADDR);

    val_low = DATA_STORE_wait_arbitrary_VAL; val_high = DATA_STORE_wait_arbitrary_VAL >> 16;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x8000 | val_high);   /* needs MSB set */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, val_low);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_wait_arbitrary_ADDR);

    /* Initialise the STX0_MISC data store registers (line and host sides) */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D1, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D1, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0022);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_tx_mux_ADDR);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D0, 0x0022);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_tx_mux_ADDR);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_D0, 0x0033);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_tx_eye_or_2x2_ADDR);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_D0, 0x0033);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_GRAM_CR, 0x8000 | DATA_STORE_tx_eye_or_2x2_ADDR);

    /* Initialise line and host useq mailboxes */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_LSB,   0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_OUT_MSB,   0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_IN_LSB,    0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_MAIL_IN_MSB,    0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_LSB,   0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_OUT_MSB,   0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_LSB,    0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_MAIL_IN_MSB,    0x0000);

    /* Initialise line mseq SPARE26 to zero */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB,    0x0000);

    /* On the host side initialise SPARE24[31] High so dfe/sr ucode does not run yet. */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE24_MSB,    0x8000);

    /* On the host side initialise SPARE28[30] High. */
    cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE28_MSB,              0x4000);

    /* Release mseq from stall (it still waits for future host input before continuing) */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_OPTIONS,        0x0007);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS,        0x0007);

    /* Disable bit swap */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config,       &data);
    data &= ~CS_BIT3;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_RX0_Config,       data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config,       &data);
    data &= ~CS_BIT3;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_COMMON_TX0_Config,       data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config,       &data);
    data &= ~CS_BIT3;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_RX0_Config,       data);
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config,       &data);
    data &= ~CS_BIT3;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_COMMON_TX0_Config,       data);
    
    /* Release MCAN reset */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_MCAN_RESET,                  0x0000);
    /* Choose 10G or 40G */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_AN_MODE_SEL,        en_40g);

    /* Enable the 10GE PCS transmitter */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_XGPCS_TX_TXCNTRL,            0x0002);

    /* Release GIGEPCS Rx and Tx and EGPCS Rx from reset */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_GIGEPCS_SOFT_RESET, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_EGPCS_RX_MODE,               0x0003);

    /* Enable host-side 1GE PCS unit (its in the receive path, not transmit)
     * in case 1000GBASE-KX is negotiated (the extra power in cases where it
     * is not is negligible).
     */
    cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_FUNCEN,                       0x0001);
    cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_GIGEPCS_SOFT_RESET,           0x0000);

    /* SPARE12[30] tells the DFE mission mode code KR is being used and to jump
     * back to the KR code once each mission mode loop is done.
     * SPARE12[3] = 1 causes the CMODE_RES algorithm to use the CR4 table
     * SPARE12[2] = 1 enable the transmitter squelch control in the ingress (line->host) path
     * SPARE12[26] = 1 enable the SNR Monitor
     */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB,    &data);
    data |=  0x4000;
    data &= ~0x0400;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_MSB,    data);

    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB,    &data);
    data &= ~0x0002; /* disable power-savings */
    if (config->advertised.tech_cr4)
    {
        data |= 0x0008;
    }
    if (config->advanced.sqlch_ing)
    {
        data |= 0x0004;
    }
    else
    {
        data &= ~0x0004;
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE12_LSB,    data);

    /* Set the KR bit in SPARE12[30] on the host side too. */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_MSB,    &data);
    data |= 0x4000;
    if (config->advanced.hphase_or) 
    {
        data |= 0x2000;         /* bit 29 */
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_MSB,    data);

    /* And clear the host Tx squelch bit SPARE12[2] and power-savings bit in SPARE12[1] for the host useq.
     * SPARE12[6] (DFE Mode) is an FC-only bit, set it High to make it ignored. 
     * SPARE12[2] = 1 enable the transmitter squelch control in the egress (host->line) path 
     */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB,    &data);
    data &= ~0x0002;  /* disable power-savings */
    if (config->advanced.sqlch_egr)
    {
        data |= 0x0004;
    }
    else
    {
        data &= ~0x0004;
    }
    data |=  0x0040; /* assert DFE mode */
    if (config->advanced.hphase_or)
    {
        data |= 0x0080;         /* bit 7 */
    }
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB,    data);

    /* SPARE4 tells the DFE how many mission.asm loops to run before starting */
    /* phase calibration.  For KR, phase calibration is manually triggered */
    /* so set SPARE4 to zero. */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_LSB, 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE4_MSB, 0x0000);

    /* To override the phase, the "disable phase calibration" rule also needs */
    /* to be set causing the microcode to set SPARE12[7] and SPARE12[29] */
    if (config->advanced.phase_or)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_CAL_RX_PHSEL, config->advanced.phase_ov);
    }
    /* As above but for the host-side. */
    if (config->advanced.hphase_or)
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_CAL_RX_PHSEL, config->advanced.hphase_ov);
    }
    /* Fill SPARE26_MSB with values for tp_mode */
    spare26_msb = (config->advanced.tpm31  << 15) | (config->advanced.tpm30 << 14) |
                  (config->advanced.ref106 << 12) |
                  (config->advanced.tpm567 << 5)  | (config->advanced.tpm4  << 4)  | (config->advanced.tpm3 << 3) |
                  (config->advanced.tpm2   << 2)  | (config->advanced.tpm1  << 1)  | (config->advanced.tpm0 << 0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_MSB, spare26_msb);

    /* Host-side SPARE26_MSB too */
    spare26_msb = (config->advanced.ring << 13) | 
                  (config->advanced.ref106 << 12) |
                  (config->advanced.hphase_ov << 0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE26_MSB, spare26_msb);

    /* SPARE27[15:0] is 10G LFI TIMEOUT1 and bits [31:16] are 1G LFI TIMEOUT1 */
    /* To make it easier on the user of the GUI the timeouts will always be specified */
    /* for 156.25 MHz reference clocks and if they indicate the clock is really */
    /* 106.25, we'll just scale it appropriately. */
    if (config->advanced.ref106) 
    {
        CS_PRINTF(("\n...................config->advanced.ref106 == TRUE\n"));
        spare27_lsb = (config->advanced.lfi_10g   * 680) / 1000; /* lfi_10g   * 106.25 / 156.25 */
        spare27_msb = (config->advanced.lfi_1g    * 680) / 1000; /* lfi_1g    * 106.25 / 156.25 */
        lfi_thresh  = (config->advanced.lfi_thres * 680) / 1000; /* lfi_thres * 106.25 / 156.25 */
    }
    else
    {
        spare27_lsb = config->advanced.lfi_10g;
        spare27_msb = config->advanced.lfi_1g;
        lfi_thresh  = config->advanced.lfi_thres;
    }

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_LSB,     spare27_lsb);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE27_MSB,     spare27_msb);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_AN_TX_LINK_FAIL_TIMER_THRES1, lfi_thresh);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_AN_TX_LINK_FAIL_TIMER_THRES0, 0x0000);

    /* Fill SPARE28_MSB */
    data = config->advanced.jmp2cal << (28-16);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_MSB, data);

    /* Fill SPARE28_LSB */
    if(config->advanced.skip_an) 
    {
        /* If skip_an is used the user must only be advertising one technology     */
        /* (i.e. kx, kx4, kr4 or cr4).  That will be considered the negotiated     */
        /* technology.  Also, if both f0 and f1 (FEC ability and FEC requested)    */
        /* are set by the user, then the FEC will be enabled too.  User must       */
        /* not do this if (1) the link partner is not expecting the FEC to be      */
        /* used or (2) the chosen technology does not support FEC, i.e. KX or KX4. */
        /* FYI, the bitfields of SPARE28_LSB match PP_LINE_MCAN_MSTR_WRITE_DATA.   */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, 
                                                    ( (config->advertised.f0 & config->advertised.f1) << 6 ) |
                                                    ( (config->advertised.tech_kx ) << 5 ) |
                                                    ( (config->advertised.tech_kx4) << 4 ) |
                                                    ( (config->advertised.tech_kr ) << 3 ) |
                                                    ( (config->advertised.tech_kr4) << 2 ) |
                                                    ( (config->advertised.tech_cr4) << 1 ));
    } 
    else 
    {
        status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE28_LSB, 0x0000);
    }

    /* Setup the time to EDC converge in DFE mode, line and host sides */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE6_MSB, config->advanced.line_t_to_conv_dfe);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE6_MSB, config->advanced.host_t_to_conv_dfe);

    /* Bug 40214 workaround */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAX_WAIT_TIMEOUT1, 0x099a);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAX_WAIT_TIMEOUT0, 0xb10d);
    /* Actually, we allow MSBs to come from advanced config. */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAX_WAIT_TIMEOUT1, config->advanced.max_wait);

    /* Override the LINK_READY wait_timer */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_WAIT_TIMEOUT, config->advanced.wait_tmr);

    /* 16-bit technology ability field (see 802.3ba-2010 section 73.6.4 table 73-4) */
    tech = (config->advertised.tech_cr4 << 4) | 
           (config->advertised.tech_kr4 << 3) | 
           (config->advertised.tech_kr  << 2) | 
           (config->advertised.tech_kx4 << 1) |
           (config->advertised.tech_kx  << 0);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_AN_TX_TECH_ABILITY_1, tech);

    /* 5-bit selector field (see http:www.ieee802.org/3/selectors/selectors.html) */
    /* (always set to 00001b) */
    adv_ability = (config->advertised.rf      << 13) | 
                  (config->advertised.pause_1 << 11) | 
                  (config->advertised.pause_0 << 10) | 
                  (config->advertised.f1      << 6)  | 
                  (config->advertised.f0      << 5)  | 1;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_AN_TX_ADV_ABILITY, adv_ability);

    /* Enable/disable AN ability detect timeout */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_AN_TX_ABILITY_DETECT_TIMER_ENABLE, config->advanced.en_adt);

    /* Enable/disable TP Max Wait Timer */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_MAX_WAIT_TIMER_EN, config->advanced.en_mwt);

    /* Set the number of additional frames to send at the start of SEND_DATA */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_ADDITIONAL_FRAMES, config->advanced.xtra_f);

    /* Apply Bug 37924 fixes */
    status |= cs4224_kran_bug_37924(slice, config->advertised.tech_cr4, config->advanced.preset, config->advanced.tpm31);

    /* Use the PRESET values from registers (needed for Bug 39671) */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_PRESET_COEFF_OVERRIDE, 0x0001);

    /* Step value for pre- and post-cursor are 2, main is 1.*/
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_COEFF_STEP_VALUE,      0x0212);

    /* This register which dictates how the training frames are generated */
    /* really has the wrong reset value, so correct it */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_TX_LD_COEFF_UPDATE_CTRL,  0x0001);

    /* Default value is probably wrong, so provide ability to override it. */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_TP_RX_REMOTE_RX_READY, (cs_uint16*)&rx_ready.wrd);

    rx_ready.bf.include_bad_markers = config->advanced.bad_mrkrs;
    rx_ready.bf.limit_down = 0x7;
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_TP_RX_REMOTE_RX_READY, rx_ready.wrd);

    /* Tell the host-side micro-sequencer what traffic rate it is currently receiving. */
    /* Bit 0 high (0x0001) - tell it is receiving  1.2500 Gbaud traffic */
    /* Bit 1 high (0x0002) - tell it is receiving 10.3125 Gbaud traffic */
    /* Bit 2 high (0x0004) - tell it is receiving  3.1250 Gbaud traffic */
    /* *** This should be a rule, but currently is not set up as one. *** */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE25_LSB,       0x0002);

    /* Reset the clocks back to their default states (reverse of what was done at the top) */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_CLKEN,                 0x1010); /* leave AN clock running */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB,    0x00e0); /* leave demux clock running */
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_POWER_DOWN_LSB,    0x0000); /* TBD: this is the setting in BP_Mode.py */ 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_LINEMISC_MSEQCLKCTRL,           0x0004);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_CLKEN,                 0x0000);
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB,    0x01f7); /* TBD: this is the setting in LoadMicrocode.py */ 
    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_POWER_DOWN_LSB,    0x01e0);

    status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_MSEQCLKCTRL,           0x0004);

    return status;
}

/**
 * Starts the KR auto-negotiation
 *
 * @param slice    [I] - The slice of the KR session
 * @param config   [I] - Pointer to the KR specific configuration data
 *
 * @return CS_OK on success, CS_ERROR on failure.
 *
 * @private
 */
cs_status cs4224_kran_start_an(
    cs_uint32 slice, 
    cs4224_kran_config_t_s* config)
{
    cs_status status = CS_OK;
    cs_uint16 spare26_lsb = 0x0001; /* Start AN Trigger */

    if (config->advanced.dis_start)
    {
        spare26_lsb = 0x0000;
    }

    /* Fill in parameters for microcode */
    spare26_lsb |= ( (  config->advanced.skip_an     &0x1) <<  1 ); /* Skip AN */
    spare26_lsb |= ( (  config->advanced.skip_tp     &0x1) <<  2 ); /* Skip TP */
    spare26_lsb |= ( (  config->advanced.en_lfit     &0x1) <<  3 ); /* Enable Link Fail Inhibit Timer */
    spare26_lsb |= ( (  config->advanced.skip_phsc   &0x1) <<  4 ); /* Skip Phase Calibration */
    spare26_lsb |= ( ((!config->advanced.en_retry)   &0x1) <<  5 ); /* Disable AN Retries */
    spare26_lsb |= ( ((!config->advanced.en_pwrsv)   &0x1) <<  6 ); /* Disable DFE Power Savings */
    spare26_lsb |= ( ((!config->advanced.en_dfe)     &0x1) <<  6 ); /* force power savings off if DFE is not used */
    spare26_lsb |= ( ((!config->advanced.en_dfe)     &0x1) <<  7 ); /* Disable DFE */
    spare26_lsb |= ( (  config->advanced.pcs_itr     &0xf) <<  8 ); /* Iterations to Wait for PCS to Sync [11:8] */
    spare26_lsb |= ( (  config->advanced.dis_sync    &0x1) << 14 ); /* Disable PCS Sync Checks in Mission Mode */
    spare26_lsb |= ( (  config->advertised.tech_kx4  &0x1) << 14 ); /* When advertising KX4, disable PCS Sync Checks in Mission Mode */
                                                                    /* NOTE: Remember to re-enable PCS Sync Checks if KX4 not negotiated */

    spare26_lsb |= ( (  config->advanced.fec_bypass  &0x1) << 15 ); /* Disable FEC even when FEC advertized and negotiated */
    if (config->advanced.fec_bypass)
    {
        spare26_lsb |= ( (  config->advanced.dis_sync &0x1) << 14 ); /* Disable PCS Sync Checks in Mission Mode when FEC bypassed */
    }

/* TODO: multi-threaded support */

    CS_PRINTF(("KR, Starting AN on slice %x, SPARE26_LSB=0x%04x\n", slice, spare26_lsb ));

    status |= cs4224_reg_set_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE26_LSB, spare26_lsb);

    return status;
}

/**
 * Initialize a single port of the device for KR, pre-AN. 
 *
 * @param master_slice  [I] - The KR master slice or port of the device(s) being initialized
 * @param rules         [I] - The set of rules to use to initialize the port.
 * @param config        [I] - Pointer to the KR specific configuration data
 *
 * @return CS_OK on success, CS_ERROR on failure.
 */
cs_status cs4224_kran_init_kr_pre_an(
    cs_uint32 master_slice, 
    cs4224_rules_t* rules,
    cs4224_kran_config_t_s *config) 
{
    cs_status status = CS_OK;
    cs_uint16 en_40g = 0;
    cs_uint32 base_slice;
                         
    if ((config->advertised.tech_cr4) || (config->advertised.tech_kr4) || (config->advertised.tech_kx4))
    {
        en_40g = 1;
    }

    /* initialize the internal advanced configs */
    status |= cs4224_kran_init_advanced(config, rules);

    /* determine if training is required */
    if (rules->kran.allow_training)
    {
        config->advanced.skip_tp = FALSE;
    }
    else
    {
        config->advanced.skip_tp = TRUE;
    }

    if (en_40g)
    {
        /* identify the base slice of the 40g slices */
        if ((master_slice & 0xFF) < 4)
        {
            base_slice = (master_slice & 0xFFFFFF00) + 0;

        }
        else
        {
            base_slice = (master_slice & 0xFFFFFF00) + 4;
        }
        
        /* Any one of the 40G slices can be selected as the master. It is determined     */
        /* by the master_slice argument.                                                 */
        /* The master needs to be configured FIRST so its MCAN is first out of reset.    */
        /* The master needs to be started (AN) LAST to avoid Link Fail Inhibit timeouts. */
        switch (master_slice & 0x7)
        {
            case 0:
                status |= cs4224_kran_config_an(base_slice + 0, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 1, rules, config);
                status |= cs4224_kran_config_an(base_slice + 2, rules, config);
                status |= cs4224_kran_config_an(base_slice + 3, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);

                status |= cs4224_kran_start_an(base_slice + 1, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config); 
                status |= cs4224_kran_start_an(base_slice + 0, config);  /* master */
                break;

            case 1:
                status |= cs4224_kran_config_an(base_slice + 1, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 0, rules, config);
                status |= cs4224_kran_config_an(base_slice + 2, rules, config);
                status |= cs4224_kran_config_an(base_slice + 3, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);

                status |= cs4224_kran_start_an(base_slice + 0, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config); 
                status |= cs4224_kran_start_an(base_slice + 1, config);  /* master */
                break;

            case 2:
                status |= cs4224_kran_config_an(base_slice + 2, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 0, rules, config);
                status |= cs4224_kran_config_an(base_slice + 1, rules, config);
                status |= cs4224_kran_config_an(base_slice + 3, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);

                status |= cs4224_kran_start_an(base_slice + 0, config); 
                status |= cs4224_kran_start_an(base_slice + 1, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config);  /* master */
                break;

            case 3:
                status |= cs4224_kran_config_an(base_slice + 3, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 0, rules, config);
                status |= cs4224_kran_config_an(base_slice + 1, rules, config);
                status |= cs4224_kran_config_an(base_slice + 2, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */

                status |= cs4224_kran_start_an(base_slice + 0, config); 
                status |= cs4224_kran_start_an(base_slice + 1, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config);  /* master */
                break;

            case 4:
                status |= cs4224_kran_config_an(base_slice + 0, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 1, rules, config);
                status |= cs4224_kran_config_an(base_slice + 2, rules, config);
                status |= cs4224_kran_config_an(base_slice + 3, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);

                status |= cs4224_kran_start_an(base_slice + 1, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config); 
                status |= cs4224_kran_start_an(base_slice + 0, config);  /* master */
                break;

            case 5:
                status |= cs4224_kran_config_an(base_slice + 1, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 0, rules, config);
                status |= cs4224_kran_config_an(base_slice + 2, rules, config);
                status |= cs4224_kran_config_an(base_slice + 3, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);

                status |= cs4224_kran_start_an(base_slice + 0, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config); 
                status |= cs4224_kran_start_an(base_slice + 1, config);  /* master */
                break;

            case 6:
                status |= cs4224_kran_config_an(base_slice + 2, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 0, rules, config);
                status |= cs4224_kran_config_an(base_slice + 1, rules, config);
                status |= cs4224_kran_config_an(base_slice + 3, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);

                status |= cs4224_kran_start_an(base_slice + 0, config); 
                status |= cs4224_kran_start_an(base_slice + 1, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config);  /* master */
                break;

            case 7:
                status |= cs4224_kran_config_an(base_slice + 3, rules, config); /* master */
                status |= cs4224_kran_config_an(base_slice + 2, rules, config);
                status |= cs4224_kran_config_an(base_slice + 1, rules, config);
                status |= cs4224_kran_config_an(base_slice + 0, rules, config);

                status |= cs4224_reg_set_channel(base_slice + 0, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (3 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 1, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (1 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 2, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (2 << 1) | 1);
                status |= cs4224_reg_set_channel(base_slice + 3, CS4224_PP_LINE_LINEMISC_KR_AN_PORT_ADDR, (0 << 1) | 1); /* master */

                status |= cs4224_kran_start_an(base_slice + 0, config); 
                status |= cs4224_kran_start_an(base_slice + 1, config); 
                status |= cs4224_kran_start_an(base_slice + 2, config); 
                status |= cs4224_kran_start_an(base_slice + 3, config);  /* master */
                break;

            default:
                break;
        }
    }
    else
    {
        status |= cs4224_kran_config_an(master_slice, rules, config);
        status |= cs4224_kran_start_an(master_slice, config);
    }

    return status;
}

/**
 * This method is called to configure the data-path to the rate that was negotiated by 
 * the KR-AN block.
 *
 * Note that: CR = faceplate, KR = backplane
 *
 * @param slice        [I] -  The port number to access 
 * @param rules        [I] -  The rules structure associated with the configuration
 * @param an_results   [I] -  Pointer to the result, see structure cs4224_kran_results_t
 *
 * @return CS_OK on success, CS_ERROR on failure
 */
cs_status cs4224_kran_init_kr_post_an(
    cs_uint32 slice, 
    cs4224_rules_t* rules,
    cs4224_kran_results_t_s *an_results) 
{
    cs_status status = CS_OK;
    cs_uint16 data;
    e_cs4224_edc_mode host_edc_mode;

    cs4224_lock(slice);

    if ((an_results->bp_1000kx) || (an_results->bp_10gkx4))
    {

        /* If the user selected DFE mode on the host side, need to switch to SR mode for 1G. */
        if ((rules->rx_if.dplx_host_edc_mode != CS_HSIO_EDC_MODE_DISABLED) &&
            (rules->rx_if.dplx_host_edc_mode != CS_HSIO_EDC_MODE_SR))
        {
    
            /* CS_PRINTF(("In cs4224_kran_init_kr_post_an, 1G negotiated, host EDC mode is DFE, configuring to SR on, slice %x\n", slice));*/
            status |= cs4224_mseq_stall(slice, CS4224_DPLX_HOST_MSEQ, TRUE);
    
            host_edc_mode = rules->rx_if.dplx_host_edc_mode; /* save the host EDC mode */
            rules->rx_if.dplx_host_edc_mode = CS_HSIO_EDC_MODE_SR; /* override to SR EDC mode */
            status |= cs4224_init_edc_mode_intf(slice, rules, CS4224_DPLX_HOST_MSEQ);
            rules->rx_if.dplx_host_edc_mode = host_edc_mode; /* restore the host EDC mode */
 
            /* The sr_mode() function overwrites SPARE12 and BANK_SELECTOR so fix them back. */
            /* These come from config_an(). */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_BANK_SELECTOR, 0x0007);
    
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_PC,            0x0000);
    
            status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_MSB,   &data);
            data |= 0x4000;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_MSB,   data);
    
            status |= cs4224_reg_get_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB,   &data);
            data &= 0xfffb;
            data |= 0x0040;
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE12_LSB,   data);
    
            /* Re-start the micro-sequencer */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_OPTIONS,       0x0007);
            /* Set SPARE24 directly (read comment in SPARE Allocation spreadsheet for why. */
            status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE24_MSB,   0x0000);
        }

        /* do this only when we have 1G PCS received on the host side */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_ENABLE,         0x0000);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_FUNCEN,             0x0001);
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_HOSTMISC_GIGEPCS_SOFT_RESET, 0x0000);

        /* Set SPARE24 directly, turn off KR DFE */
        status |= cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE24_MSB,    0x0000);

        /* Set SPARE25 based on whether it is KX or KX4. */
        if(an_results->bp_10gkx4)
        {
            /* Tell the host-side micro-sequencer that it is receiving 3.125 Gbaud traffic */
            cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE25_LSB, 0x0004);
        } 
        else 
        {
            /* Tell the host-side micro-sequencer that it is receiving 1.250 Gbaud traffic */
            cs4224_reg_set_channel(slice, CS4224_PP_HOST_SDS_DSP_MSEQ_SPARE25_LSB, 0x0001);
        }
    }

    cs4224_unlock(slice);

    return status;
}

/**
 * This method is called to check if the MSEQ has finished its
 * KR AN & TP sequence. It determines this by looking at the 
 * mission mode achieved bit.
 *
 * @param port        [I] - The slice or port of the device(s) being polled
 * @param kran_status [O] - The status of KR AN, one of 
 *                          CS4224_KRAN_AN_NOT_DONE or CS4224_KRAN_AN_DONE 
 *
 * @return CS_OK on success, CS_ERROR on failure
 *
 * @private
 */
cs_status cs4224_kran_poll_an(
    cs_uint32      slice,
    e_cs4224_kran_an_status_t *kran_status) 
{
    cs_status status = CS_OK;
    cs_uint16 data = 0;
    *kran_status = CS4224_KRAN_AN_NOT_DONE;

    /* if the line side is in mission mode, we are done... */
    status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE25_LSB, &data);
    if (data == 0x0040)
    {
        *kran_status = CS4224_KRAN_AN_DONE;
    }  
    return status;    
}

/**
 * Forever wait for KR AN to complete negotiating with its peer. The AN results
 * are returned in argument an_results.
 *
 * @param slice       [I] - The slice of the device(s) being polled
 * @param an_results  [O] - The results of the AN
 * @param ptr         [O] - Pointer to optional user defined data to be returned
 *                          to calling method.
 *
 * @return an_done  - Flag pointer indicating result, one of 
 *                    CS4224_KRAN_AN_NOT_DONE or CS4224_KRAN_AN_DONE 
 */
e_cs4224_kran_an_status_t cs4224_kran_wait_for_an(
    cs_uint32 slice,
    cs4224_kran_results_t_s *an_results,
    void* ptr) 
{
    cs_status status = CS_OK;
    e_cs4224_kran_an_status_t an_done = CS4224_KRAN_AN_NOT_DONE;
    CS4224_PP_LINE_AN_TX_BP_STATUS_t    bp_status;
    CS4224_PP_LINE_AN_RX_LP_ABILITY_1_t lp_ability_1;
    cs_uint16 curr_retries, prev_retries;

    an_results->bp_par_detect = FALSE;
    an_results->bp_40gcr4     = FALSE;
    an_results->bp_40gkr4     = FALSE;
    an_results->bp_10gkx4     = FALSE;
    an_results->bp_10gkr      = FALSE;
    an_results->bp_1000kx     = FALSE;
    an_results->bp_fec        = FALSE;
    an_results->bp_rf         = FALSE;
    an_results->bp_pause      = 0;

    /* Monitor for AN retries while we wait for AN to complete. This loop makes sure there are no AN
       retries while we are populating the an_results structure */
    do 
    {
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB, &prev_retries);

        /* loop until an_done == CS4224_KRAN_AN_DONE */
        while (an_done == CS4224_KRAN_AN_NOT_DONE)
        {
            cs4224_kran_poll_an(slice, &an_done);
            /* arg of 1 delays 1 millisecond */
            CS_MDELAY(1);
        }
        /* get the KR-AN results */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_BP_STATUS,    &(bp_status.wrd));
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_RX_LP_ABILITY_1, &(lp_ability_1.wrd));
        
        /* wait for a bit to see if retries increases */
        CS_MDELAY(200);
        
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB, &curr_retries);
    }
    while (curr_retries != prev_retries);

    an_results->bp_par_detect = bp_status.bf.parallel_detect;
    an_results->bp_40gcr4     = bp_status.bf.bp_40gcr4;
    an_results->bp_40gkr4     = bp_status.bf.bp_40gkr4;
    an_results->bp_10gkx4     = bp_status.bf.bp_10gkx4;
    an_results->bp_10gkr      = bp_status.bf.bp_10gkr;
    an_results->bp_1000kx     = bp_status.bf.bp_1000kx;
    an_results->bp_fec        = bp_status.bf.bp_fec;
    an_results->bp_rf         = lp_ability_1.bf.rf;
    an_results->bp_pause      = (lp_ability_1.wrd & 0x1c00) >> 10;

#if 0    
    CS_PRINTF(("KR AN result is DONE for PHY %x\n", slice));
    cs4224_kran_show_negotiated(an_results);
#endif

    /* clear interrupts */
    status |= cs4224_diags_clear_interrupts(slice);

    return CS4224_KRAN_AN_DONE;
}

/**
 * Wait for KR AN to complete negotiating with its peer. A timeout is specified
 * (in seconds) to abort waiting. The AN results are returned in argument an_results.
 *
 * @param slice            [I] - The slice of the device(s) being polled
 * @param max_secs_to_poll [I] - Determines the number of loops to wait for. Approximates number of seconds.
 * @param an_results       [O] - The results of the AN
 *
 * @return an_done  - Flag pointer indicating result, one of 
 *                    CS4224_KRAN_AN_NOT_DONE or CS4224_KRAN_AN_DONE 
 */
e_cs4224_kran_an_status_t cs4224_kran_wait_for_an_with_timeout(
    cs_uint32 slice,
    cs_uint32 max_secs_to_poll,
    cs4224_kran_results_t_s *an_results)
{
    cs_status status = CS_OK;
    cs_uint32 an_loop_count = 0, retries_loop_count = 0;
    cs_uint32 max_iterations;
    e_cs4224_kran_an_status_t an_done = CS4224_KRAN_AN_NOT_DONE;
    CS4224_PP_LINE_AN_TX_BP_STATUS_t    bp_status;
    CS4224_PP_LINE_AN_RX_LP_ABILITY_1_t lp_ability_1;
    cs_uint16 curr_retries, prev_retries;

    /* convert to milliseconds, timer resolution is 1 millisecs */
    max_iterations = (max_secs_to_poll * 250);

    an_results->bp_par_detect = FALSE;
    an_results->bp_40gcr4     = FALSE;
    an_results->bp_40gkr4     = FALSE;
    an_results->bp_10gkx4     = FALSE;
    an_results->bp_10gkr      = FALSE;
    an_results->bp_1000kx     = FALSE;
    an_results->bp_fec        = FALSE;
    an_results->bp_rf         = FALSE;
    an_results->bp_pause      = 0;

    /* Monitor for AN retries while we wait for AN to complete. This loop makes sure there are no AN
       retries while we are populating the an_results structure */
    do 
    {
        an_done = CS4224_KRAN_AN_NOT_DONE;
        an_loop_count = 0;
        retries_loop_count += 1;
        
        if(retries_loop_count >= 6)
        {
            /* only wait for a couple retries, otherwise this method will take forever */
            CS_TRACE(("ERROR: KR-AN Completes but the link doesn't stay up on slice %x\n", slice));
            return CS4224_KRAN_AN_NOT_DONE;
        }
        
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB, &prev_retries);

        /* loop until an_done == CS4224_KRAN_AN_DONE or timeout */
        while ((an_done == CS4224_KRAN_AN_NOT_DONE) && (an_loop_count < max_iterations))
        {
            cs4224_kran_poll_an(slice, &an_done);
            CS_MDELAY(1);
            cs4224_kran_dump_regs(slice, an_loop_count);
            an_loop_count++;
        }
        if (an_loop_count >= max_iterations)
        {
            CS_TRACE(("ERROR: KR-AN never completed on slice %x\n", slice));
            return CS4224_KRAN_AN_NOT_DONE;
        }
        
        /* get the KR-AN results */
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_TX_BP_STATUS,    &(bp_status.wrd));

        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_AN_RX_LP_ABILITY_1, &(lp_ability_1.wrd));

        /* Add another longer delay before we get the retries, to see if the link dropped */
        /* this is important for two-pass mode and other weirder configs */
        CS_MDELAY(200);
        
        status |= cs4224_reg_get_channel(slice, CS4224_PP_LINE_SDS_DSP_MSEQ_SPARE22_LSB, &curr_retries);
    }
    while (curr_retries != prev_retries);

    an_results->bp_par_detect = bp_status.bf.parallel_detect;
    an_results->bp_40gcr4     = bp_status.bf.bp_40gcr4;
    an_results->bp_40gkr4     = bp_status.bf.bp_40gkr4;
    an_results->bp_10gkx4     = bp_status.bf.bp_10gkx4;
    an_results->bp_10gkr      = bp_status.bf.bp_10gkr;
    an_results->bp_1000kx     = bp_status.bf.bp_1000kx;
    an_results->bp_fec        = bp_status.bf.bp_fec;
    an_results->bp_rf         = lp_ability_1.bf.rf;
    an_results->bp_pause      = (lp_ability_1.wrd & 0x1c00) >> 10;
    
#if 0
    CS_PRINTF(("KR AN result is DONE for PHY %x\n", slice));
    cs4224_kran_show_negotiated(an_results);
    CS_PRINTF(("  prev_retries=%d, curr_retries=%d\n", prev_retries, curr_retries));
#endif

    /* clear interrupts */
    status |= cs4224_diags_clear_interrupts(slice);

    return CS4224_KRAN_AN_DONE;
}

/** Prints KRAN negotiated results
 * 
 * @param an_results [I] - The negotiated results returned by one of the wait_for_an methods
 */
void cs4224_kran_show_negotiated(
    cs4224_kran_results_t_s *an_results)
{
    CS_PRINTF(("KR AN Negotiated Results\n"));
    CS_PRINTF(("  1000Base-KX:     %s\n" , an_results->bp_1000kx ?       "ON" : "OFF"));
    CS_PRINTF(("  10GBase-KR:      %s\n" , an_results->bp_10gkr ?        "ON" : "OFF"));
    CS_PRINTF(("  40GBase-KR4:     %s\n" , an_results->bp_40gkr4 ?       "ON" : "OFF"));
    CS_PRINTF(("  40GBase-CR4:     %s\n" , an_results->bp_40gcr4 ?       "ON" : "OFF"));
    CS_PRINTF(("  10GBase-KX4:     %s\n" , an_results->bp_10gkx4 ?       "ON" : "OFF"));
    CS_PRINTF(("  FEC Ability:     %s\n" , an_results->bp_fec ?          "ON" : "OFF"));
    CS_PRINTF(("  Parallel Detect: %s\n" , an_results->bp_par_detect ?   "ON" : "OFF"));
    CS_PRINTF(("  Remote Fault:    %s\n" , an_results->bp_rf ?           "ON" : "OFF"));
    CS_PRINTF(("  Pause:           %d\n" , an_results->bp_pause));
}

/** @file cs4224_ucode.c
 ****************************************************************************
 *
 * @brief
 *    This module contains code for programming the microcode on the
 *    CS4224 devices.
 *
 ****************************************************************************
 * @author
 *    Copyright (c) 2011-2015, Inphi Corporation
 *    All rights reserved.
 *    
 *    Redistribution and use in source and binary forms, with or without modification, 
 *    are permitted provided that the following conditions are met:
 *    
 *    1.	Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *    
 *    2.	Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation and/or 
 *       other materials provided with the distribution.
 *    
 *    3.	Neither the name of Inphi Corporation nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software without 
 *       specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 *    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *    API Version Number: 3.7.8
 ***************************************************************************/

#if !defined(CS_SKIP_UCODE_DOWNLOAD)

/* we need both standard library and a file system for file I/O */
  
#ifndef CS_DONT_USE_STDLIB
#ifdef  CS_HAS_FILESYSTEM

#include <stdlib.h>
#include <string.h>

#define CS4224_ADDRSIZE 49152           /* 48K to avoid segment hopping */
#define CS4224_MAXLINE 256             /* Length of longest input line + 1 */

cs_status cs4224_ucode_data_parse_file(
    cs_uint32 slice, 
    FILE *infilePH);
cs_status cs4224_ucode_data_parse_file_bin(
    cs_uint32 slice,
    FILE *infilePH);

/**
 *
 * This method Parses data buffer and writes it into the HW.
 * 
 *  @param die      [I] -  The die number of the device
 *  @param lbufPC   [I] -  pointer to character buffer for null terminated line
 *  @return             -  Integer identifying failure.
 *      0 : Success
 *      10: Error in record
 *      13: Bad register address
 *      14: cs4224_reg_set failure
 *      15: EEPROM timeout (if programming an EEPROM access register)
 * 
 *  @private
 *
 */
int cs4224_ucode_parse_data_buf(
    cs_uint32 die, 
    char *lbufPC )
{
    unsigned int addr, data;
    cs_uint16 access_status = 0;
    cs_int16 max_iterations = 100;
    
    /* if the buffer isn't valid, exit right away */
    if(lbufPC == NULL)
    {
        CS_TRACE(("ERROR: Invalid lbufPC == NULL\n"));
        return 10;
    }
        
    /* examine 1st character on the line to determine what kind of command it is */
    switch( *(lbufPC) )
    {
        case 'w':
            /* write command */
            if( 2 != sscanf(lbufPC, "write %6x %6x", &addr, &data) )
            {
                /* Flag error in record */
                return 10;
            }
            break;

        /* ignore all but 'write' records */
        default:
            return 0;
    }
    
    if( addr > CS4224_ADDRSIZE ) 
    {
        /* if address exceeds buffer size */
        CS_TRACE(("ERROR: Address larger than max device address\n"));
        return 13;
    }

    if(CS_OK != cs4224_reg_set(die, addr, data))
    {
        /* failure to write data */
        CS_TRACE(("ERROR: cs4224_reg_set(0x%x,0x%x,0x%x) returned CS_ERROR\n",die,addr,data));
        return 14;
    }
    
    /* If this is a write to the EEPROM_MICRO_ACCESS_CONTROL
     * then wait for the previous access to finish. */
    if (CS4224_EEPROM_MICRO_ACCESS_CONTROL == addr)
    {
        /* Delay here, as some script files are missing the command to
           wait for the write to complete. */
        CS_UDELAY(5000);

        /* Wait for the EEPROM_MICRO_ACCESS_STATUS.MicroAccessDone bit
         * to be set. */
        while(CS_IF_CLR(access_status, CS_BIT0) && (max_iterations > 0))
        {
            cs4224_reg_get(die, CS4224_EEPROM_MICRO_ACCESS_STATUS, &access_status);
            max_iterations -= 1;
        }


        if(max_iterations <= 0)
        {
            CS_TRACE(("ERROR: Timed out waiting for a EEPROM write to occur on die %x\n", die));
            return 15;
        }
    }

    /* Successful return */
    return 0;
}

/**
 *
 * This method Parses data buffer and writes it into the HW.
 *
 *  @param die      [I] -  The die number of the device
 *  @param lbufPC   [I] -  pointer to character buffer for null terminated line
 *  @return             -  Integer identifying failure.
 *      0 : Success
 *      10: Error in record
 *      13: Bad register address
 *      14: cs4224_reg_set failure
 *      15: EEPROM timeout (if programming an EEPROM access register)
 *
 *  @private
 *
 */
int cs4224_ucode_parse_data_buf_bin(
    cs_uint32 die,
    cs_uint8 *buf )
{
    cs_uint16 access_status = 0;
    cs_int16 max_iterations = 100;

    cs_uint16 addr;
    cs_uint16 data;

    /* buffer is two unsigned shorts, little endian. */
    addr = buf[0] | buf[1] << 8;
    data = buf[2] | buf[3] << 8;

    if( addr > CS4224_ADDRSIZE )
    {
        /* if address exceeds buffer size */
        CS_TRACE(("ERROR: Address larger than max device address\n"));
        return 13;
    }

    if(CS_OK != cs4224_reg_set(die, addr, data))
    {
        /* failure to write data */
        CS_TRACE(("ERROR: cs4224_reg_set(0x%x,0x%x,0x%x) returned CS_ERROR\n",die,addr,data));
        return 14;
    }

    /* If this is a write to the EEPROM_MICRO_ACCESS_CONTROL
     * then wait for the previous access to finish. */
    if (CS4224_EEPROM_MICRO_ACCESS_CONTROL == addr)
    {
        /* Delay here, as some script files are missing the command to
           wait for the write to complete. */
        CS_UDELAY(5000);

        /* Wait for the EEPROM_MICRO_ACCESS_STATUS.MicroAccessDone bit
         * to be set. */
        while(CS_IF_CLR(access_status, CS_BIT0) && (max_iterations > 0))
        {
            cs4224_reg_get(die, CS4224_EEPROM_MICRO_ACCESS_STATUS, &access_status);
            max_iterations -= 1;
        }


        if(max_iterations <= 0)
        {
            CS_TRACE(("ERROR: Timed out waiting for a EEPROM write to occur on die %x\n", die));
            return 15;
        }
    }

    /* Successful return */
    return 0;
}

/**
 * This method opens a file whose name was supplied in the file_name
 * argument. If the file open is successfull, the method cs4224_ucode_data_parse_file()
 * is called to parse and program the usequencer.
 *
 * This method is only available if CS_HAS_FILESYSTEM is defined
 * and the standard library is available (!CS_DONT_USE_STDLIB).
 *
 *  @param slice      [I] -  The slice number of the device to access.
 *  @param file_name  [I] -  Pointer to a string containing a file name.
 *
 *  @return CS_OK or CS_ERROR.
 *
 */

cs_status cs4224_ucode_data_prgm_from_file(
    cs_uint32   slice, 
    const char* file_name)
{
    FILE      *infilePH;     /* Handle for input file */
    cs_status status;

    /* Check the file name argument */
    if( *file_name == '\0' )  /* If didn't specify input file */
    {
        CS_TRACE(("ERROR: Missing input file argument\n" ));
        return CS_ERROR;
    }

    /* OK, let's try to open the file */
    if( ( infilePH = fopen( file_name, "r" )  )== NULL )
    {
        CS_TRACE(("ERROR: Could not open input file: %s\n", file_name ));
        return CS_ERROR;
    }

    status = cs4224_ucode_data_parse_file(slice, infilePH );

    fclose( infilePH );

    return status;
}

/**
 * This method opens a file whose name was supplied in the file_name
 * argument. If the file open is successfull, the method cs4224_ucode_data_parse_file()
 * is called to parse and program the usequencer.
 *
 * This method is only available if CS_HAS_FILESYSTEM is defined
 * and the standard library is available (!CS_DONT_USE_STDLIB).
 *
 *  @param slice      [I] -  The slice number of the device to access.
 *  @param file_name  [I] -  Pointer to a string containing a file name.
 *
 *  @return CS_OK or CS_ERROR.
 *
 */

cs_status cs4224_ucode_data_prgm_from_file_bin(
    cs_uint32   slice,
    const char* file_name)
{
    FILE      *infilePH;     /* Handle for input file */
    cs_status status;

    /* Check the file name argument */
    if( *file_name == '\0' )  /* If didn't specify input file */
    {
        CS_TRACE(("ERROR: Missing input file argument\n" ));
        return CS_ERROR;
    }

    /* OK, let's try to open the file */
    if( ( infilePH = fopen( file_name, "r" )  )== NULL )
    {
        CS_TRACE(("ERROR: Could not open input file: %s\n", file_name ));
        return CS_ERROR;
    }

    status = cs4224_ucode_data_parse_file_bin(slice, infilePH );

    fclose( infilePH );

    return status;
}

/**
 *
 * This method reads a line from the input file then sends it to the parser.
 *
 * This method is only available if CS_HAS_FILESYSTEM is defined
 * and the standard library is available (!CS_DONT_USE_STDLIB).
 *
 *  @param slice      [I] -  The slice number of the device to access.
 *  @param infilePH   [I] -  Pointer to an input file.
 *  @return               -  CS_OK or CS_ERROR.
 *
 *  @private
 *
 */
cs_status cs4224_ucode_data_parse_file(
    cs_uint32 slice, 
    FILE *infilePH)
{
    int c,                              /* Temp char storage */
        resN;                           /* result status */
    char *lbufPC, lbufAC[CS4224_MAXLINE];
    int linectrN = 0;
    cs_uint16 checksum_status;
    cs_uint32 die;

    /* get the die associated to this slice */
    die = cs4224_get_die_from_slice(slice);

    /* toggle the checksum calculator, note that the data writes will
       assert the checksum bit to start calculating the checksum */
    cs4224_lock(slice);
    cs4224_reg_set(die, CS4224_GLOBAL_DWNLD_CHECKSUM_CTRL, 0x01);
    cs4224_reg_set(die, CS4224_GLOBAL_DWNLD_CHECKSUM_CTRL, 0x00);
    cs4224_unlock(slice);
    
    lbufPC = lbufAC;                    /* Point at beginning of line buffer */

    while( (c = fgetc( infilePH ))) 
    {
        if( (c == '\n') || (c == EOF) ) /* If found end of line or file */
        {                               /* Parse the Line */
            if( ( c == EOF ) && (  ferror( infilePH ) ) )
            {
                CS_TRACE(("ERROR: Error reading input file\n" ));
                return CS_ERROR;
            }
            else
            { 
                /* OK, have a complete line in buffer */
                linectrN++;             /* Increment line counter */
                if( lbufPC == lbufAC )
                        break;          /* ignore blank lines */
                *lbufPC = 0;            /* Terminate the line string */

                cs4224_lock(slice);
                /* let's assume it's an data file */
                if( (resN = cs4224_ucode_parse_data_buf( die, lbufAC )) ) /* Parse data record to mem */
                {
                    CS_TRACE(("ERROR: Error reading record input file at line %d, return code = %d\n",
                        linectrN, resN ));
                    cs4224_unlock(slice);
                    return CS_ERROR;
                }
                cs4224_unlock(slice);

                lbufPC = lbufAC;        /* Repoint line buffer pointer */
            }           /* End of have a complete line */
        }
        else
            *lbufPC++ = c;                  /* Place char into line buffer */
    }

    cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_STATUS, &checksum_status);

    if (0x1 == checksum_status)
    {
        cs_uint16 csum_hw, csum_sw;
        cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_HW, &csum_hw);
        cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_SW, &csum_sw);

        printf("ERROR: Calculated Checksum Does Not Match File Checksum, HW: 0x%x, SW: 0x%x\n", csum_hw, csum_sw);
        CS_TRACE(("ERROR: Calculated Checksum Does Not Match File Checksum\n" ));
        return CS_ERROR;

    }
    return CS_OK;
}                                             

/**
 *
 * This method reads a line from the input file then sends it to the parser.
 *
 * This method is only available if CS_HAS_FILESYSTEM is defined
 * and the standard library is available (!CS_DONT_USE_STDLIB).
 *
 *  @param slice      [I] -  The slice number of the device to access.
 *  @param infilePH   [I] -  Pointer to an input file.
 *  @return               -  CS_OK or CS_ERROR.
 *
 *  @private
 *
 */
cs_status cs4224_ucode_data_parse_file_bin(
    cs_uint32 slice,
    FILE *infilePH)
{
    int resN;                           /* result status */
    int linectrN = 0;
    cs_uint16 checksum_status;
    cs_uint32 die;

    /* get the die associated to this slice */
    die = cs4224_get_die_from_slice(slice);

    /* toggle the checksum calculator, note that the data writes will
       assert the checksum bit to start calculating the checksum */
    cs4224_lock(slice);
    cs4224_reg_set(die, CS4224_GLOBAL_DWNLD_CHECKSUM_CTRL, 0x01);
    cs4224_reg_set(die, CS4224_GLOBAL_DWNLD_CHECKSUM_CTRL, 0x00);
    cs4224_unlock(slice);

    cs_uint8 buf[4];
    while (1 == fread(&buf, sizeof(buf), 1, infilePH))
    {
        cs4224_lock(slice);
        if( (resN = cs4224_ucode_parse_data_buf_bin( die, buf )) )
        {
            CS_TRACE(("ERROR: Error processing record input file at position %d, return code = %d\n",
                linectrN, resN ));
            cs4224_unlock(slice);
            return CS_ERROR;
        }
        cs4224_unlock(slice);
    }

    cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_STATUS, &checksum_status);

    if (0x1 == checksum_status)
    {
        cs_uint16 csum_hw, csum_sw;
        cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_HW, &csum_hw);
        cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_SW, &csum_sw);

        printf("ERROR: Calculated Checksum Does Not Match File Checksum, HW: 0x%04x, SW: 0x%04x\n", csum_hw, csum_sw);
        CS_TRACE(("ERROR: Calculated Checksum Does Not Match File Checksum\n" ));
        return CS_ERROR;

    }
    return CS_OK;
}

  
#endif  /* CS_DONT_USE_STDLIB */
#endif  /* CS_HAS_FILESYSTEM  */ 
   

/**
 *
 * This method parses data image and writes it into the HW.
 * Note this method will write microcode to the microsequencer
 * directly or to the eeprom.
 * 
 *  @param slice       [I] -  The slice number of the device to access.
 *  @param microcode   [I] -  pointer to buffer containing the image
 *  @param len_buffer  [I] -  length of image in units of unsigned shorts
 *
 *  @return CS_OK on success, CS_ERROR on failure
 */
cs_status cs4224_ucode_data_prgm_image(
    cs_uint32 slice,
    cs_uint16 microcode[],
    cs_uint32 len_buffer)
{
    cs_uint32 i;
    cs_status status = CS_OK;
    cs_uint16 data0, data1;
    cs_uint32 die;
    
    /* get the die associated to this slice */
    die = cs4224_get_die_from_slice(slice);

    /* toggle the checksum calculator, note that the file data will
       assert the checksum bit to start calculating the checksum */
    cs4224_lock(slice);
    cs4224_reg_set(die, CS4224_GLOBAL_DWNLD_CHECKSUM_CTRL, 0x01);
    cs4224_reg_set(die, CS4224_GLOBAL_DWNLD_CHECKSUM_CTRL, 0x00);
    cs4224_unlock(slice);

    for(i = 0; i < len_buffer; i+=2)
    {
        unsigned short addr = microcode[i];        
        unsigned short data = microcode[i+1];
        cs_uint16 access_status = 0;
        cs_int16 max_iterations = 100;

        /* Program data here */
        cs4224_lock(slice);

        status |= cs4224_reg_set(die, addr, data);

        /* If this is a write to the EEPROM_MICRO_ACCESS_CONTROL
         * then wait for the previous access to finish. */
        if (CS4224_EEPROM_MICRO_ACCESS_CONTROL == addr)
        {
            /* Wait for the EEPROM_MICRO_ACCESS_STATUS.MicroAccessDone bit
             * to be set. */
            while(CS_IF_CLR(access_status, CS_BIT0) && (max_iterations > 0))
            {
                cs4224_reg_get(die, CS4224_EEPROM_MICRO_ACCESS_STATUS, &access_status);
                max_iterations -= 1;
            }

            if(max_iterations <= 0)
            {
                CS_TRACE(("ERROR: Timed out waiting for an EEPROM write to occur on die %x\n", die));
                return CS_ERROR;
            }
        }

        cs4224_unlock(slice);

    }

    status |= cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_STATUS, &data0);
    if (0x1 == data0)
    {
        status |= cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_HW, &data0);
        status |= cs4224_reg_get(die, CS4224_GLOBAL_DWNLD_CHECKSUM_SW, &data1);
        CS_TRACE(("ERROR: Comms issue! Image checksum does not match HW-calculated checksum, image=0x%04x, hw=0x%04x\n", data1, data0));
        status |= CS_ERROR;
    }

    return status;
}

/**
 *
 * This method calculates a CRC-16 on 32 bit chunks of data. 
 * 
 *  @param input_data  [I] -  The 32-bit data word input into the checksum calculator
 *  @param crc_init    [I] -  The input checksum (scalar)            
 *
 *  @returns calculated CRC-16 
 *
 *  @private
 */
cs_uint32 cs4224_calc_crc16(
    cs_uint32 input_data,
    cs_uint32 crc_init)
{
    cs_uint32 i, j, crc;
    cs_uint32 tmp, msb, data = 0;
    
    crc = crc_init & 0x0000ffff;

    for (i = 0; i < 4; i++)
    {
        if (i == 0) {data = (input_data & 0xff000000) >> 24;}
        if (i == 1) {data = (input_data & 0x00ff0000) >> 16;}
        if (i == 2) {data = (input_data & 0x0000ff00) >>  8;}
        if (i == 3) {data = (input_data & 0xff0000ff) >>  0;}

        tmp = 0x000080;

        for (j = 0; j < 8; j++)
        {
            msb = crc & 0x8000;
            crc <<= 1;
            crc &= 0x0000ffff;
            if (data & tmp)
            {
                msb ^= 0x00008000;
            }
            if (msb)
            {
                crc ^= 0x1021;
            }
            tmp >>= 1;
        }
    }
    return crc;
}

/**
 * CRC-16 Calculator State Machine
 */
typedef enum 
{
    /** Pre CRC-16 calculation state */
    CS4224_UCODE_PRE_CRC16_CALC     = 1,

    /** CRC-16 calculation state */
    CS4224_UCODE_ACTIVE_CRC16_CALC  = 2,

    /** Post CRC-16 calculation state */
    CS4224_UCODE_POST_CRC16_CALC    = 3,

} e_cs4224_ucode_crc16_t;

#ifdef CS_MULTI_CHIP_UCODE_PRGM
/* You need to figure out a maddr_value to use that all the devices on this comms bus will respond to.
 * You generally choose this from the maddr's you used for the external pins on the available devices.
 * 
 * Say for example you have three devices on the same I2C bus, and then another three devices on a different
 * I2C bus. Your implementation of cs4224_reg_get/set already translates the upper bits of the slice 
 * parameter into I2C addresses to use. Pick one of those I2C addresses (maddr) that will be your 'main' device. 
 * Any writes to that device will also write to the other two devices on the same I2C bus.
 * 
 * Note that your MADDR can be read in the GLOBAL_PIN_STATUS register (addr 0x16). This MADDR is from the external
 * pins on the device.
 * 
 * maddr to use for I2C bus 1 = 0x00
 * 
 *   device 0
 *   maddr[5:0] = 0x00
 *   slice = 0x00000
 *   
 *   device 1
 *   maddr[5:0] = 0x10
 *   slice = 0x10000
 *   
 *   device 2
 *   maddr[5:0] = 0x20
 *   slice = 0x20000
 * 
 * maddr to use for I2C bus 2 = 0x30
 * 
 *   device 3
 *   maddr[5:0] = 0x30
 *   slice = 0x30000
 *   
 *   device 4
 *   maddr[5:0] = 0x40
 *   slice = 0x40000
 *   
 *   device 5
 *   maddr[5:0] = 0x50
 *   slice = 0x50000
 * 
 */

/**
 * Returns the GLOBAL_BROADCAST value to use to override the maddr
 * 
 * Do not use this method unless you have contacted Cortina support, this is very
 * experimental!
 * 
 * @param slice [I] - Used for the upper bits of the device
 * 
 * @return value needed to use for the GLOBAL_BROADCAST register
 * 
 * @private
 */
cs_uint16 cs4224_maddr_get_override(
    cs_uint32 slice)
{
    #error "You must edit cs4224_maddr_get_override to use maddr overrides for your system"

    cs_uint32 device = slice & 0xFFFFFF00;
    cs_uint16 maddr_value = 0x0;
    
    switch(device)
    {
        case 0x00000:
        case 0x10000:
        case 0x20000:
            /* set the maddr_value you want to use for this I2C bus
             * example from the comment block above this function */
            maddr_value = 0x00;
            break;
        
        case 0x30000:
        case 0x40000:
        case 0x50000:
            maddr_value = 0x30;
            break;
        
        default:
            CS_TRACE(("ERROR: Unknown device %x\n",device));
            return 0x0;
    }
    
    return 0x3E00 | (maddr_value & 0x0000003E); /* do not change this line */
}

/**
 * This method overrides the maddr mask on all the devices within a single I2C bus.
 * Used for experimental multi-chip ucode programming.
 * 
 * Do not use this method unless you have contacted Cortina support, this is very
 * experimental!
 * 
 * @param slice [I] - Used for the upper bits of the device
 * 
 * @return CS_OK on success, CS_ERROR otherwise
 * 
 * @private
 */
cs_status cs4224_maddr_override_setup(
    cs_uint32 slice)
{
    #error "You must edit cs4224_maddr_override_setup to use maddr overrides for your system"

    cs_status status = CS_OK;
    cs_uint8 i = 0;
    cs_uint32 device = slice & 0xFFFFFF00;
    
    /* change the size of this array to be the number of devices on the same comms bus/wires */
    cs_uint32 devices[3] = {0x0, 0x0, 0x0};
    
    
    switch(device)
    {
        /* 'main' device address that we'll use */
        case 0x00000:
            CS_PRINTF(("Setting up broadcast to all devices on I2C bus 1\n"));
            
            /* set devices we want to program, just the upper bits of the slice parameter */
            devices[0] = 0x00000;
            devices[1] = 0x10000;
            devices[2] = 0x20000;
            /* program the GLOBAL_BROADCAST register on each device to force it to listen to ucode writes */
            for(i=0; i<sizeof(devices)/sizeof(devices[0]); i++)
            {
                /* NOTE: We ignore the status of the register sets since the checksum read-back will fail in an i2c transaction */
                /* die 0 */
                cs4224_reg_set(devices[i], CS4224_GLOBAL_BROADCAST, cs4224_maddr_get_override(device));
                /* die 1 */
                cs4224_reg_set(devices[i]+1, CS4224_GLOBAL_BROADCAST, cs4224_maddr_get_override(device));
                if(CS_OK != status)
                {
                    CS_TRACE(("ERROR: Cannot communicate with %x, devices left in bad state, perform external reset\n",devices[i]));
                    return status;
                }
            }
            break;
        case 0x10000:
        case 0x20000:
            /* if you program device 0x00000 first, these ones should never get here because
             * their ucode will already be programmed */
            CS_TRACE(("ERROR: Program device 0x00000 first.\n"));
            return CS_ERROR;
        
        case 0x30000:
            CS_PRINTF(("Setting up broadcast to all devices on I2C bus 2\n"));
            
            devices[0] = 0x30000;
            devices[1] = 0x40000;
            devices[2] = 0x50000;
            
            for(i=0; i<sizeof(devices)/sizeof(devices[0]); i++)
            {
                /* die 0 */
                cs4224_reg_set(devices[i], CS4224_GLOBAL_BROADCAST, cs4224_maddr_get_override(device));
                /* die 1 */
                cs4224_reg_set(devices[i]+1, CS4224_GLOBAL_BROADCAST, cs4224_maddr_get_override(device));
                if(CS_OK != status)
                {
                    CS_TRACE(("ERROR: Cannot communicate with %x, devices left in bad state, perform external reset\n",devices[i]));
                    return status;
                }
            }
            break;
        case 0x40000:
        case 0x50000:
            CS_TRACE(("ERROR: Program device 0x30000 first.\n"));
            return CS_ERROR;
        
        
        default:
            CS_TRACE(("ERROR: Unknown device %x\n",slice));
            return CS_ERROR;
    }
    
    return status;
}

#endif /* CS_MULTI_CHIP_UCODE_PRGM */

/**
 * This method is called to program the microsequencer into both dies. This
 * is acheived by enabling the die broadcast feature. This method parses the
 * data image and writes it into the HW.
 * 
 * This method will monitor the address written to and intercept writes
 * to the CS4224_GLOBAL_BROADCAST register (0x0017). This register controls
 * the die broadcast feature. If this register is written to, the maadr_mask bit [8] 
 * is set to ensure the broadcast feature remains enabled.
 * 
 * This method calculates 2 checksums, one to compare with the checksum in the image, 
 * the other to compare to the checksum calculated by the hardware.
 * Because of the GLOBAL_BROADCAST register intercept, the HW calculated checksum will not match the 
 * image (SW) checksum. To verify that the download is correct, the image checksum
 * is compared to the calculated checksum.
 *
 * Note this method will write microcode to the microsequencer directly.
 * 
 * NOTE: Cannot be used for programming the EEPROM, use cs4224_ucode_data_prgm_image() instead
 *
 *  @param slice       [I] -  The slice number of the device to access.
 *  @param microcode   [I] -  pointer to buffer containing the image
 *  @param len_buffer  [I] -  length of image in units of unsigned shorts
 *
 *  @return CS_OK on success, CS_ERROR on failure
 *
 *  @private
 */
cs_status cs4224_ucode_data_prgm_image_broadcast(
    cs_uint32 slice, 
    cs_uint16 microcode[], 
    cs_uint32 len_buffer)
{
    cs_uint32 i;
    cs_status status = CS_OK;
    cs_status tmp_status = CS_OK;
    cs_uint16 checksum, data;
    cs_uint32 crc_sw = 0xffff;
    cs_uint32 crc_hw = 0xffff;
    cs_uint32 input_data_hw, input_data_sw;
    e_cs4224_ucode_crc16_t crc_sm = CS4224_UCODE_PRE_CRC16_CALC;
    
    /* upper bits of slice used to pick chip being used */
    cs_uint32 upper_bits = slice & 0xffffff00;
    
    if(microcode == NULL || len_buffer == 0)
    {
        return CS_ERROR;
    }
    
    
    /* Ensure the MDIO timeout is increased on both dies, as per Bugzilla 35875 */
    status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_MDIO_CONFIG, CS4224_GLOBAL_MDIO_CONFIG_pref);
    status |= cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_MDIO_CONFIG, CS4224_GLOBAL_MDIO_CONFIG_pref);

#ifdef CS_MULTI_CHIP_UCODE_PRGM
    /* setup devices that need to listen to this ucode write */
    status |= cs4224_maddr_override_setup(slice);
    if(CS_OK != status)
    {
        CS_TRACE(("ERROR setting up maddr overrides, chips probably left in a broken state\n"));
        status |= cs4224_reg_set(upper_bits, CS4224_GLOBAL_BROADCAST, 0x0);
        return CS_ERROR;
    }
    /* config to broadcast to both dies + already applied forced maddr */
    data = cs4224_maddr_get_override(slice) | 0x0100;
#else
    /* config to broadcast to both dies */
    data = 0x0100;
#endif
    /* force die 1 to listen to die 0's address */
    /* ignore the status returned by the reg set since an I2C transaction will fail to get the checksum */
    cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_BROADCAST, data);
    

    if(CS_OK != status)
    {
        return status;
    }
    
    for(i = 0; i < len_buffer; i+=2)
    {
        unsigned short addr = microcode[i];        
        unsigned short data = microcode[i+1];

        if (addr == CS4224_EEPROM_MICRO_ACCESS_CONTROL)
        {
            CS_TRACE(("ERROR: Cannot program the EEPROM using die broadcast! Use cs4224_ucode_data_prgm_image() instead\n"
                      "Exiting early; ucode left in a broken state. Recommend resetting before continuing\n"));
            
            /* disable broadcasting to both dies */
            cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_BROADCAST, 0x0000);
            
            return CS_ERROR;
        }
        
        if (crc_sm == CS4224_UCODE_ACTIVE_CRC16_CALC)
        {
            /* calculate our own crc that will mirror the one in the image,
             * without the below BROADCAST trap */
            input_data_sw = (addr << 16) + data;
            crc_sw = cs4224_calc_crc16(input_data_sw, crc_sw);
        }

        if (addr == CS4224_GLOBAL_BROADCAST)
        {
            /* intercept to ensure the broadcast bit remains set */
#ifdef CS_MULTI_CHIP_UCODE_PRGM
            data |= cs4224_maddr_get_override(slice) | 0x0100;
#else
            data |= 0x0100;
#endif
        }

        if (crc_sm == CS4224_UCODE_ACTIVE_CRC16_CALC)
        {
            /* calculate our own crc that that will mirror the HW calculated one,
             * with the above BROADCAST trap */
            input_data_hw = (addr << 16) + data;
            crc_hw = cs4224_calc_crc16(input_data_hw, crc_hw);
        }

        cs4224_lock(slice);

        /* Program hw here */
        tmp_status = cs4224_reg_set(0 | upper_bits, addr, data);
        
        cs4224_unlock(slice);

        if(addr != CS4224_GLOBAL_BROADCAST)
        {
            /* ignore the status of writes to BROADCAST */
            status |= tmp_status;
        }
        
        if(CS_OK != status)
        {
            /* some kind of legitimate write issue */
            CS_TRACE(("ERROR: cs4224_reg_set(0x%x, 0x%x, 0x%x) returned an error during ucode programming.\n"
                      "Exiting early; ucode left in a broken state. Recommend resetting before continuing\n",
                      upper_bits, addr, data));
            
            /* disable broadcasting to both dies */
            cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_BROADCAST, 0x0000);
            
            return CS_ERROR;
        }

        /* update our checksum calculator state machine */
        if (addr == CS4224_GLOBAL_DWNLD_CHECKSUM_CTRL) 
        {
            if (data == 0x0001)
            {
                /* HW CRC-16 calculator enabled */
                crc_sm = CS4224_UCODE_ACTIVE_CRC16_CALC;
            }
            else
            {
                /* HW CRC-16 calculator disabled */
                crc_sm = CS4224_UCODE_POST_CRC16_CALC;
            }
        }

    }

    /* disable broadcasting to both dies */
    status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_BROADCAST, 0x0000);

    /* get the image checksum */
    status |= cs4224_reg_get(0 | upper_bits, CS4224_GLOBAL_DWNLD_CHECKSUM_SW, &checksum);
    /* CS_PRINTF(("Calculated Checksums: calc=0x%04x, image=0x%04x\n", crc_sw, checksum));*/

    /* compare our mirror checksum with the image checksum, this checks that OUR
     * program memory or wherever we got the image from isn't corrupted */
    if (crc_sw != checksum)
    {
        CS_TRACE(("ERROR: SW-calculated checksum does not match image-checksum (image corrupt?), calc=0x%04x, image=0x%04x\n", crc_sw, checksum));
        status |= CS_ERROR;
    }

    /* write our calculated hardware checksum to CHECKSUM_SW reg so the CHECKSUM_STATUS clears */
    status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_DWNLD_CHECKSUM_SW, crc_hw);
    status |= cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_DWNLD_CHECKSUM_SW, crc_hw);

    /* check that the chip hw checksum and our calculated crc_hw checksum match */
    status |= cs4224_reg_get(0 | upper_bits, CS4224_GLOBAL_DWNLD_CHECKSUM_STATUS, &data);
    if (0x1 == data)
    {
        status |= cs4224_reg_get(0 | upper_bits, CS4224_GLOBAL_DWNLD_CHECKSUM_HW, &checksum);
        CS_TRACE(("ERROR: Comms issue! SW-calculated checksum does not match HW-calculated checksum, calc=0x%04x, hw=0x%04x\n", crc_hw, checksum));
        status |= CS_ERROR;
    }
    
    status |= cs4224_reg_get(1 | upper_bits, CS4224_GLOBAL_DWNLD_CHECKSUM_STATUS, &data);
    if (0x1 == data)
    {
        status |= cs4224_reg_get(1 | upper_bits, CS4224_GLOBAL_DWNLD_CHECKSUM_HW, &checksum);
        CS_TRACE(("ERROR: Die-broadcast issue! SW-calculated checksum does not match HW-calculated checksum on die 1, calc=0x%04x, hw=0x%04x\n", crc_hw, checksum));
        status |= CS_ERROR;
    }
    
    if(CS_OK != status)
    {
        /* Clear the timestamps */
        status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_UCODE_TIMESTAMP0, 0x0);
        status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_UCODE_TIMESTAMP1, 0x0);
        status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_UCODE_TIMESTAMP2, 0x0);
        status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_UCODE_VERSION_KR, 0x0);
        status |= cs4224_reg_set(0 | upper_bits, CS4224_GLOBAL_UCODE_VERSION_FC, 0x0);
        
        status |= cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_UCODE_TIMESTAMP0, 0x0);
        status |= cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_UCODE_TIMESTAMP1, 0x0);
        status |= cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_UCODE_TIMESTAMP2, 0x0);
        status |= cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_UCODE_VERSION_KR, 0x0);
        status |= cs4224_reg_set(1 | upper_bits, CS4224_GLOBAL_UCODE_VERSION_FC, 0x0);
    }
    
    return status;
}

#endif /* !CS_SKIP_UCODE_DOWNLOAD */




