
/***********************license start***********************************
* Copyright (c) 2003-2016  Cavium Inc. (support@cavium.com). All rights
* reserved.
*
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are
* met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*
*   * Neither the name of Cavium Inc. nor the names of
*     its contributors may be used to endorse or promote products
*     derived from this software without specific prior written
*     permission.
*
* This Software, including technical data, may be subject to U.S. export
* control laws, including the U.S. Export Administration Act and its
* associated regulations, and may be subject to export or import
* regulations in other countries.
*
* TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
* AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
* WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
* TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
* REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT
* DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES
* OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR
* PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT,
* QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK
* ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
***********************license end**************************************/
/dts-v1/;

/include/ "ddr4-common.dtsi"

/ {
cavium,bdk {
	/* On-chip TWSI port connected to the BMC for IPMI traffic.
	-1 = No connection exists. 0+ is TWSI bus number. */
	//BMC-TWSI = "-1";

	/* This specifies a watchdog timer should run during boot and reset
	the chip if boot hangs for some reason. The timeout is specified
	in milliseconds. Zero disables the watchdog. */
	//WATCHDOG-TIMEOUT = "0";

	/* Allow a sequence of TWSI writes to be performed during boot. Each
	string in the list line is executed in sequence. The TWSI write
	format is:
	    node,twsi_id,dev_addr,internal_addr,num_bytes,ia_width_bytes,data
	    sleep,ms
	    gpio,node,gpio_num,state
	node           = Node ID the twsi bus is on. -1 means the local node
	twsi_id        = TWSI bus to use
	dev_addr       = TWSI bus address
	internal_addr  = TWSI internal address, zero if not used
	num_bytes      = Number of bytes to write (1-8)
	ia_width_bytes = Internal address width in bytes (0-2)
	data           = Data to write as a 64bit number
	sleep,ms       = This on a line delays for 'ms' milliseconds
	gpio,...       = This sets the state of a GPIO gpio_num to 0 or 1 */
	//TWSI-WRITE = "";
	TWSI-WRITE = 
	"gpio, 0, 77, 0",	/* Assert PCA9547 RESET_L */
	"sleep, 100",
	"gpio, 0, 77, 1",	/* De-assert PCA9547 RESET_L */
	"sleep, 250",

        /* Select channel 5 in PCA9547 - the XCEDE connector */
        "0,0,0x70, 0, 1, 1, 0xd",         
	"sleep, 10",

	"gpio, 0, 34, 0",	/* Assert overall PHY reset */
	"gpio, 0, 41, 1",	/* Assert VSC7224 reset (address 0x10) */
	"gpio, 0, 43, 1",	/* Assert VSC7224 reset (address 0x11) */
	"gpio, 0, 68, 1",	/* Assert VSC7224 reset (address 0x12) */
	"gpio, 0, 70, 1",	/* Assert VSC7224 reset (address 0x13) */

	"sleep, 10",

	"gpio, 0, 41, 0",	/* De-assert VSC7224 reset (address 0x10) */
	"gpio, 0, 43, 0",	/* De-assert VSC7224 reset (address 0x11) */
	"gpio, 0, 68, 0",	/* De-assert VSC7224 reset (address 0x12) */
	"gpio, 0, 70, 0",	/* De-assert VSC7224 reset (address 0x13) */
	"gpio, 0, 34, 1",	/* De-assert overall PHY reset */

	"sleep, 250",

    /* Tx path for XFI - All 4 channels are Tx at TWSI address 0x10 */
	"0, 0, 0x10, 0x7f, 2, 1, 0x0030", /* Page select FSYNC0 (0x30) */
	"sleep, 10",
	"0, 0, 0x10, 0x80, 2, 1, 0x2841", /* Set FSYNC0 for 10.3125Gbps  See Table 3 */
	"sleep, 10",
	"0, 0, 0x10, 0x81, 2, 1, 0x0008", /* i/p VGA gain settings (0x0: Min 0x7f: Max) */
	"sleep, 10",
	"0, 0, 0x10, 0x82, 2, 1, 0x7a00", /* EQBUFZONE */
	"sleep, 10",
	"0, 0, 0x10, 0x83, 2, 1, 0x000f", /* EQPEAKDIFF */
	"sleep, 10",
	"0, 0, 0x10, 0x84, 2, 1, 0x9c18", /* EQTABLE_DCOFF0 */
	"sleep, 10",
	"0, 0, 0x10, 0x85, 2, 1, 0x0",    /* EQDCOFF12 */
	"sleep, 10",

	"0, 0, 0x10, 0x7f, 2, 1, 0x0050", /* Broadcast config register for all channels */
	"sleep, 10",
	"0, 0, 0x10, 0x82, 2, 1, 0x0014", /* Shrink EQ_BUFF */
	"sleep, 10",
	"0, 0, 0x10, 0x90, 2, 1, 0x5585", /* Select min DFE Delay (DFE_DELAY) */
	"sleep, 10",
	"0, 0, 0x10, 0x92, 2, 1, 0x207f", /* Set DFE 1-3 limit (DXMAX) = 32dec, AP Max limit = 127 decimal */
	"sleep, 10",
	"0, 0, 0x10, 0x93, 2, 1, 0x2000", /* Set AP Min limit = 32 decimal */
	"sleep, 10",
	"0, 0, 0x10, 0x94, 2, 1, 0x0031", /* Set DFE Averaging to the slowest (DFE_AVG) */
	"sleep, 10",
	"0, 0, 0x10, 0x9c, 2, 1, 0x0000", /* Set Inductor Bypass OD_IND_BYP = 0 & fastest Rise/Fall */
	"sleep, 10",
	"0, 0, 0x10, 0xaa, 2, 1, 0x0888", /* Setting DFE Boost = none. Must set for rev C (if DFE in adapt mode) */
	"sleep, 10",
	"0, 0, 0x10, 0xa8, 2, 1, 0x2408", /* Setting EQ Min/Max = 8/72 */
	"sleep, 10",
	"0, 0, 0x10, 0xa9, 2, 1, 0x0060", /* Setting EQVGA = 96, when in EQVGA manual mode */
	"sleep, 10",
	"0, 0, 0x10, 0x87, 2, 1, 0x4021", /* Setting SW_BFOCM, bits 15:14 to 01 */
	"sleep, 10",
	"0, 0, 0x10, 0x89, 2, 1, 0x7313", /* Turn off adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
	"0, 0, 0x10, 0x89, 2, 1, 0x7f13", /* Turn on adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
    /* Tx (towards SFP+) Settings */
	"0, 0, 0x10, 0x99, 2, 1, 0x0010", /* Maintap 0x00:+0.5mA 0x01:+1mA 0x27:+20mA */
	"sleep, 10",
	"0, 0, 0x10, 0x9a, 2, 1, 0x0009", /* Pretap 0x00:-3.75mA 0x00:-3.5mA 0x0f:0mA 0x1f: 4mA */
	"sleep, 10",
	"0, 0, 0x10, 0x9b, 2, 1, 0x0004", /* Posttap 0x00:-0.25mA 0x01:-0.5mA 0x3f:-16mA */
	"sleep, 10",

    /* Rx path for XFI - All 4 channels are Rx at TWSI address 0x10 */
	"0, 0, 0x11, 0x7f, 2, 1, 0x0030", /* Page select FSYNC0 (0x30) */
	"sleep, 10",
	"0, 0, 0x11, 0x80, 2, 1, 0x2841", /* Set FSYNC0 for 10.3125Gbps  See Table 3 */
	"sleep, 10",
	"0, 0, 0x11, 0x81, 2, 1, 0x0008", /* i/p VGA gain settings (0x0: Min 0x7f: Max) */
	"sleep, 10",
	"0, 0, 0x11, 0x82, 2, 1, 0x7a00", /* EQBUFZONE */
	"sleep, 10",
	"0, 0, 0x11, 0x83, 2, 1, 0x000f", /* EQPEAKDIFF */
	"sleep, 10",
	"0, 0, 0x11, 0x84, 2, 1, 0x9c18", /* EQTABLE_DCOFF0 */
	"sleep, 10",
	"0, 0, 0x11, 0x85, 2, 1, 0x0",    /* EQDCOFF12 */
	"sleep, 10",

	"0, 0, 0x11, 0x7f, 2, 1, 0x0050", /* Broadcast config register for all channels */
	"sleep, 10",
	"0, 0, 0x11, 0x82, 2, 1, 0x0014", /* Shrink EQ_BUFF */
	"sleep, 10",
	"0, 0, 0x11, 0x90, 2, 1, 0x5585", /* Select min DFE Delay (DFE_DELAY) */
	"sleep, 10",
	"0, 0, 0x11, 0x92, 2, 1, 0x207f", /* Set DFE 1-3 limit (DXMAX) = 32dec, AP Max limit = 127 decimal */
	"sleep, 10",
	"0, 0, 0x11, 0x93, 2, 1, 0x2000", /* Set AP Min limit = 32 decimal */
	"sleep, 10",
	"0, 0, 0x11, 0x94, 2, 1, 0x0031", /* Set DFE Averaging to the slowest (DFE_AVG) */
	"sleep, 10",
	"0, 0, 0x11, 0x9c, 2, 1, 0x0000", /* Set Inductor Bypass OD_IND_BYP = 0 & fastest Rise/Fall */
	"sleep, 10",
	"0, 0, 0x11, 0xaa, 2, 1, 0x0888", /* Setting DFE Boost = none. Must set for rev C (if DFE in adapt mode) */
	"sleep, 10",
	"0, 0, 0x11, 0xa8, 2, 1, 0x2408", /* Setting EQ Min/Max = 8/72 */
	"sleep, 10",
	"0, 0, 0x11, 0xa9, 2, 1, 0x0060", /* Setting EQVGA = 96, when in EQVGA manual mode */
	"sleep, 10",
	"0, 0, 0x11, 0x87, 2, 1, 0x4021", /* Setting SW_BFOCM, bits 15:14 to 01 */
	"sleep, 10",
	"0, 0, 0x11, 0x89, 2, 1, 0x7313", /* Turn off adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
	"0, 0, 0x11, 0x89, 2, 1, 0x7f13", /* Turn on adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
    /* Rx (towards CN83XX) Settings */
	"0, 0, 0x11, 0x97, 2, 1, 0x1400", /* Pretap disable; Posttap disable */
	"sleep, 10", 
	"0, 0, 0x11, 0x99, 2, 1, 0x0008", /* Maintap 0x00:+0.5mA 0x01:+1mA 0x27:+20mA */
	"sleep, 10",

    /* Turn on SFP+ outputs */
	"gpio, 0, 45, 0",	/* Assert SFP 0 TX_DIS to 0 */
	"gpio, 0, 49, 0",	/* Assert SFP 1 TX_DIS to 0 */
	"gpio, 0, 53, 0",	/* Assert SFP 2 TX_DIS to 0 */
	"gpio, 0, 65, 0",	/* Assert SFP 3 TX_DIS to 0 */

    /* Tx path for QSFP+ All 4 channels are Tx at TWSI address 0x12 */
	"0, 0, 0x12, 0x7f, 2, 1, 0x0030", /* Page select FSYNC0 (0x30) */
	"sleep, 10",
	"0, 0, 0x12, 0x80, 2, 1, 0x2841", /* Set FSYNC0 for 10.3125Gbps  See Table 3 */
	"sleep, 10",
	"0, 0, 0x12, 0x81, 2, 1, 0x0008", /* i/p VGA gain settings (0x0: Min 0x7f: Max) */
	"sleep, 10",
	"0, 0, 0x12, 0x82, 2, 1, 0x7a00", /* EQBUFZONE */
	"sleep, 10",
	"0, 0, 0x12, 0x83, 2, 1, 0x000f", /* EQPEAKDIFF */
	"sleep, 10",
	"0, 0, 0x12, 0x84, 2, 1, 0x9c18", /* EQTABLE_DCOFF0 */
	"sleep, 10",
	"0, 0, 0x12, 0x85, 2, 1, 0x0",    /* EQDCOFF12 */
	"sleep, 10",

	"0, 0, 0x12, 0x7f, 2, 1, 0x0050", /* Broadcast config register for all channels */
	"sleep, 10",
	"0, 0, 0x12, 0x82, 2, 1, 0x0014", /* Shrink EQ_BUFF */
	"sleep, 10",
	"0, 0, 0x12, 0x90, 2, 1, 0x5585", /* Select min DFE Delay (DFE_DELAY) */
	"sleep, 10",
	"0, 0, 0x12, 0x92, 2, 1, 0x207f", /* Set DFE 1-3 limit (DXMAX) = 32dec, AP Max limit = 127 decimal */
	"sleep, 10",
	"0, 0, 0x12, 0x93, 2, 1, 0x2000", /* Set AP Min limit = 32 decimal */
	"sleep, 10",
	"0, 0, 0x12, 0x94, 2, 1, 0x0031", /* Set DFE Averaging to the slowest (DFE_AVG) */
	"sleep, 10",
	"0, 0, 0x12, 0x9c, 2, 1, 0x0000", /* Set Inductor Bypass OD_IND_BYP = 0 & fastest Rise/Fall */
	"sleep, 10",
	"0, 0, 0x12, 0xaa, 2, 1, 0x0888", /* Setting DFE Boost = none. Must set for rev C (if DFE in adapt mode) */
	"sleep, 10",
	"0, 0, 0x12, 0xa8, 2, 1, 0x2408", /* Setting EQ Min/Max = 8/72 */
	"sleep, 10",
	"0, 0, 0x12, 0xa9, 2, 1, 0x0060", /* Setting EQVGA = 96, when in EQVGA manual mode */
	"sleep, 10",
	"0, 0, 0x12, 0x87, 2, 1, 0x4021", /* Setting SW_BFOCM, bits 15:14 to 01 */
	"sleep, 10",
	"0, 0, 0x12, 0x89, 2, 1, 0x7313", /* Turn off adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
	"0, 0, 0x12, 0x89, 2, 1, 0x7f13", /* Turn on adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
    /* Tx Settings */
	"0, 0, 0x12, 0x99, 2, 1, 0x0010", /* Maintap 0x00:+0.5mA 0x01:+1mA 0x27:+20mA */
	"sleep, 10",
	"0, 0, 0x12, 0x9a, 2, 1, 0x0009", /* Pretap 0x00:-3.75mA 0x00:-3.5mA 0x0f:0mA 0x1f: 4mA */
	"sleep, 10",
	"0, 0, 0x12, 0x9b, 2, 1, 0x0004", /* Posttap 0x00:-0.25mA 0x01:-0.5mA 0x3f:-16mA */
	"sleep, 10",

    /* Rx path for QSFP+ - All 4 channels are Rx at TWSI address 0x13 */
	"0, 0, 0x13, 0x7f, 2, 1, 0x0030", /* Page select FSYNC0 (0x30) */
	"sleep, 10",
	"0, 0, 0x13, 0x80, 2, 1, 0x2841", /* Set FSYNC0 for 10.3125Gbps  See Table 3 */
	"sleep, 10",
	"0, 0, 0x13, 0x81, 2, 1, 0x0008", /* i/p VGA gain settings (0x0: Min 0x7f: Max) */
	"sleep, 10",
	"0, 0, 0x13, 0x82, 2, 1, 0x7a00", /* EQBUFZONE */
	"sleep, 10",
	"0, 0, 0x13, 0x83, 2, 1, 0x000f", /* EQPEAKDIFF */
	"sleep, 10",
	"0, 0, 0x13, 0x84, 2, 1, 0x9c18", /* EQTABLE_DCOFF0 */
	"sleep, 10",
	"0, 0, 0x13, 0x85, 2, 1, 0x0",    /* EQDCOFF12 */
	"sleep, 10",

	"0, 0, 0x13, 0x7f, 2, 1, 0x0050", /* Broadcast config register for all channels */
	"sleep, 10",
	"0, 0, 0x13, 0x82, 2, 1, 0x0014", /* Shrink EQ_BUFF */
	"sleep, 10",
	"0, 0, 0x13, 0x90, 2, 1, 0x5585", /* Select min DFE Delay (DFE_DELAY) */
	"sleep, 10",
	"0, 0, 0x13, 0x92, 2, 1, 0x207f", /* Set DFE 1-3 limit (DXMAX) = 32dec, AP Max limit = 127 decimal */
	"sleep, 10",
	"0, 0, 0x13, 0x93, 2, 1, 0x2000", /* Set AP Min limit = 32 decimal */
	"sleep, 10",
	"0, 0, 0x13, 0x94, 2, 1, 0x0031", /* Set DFE Averaging to the slowest (DFE_AVG) */
	"sleep, 10",
	"0, 0, 0x13, 0x9c, 2, 1, 0x0000", /* Set Inductor Bypass OD_IND_BYP = 0 & fastest Rise/Fall */
	"sleep, 10",
	"0, 0, 0x13, 0xaa, 2, 1, 0x0888", /* Setting DFE Boost = none. Must set for rev C (if DFE in adapt mode) */
	"sleep, 10",
	"0, 0, 0x13, 0xa8, 2, 1, 0x2408", /* Setting EQ Min/Max = 8/72 */
	"sleep, 10",
	"0, 0, 0x13, 0xa9, 2, 1, 0x0060", /* Setting EQVGA = 96, when in EQVGA manual mode */
	"sleep, 10",
	"0, 0, 0x13, 0x87, 2, 1, 0x4021", /* Setting SW_BFOCM, bits 15:14 to 01 */
	"sleep, 10",
	"0, 0, 0x13, 0x89, 2, 1, 0x7313", /* Turn off adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
	"0, 0, 0x13, 0x89, 2, 1, 0x7f13", /* Turn on adaptive input equalization and VGA adaptive algorithm control */
	"sleep, 10",
    /* Rx Settings */
	"0, 0, 0x13, 0x97, 2, 1, 0x1400", /* Pretap disable; Posttap disable */
	"sleep, 10", 
	"0, 0, 0x13, 0x99, 2, 1, 0x0008", /* Maintap 0x00:+0.5mA 0x01:+1mA 0x27:+20mA */
	"sleep, 10",

	"sleep, 1";

	/* Allow a sequence of MDIO writes to be performed during boot. Each
	string in the list line is executed in sequence. The MDIO write
	format is:
	    clause,node,bus_id,phy_id,device,location,val
	    sleep,ms
	    gpio,node,gpio_num,state
	clause   = MDIO clause for the write (22 or 45)
	node     = Node the MDIO bus is connected, -1 for local
	bus_id   = MDIO bus to use
	phy_id   = MDIO address
	device   = Clause 45 internal device address, zero for clause 22
	location = MDIO register
	val      = Value to write
	sleep,ms = This on a line delays for 'ms' milliseconds
	gpio,... = This sets the state of a GPIO gpio_num to 0 or 1 */
	//MDIO-WRITE = "";

	/* PHY address encoding:
	    Bits[31:24]: Node ID, 0xff for node the ethernet device is on
	    Bits[23:16]: Only used for TWSI
	    Bits[15:12]: PHY connection type (0=MDIO, 1=Fixed, 2=TWSI)
	For MDIO:
	    Bits[31:24]: Node ID, 0xff for node the ethernet device is on
	    Bits[23:16]: 0
	    Bits[15:12]: 0=MDIO
	    Bits[11:8]: MDIO bus number
	    Bits[7:0]: MDIO address
	For Fixed:
	    Bits[31:24]: 0
	    Bits[23:16]: Zero
	    Bits[15:12]: 1=Fixed
	    Bits[11:0]:  0 = 1Gb, 1 = 100Mb
	For TWSI:
	    Bits[31:24]: Node ID, 0xff for node the ethernet device is on
	    Bits[23:16]: TWSI internal address width in bytes (0-2)
	    Bits[15:12]: 2=TWSI
	    Bits[11:8]: TWSI bus number
	    Bits[7:0]: TWSI address */
	//PHY-ADDRESS.N%d.BGX%d.P%d = "-1";
	// When board is running as Node 0
	// BGX0 (QLM2) PHY addresses
	PHY-ADDRESS.N0.BGX0.P0 = "0xff012010"; // 0x10 for output, 0x11 for input
	PHY-ADDRESS.N0.BGX0.P1 = "0xff012010";
	PHY-ADDRESS.N0.BGX0.P2 = "0xff012010";
	PHY-ADDRESS.N0.BGX0.P3 = "0xff012010";
	// BGX1 (QLM3) PHY addresses
	PHY-ADDRESS.N0.BGX1.P0 = "0xff012012"; // 0x12 for output, 0x13 for input
	PHY-ADDRESS.N0.BGX1.P1 = "0xff012012";
	PHY-ADDRESS.N0.BGX1.P2 = "0xff012012";
	PHY-ADDRESS.N0.BGX1.P3 = "0xff012012";
	// BGX2 (DLM6) PHY addresses
	PHY-ADDRESS.N0.BGX2.P2 = "0xff000016";
	PHY-ADDRESS.N0.BGX2.P3 = "0xff000017";

	/* Independent enables for each on-chip BGX port. Use this to
	disable ports that are not wired on a board. Default is that all
	ports are enabled. */
	//BGX-ENABLE.N%d.BGX%d.P%d = "1";

	/* Number of packet buffers in the BDK. */
	//BDK-NUM-PACKET-BUFFERS = "0x1000";

	/* The size of each packet buffer in the BDK. */
	//BDK-PACKET-BUFFER-SIZE = "0x400";

	/* Controls whether the BDK displays link status messages. */
	//BDK-SHOW-LINK-STATUS = "1";

	/* Controls the cores used by the BDK. Zero means all cores. */
	//BDK-COREMASK = "0";

	/* Timeout for the boot menu in seconds. */
	//BDK-BOOT-MENU-TIMEOUT = "0xa";

	/* This is used by the boot menu to control which boot path the init
	code chooses. The supported options are
	    0 = Normal boot path
	    1 = Diagnostics boot path */
	//BDK-BOOT-PATH-OPTION = "0";

	/* This is used by the boot apps to determine the next boot stage.
	    e.g.:
	      BDK-CONFIG-BOOT-NEXT-STAGE-INIT=/fatfs/cortina-app.bin */
	//BDK-CONFIG-BOOT-NEXT-STAGE-%s = "";

	/* BDK trace level. This is a bitmask of the enumeration defined in
	bdk-trace.h. Each bit turns on tracing of a specific BDK
	component. */
	//BDK-CONFIG-TRACE = "0";

	/* Determine how multi-node is supported for this system:
	    0 = Multi-node is not supported
	    1 = Multi-node is supported and booting requires two nodes
	    2 = Multi-node is auto detected. Two nodes are used if
	        if available, otherwise fall back to single node. */
	//MULTI-NODE = "2";
	MULTI-NODE = "0";

	/* Determine if internal PCIe ECAMs support Enhanced Allocation(EA):
	    0 = Enhanced Allocation is not supported
	    1 = Enhanced Allocation is supported
	Note EA is not supported on CN88XX pass 1.x, and is always
	disabled. */
	//PCIE-ENHANCED-ALLOCATION = "1";

	/* Enforcing stronger PCIe ordering. Use this option if a PCIe card
	is having compatibility issues.
	    0 = Don't wait for commit, default for best performance.
	    1 = Wait for commit, use conservative ordering. */
	//PCIE-ORDERING = "0";

	/* Force CCPI lane reversal. This should be set for boards which
	reverse the CCPI lanes between nodes. If lane 0 connects to lane
	23, this option is needed. CN88XX pass 2.0 and higher automatically
	detect lane reversal, so setting this is optional.
	    0 = Automatically detect lane reversal, no lane reversal on
	        CN88XX pass 1.x.
	    1 = Force lane reversal, required on CN88XX pass 1.0 with CCPI
	        lanes reversed. */
	//CCPI-LANE-REVERSE = "0";

	/* Cavium SKU for the chip. This is determined by early code and
	passed to later software for display. This should not be set in
	the input device tree, it will be ignored. */
	//CHIP-SKU.NODE%d = "TBD";

	/* For Cavium evaluation boards, query the MCU for QLM/DLM setup
	information. The MCU supplies a TWSI protocol for the SOC to
	query the modules plugged in and automatically set the QLMs or 
	DLMs to the correct mode. This should only be enabled(1) on Cavium
	EBB8XXX boards. Other boards should have it disabled(0). */
	QLM-AUTO-CONFIG = "0";
	//QLM-AUTO-CONFIG = "1";

	/* Set the mode of a QLM/DLM. The possible mode strings are:
	    DISABLED
	    PCIE_1X1
	    PCIE_2X1
	    PCIE_1X2
	    PCIE_1X4
	    PCIE_1X8
	    SATA_4X1
	    SATA_2X1
	    ILK
	    SGMII_4X1
	    SGMII_2X1
	    XAUI_1X4
	    RXAUI_2X2
	    RXAUI_1X2
	    OCI
	    XFI_4X1
	    XFI_2X1
	    XLAUI_1X4
	    10G_KR_4X1
	    10G_KR_2X1
	    40G_KR4_1X4 */
	//QLM-MODE.N%d.QLM%d = "";

	/* Set the speed of a QLM/DLM in Mhz. The possible speeds are:
	    1250
	    1500
	    2500
	    3000
	    3125
	    5000
	    6000
	    6250
	    8000
	   10312 */
	//QLM-FREQ.N%d.QLM%d = "0";

	/* Set the source of the QLM/DLM reference clock:
	    0 = Common clock 0
	    1 = Common clock 1
	    2 = QLM external reference */
	//QLM-CLK.N%d.QLM%d = "2";

	QLM-MODE.N0.QLM0 = "PCIE_1X8";
	QLM-FREQ.N0.QLM0 = "8000";

	QLM-MODE.N0.QLM1 = "PCIE_1X8";
	QLM-FREQ.N0.QLM1 = "8000";

	QLM-MODE.N0.QLM2 = "XFI_4X1";
	QLM-FREQ.N0.QLM2 = "10312";

	QLM-MODE.N0.QLM3 = "XLAUI_1X4";
	QLM-FREQ.N0.QLM3 = "10312";

	QLM-MODE.N0.QLM4 = "SATA_2X1";
	QLM-FREQ.N0.QLM4 = "6000";

	QLM-MODE.N0.QLM5 = "SATA_2X1";
	QLM-FREQ.N0.QLM5 = "6000";

	/* Setting of GSERX_LANEX_TX_CFG_0[CFG_TX_SWING] for the QLM/DLM. This
	should only be used for QLMs or DLMs used for BGX and CCPI not using KR
	training. */
	//QLM-TUNING-TX-SWING.N%d.QLM%d.LANE%d = "-1";

	/* Setting of GSERX_LANEX_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] for the
	QLM/DLM. This should only be used for QLMs or DLMs used for BGX and CCPI not
	using KR training. CFG_TX_PREMPTAP:
	    Bits[8:5] = Tx Post Tap; Bits[3:0] = Tx Pre Tap */
	//QLM-TUNING-TX-PREMPTAP.N%d.QLM%d.LANE%d = "-1";

	/* Setting of GSERX_LANEX_TX_CFG_3[PCS_SDS_TX_GAIN] for the QLM/DLM. This
	should only be used for QLMs or DLMs used for BGX and CCPI not using KR
	training. */
	//QLM-TUNING-TX-GAIN.N%d.QLM%d.LANE%d = "-1";

	/* Setting of GSERX_LANEX_TX_CFG_3[CFG_TX_VBOOST_EN] for the QLM/DLM. This
	should only be used for QLMs or DLMs used for BGX and CCPI not using KR
	training. */
	//QLM-TUNING-TX-VBOOST.N%d.QLM%d.LANE%d = "-1";

	/* The insertion loss at Nyquist rate (e.g. 5.125Ghz for XFI/XLAUI) in
	dB should be passed into the channel loss attribute. For CN8XXX,
	this attribute is only used for XFI/10GBASE-KR and
	XLAUI/40GBASE-KR4 links. If no channel loss attribute is provided
	the default value assumes a loss of greater than 10dB. */
	//QLM-CHANNEL-LOSS.N%d.QLM%d = "-1";

	QLM-CHANNEL-LOSS.N0.QLM2 = "2";
	QLM-CHANNEL-LOSS.N0.QLM3 = "2";

	QLM-TUNING-TX-SWING.N0.QLM2.LANE0 = "22";
	QLM-TUNING-TX-SWING.N0.QLM2.LANE1 = "22";
	QLM-TUNING-TX-SWING.N0.QLM2.LANE2 = "22";
	QLM-TUNING-TX-SWING.N0.QLM2.LANE3 = "22";

	QLM-TUNING-TX-PREMPTAP.N0.QLM2.LANE0 = "0x0";
	QLM-TUNING-TX-PREMPTAP.N0.QLM2.LANE1 = "0x0";
	QLM-TUNING-TX-PREMPTAP.N0.QLM2.LANE2 = "0x0";
	QLM-TUNING-TX-PREMPTAP.N0.QLM2.LANE3 = "0x0";

	QLM-TUNING-TX-SWING.N0.QLM3.LANE0 = "22";
	QLM-TUNING-TX-SWING.N0.QLM3.LANE1 = "22";
	QLM-TUNING-TX-SWING.N0.QLM3.LANE2 = "22";
	QLM-TUNING-TX-SWING.N0.QLM3.LANE3 = "22";

	QLM-TUNING-TX-PREMPTAP.N0.QLM3.LANE0 = "0x0";
	QLM-TUNING-TX-PREMPTAP.N0.QLM3.LANE1 = "0x0";
	QLM-TUNING-TX-PREMPTAP.N0.QLM3.LANE2 = "0x0";
	QLM-TUNING-TX-PREMPTAP.N0.QLM3.LANE3 = "0x0";

	/* Speed grade to use for DRAM in MT/s. Hardware may adjust this value
	slightly to improve DRAM stability, so scope measurements may not
	exactly match the frequency with MT/s. The Cavium supported speed
	grades are:
	       0 (auto-set from SPD contents)
	     666 MT/s (DDR3 only)
	     800 MT/s (DDR3 only)
	    1066 MT/s (DDR3 only)
	    1333 MT/s (DDR3 only)
	    1600 MT/s
	    1866 MT/s
	    2133 MT/s (DDR4 only)
	Parameters:
	    N#: Parameter can be different for each node. This specifies
	        which node the value is for. Node must be 0-3. Optional. */
	//DDR-SPEED.N%d = "0";

	/* TWSI address of the DIMM SPD. The encoding of this address is
	:    [15:12]: TWSI bus the DIMM is connected to.
	     [11:7]: Reserved, set to zero.
	      [6:0]: TWSI address for the DIMM.
	A value of zero means the DIMMs are not accessible. Hard coded
	values will be read from DDR-CONFIG-SPD-DATA.Parameters:
	    LMC#: Parameter can be different for memory controller. This
	        specifies which LMC the value is for. LMC must be
	        0-3. Optional.
	    N#: Parameter can be different for each node. This specifies
	        which node the value is for. Node must be 0-3. Optional. */
	//DDR-CONFIG-SPD-ADDR.DIMM%d.LMC%d.N%d = "0";
	DDR-CONFIG-SPD-ADDR.DIMM0.LMC1 = "0x0053";
	DDR-CONFIG-SPD-ADDR.DIMM0.LMC0 = "0x0057";

        /* Other DRAM settings are read from ddr4-common.dtsi */

	/* Specify a on-chip GPIO used to control power for a USB port. When
	set, the USB host controller will toggle the GPIO automatically
	during USB reset events. The default value assumes the SOC has no
	control of the USB power and it is always on. */
	//USB-PWR-GPIO.N%d.PORT%d = "-1";
	USB-PWR-GPIO.N0.PORT0 = "12";
	USB-PWR-GPIO.N0.PORT1 = "13";

	/* Specify the polarity of a on-chip GPIO used to control power for
	a USB port. The GPIO used is specified by USB-PWR-GPIO. Setting this
	GPIO low. The default value drives the GPIO high. */
	//USB-PWR-GPIO-POLARITY.N%d.PORT%d = "1";
        USB-PWR-GPIO-POLARITY = "1";

	/* Specify reference clock source for SuperSpeed and HighSpeed PLL.
	Possible sources:
	 USB_REF_CLK pin
	Additional sources for CN81XX/CN80XX chips
	 DLMC_REF_CLK0 pin
	 DLMC_REF_CLK1 pin
	 PLL_REF_CLK
	Clock used by usb needs to run at 100MHz frequency except PLL_REF_CLK
	which requires 50MHz frequency.
	Encoding:
	0 - SS(USB_REF_CLK)   HS(USB_REF_CLK)
	1 - SS(DLMC_REF_CLK0) HS(DLMC_REF_CLK0)
	2 - SS(DLMC_REF_CLK1) HS(DLMC_REF_CLK1)
	3 - SS(USB_REF_CLK)   HS(PLL_REF_CLK)
	4 - SS(DLMC_REF_CLK0) HS(PLL_REF_CLK)
	5 - SS(DLMC_REF_CLK1) HS(PLL_REF_CLK)
	The default is 0 : USB_REF_CLK. */
	//USB-REFCLK-SRC.N%d.PORT%d = "0";
	USB-REFCLK-SRC.N0.PORT0 = "0";
	USB-REFCLK-SRC.N0.PORT1 = "0";

	/* Number of reading with no errors to signal the start of an
	eye. The default value should be good for most cases. */
	//QLM-EYE-NUM-ZEROS = "2";

	/* Time to sample at each location in microseconds. The default
	value should be good for most cases. */
	//QLM-EYE-SAMPLE-TIME = "0x190";

	/* Time to settle after each movement in microseconds. The
	default value should be good for most cases. */
	//QLM-EYE-SETTLE-TIME = "0x32";

	/* Temperature where THERMAL_TRIP_N is asserted. When the chip reaches
	this temperature THERMAL_TRIP_N will assert, signalling the board
	to emergency power off. The default value is the Cavium recommended
	maximum temperature of the chip. Values between 0 and 110 degrees
	Celsius. */
	//VRM-TEMP-TRIP.N%d = "0x6e";

	/* Temperature where maximum throttling is applied to the chip. Chip
	performance will be greatly reduced to keep the temperature below
	thermal trip (VRM-TEMP-TRIP). The default value is the Cavium
	recommended maximum operating temperature of the chip. Values
	between 0 and 110 degrees Celsius. */
	//VRM-TEMP-HIGH.N%d = "0x6e";

	/* Temperature where minimum throttling is applied to the chip. Chip
	performance will be maximized at or below this temperature. The
	throttling level will be set to VRM-THROTTLE-NORMAL. The default
	value is the Cavium recommended operating temperature of the chip.
	Values between 0 and 110 degrees Celsius. */
	//VRM-TEMP-LOW.N%d = "0x64";

	/* Throttle level of the chip when operating normally. Temperatures
	at or below VRM-TEMP-LOW will use this throttling level. The default
	level (70%), allows good performance while still reducing power under
	heavy loads. Value is a percentage between 1 and 100. */
	//VRM-THROTTLE-NORMAL.N%d = "0x41";

	/* Throttle level of the chip is overheating. Temperatures at or
	above VRM-TEMP-HIGH will use this throttling level. The default
	level (5%), allows for forward progress while still reducing power.
	Value is a percentage between 1 and 100. Setting a value of 100
	disables dynamic throttling (not recommended). */
	//VRM-THROTTLE-THERM.N%d = "0xf";

	/* Internal source for GPIO pins. The enumeration GPIO_PIN_SEL_E
	details the possible internal sources for GPIO pins in the chip.
	The value of this setting is the numeric value from the GPIO_PIN_SEL_E
	enumeration. The default value(-1) leaves the pin at the hardware
	default, which is to connect the pin to the GPIO block for manual
	control.
	Parameters:
	    GPIO#: Which GPIO pin to configure.
	    N#: Setting can be different for each node. This specifies
	        which node the value is for. Node must be 0-3. Optional. */
	//GPIO-PIN-SELECT-GPIO%d.N%d = "-1";

        /* Set the polarity of GPIO pins. GPIO pins are normally high=1 and
        low=0. Setting this configuration item to '1' inverts this, so
        high=0 and low=1. The inversion applies to both input and output.
        The default value of '0' configures high=1 and low=0.
        Parameters:
            GPIO#: Which GPIO pin to configure.
            N#: Setting can be different for each node. This specifies
                which node the value is for. Node must be 0-3. Optional. */
        //GPIO-POLARITY-GPIO%d.N%d = "0";
}; /* cavium,bdk */
}; /* / */
